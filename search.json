[{"title":"Hello World","url":"/2021/04/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"运气","url":"/2021/06/12/luck/","content":"攒了很多文想写，但由于总觉得自己了解的还不够加上生活比较忙碌迟迟没有写，不过哪怕写的再差，月底之前一定会再憋一篇技术文出来。\n最近比较想写运气这个话题的内容。因为各种意义上，我实在是”倒霉”，尤其是最近几个月。比如说前些时间让我很头疼的毕业相关事宜，刚从学校那边上回北京高铁，导员就通知我一个放进档案的表格字写的不合格要我重写，填一些论文以及实习材料的时候都全填完了论文指导老师才说哪里哪里应该怎么写，好多又白费了。\n先别急着关闭博客，我不是来讲我多”倒霉”的。\n倒霉不是倒霉我觉得这其中一部分并不是真正随机的事情，它们可以通过人为因素来一定程度的避免，这也是为什么我在前面的倒霉加了双引号表示。比如说要我重写的表格，明知道要放进档案但我还是没花太多精力去一笔一画的写导致字迹略草（虽说比平常的字好很多了），如果我当时再认真点写或许就可以避免这所谓的“倒霉了”。\n为什么要这样区分？这些事情中自己总有做的不够好的地方，如果能改正那可以减少下次发生类似事件的概率（@@@：重复同一件事情是无用的，木大木大），进而还能间接减少坏心情\n改变自己的视角，将出现的问题、差错视为一个发现自己问题并且纠正的机会（这是一场「试炼」，我认为这是一场让我战胜过去「试炼」，我接受了，只有在战胜那不成熟的过去后，人才能有所成长…你不也是一样吗？）\n把一切都推脱出去的行为一点也不可爱（划重点）\n误区尽管这类事情中很多是个人因素，但不要因此苛责自己，出错这件事情是不可避免的。并不是说因为自己应该做到些什么就把责任全部归咎于自己身上，比如说你在人行道没看路有摩托撞上来了，自己没看路是一方面，但是对方也没有遵守道路行驶规则。\n再重复一次，改变这些看法的本质只是为了改正自己做的不合适的地方，不要因为这个而苛责自己。实际上确实存在容易将责任归于自己身上的人，如果你是这样那希望本文能够让你意识到问题并且开始萌生改变的想法。\n人为防范的例子很多人可能都会有到学校/公司之后发现今天晚上会有雨，但是没有带雨伞的经历。其中也有不少认为今天真倒霉，偏偏要下雨了没带伞。但如果你考虑到这种情况还会发生，于是下次又买了一把伞放在学校/公司那就不一样了，不会因为同样的理由被雨淋，减少了觉得“倒霉”的次数，进而心情还会好一些。\n无可奈何的情况除了人为可控的情况，当然也有一些不可抗力，比如说抽卡，抽卡，还有抽卡，但你钱砸的够多还是能抽到。这种情况那我只能说平日多扶老奶奶过马路，多关心孤寡推友 比如作者\n最后，希望读者能够早日脱离“运气”的陷阱，减少运气对自己的情绪影响以及能够从中学到些什么。\n","categories":["Thinking"]},{"title":"Rc-lang开发周记0 基本块与if重排","url":"/2021/12/19/rc-lang-dev-0/","content":"目前的工作重心在于将ast转换为tac指令。\n由于ast的if转成的中间表示的条件跳转是带有两个分支的，因此需要对if后面所跳转到的位置进行重排。\n基本块与重排相关的代码目前在ir/cfg.rb中，ast到tac的代码目前在ir/tac/tac.rb中\n而跳转指令实质上是从一个基本块（BasicBlock）跳转到另一个基本块，因此我们需要先将tac（三地址码）转换成由基本块构成的形式\n基本块核心性质\n每个基本块是从一个label开始（单一入口点）\n每个基本块是由一个跳转结束（单一结束点）\n\n每一个基本块是独立的，因为由跳转结束，所以不管怎么更换基本块的位置最后都不会影执行顺序的正确性\n案例def f(cond, a, b)  n = a + b  if cond    n * 2  else    n + 2  endend\n\n比如这段代码，就会存在三个基本块\n\nmain开始到if的条件跳转\ntrue的部分是一个基本块\nfalse的部分是一个基本块\n\n2和3：在生成if代码的时候会给true和false的分支各自添加一个label作为跳转目标，而每个分支结束都会跳转到最后结束的分支\n用途能够表示程序的控制流。\n目前用于重排if指令，后续代码的优化分析会经常用到。最经典的就是ssa(Static Single Assign)相关操作，需要对控制流进行分析，而转换为cfg的形式本质上只需要对cfg分析就可以了\n构造算法构造算法很简单。从头到尾进行一遍搜索，找到一个label就开始一个基本块，而到了一个跳转就结束一个基本块。\n但是存在两种特殊情况\n\n当前是label的情况下前一条指令不是jump的话需要手动添加一个jump跳转到当前的label\n当前是jump的情况下如果下一个不是label则需要将下一个指令设置为label\n\n上核心代码（这里省掉了检查第一个label的代码\ntac_list.each_with_index do |cur_tac, index|  if cur_tac.is_a? TAC::Label    # prev is not a jump, maybe need push a jump to this label    # but when first, not need process    valid_do(tac_list, index - 1) do |prev_tac|      unless prev_tac.is_a? TAC::Jump        blocks.last.push TAC::DirectJump.new(cur_tac)      end    end    blocks.push BasicBlock.new(cur_tac)  elsif cur_tac.is_a? TAC::Jump    # next is not a label, need create a block and push a label to next block    blocks.last.push cur_tac    valid_do(tac_list, index + 1) do |next_tac|      unless next_tac.is_a? TAC::Label        blocks.push BasicBlock.new(&quot;TmpLabel#&#123;tmp_label_count&#125;&quot;)        # push a label      end    end  else    blocks.last.push cur_tac  endend\n\n目前这里的tac采用的是数组而不是链式结构，所以查看前一个以及插入结点略微麻烦（第一次写，所以一开始写的时候没有想到那么多，后续可以考虑换成链式结构方便插入与查找前驱后继）\n重排if重排的过程分为三步\n\n找到所有的路线\n路线排序\n\n找到所有路线这里也是采用相对比较简单粗暴的算法\n类似于dfs的形式，将所有的基本块放入一个队列中，从第一个未标记的开始深度优先遍历，和dfs一样需要标记中途遍历过的结点，但是并不恢复标记。一条路走完后会从队列取出下一个未走过的点作为新的路线的起点。\n从当前的块选择下一个到达块的时候优先选择false分支， ****为了后续转到vm指令的时候不需要考虑CondJump false的情况，false直接顺着走就可以了，方便后面的排序\n上代码\ndef search_all_branches(cfg)  blocks = cfg.blocks  tag = Tag.new  q = blocks  roads = []  # dfs that traverse all nodes  until q.empty?    roads.push search_single_road(q, tag)  end  roads.reduce([]) do |sum, road|    sum + road.blocks  endenddef search_single_road(q, tag)    t = Road.new    b = q.shift    until tag.has_marked(b)      tag.mark(b)      t.append(b)      # find last(false branch)      first_next_b = b.all_next.reverse.find &#123; |next_b| not tag.has_marked(next_b) &#125;      if first_next_b.nil?        break      else        b = first_next_b      end    end    tend\n\n排序这里有三种情况\n\nCondJump后面接着的是false的块，则不需要做任何事情\n后面接的是true块，则需要调换顺序，而条件需要设置为相反的\n后面的块和这个CondJump没有关联，那么需要将这个CondJump(cond, label_true, label_false)转换为一个CondJump(cond, label_true, label_false‘)，之后在后面添加一个label_false’以及直接到label_false的跳转指令\n\nCondJump(cond, label_true, label_false) →\nCondJump(cond, label_true, label_false‘) + label_false’ + Jump(label_false)\n我这里是通过判断块的第一个label来判断是不是对应的块。代码写的比较粗糙\ndef reorder_branches_impl(tac_list)  tac_list.each_with_index do |tac, index|    if tac.is_a? TAC::CondJump      next_tac = tac_list[index + 1]      if next_tac == tac.false_addr        # is ok      elsif next_tac == tac.true_addr\t\t\t\tset_not_cond(tac_list, index)        next_false_tac = tac_list[index + 2]        tac_list[index + 1], tac_list[index + 2] = next_false_tac, next_tac      else        old_false_branch = tac.false_addr        new_false_branch = TAC::Label.new(&quot;#&#123;tac.false_addr.name&#125;f&#x27;&quot;)        tac.false_addr = new_false_branch        tac_list.insert(index + 1, new_false_branch)        tac_list.insert(index + 2, TAC::DirectJump.new(old_false_branch))      end    end  endend\n\n可以看到这里也是由于使用数组来保存导致插入新指令比较麻烦（下次一定修改为链式，咕咕咕）\n关于更详细的案例可以看对应的测试代码。重排if的测试代码在spec/ir/tac_spec.rb中\n参考资料现代编译原理C语言描述 第七章、第八章\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记1 中间代码表示","url":"/2021/12/26/rc-lang-dev-1/","content":"本周前面的时间主要选择了重新整理项目结构以及修正了自己滥用require_relative的问题，后面的话则是开始对ast to tac进行测试，尝试通过TDD的方式在开发效率和质量确保找到一个平衡点。\n比起测试，更主要的目的是重新回顾自己tac的设计决策，前面写的时候更多是一时兴起，完全不顾结构与正确性就往下写，比起急急忙忙往后赶进度还是应该将当前的内容做好才行。\n当前的项目结构.github # CI 尽管代码不多，但是依然要依靠单元测试和CI保证每次修改的正确性analysis # 代码分析的内容，目前并没有做过多的内容interface # 编译器、解释器和REPL的入口compiler # compiler的实现interpreter # 解释执行的实现ir # 多级ir的实现，ast, tac, vm指令lib # 编译器相关的一些简单的库，比如env, log或者错误处理之类parserspec # 专门用于测试\n\n解释执行实现的部分由于其他内容快速修改，暂无法顾及，因此暂时无法正常工作\nRc-lang的多层IR结构\n高层IR：AST\n中层IR：四元式\n底层IR：VM指令\n\n本周内容主要以中层IR为主\n中间代码表示IR主要分为两类\n\n线性IR\n图IR\n\n要注意的是树IR也是一种DAG图，因此也属于图IR，而高层的AST也是属于图IR\n选择IR的时候最主要的一点是我们要用它来做什么、需要什么信息，我想也没有什么绝对的设计正确，只要提供了所需信息，方便后续测试就足够了。在这里对比一下常见的IR实现（以线性IR为主）\n线性IR的概念三地址码是指 指令右侧只能有一个运算，不允许出现组合的形式\na2 = (b + c) * 4需要被翻译为a1 = b + ca2 = a1 * 4\n\n龙书中选择了线性IR的方式，使用了传统的三地址码。而虎书采用了树形IR（最后会简单提及）\n四元式具有四个字段，类似于 op arg1 arg2 result的形式，但是存在一些特例\n\nop仅需要一个参数\nparam的运算不使用args2和result（这里的param是龙书中用于传递函数参数的指令，龙书针对每一个参数产生一个param，仅传递参数也不需要返回值）\n转移指令将跳转地址放入result\n\n这些特例是针对虎书中的指令，实际可以根据需求进行一些变动\n定义这是我的四元式定义 在文件ir/tac/quad.rb中\nclass Quad  attr_accessor :op, :result, :lhs, :rhs  def initialize(op, result, lhs, rhs)    @op, @result, @lhs, @rhs = op, result, lhs, rhs  end  def to_s    &quot;#&#123;@result&#125; = #&#123;@lhs&#125; #&#123;@op&#125; #&#123;@rhs&#125;&quot;  end  def ==(other)    @op == other.op &amp;&amp; @result == other.result &amp;&amp; @lhs == other.lhs &amp;&amp; @rhs == other.rhs  endend\n\n以及我个人觉得没必要全都严格按照这种方式来，还是以自己的需求为准。按照常规的四元式op可以是各种类型的\n比如说我实现的Assign和Call（其他的op目前还没有修改以及做更多测试，本周先介绍这两个最基本的）\n通过类型来获取更多的信息，而不是仅仅通过字符串判别。还可以做到像call一样设置一个别名，能够显得更加直观\nclass Assign &lt; Quad  def initialize(result, lhs)    @op = &#x27;assign&#x27;    @result = result    @lhs = lhs    @rhs = EmptyValue.new  endend\n\nclass Call &lt; Quad  def initialize(result, target, args)    @op = &#x27;call&#x27;    @result = result    @lhs = target    @rhs = args  end  def target    @lhs  end  def args    @rhs  endend\n\nAssign没什么可说的。但是Call比较特殊\nargs并不是只有一个地址，所以Call并不算严格意义上的四元式。上面也提及过龙书中的Call的参数是通过一个param指令传递的，然后单独调用一个call。但就我目前来说这样做比较方便，等到后续做其他功能发现这么做的坏处的时候再修改也不晚\n转换实现\n转换代码在ir/tac/translator.rb中\nclass Assign # Rc::AST::Assign  attr_reader :var_obj, :expr  def initialize(var_obj, expr)    @var_obj, @expr = var_obj, expr  endenddef on_assign(node)  name = visit(node.var_obj)  expr = visit(node.expr)  Assign.new(name, expr).tap &#123; |assign| @tac_list.push assign &#125;end\n\n转换ast::assign的时候会将原来的名字作为tac::assign一个目标地址（尽管设计上留有了这个空间，但是目前先不考虑成员变量这种复杂的情况），然后再将表达式返回的内容设置为assign的operand。因此我们需要看一下expr的转换\nclass Expr # Rc::AST::Expr\tattr_reader :exprend# Rc::AST::Expr -&gt; Operanddef on_expr(node)  expr = visit(node.expr)  if expr.is_a? Operand    expr  elsif expr.is_a? Quad    expr.result  else    raise &#x27;unknown expr type&#x27;  endend\n\n存在两种情况\n\n转换为一个operand（比如说常量的情况）\n\n转换为了一个quad\n比如说c = a * b，a * b 会先存到一个临时变量再赋值。关于这个，龙书6.1.1中提到了这样的内容\n\n为什么我们需要复制指令？通常，每个子表达式都会有一个它自己的新临时变量来存放运算结果。只有处理赋值运算符=时，我们才知道将把整个表达式的结果赋到哪里，一个代码优化过程将会发现可以发生替换\n\n我没完全理解，也许只有做优化的时候才会明白，就先沿用这样的设计了\n\n\nquad的时候需要返回对应的临时变量，因为返回值会直接用于assign的operand\n测试\n然后我们再来看一下测试代码 spec/ir/tac_spec.rb\ncontext &#x27;assign&#x27; do  it &#x27;succeed&#x27; do    s = &lt;&lt;SRCdef f1\ta = 1\tb = 2\tc = a * bendSRC    tac = get_tac(s)    list = tac.first_fun_tac_list    expect(list[1]).to eq Assign.new(Name.new(&#x27;a&#x27;), Number.new(1))    expect(list[2]).to eq Assign.new(Name.new(&#x27;b&#x27;), Number.new(2))    expect(list[3]).to eq Quad.new(&#x27;*&#x27;, TempName.new(&#x27;0&#x27;), Name.new(&#x27;a&#x27;), Name.new(&#x27;b&#x27;))    expect(list[4]).to eq Assign.new(Name.new(&#x27;c&#x27;), TempName.new(&#x27;0&#x27;))  endend\n\n可以看到有简单的assign, 还有一个表达式的运算。\n表达式的运算转换为了一个quad，并且保存在了临时变量中，最后再将这个临时变量assign给c\n线性IR的存储方式对于线性IR来说，保存的方式也是一个比较重要的实现决策，很大程度会影响到后续各种操作。\n而实际实现无外乎数组和链表两种保存方式，在上周做重排if的时候也能看到数组的方式插入删除比较麻烦，而且效率会比较低。数组插入删除的方式也有对应的优化实现，但是对于其他优点目前没什么了解，后续做到优化的时候可能会需要考虑到这些实现方式的差别。\n我当前所有指令都保存在了一个数组，所以上面的四元式并没有指向前后的指令。之所以这么选择是因为当时没考虑太多，很自然的会想到一组指令会存到一个数组中。不过需要时在ast全部转为tac以后再做一下转换即可，需要做其他优化时再添加。当前目的是直接生成下一步的指令，所以现在这样就够了。\n名称与地址对于线性ir来说名称和地址是非常重要的事情。名称与地址是对应了三地址码的操作数，可以是常数，可以是一个地址，也可以是一个名字（间接索引到地址）\n所以有了一个operand的定义，在文件ir/tac/operand.rb中\nclass Operandend\n\n1.名字通过名字确定一个地址，实际实现可以通过符号表来索引到对应地址。\nclass Name &lt; Operand  attr_accessor :name  def initialize(name)    @name = name  end  def to_s    @name.gsub(/:/, &#x27;&#x27;)  end  def ==(other)    @name == other.name  endendclass TempName &lt; Nameend\n\n2.常量如果是数字类型的常量可以直接放入，这也符合CPU指令的行为。（bool本质也是数字）\n如果是字符串常量则需要记录到全局的一个表中，本质上我们还是使用字符串的地址。这个表里的东西在后续转vm指令和运行时会放入常量段，由于不会牵扯到改变，因此目前这里采用了一个普通的列表，通过索引来获取地址的方式。这里或许会牵扯到优化的问题，我觉得关于字符串常量这种优化可以放到转入这一步之前，如果遇到其他场合再做修改。\n两种常量的定义\nclass Number &lt; Operand      attr_accessor :num      def initialize(num)            @num = num      end      def to_s            @num.to_s      end      def ==(other)            @num == other.num     endend\n\nclass Memory &lt; Operand  attr_reader :addr  def initialize(addr)    @addr = addr  end  def ==(other)    @addr == other.addr  endend\n\n常量的转换\ndef on_bool_constant(node)  Number.new(node.val.to_i)enddef on_number_constant(node)  Number.new(node.val.to_i)enddef on_string_constant(node)  Memory.new(@const_table.add(node.val))end\n\n在这里涉及到一个const_table的问题。字符串会放在常量区，因此我选择在这里转换为一个地址。关于Memory或许需要选择段的问题，但是目前还没有遇到需要区分的情况，后续添加其他类型的常量再考虑吧，因此也是先这样。\nclass Memory &lt; Operand  attr_reader :addr  def initialize(addr)    @addr = addr  end  def ==(other)    @addr == other.addr  endend\n\n常量表\nclass ConstTable  attr_reader :list  def initialize    @list = []  end  def add(constant)    i = @list.index(constant)\t\ti.or_else do      @list.push constant      @list.size - 1    end  end  private def method_missing(symbol, *args)    @list.method(symbol).try &#123; |x| x.call(*args) &#125;  end  def ==(other)\tlist == @other.list  endend\n\n目前选择了这样简单的形式。没有用Set的原因是难以添加一个成员以后再返回对应的索引，可以作为后续优化的一个点。\nor_else是一个hack, nil的情况会返回block中的代码\n3.临时变量临时变量会出现在各种表达式中，前面转换的实现中也能看到相关内容。这里不多赘述\n其他IR形式这里对于SSA(Static Single Assign)就暂不提及了，SSA更多的是用于优化方面，目前的目标是生成VM指令并且能在VM上运行，做到SSA的时候会讲的\n其他的形式在这里大概一提，不讲过多细节（写不完了）\n三元式具有三个字段，类似于op arg1 arg2的形式。和四元式不同，不会显式保存返回结果，而是将每个结果存入列表中，因此三元式对结果的引用也是依靠于位置。很明显，这样就会导致如果添加或者减少指令则会变得很麻烦，因此引入间接三元式（在这里不赘述了，有兴趣自行搜索）\n由于实现比较麻烦，所以我还是选择使用常规四元式\n图IR虎书采用了树形IR\n由于我目前选择了线性的方式，暂无这方面的代码，姑且还是提一下虎书中的实现并且贴一下图\n其实也比较接近于tac，只是结构变成了树状，同样会有各种常数，内存操作，调用等等，因为中层IR本质上都是要将AST转换为接近于机器表示，所以不管什么样子最终都是要接近于机器指令。不同的存储方式区别只是做优化的时候不同\n\n\n最后tac指令以及对应的operand过于繁琐，测试代码也有待改进，对于Ruby来说这些都可以利用元编程来精简代码，而且可以疯狂造dsl。只是每天的开发时间实在不多，还是以能做出来为最高优先级。\n写了足足快俩小时，有点写的不耐烦了（有点时间焦虑，先以能写完为目标吧…）。写的过程中我会强迫自己反思和改进，上周写的时候最后还发现了一个bug，也算是不亏，下周也会更（在新建文件了，咕咕咕\n参考https://www.zhihu.com/question/33518780/answer/56731699\n编译原理 第六章\n现代编译原理 第七章\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记2 VM相关","url":"/2022/01/02/rc-lang-dev-2/","content":"本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧\n本周vm的代码都在ir/vm中，translator用于转换，inst是指令定义，vm.rb是入口\nFunction转换这是我目前的Function的ast定义\nclass Function    attr_reader :name, :args, :stmtsend\n\n在修改function生成代码的时候发现了一个问题，因为我有默认最后一个值直接返回的设计，所以或许应该在高层添加一个将stmt显式抽出\nreturn的操作。这个步骤现在看来大概分为简单两步\n\n消除不可达代码，比如说一个return后面还有好几个值\n消除后就可以放心将最后一个语句的结果转换为一个返回值了\n\n但是第二步实际实现的时候可能没有这么简单，这里就暂提个思路，以后再回头看这个设计是否有需要\n无意义的tac to vm inst之后做了一些将tac转到vm指令。在做这个的过程我才意识到其实不需要转成tac，对于tac和vm指令的表达力应该是同等级的，都比较偏向于中层IR。查看了一下其他语言的做法，Ruby和Java都是从AST转到了字节码\n深入理解Java虚拟机310页：\n\n字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作\n\nRuby原理剖析36页：\n\n在解析完 词条生成AST之后，Ruby1.9和Ruby2.0继续把代码编译成一系列的底层指令，叫做YARV指令\n\n这里的YARV是Ruby的字节码解释器，而YARV指令自然就是对应的字节码。而Ruby1.9之前是直接解释执行ast的，甚至不会考虑到tac这样的东西\n为什么不需要先转成tac优化后再到vm指令关于这一点，我询问了朋友，最后的结论大概有以下两点。如果读者对这方面很了解希望能科普一下\n\n转成tac做优化以后，尤其是部分针对全局的优化会以及其他的变换会剔除掉一些JIT时所需要的信息。\n关于这点我问了很久，我觉得还要尽可能地多做优化再到jit，应该要通过控制不做哪些优化来避免剔除所需信息。因为我对这几个层面所能做的优化了解不深，不知道所能做的优化有哪些差异，也没法举出例子或者说明收益\n后续我又了解了一些信息，发现jit中还有一个名叫的deoptimize技术，这个出现在multi tiered jit中。关于这个的内容在我另一篇博客中\n\n如果直接显式执行的是源码而不是字节码，先转成tac做处理再到vm指令会影响到了启动时间\nRuby是在内部对源码解析之后再由vm来执行。Java可能给大多数人的印象是必须要先编译到字节码，然后再单独加载执行字节码，但调查发现Java9开始可以通过jshell来直接执行。将这个过程封装到一起实际上也不麻烦，只是不需要你显式操作罢了\n\n\n所以经过了这些结论，前面做的tac到vm指令的就白费了，只能重新写一套从ast生成vm指令代码。生成tac这个过程并没有白费，编写的过程中让我有对这个东西有了更深的理解，以及后续可能会用tac实现优化算法。\nVM简介至于VM的实现，很自然的就会选择栈式VM。以学习为目的肯定要做寄存器分配，但是因为后续想做jit，所以寄存器分配就留到那个时候再做，或者说可以再从tac做成aot，反正目前还是以实现学习为目的。\n搞一个VM本质是什么？我觉得本质是对运行时的环境进行处理。那么我们首先要来谈及这个环境都有哪些部分\n我觉得简单可以分为以下两种\n\n数据（代码与计算的数据）\n当前状态（寄存器与栈帧）\n\n数据数据牵扯到的问题有很多，比如说数据排布、对象布局、地址分配等等。这也是我第一次动手做这些，这里就先从最简单的只有int32做起。如果后面做完善了可以再单独出一期把这些东西串起来（咕咕咕咕咕咕\n当前状态寄存器寄存器就从目前来说，我们需要一个pc寄存器来表明当前执行到哪条语句了。至于vm那边的实现目前使用一个数组保存，pc保存下数组索引就好\n栈帧栈帧根据不同的需求内容也各不相同\n我们来看一下龙书中提到的常见栈帧成员（不论什么书其实大都差不多\n\n局部变量\n临时变量的位置（牵扯到临时变量？\n机器状态（保存的特殊寄存器值，这个和调用约定也有一定关联。调用约定决定了哪些寄存器是需要保存的，哪些是不需要保存的，关于调用约定更多详情还请自行查询\nrbp指针（用于管理访问链\n指向调用者的地址\n返回值（我选择统一放到一个寄存器中）\n实参\n\n要注意的是书中提到的基本上是针对非VM的栈帧，VM的栈帧可以根据需求做出不一样的设计，比如说Ruby中采用了双栈的设计，一个调用栈用于管理调用链，一个计算栈用于存放各种变量与计算，而对于非VM栈帧絕大多说都是一个栈（我没听说过有使用双栈的，但是说不定也存在呢）通过栈中保存的rbp寄存器中的值来处理访问链\n就目前从头开始实现而言，我们需要什么再加什么就好了，后续每个东西怎么加，为什么加我都会有一定说明。\nVM指令转换计算赋值先从普通的运算赋值做起。这里其实有点问题，我还没有处理好单独的语句，所以都放到了一个函数里（写完这篇就去改），以及对于函数定义该如何处理我也没想好。\ndef foo  a = 3 * 2end\n\n在Ruby的虚拟机中扫描到类似的函数定义则是会产生一行调用 definemethod :foo, foo\n而foo本身的内容则是\n== disasm: #&lt;ISeq:f@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])[ 1] a@00000 putobject                              3                         (   2)[LiCa]0002 putobject                              20004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;0006 dup0007 setlocal_WC_0                          a@00009 leave                                                            (   3)[Re]\n\n这里出现了一个点，由于函数体中是一个assign，值会pop走，但是这个assign又是作为一个返回值，因此ruby中对结果调用了dup，创建一个重复的值用于返回。在写博客的时候看到Ruby指令的结果刚意识到这个问题，不过这个是属于关于函数体与函数调用相关的内容，这里目前暂不修改。\n作为参考，进行编写测试。\ncontext &#x27;assign&#x27; do  it &#x27;normal expr&#x27; do    s = &lt;&lt;SRCdef fooa = 1 * 2endSRC    inst = get_vm_inst(s)    expect(inst).to eq [Rc::VM::Push.new(1), Push.new(2), Mul.new, SetLocal.new(0), Return.new]  endend\n\n对于一个普通的a = 1 * 2，我们期望的行为是将两个参数push到栈上，之后进行mul操作，最后设置本地变量的值\n乘法操作class Binary # Rc::AST::Binary  attr_reader :op, :lhs, :rhsenddef on_binary(node)  [    push(visit(node.lhs)),    push(visit(node.rhs)),    translate_op(node.op),  ]end\n\n操作数的处理指令操作数目前分了两种，一种是直接可以保存值的，一种是引用某个名字\nmodule VMInstOperand  class Value &lt; Struct.new(:value)  end  # Ref a exist var  class Ref &lt; Struct.new(:ref)  end  def push(node)    if node.is_a? Value      Push.new(node.value)    elsif node.is_a? Ref      GetLocal.new(node.ref)    else      raise &quot;Unsupported node type #&#123;node.class&#125;&quot;    end  endend# 下面两个都是visit结点的函数def on_number_constant(node)  Value.new node.val.to_iend# Get or Set, so need return a iddef on_identifier(node)  Ref.new cur_fun_env[node.name].idend\n\n这么设计的原因是\n\n针对一个简单的数值我们可以直接将值push到栈上\n针对一个名字我们需要去符号表中找到这个名字所在的位置，再将对应的值push到栈上\n\n同时也有不同的“push操作”\n\n针对简单的值直接push\n针对名字我们通过GetLocal来获取（对于vm那边的实现，需要根据局部变量的基址和偏移量以及类型找到对应的值再放上去，但是类型目前不考虑，统一int32）\n\n这里暂时不考虑访问外部作用域的问题，这会涉及到符号表的访问以及栈的修改两部分内容。\n针对这样的设计，我们需要开始增加栈的功能了\n\n简单数值的运算，我们需要能将值放上去，再进行运算取出或者留在栈里（这些临时变量）\n\n因此就有了如下最最最简单的栈\n----------  临时变量----------\n\n\n我们需要留有局部变量的位置，能够在里面存取数据。临时变量是会随着当前函数结束而销毁，因此我们需要添加临时变量的位置在栈上，栈回退的时候也会直接销毁掉\n由于1需要反复修改栈指针的操作需要所以放在当前栈帧的最顶端比较合适\n\n\n因此就有了如下最最简单的栈\n----------  临时变量----------  局部变量----------\n\nop处理这个没什么好说的，简单从op字符串转换到不同类型的运算指令\ndef translate_op(op)    case op.op    in &#x27;+&#x27;      Add.new# ...以下省略\n\n符号表就之前的代码而言，符号表信息之类的记录的并不够。在实际考虑栈帧以及执行之前我对符号表的认识仅仅停留在作为解释器的env以及他的功能的“概念”上。由于是之前写过的，就直接拿来用了，没有 再来认真反思设计以及其他的问题，回头再重新设计吧，先能用就行\n考虑局部变量如何保存这个问题，引出了我对符号表更多的实际理解，所以还是要自己动手做才能更有助于理解，只是看一些理论讲还是不够，至少对我而言是这样的\n关于扫描分析的代码在analysis/global_env中\n符号表相关的定义在lib/env中\n全局表class GlobalEnv &lt; Struct.new(:define_env, :const_table, :fun_env)end\n\n全局表目前保存三个东西\n\n各种定义（类定义、函数定义等），这个设计是比较早的时候写的，可能并不合适，后续再好好想一下该怎么做\n常量表\n函数的符号表，根据函数名找到对应函数的符号表\n\n条目针对生成VM指令的阶段，需要知道一个临时变量的位置，因此有了这样的一个东西作为符号表的条目。\nclass EnvItemInfo &lt; Struct.new(:id, :type)end\n\nid的话在一个函数中是自增的，用于GetLocal和SetLocal中计算具体的offset（这个设计对于后续可能不够用，先这样）。类型肯定也是需要的，但是目前并没有考虑类型的问题，就留了这么一个坑在这里\n函数def on_function(node)  @define_env.define_symbol(node.name, node)  @cur_fun_sym = Env.new  @cur_fun_var_id = 0  @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)  visit(node.stmts)  @fun_env[node.name] = @cur_fun_symend\n\n\n将函数名字关联到结点\n从每个函数开始分析时初始化各参数的状态\n将参数merge进当前函数的符号表中\n访问函数体\n将函数名关联到对应的符号表\n\n最后今天写的太久有点写不下去了，所以到后面内容比较潦草，还请见谅。（目前以保证更新频率为主）有疑惑的地方可以联系我\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记3 生成C++代码","url":"/2022/01/09/rc-lang-dev-3/","content":"由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。\n指令定义每个指令有一个InstType的枚举字段来标明类型\n所有指令继承自一个VMInst类\nstruct VMInst &#123;    InstType type;protected:    VMInst(InstType t) : type(t) &#123;&#125;;&#125;;struct Addr : VMInst &#123;public:    Addr(int offset, string seg) : VMInst(InstType::Addr), _offset(offset), _seg(seg) &#123;&#125;private:    int _offset;    string _seg;&#125;;\n\nC++解析最主要的问题是要如何让C++解析这边生成的东西。我目前就选用了最简单粗暴的方法，直接生成字符串，用空格分离参数，用换行分离指令\n获取所有指令信息获取有哪些指令我将所有的指令都放到了Rc::VM::Inst中，通过获取这个module的所有constant，判断哪些是Class\ndef get_classes(mod)\tmod.constants.map&#123;|c| mod.const_get(c)&#125;.select&#123;|c| c.is_a? Class&#125;.sort_by&#123; |klass| klass.to_s &#125;endclasses = get_classes(Rc::VM::Inst)\n\n通过这个代码能够获取到Inst这个模块中的所有指令\n\n获取每个指令里面是怎么样的\n\n由于ruby并没有定义成员类型的东西，因此我选择自己造一个指定成员类型的东西\n有两种实现\n实现方式TypeStruct第一种是将Struct给包装一层，我给其命名为TypeStruct\n使用方式\nclass CondJump &lt; TypeStruct.new(:cond, :addr =&gt; :int)  def to_s    &quot;CondJump #&#123;cond&#125; #&#123;addr&#125;&quot;  endend\n\n类似于常规的Struct的使用方式，但是输入变成了可以是一个hash\n实现\n\n实现的一个要点在于new返回的东西需要是一个class。那么我们需要知道Ruby中new是怎么运作的\n常规的对象来说，new中会做三件事。class MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = “\\n”, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map { |td| td.name }  endend通过allocate分配空间，send initialize方法进行构造对象，最后将obj返回。而在这里只要修改返回的内容即可\n\n另一个要点在于需要给返回的class添加一些实例方法\n这里我们需要先理解常规的Struct.new做了什么，在我的理解本质上是返回了一个通过动态添加定义的匿名class，那么我们需要的是给这个匿名class添加一些方法来定义\n那么我们很自然的就会想到将所有传给new的参数转换为每一个成员以及与之相应的类型定义，之后再对其中每一对“成员名⇒类型”定义对应的获取类型的方法\n\n保存一个type_map，用于后面获取信息使用\n\n\n来看一下代码\ndef args_to_hash(*args)  args.reduce(&#123;&#125;) do |sum, arg|    sum.merge(      if arg.is_a? Hash        arg      else        &#123; arg =&gt; :str &#125;      end)  endendclass TypeStruct  include TypeCheck  def self.new(*args, &amp;block)    # if don&#x27;t have allocate, will be nil class    obj = allocate    # initialize is a private method    # initialize must be send instead of direct call    obj.send(:initialize, *args, &amp;block)  end  def initialize(*args)    args = args_to_hash(*args)    Struct.new(*args.keys).tap do |klass|      args.each do |attr, type|        check(type)        # per class Struct is different        klass.define_method &quot;#&#123;attr&#125;_t&quot; do          type        end      end\t  klass.define_method &quot;type_map&quot; do        args      end    end  endend\n\n还有一个点是需要在这里检查type的合法性，这里想过生成类的，但是最后想或许现在没必要，还是先用符号吧。检查相关的代码如下\nmodule TypeCheck  VALID_TYPE = &#123;:int =&gt; :int, :str =&gt; :string&#125;  def invalid?(type)    VALID_TYPE.keys.include? type  end  def check(type)    unless invalid? type      raise &quot;invalid type #&#123;type&#125;, only supported #&#123;VALID_TYPE.map(&amp;:to_s).join(&#x27;,&#x27;)&#125;&quot;    end  end  module_function :check, :invalid?end\n\nattr_type第二种是增加了一个像attr_reader一样叫做attr_type的东西，但是这个要依赖于常规的Struct，我还是想要常规Struct内部的东西来避免重复代码。虽然有办法不依赖Struct，但是那样需要在这个attr_type里面引入更多不属于这个函数的功能，于是还是放弃吧\n使用示例\nclass Push &lt; Struct.new(:value)  attr_type :value =&gt; :int  def to_s    &quot;Push #&#123;value&#125;&quot;  endend\n\n实现\n实现的核心原理还是参数转到hash再对每一对值define_method，只是这次我们要直接hack Module。attr_reader等函数也是采用的类似的做法\ntype_map的处置有一些不同，type_map需要将成员初始化，所有成员默认str类型，接着需要不断的merge新的参数，这个时候会将type_map中在args出现过的key所关联的值更新，这么解释可能比较复杂，看代码更直接一些\n&#123;:a =&gt; 1&#125;.merge(&#123;:a =&gt; 2&#125;)=&gt; &#123;:a=&gt;2&#125;\n\nclass Module  def attr_type(*args)    args = args_to_hash(*args)    args.map do |attr, type|      TypeCheck::check(type)      define_method &quot;#&#123;attr&#125;_t&quot; do        type      end    end\t@type_map ||= self.members.reduce(&#123;&#125;) &#123;|mem| &#123;mem =&gt; :str&#125;&#125;    @type_map.merge!(args)  endend\n\n二者的选择最后的结果嘛…ide分析不出来，不想看到各种报错的红线。遇到需要手动new的时候只能改成第二种了\n\n在获取成员的时候也用了很脏的做法，没找到什么在不new的情况下获取成员的好方法，因此也只有先new再从里面找。\n生成以前没做的坑这里其实做一个dsl来描述然后生成是最好的。在好久之前了解rv的时候我甚至一度想开一个坑，用一个dsl来描述一个isa，之后生成对应的C++的读写代码。最后也是咕咕咕了，后续有时间可以做一下，还是挺有意思的。\n这是一个描述load store的例子。当时做的时候没想到，现在一想其实也可以直接用Struct来描述，采用和我上面一致的方案\nISA.define :LOAD do  field :rd, 5  field :funct3, 3  field :rs1, 5  field :imm, 12endISA::define :STORE do  field :offset_4_0, 5  field :width, 3  field :base, 5  field :src, 5  field :offset, 5end\n\n这是一个只做了外观没有做内部实现的例子，属实有点问题，正经人谁会搞出这玩意\nnamespace :Suica do  namespace :T do    struct :F do      auto :a1      auto :a2, 1      void :f2, [&#x27;a&#x27;, &#x27;b&#x27;] do      end    end  endend\n\n生成的实现有点扯远了，我们来看一下实际生成C++代码的部分。\n我们需要生成如下几步\n\n获取所有指令信息\ninclude头文件，名称空间等内容\nInstType的enum定义\n所有指令类的定义\n解析输入的部分\n\n每个部分生成一个源码字符串，最后将这些拼接为一个长的字符串就好了\n捋清这个流程以后就简单贴一下部分代码好了，源码中&lt;&lt;SRC的部分是一个字符串块的开始，SRC是结束，中间的任何字符都会保留，除了#{expr}，这个是将expr to_s以后再嵌入进去\n帮助方法这是我自己加给Array的辅助函数，因为经常会有需要遍历array的所有对象做一套统一的操作最后再join连接的情况\nclass Array  def generate(c = &quot;\\n&quot;, &amp;f)    map &#123;|a| f[a] &#125;.join(c)  end  def pure_generate(&amp;f)    map &#123; |a| a.demodulize_class &#125;.generate(&amp;f)  endend\n\ndemodulize_class的话就是简单的将类名去除了module前缀\n获取所有指令信息虽然上面提过，这里再放一下代码\ndef get_classes(mod)      mod.constants.map&#123;|c| mod.const_get(c)&#125;.select&#123;|c| c.is_a? Class&#125;.sort_by&#123; |klass| klass.to_s &#125;end\n\n头文件def gen_header_namespace  &lt;&lt;SRC#include &lt;string&gt;#include &lt;vector&gt;#include &lt;memory&gt;#pragma onceusing std::string;SRCend\n\nInstType的enum定义def gen_enum_inst_type(classes)  &lt;&lt;SRCenum class InstType &#123;#&#123;classes.pure_generate &#123;|c| &quot;#&#123;c&#125;,&quot;&#125;&#125;&#125;;SRCend\n\n生成的样子\nenum class InstType &#123;Add,Label,SetLocal,&#125;;\n\n指令类定义def gen_class_define(klass)  class_name = klass.demodulize_class  member_map = klass.get_member_map  params = member_map.generate(&#x27;, &#x27;) &#123;|td| gen_class_member(td)&#125;  init_member = &quot;#&#123;member_map.keys.generate(&#x27;, &#x27;) &#123;|name| &quot;_#&#123;name&#125;(#&#123;name&#125;)&quot;&#125;&#125;&quot;  init_member = &quot;, #&#123;init_member&#125;&quot; unless init_member.empty?  init_inst = &quot;VMInst(InstType::#&#123;class_name&#125;)&quot;  &lt;&lt;SRCstruct #&#123;class_name&#125; : VMInst&#123;public:  #&#123;class_name&#125;(#&#123;params&#125;):#&#123;init_inst&#125;#&#123;init_member&#125; &#123;&#125;private:#&#123;member_map.generate &#123;|mem_ty| &quot;#&#123;gen_class_member(mem_ty, &#x27;_&#x27;)&#125;;&quot;&#125;&#125;&#125;;SRCend\n\n这里可能有一些需要提一下的东西，比如说有一个get_member_map\nclass Class  def get_member_map    instance = self.new    # need keep same order    MemberMap.new(instance.try(:type_map).or_else&#123;[]&#125;.map do |name, type|      TypeDefine.new(name, type)    end)  endend\n\n为了保持顺序，我选择了用数组来存放。指令最多无外乎一两百条，对于这个数据量不需要太去关心什么高效算法。\n为了有更多的类型信息来帮助写易读和更可用的代码，一个名称类型对也转转换为了一个类型\nclass TypeDefine &lt; Struct.new(:name, :type)end\n\n而MemberMap是一层包装，内部用typedefine的array存储，但也是可以像hash一样取出所有的key\nclass MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = &quot;\\n&quot;, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map &#123; |td| td.name &#125;  endend\n\n生成的样子\nstruct Label : VMInst&#123;public:  Label(string name):VMInst(InstType::Label), _name(name) &#123;&#125;private:string _name;&#125;;\n\n解析代码def gen_all_parser(classes)  &lt;&lt;SRCstd::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list)&#123;#&#123;classes.generate &#123;|x| gen_parser(x)&#125;&#125;throw std::runtime_error(&quot;Unknown inst type&quot; + list[0]);&#125;SRCend\n\n生成的样子（这里只放一个示例\nstd::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list) &#123;\t    if (list[0] == &quot;Addr&quot;)\t\t        return std::make_unique&lt;Addr&gt;(std::stoi(list[1]), list[2]);&#125;\n\nC++代码格式这里应该提一下，这种生成方式代码格式一定会乱七八糟，所以还应该调用一下clang-format处理一下。但是VM那边的clang-format之类的许多东西还没有加好，之后再做一下吧\n最后感谢你能看到这里，我再闲谈几句没什么关联的\n这个系列我已经到了四篇，也就是一个月。持续做了这么几次已经可以确定只要不出意外自己就能连载下去，于是之后都会在推特推送我的更新（本周的就先算了，ruby本身所占比例有点大）RealAkemiHomura’ Twitter\n如果对我的日常有兴趣可以点个关注，如果并不在意这个只想看后续的文章，那么可以通过rss订阅，或者每周一查看我的文章，更新一定是在周末\n前面也提到元旦状态差，这些天甚至几次觉得这个系列过于玩具没有意义，想要断更、项目不想做下去了。但我最后还是决定继续更新，不为别的，只因为我还想接着做这个项目，哪怕内容如此简陋，只是一个过于简单的玩具，但我确实从中收获了知识和乐趣\n","categories":["Ruby"],"tags":["Rc-lang","元编程"]},{"title":"Rc-lang开发周记4 函数其一","url":"/2022/01/16/rc-lang-dev-4/","content":"本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。\n函数解析方式这里我一开始没想好怎么做的，所以会做的很诡异，最大的原因是静态类型语言和动态类型语言是不同的。由于我只对动态语言有一些了解，这里暂时只提动态语言的一些点\n动态语言手头动态类型语言的资料是相对较多的，而实际看编译出的产物也是相对熟悉一些。\n对于Ruby和Python来说，函数都是动态定义的。因此解析到一个函数的时候会产生一个定义函数的指令\nRuby\n0000 definemethod     :foo, foo      (   1)[Li]\n\n（后面的1是行号）\nPython\ndef f():0 LOAD_CONST    0 (code object f)3 MAKE_FUNCTION 06 STORE_NAME    0 (f)\n\n而函数本体内容则是创建了一个函数对象并放到了其他的位置，以及地址是重新从0开始的。这个地址应该是相对地址，因为会动态装载\n这两个的源代码不一样的，只是想展示地址都是从0开始。dump出来的内容差异也比较大\nRuby\ndef foo a = 3 * 2end\n\n== disasm: #&lt;ISeq:foo@&lt;compiled&gt;:9 (9,0)-(11,3)&gt; (catch: FALSE)local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])[ 1] a@00000 putobject                              3                         (  10)[LiCa]0002 putobject                              20004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;[CcCr]0006 dup0007 setlocal_WC_0                          a@00009 leave\n\nPython（函数体被编译成的内容\ndef f():\tprint(&quot;Function&quot;)\n\n0 LOAD_CONST 1 (“Function”)3 PRINT_ITEM4 PRINT_NEWLINE5 LOAD_CONST 0 (None)8 RETURN_VALUE\n\n实现一开始是想仿照做一个动态的实现，但是后来觉得还是静态的好，导致产生了如下的代码。\n对于一个函数，我生成了一个DefineFun。FunLabel是因为我不知道它们是如何判断函数结尾到哪里的，这属于我当时的一个理解错误，编译的时候函数体的内容会被编译好放到其他位置，而不是说运行时再看到一个函数的标签，再将之后的一段代码跳过。\n# 只展示关键部分# 错误版本def on_function(node)  [DefineFun.new(node.name), super(node), Return.new, FunEnd.new]end\n\n正确的做法应当是在编译的时候就将这些代码单独放到其他位置，运行时再进行装载。\n调用无参函数函数调用我们先从简单的无参函数说起\ndef f1    a = 1    1end\n\ntarget那么首先，我们需要考虑到call的target如何来做处理。很自然的会想到target可以使用字符串。\n尽管使用字符串的话会导致指令长度膨胀，解析复杂等。但目前不考虑那些，解析的也是字符串指令，所以先这样\n去哪里找目标函数的信息这个自然来说是需要符号表中保存了\n符号表中的函数信息对于符号表来说，表中条目需要保存的信息有以下几条\n\n参数个数（目前全部为无类型，因此返回类型也无需考虑）\nlocal变量的信息\n函数体的指令地址\n\n这些目前来说都是编译期间可知的，所以也会以字符串的方式dump出来供vm去解析。至于函数体地址的问题牵扯到链接，而目前我们先不需要考虑链接的情况，只需要将生成的符号表中的地址加载进来就好了。\n生成符号表由于以上需求，我们在编译的时候需要生成符号表信息\n我们之前设计的全局符号表是这样的\nclass GlobalEnv &lt; Struct.new(:define_env,:const_table, :fun_env)end\n\n暂时不考虑常量表，我们需要的是剩下两个表的信息。\n生成vm指令这个阶段会将一个全局定义表（define_env，目前仅存其定义），将其定义更改为args以及offset\noffset都是未知的所以先设置为一个未定义值，因为我是通过返回数组并且把数组连接起来的形式，所以这个时候并不知道偏移量。这里用一个数组存放值的做法实在很差劲，但是实在没精力改进了…先能跑吧\ndef on_function(node)    ...      @global_env.define_env[node.name] = [node.args, &#x27;undefined&#x27;]    ...end\n\n重新设置偏移量\ninst.each_with_index do |ins, index|      if ins.is_a? DefineFun            @global_env.define_env[ins.name][1] = index      endend\n\n而fun_env表，则是保存了每个表的参数以及局部变量的信息。拥有fun_env表和define_env表（这两个表其实应该合并，下次一定…）的信息，我们就能够生成出上面所需的信息了\ndef gen_sym_table(global_env)      global_env.define_env.map do |name, (args, offset)|        &quot;#&#123;name&#125; #&#123;args.size&#125; #&#123;global_env.fun_env[name].size&#125; #&#123;offset&#125;&quot;      end.join(&quot;\\n&quot;)end\n\n生成示例 格式为 函数名，参数个数，local var个数，起始地址\nmulti 2 2 0main 0 1 6\n\n函数符号表中的条目\nstruct FunInfo&#123;        FunInfo(): FunInfo(0, 0, 0) &#123;&#125;        FunInfo(size_t _argc, size_t _locals, size_t _begin): argc(_argc), locals(_locals), begin(_begin) &#123;&#125;        FunInfo(constFunInfo&amp; other) =default;        FunInfo(FunInfo&amp;&amp; other) =default;        FunInfo&amp;operator=(constFunInfo&amp; other) =default;        FunInfo&amp;operator=(FunInfo&amp;&amp; other) =default;        size_t argc;        size_t locals;        size_t begin;&#125;;\n\n调用栈既然要调用函数，那么就需要调用栈这个东西了\n就目前的需求来说，调用栈中的栈帧需要有以下几种成员\n\n前一个栈帧（跟踪整个调用链）\n返回的pc地址（函数调用结束后需要返回到调用者）\n当前栈帧在栈中的起始地址（起始地址开始分配局部变量的空间）\n\n关于多个栈帧之间的存储方式，由于需要频繁添加删除尾部结点，因此选择了链表的方式。如果使用数组的话会牵扯到长度不够再重新分配数组空间的情况\n而实际栈内数据的布局是\n----------------    tmp var----------------        f1    local var----------------  ----------------    tmp var----------------        main    local var----------------\n\n注意这里和实际的栈不同，对于实际的栈来说类似于返回的pc地址，以及前一个栈帧的地址都是保存在栈内的\n返回值目前的设计是返回值最后放到栈顶，这样返回的时候直接从栈顶取值，之后再恢复栈就可以了\n调用带参数的函数def f1(a, b)\t    c = a + b\t    cend\n\n参数传递目前采用的是push的方式直接push参数，这个体现在函数调用的时候编译出的指令上\ndef on_fun_call(fun_call)    fun_call.args.map &#123; |arg| push(visit(arg)) &#125; + [Call.new(fun_call.name)]  end\n\n栈内数据排布\n----------------    tmp var----------------    local var           f1----------------       args----------------  ----------------     tmp var----------------    local var           main----------------       args----------------\n\n关于参数传递的话题其实还有很多，比如说顺序，变长参数，谁来释放，在之后的内容再一点点补足\n正文无关闲谈首先是最重要的一点：本周的内容就充满了各种应付式的内容，这在往期我都是会直接当场修改掉的，但实属有些无力…我在想这样的内容发出来会不会很不负责任，但是如果停更那我所做出的每周更新的承诺这么快就要被打破了，而且以后更容易不遵守了。\n本周的内容相对少的多，最加对于压力的感知更加明显了，尽管我反复将注意力转移到当前做的事情上（每天也会有对应冥想练习），但很多事情依然力不从心。时间安排的太满，我不会的太多，但每一项我都无法舍弃，最后分配到做这个的时间真的不多了，还要一边查看各种实现学习一边写，好多东西都是周日写的时候才学习修改的。学习实现基本上也是靠看书，看前人总结过的内容，对于大型项目实在没有精力去扒。这周还在看Ruby的YJIT的论文，本就不多的时间更没多少了，最后论文也没看多少（就看了几段介绍…），这篇论文读明白后也会再出一篇博客，尽管只看了一点但也让我增加了许多JIT方面的常识\nYJIT: a basic block versioning JIT compiler for CRuby\n如何能摆脱这种状态，如果读者有经验还请赐教\n如果我是学生的时候就能开始做这件事情就好了..可是没有那么多如果\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记5 函数其二&OOP其一","url":"/2022/01/23/rc-lang-dev-5/","content":"本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽\n那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。\n函数在VM的实现回顾之前没有提及函数相关的内容在vm是怎么实现的，所以这里首先提及这个话题\n函数的实现无外乎就是调用与返回的情况，这里再多加一个关于getlocal和setlocal以及计算的实现部分。\n先来简单回顾一下我们的栈上的信息\n--------------------       tmp var--------------------      local var           f1--------------------         args--------------------  ----------------       tmp var--------------------      local var           main--------------------         args--------------------\n\n除了这些再来看一下我们的栈帧\nclass StackFrame&#123;    std::shared_ptr&lt;StackFrame&gt; _prev;    char *_base;    size_t _ret_addr;&#125;;\n\n关于这些成员都是因为什么需要增加的，请回顾上期内容\nRc-lang开发周记4 函数其一 | Homura’s Blog\n具体实现call\n去符号表找符号\n这一步在vm中处理，找到符号的话将信息传递给栈来做第二步\n\n栈处理\n\n更新pc\n\n\n着重讲一下栈的处理\n\n设置当前栈帧基址\n由于目前参数是在call之前push的（这个push一定紧接着call），因此需要先将stack_top指针移动到第0个参数的位置，得出基址\n\n分配局部变量空间\n根据局部变量的数量再将栈基址向上移动\n\n创建新的栈帧\n\n\n实现代码，都在eval_stack.h中\nvoid begin_call(size_t argc, size_t locals, size_t ret_addr)&#123;    // 1.set stack base    auto *base = get_args_begin(argc);    // 2.alloc local var space    _stack_top = stack_move(base, static_cast&lt;int&gt;(locals));    // 3.create new stack frame    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr);&#125;char *get_args_begin(size_t argc)&#123;    return _stack_top - argc * WordLength;&#125;char *stack_move(char *stack_pos, int offset)&#123;    return stack_pos + offset * WordLength;&#125;\n\n关于WordLength\nconstexpr static size_t WordLength = sizeof(int);\n\nreturn\n获取返回值\n由于在函数体内计算的时候最后会将返回值push到栈顶，那么这里需要先pop将值取出来\n\n栈帧回退\n\n重置pc\n\n返回值放到栈顶\n\n\n这个返回值有点折腾…目前就先这个样子\n这里也是着重讲一下栈帧回退\nsize_t end_call()&#123;    auto ret_addr = _frame-&gt;ret_addr();    _stack_top = stack_move(_frame-&gt;base(), -1);    _frame = _frame-&gt;prev();    return ret_addr;&#125;\n\ngetlocal/setlocal就是简单的从当前栈基址添加偏移量\nint get_local(size_t offset)&#123;    return *get_base_offset(static_cast&lt;int&gt;(offset));&#125;void set_local(size_t offset, int value)&#123;    *get_base_offset(static_cast&lt;int&gt;(offset)) = value;&#125;int *get_base_offset(int offset)&#123;    return get_offset_pos(_frame-&gt;base(), offset);&#125;\n\n运算template&lt;typename Callable&gt;void exec(Callable &amp;&amp;f)&#123;    auto new_v = f(pop(), pop());    push(new_v);&#125;\n\n函数最基本的功能完成了，那我们该做创建对象相关的部分了。\n从常见的类开始我们从一个常见的类的例子开始引入我们的问题\nclass Foo\tattr_reader :a\tdef initialize(a)    @a = a\tend\tdef add(b)\t\t@a + b\tendend\n\n这个类很简单，一个成员变量、一个构造函数和一个实例方法。\n在我们想要使用这个类之前，我们需要在编译期间先解析这个类的信息\n解析成员创建一个类表。保存了所有定义的类的定义，以及可以作为一个类型查询表。\n这个解析的过程一度想要直接从Ruby抄一套类似的，但是工作量会非常大，因为需要到基类查找方法，牵扯到继承等各种问题\n目前类的ast结构\nclass ClassDefine\tattr_reader :name, :define, :parent, :fun_list, :var_listend\n\n这个定义中define是之前做的对于现在来说是不必要的内容，但是我目前时间有限不太敢动，怕前面的东西都乱套了，留个todo再说。parent是因为之前ast解释器的部分做了继承，但是目前vm这边还没有开始做，也就先不管它\n对于成员函数全部翻译一遍，重命名一下符号，而对于成员变量，直接将信息添加到对应的表中即可。所以目前ClassTable是这样的\nclass ClassTable  attr_accessor :instance_methods, :instance_vars  def initialize    @instance_methods = &#123;&#125;    @instance_vars = &#123;&#125;  end  def add_instance_method(name, define)    @instance_methods[name] = define  end  def add_instance_var(name, define)    @instance_vars[name] = define  endend\n\n除了解析信息，还需要在运行的时候创建这个类的对象。创建对象则分为两步\n\n分配内存\n初始化\n\n分配内存关于分配内存我们需要知道\n\n为了知道所分配空间的大小，首先需要获取类型信息。那么该如何获取类型信息以及类型信息怎么存放，存在哪里\n\n目前不考虑元编程的地方，所以这些信息都是编译期间可知的。假设要做更多元编程的内容，那么需要将一部分的内容放到运行时处理。按照我的理解来说，到时候将类型信息传递给vm，以及添加一些指令专门用于做元编程（这样指令种类会增加很多）。但这仅限于我粗浅的理解，更详细的还是要等到我做的时候再考虑。\n\n如何计算空间大小\n\n这个时候可能会出现一个最简单不过的想法，直接将所有成员大小都加起来不就好了。但是如果这样做，地址无法对齐，在vm那边取是很麻烦的事情。关于对齐暂时也不考虑，目前只考虑数据全为一个字长的整型数字，因此产生的对象也只会有带有这样成员的数字。还有会遇到空对象的情况，没有任何成员函数该怎么办（关于空对象，下文会单独提一下）\n除了基本的空间大小，还需要考虑留有GC信息的头部。这个就牵扯到下一个问题\n\n数据保存的格式\n\nGC需要保存哪些对象信息，这些信息又是如何保存的。关于这一点在后面的Ruby的Object实现中会略微提及\nGC相关的更多内容要等到之后实现的时候再更详细的提及了\n关于这里实际上还有更多复杂的话题，比如说递归数据类型，Union等，这些也都以后做的时候再来讨论\n初始化生成方法这里涉及到了一个问题，一个最简单的Foo对象并没有构造函数，那么我们需要先在ast的阶段生成对应的“无参”构造函数。\n调用调用这里本质上是一个方法查找机制，目前想先做最简单的，后面按需添加。直接去对应的this指针，找到对应类的信息，然后再从类表中进行查找，还没做实现，大概会到下周的内容中\n同时这个方法也是作为一个成员函数被调用（尽管是外部不可见的），这里就顺便讲调用成员函数的做法\n首先考虑调用成员函数的时候就需要引入this指针了，这个属于固定在栈内的内容，所以我把它放到了栈帧的结构中，而不是栈的实际数据中。\n一些语言this相关说到this指针，我想到了两个语言\n第一个是Python，因为Python是需要显式传递self的\n另一个是C#，C#的extension机制大概是这个样子，通过这种方式来给某个类添加类函数，我没有深究过后面的实现机制，但我想大概是解析到这里就给符号表中的这个类添加一个成员函数吧\npublic static class SomeClassExtension&#123;    public static void method(this SomeClass instance, args)&#125;\n\nRuby本身也有一些相似的对象，定义类函数的时候会需要self。不过这里的self的含义变成了这个类，而不是某个实例成员\nclass Foo\tdef self.f\tendend\n\n特殊情况无成员变量类class Helper  def add(a, b)    a + b  endend\n\n这种情况最大的问题在于对象空间大小的问题。目前我已知的做法有如下几种\nC++中对于类似的类在实例化的时候会有一个一字节的空间占用，为的是区分地址\n而Rust则有一个叫ZeroSizedTypes的东东，在谷歌搜索的时候搜索到了这样一段代码\nuse std::mem::size_of;fn  main() &#123;   println!(&quot;&#123;&#125;&quot;, size_of::&lt;()&gt;());   println!(&quot;&#123;&#125;&quot;, size_of::&lt;[(); 100]&gt;());   let boxed_unit = Box::new(());   println!(&quot;&#123;:p&#125;&quot;, boxed_unit); &#125;作者：zqliang链接：https://ld246.com/article/1539826769170来源：链滴协议：CC BY-SA 4.0 https://creativecommons.org/licenses/by-sa/4.0/\n\n运行结果\n000x1\n\n可以看到Rust不像C++一样会有一字节的空间占用\n带有GC的语言通常是会有一个header的开销（header用于存储类型以及GC信息），成员域部分会因实际实现不同而不同\n对于Ruby来说Object是这个样子的。因此对象即便为空也会有下面这个union的开销\nstruct RObject&#123;    struct RBasic basic;    union     &#123;        struct &#123;...&#125; heap; //省略        Value ary[ROBJECT_EMBED_LEN_MAX];    &#125;&#125;\n\nRuby的类与函数def f1\t9endclass S  def initialize    9  end  def f1    9  endendm = 1a = S.new()\n\n成员函数和“普通函数”定义对比== disasm: #&lt;ISeq:f1@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)0000 putobject                              9                         (   2)[LiCa]0002 leave                                                            (   3)[Re]\n\n== disasm: #&lt;ISeq:initialize@&lt;compiled&gt;:5 (5,2)-(7,5)&gt; (catch: FALSE)0000 putobject                              9                         (   6)[LiCa]0002 leave                                                            (   7)[Re]\n\n可以看到编译出的函数没什么不同。我想这是因为Ruby的一切皆对象的缘故。哪怕只是一个单独的函数，也是定义在Kernel中，本质上还是一个成员函数。\n而这个initialize也是和普通的成员函数是一致的，特别之处只是会在Object的new中被调用，甚至和普通成员函数一样可以被外部调用\n== disasm: #&lt;ISeq:f1@&lt;compiled&gt;:9 (9,2)-(11,5)&gt; (catch: FALSE)0000 putobject                              9                         (  10)[LiCa]0002 leave                                                            (  11)[Re]\n\n调用方式0011 putself                                                          (   9)[Li]0012 opt_send_without_block                 &lt;calldata!mid:f1, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;\n\n定义类0003 putspecialobject                       3                         (   3)[Li]0005 putnil0006 defineclass                            :S, &lt;class:S&gt;, 00010 pop\n\n这里可以看到，Ruby中类也是和method一样是通过特殊的vm指令进行动态定义的\n编译出的类定义的内容\n== disasm: #&lt;ISeq:&lt;class:S&gt;@&lt;compiled&gt;:4 (4,0)-(12,3)&gt; (catch: FALSE)0000 definemethod                           :initialize, initialize   (   5)[LiCl]0003 definemethod                           :f1, f1                   (   9)[Li]0006 putobject                              :f10008 leave\n\n调用构造函数的全部流程流程0016 opt_getinlinecache                     25, &lt;is:0&gt;                (   9)[Li]0019 putobject                              true0021 getconstant                            :S0023 opt_setinlinecache                     &lt;is:0&gt;0025 opt_send_without_block                 &lt;calldata!mid:new, argc:0, ARGS_SIMPLE&gt;0027 dup0028 setlocal_WC_0                          a@1\n\n除去前面的优化和后面的赋值操作，可以发现new对象的时候实际调用还是在new上而不是所谓的构造函数。可以从这里一定程度的看到Ruby创建对象的实现：Ruby在创建对象的时候是会先调用隐含的new函数（继承自Object），而这个new函数的默认实现会调用allocate，之后调用对应的initialize方法，最后再将new出来的对象返回。关于这个知识点在之前做TypeStruct的时候也提及过，有兴趣的可以去看一下\nRc-lang开发周记3 生成C++代码 | Homura’s Blog\n参考资料Ruby原理剖析\n垃圾回收的算法与实现\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记6 OOP其二","url":"/2022/01/30/rc-lang-dev-6/","content":"在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看\n在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。\n本周修改的主要方向：所有的函数操作都是基于一个类的（因此函数信息也都会放到类中）\n在功能上要修改的有以下三个方面（测试这里暂且不谈）\n\n符号表分析\n生成vm指令\nVM运行时解析执行方式\n\n与此同时还更改了”链接”的方式，所有函数全部在第一次使用时动态加载\n符号表定义以前的\nclass GlobalEnv &lt; Struct.new(:define_env, :const_table, :fun_env)end\n\n现在的\nclass GlobalEnv &lt; Struct.new(:const_table, :class_table)end\n\n可以看到将所有信息都集成到一个class_table符号表目前全部依靠一个class_table进行运作，目前的内容也很简单，只是保存instance methods和vars的信息\nclass ClassTable  attr_accessor :instance_methods, :instance_vars  def initialize    @instance_methods = &#123;&#125;    @instance_vars = &#123;&#125;  end  def add_instance_method(name, define)    @instance_methods[name] = define  end  def add_instance_var(name, define)    @instance_vars[name] = define  endend\n\n这种时候需要单独解释类型信息，这就是动态类型的头疼之处，想试试Scala，但是没时间学了\nclass InstanceMethodInfo &lt; Struct.new(:define, :env, :args)end\n\ndefine在符号分析的时候是ast的结点，而在后面翻译到vm指令的时候\n相比之前取消了offset，因为全要等到运行时加载，这里的offset没有意义了\n而env就是在global_env中被干掉的fun_env，参数信息没什么好说的，目前仅保存名字以及只用于统计数量\n实际分析class_table的初始化def initialize  @define_env = Env.new  init_class_table  @const_table = Set[]  @cur_class_name = Rc::Define::GlobalObjectenddef init_class_table  @class_table = Env.new  @class_table.define_symbol(Rc::Define::GlobalObject, ClassTable.new)endmodule Rc  module Define    GlobalObject = &#x27;Kernel&#x27;    UndefinedMethod = &#x27;Undefined&#x27;    ConstructorMethod = &#x27;initialize&#x27;  endend\n\n塞进去一个默认的全局类，在vm执行的时候也会提到这里\n类def on_class_define(node)  # save old  old_class_name = @cur_class_name  # make new and update  @cur_class_name = node.name  class_table = ClassTable.new  # define before visit fun, because of this is a context used for visit fun  @class_table.define_symbol(node.name, class_table)  # visit and add value to class_table  node.fun_list.each &#123;|f| visit(f)&#125;  node.var_list.each &#123;|v| class_table.add_instance_var(v.name, v.val)&#125;  # restore name  @cur_class_name = old_class_nameend\n\n访问到类的时候创建一个类表，之后遍历visit成员的var和method，将这些信息添加到类表中\nmethod是在visit的内部添加的，这里目前这样做是因为如果是Kernel的method，则不会经过on_class_define，这里应当在前面ast层面就做处理。先记下来以后来修改，目前比较想赶快赶工到能做GC的地方\n函数之前\ndef on_function(node)    @define_env.define_symbol(node.name, node)    @cur_fun_sym = Env.new    @cur_fun_var_id = 0    @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)    visit(node.stmts)    @fun_env[node.name] = @cur_fun_sym  end\n\n现在\ndef on_function(node)  @cur_fun_sym = Env.new  @cur_fun_var_id = 0  @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)  visit(node.stmts)  @fun_env[node.name] = @cur_fun_sym  cur_class.add_instance_method(node.name, InstanceMethodInfo.new(node, @cur_fun_sym, node.args))end\n\n也没什么可说的，主要还是符号表存储方式的差别导致了这里信息存储的位置不同了\nvm代码生成translate之前的实现\ndef translate(ast, global_env)  @global_env = global_env  inst = visit(ast).flatten.compact  inst.each_with_index do |ins, index|    if ins.is_a? FunLabel      @global_env.define_env[ins.name].offset = index    end  end  @global_env.define_env.reject! do |name, table|    name.include? &#x27;@&#x27; or table.is_a? Rc::AST::Function  end  instend\n\n现在的实现\ndef translate(global_env)  global_env.class_table.update_values do |class_name, table|    @cur_class_name = class_name    table.instance_methods.update_values do |f_name, method_info|      @cur_method_info = method_info      method_info.define = visit(method_info.define).flatten.compact      method_info    end    table  end  global_envendclass Hash  def update_values(&amp;block)    each do |key, value|      self[key] = block.call(key, value)    end  endend\n\n尽管都是以一个函数为单位进行visit，但是对于现在的实现来说更大的遍历单位是一个class\n可以看到这里已经不再设置offset了，等到vm执行的时候再生成offset\non function之前\ndef on_function(node)  @cur_fun = node.name  @global_env.define_env[node.name] = Rc::FunTable.new(cur_fun_env, node.args, &#x27;undefined&#x27;)  [FunLabel.new(node.name), super(node), Return.new]end\n\n现在\ndef on_function(node)  @cur_fun = node.name  [FunLabel.new(node.name), super(node), Return.new]end\n\non_function只会在translate调用，只需要获取编译出的所有指令就可以了，关于表的更新都在translate中做\n此外，获取当前函数的env要修改一下\n之前\ndef cur_fun_env  @global_env.fun_env[@cur_fun]end\n\n现在\ndef cur_fun_env  @cur_method_info.envend\n\ncur_method_info可以在前面的translate中看到不断的更新值\ndump信息目前全部dump到了一个文件中\n源码class Foo  def initialize()  end  def add(x, y)    x + y  end  var a = 1enddef main    var f = Foo.new()end\n\n编译出的文件Kernelmain 0 1FunLabel mainAlloc FooCall Foo initializeSetLocal 0ReturnFoo # 类名a # 成员变量initialize 0 0 # 成员函数名 args数量 local_var数量FunLabel initialize # 函数定义Returnadd 2 2FunLabel addGetLocal 0GetLocal 1AddReturn\n\nFunLabel或许也可以删掉了，目前先这样留着吧，说不定debug会用得上\n写到一半才意识到完全可以使用一些现有的格式来做到这件事情，但这也只是临时用的东西，最后一定会转成真正的字节码而不是这种dump，先这样吧，大家千万不要跟我学坏\n实现这个也没什么好讲的，并非重点，相比之前不同也是以类为一个单位。目前是都编译到了一个文件，目前这样就够用\ndef gen_class_table(global_env)  global_env.class_table.map do |class_name, table|    &lt;&lt;SRC#&#123;class_name&#125;#&#123;table.instance_vars.keys.map(&amp;:to_s).join(&#x27; &#x27;)&#125;#&#123;table.instance_methods.map &#123; |name, info| gen_method(name, info) &#125;.join(&quot;\\n&quot;) &#125;SRC  end.join(&quot;\\n&quot;)enddef gen_method(name, method_info)  &lt;&lt;SRC#&#123;name&#125; #&#123;method_info.args.size&#125; #&#123;method_info.env.size&#125; #&#123;method_info.offset&#125;#&#123;method_info.define.map(&amp;:to_s).join(&quot;\\n&quot;)&#125;SRCend\n\nVM符号表这里要和ruby的符号表一致。用两种语言做这种时候就很麻烦，要再做一份\nstruct ClassInfo&#123;    std::vector&lt;std::string&gt; _vars;    SymbolTable&lt;FunInfo&gt; _methods;&#125;;struct FunInfo&#123;  \tsize_t argc;    size_t locals;    size_t begin;    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; inst_list;&#125;;\n\n不过要注意FunInfo中这里要保存起始地址，因为装载以后就会有地址了，默认为0（不可能存在的地址，视为未链接）\n加载文件先这样凑合用好了\nSymbolTable&lt;ClassInfo&gt; parse() &#123;    std::ifstream f(_path);    std::string str;    SymbolTable&lt;ClassInfo&gt; class_table;    while (std::getline(f, str)) &#123;        // 1. class name        auto class_name = str;        // 2. member vars        std::getline(f, str);        auto member_vars = split(str);        // 3. functions        std::getline(f, str);        SymbolTable&lt;FunInfo&gt; fun_table;        while(!str.empty())        &#123;            // 3.1 info            auto fun_info = split(str);            auto name = fun_info[0];            auto args = std::stoi(fun_info[1]);            auto local_vars = std::stoi(fun_info[2]);            // 3.2 add to class_table            fun_table.define(name, FunInfo(args, local_vars));            // 3.3 define            std::getline(f, str);            auto &amp;inst_list = fun_table[name].inst_list;            while(std::getline(f, str) &amp;&amp; !str.empty())            &#123;                auto list = split(str);                inst_list.push_back(get_inst(list));            &#125;            std::getline(f, str);        &#125;        ClassInfo class_info(member_vars, fun_table);        class_table.define(class_name, class_info);    &#125;    return class_table;&#125;\n\n函数调用由于增加了类相关的内容以及“动态链接”，这里的变化会大得多\n之前\nvoid begin_call(const std::string&amp; f)&#123;    if(!_sym_table.contains(f))    &#123;        // todo: find definition        throw std::runtime_error(&quot;Target Function&quot; + f + &quot;Not Found&quot;);    &#125;    auto &amp;fun = _sym_table[f];    // 1. stack process    _eval_stack.begin_call(fun.argc, fun.locals, _pc);    // 2. set pc    _pc = fun.begin;    LOG_DEBUG(&quot;Call &quot; + f + &quot; PC:&quot; + std::to_string(_pc))&#125;\n\n之后\nvoid begin_call(const std::string&amp; klass, const std::string&amp; f)&#123;    if(!_sym_table.contains(klass) || !_sym_table[klass]._methods.contains(f))    &#123;        throw std::runtime_error(&quot;Target Function&quot; + f + &quot;Not Found&quot;);    &#125;    auto &amp;fun = _sym_table[klass]._methods[f];    if(fun.begin == UndefinedAddr)    &#123;        fun.begin = load_method(fun);    &#125;    // 1. stack process    _eval_stack.begin_call(fun.argc, fun.locals, _pc);    // 2. set pc    _pc = fun.begin;    LOG_DEBUG(&quot;Call &quot; + f + &quot; PC:&quot; + std::to_string(_pc))&#125;\n\n变化主要有两个\n\n查找被调用函数的方式，需要先查找类表再从中查找到对应函数信息\n加载\n\n关于加载的实现\nsize_t load_method(const FunInfo&amp; f)&#123;    // 1. get start    auto start = std::max&lt;int&gt;(0, static_cast&lt;int&gt;(_inst_list.size() - 1));    // 2. load inst to inst_list    for(auto &amp;&amp;inst : f.inst_list)    &#123;        _inst_list.push_back(inst);    &#125;    return start;&#125;\n\n目前的需求来说这些就足够了，因为目前没有牵扯到一些相对寻址的指令。之后加到那些指令的时候再来更新\n初始化里面目前就这么一行代码，其实也没有太大变化，只是入口需要指定类了\nbegin_call(VMGlobalClass, VMEntryFun);\n\n最后正式开始构造对象以及调用构造函数要等到GC弄出来再写了（尽管编译器这边已经做了，但是VM不做出对应功能毫无意义）。下个周不出意外的话应该要开GC的坑了，尽管放假了，但依然有一堆事情要处理，就像写博客回顾、重构代码一样，我的生活也需要做一些打扫与清理，还有一些需要学习的新知识，所以大概率还是会维持平常的进度。不寻求太大的变化，能维持这样的进度我觉得也不错。\n我觉得这种对比修改前后代码的方式还挺不错的，以后如果再涉及到修改已有设计的地方都会再加一些。\n最近有些疏于测试了..尤其是VM代码一点都没有，下次一定\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记 序","url":"/2021/12/19/rc-lang-dev-preface/","content":"之前毕业设计想尝试设计一门语言并且实现编译器，奈何时间加个人状态不佳只做到了十分简陋的ast解释器，最近又想着转成编译器并且打算认认真真做下去。既然要做那索性把这个过程中重要的部分记录下来，记录的过程能够反思做的内容，回顾有没有隐藏bug，并且能够督促我继续做下去。不过受限于时间精力，恕我不能一口气把以前写的部分的讲解补上，下次一定（咕咕咕）\nRclang长远的想法是作为一门教学相联系的语言（并不是给刚学编程的人教学的意思），但是那还太遥远，甚至都不知道能不能坚持到那个时候，现阶段的目标是能够编译正确的代码到VM上正确执行，并且在这个过程中加强自己编程语言、编译器以及VM的基础知识。所以会有许多为了能跑或者了解相关知识而实现的决策，并且会反复修改很多设计\n本人水平不足，代码赶工情况很明显，因为时间真的不多，每天都要上班，同时每天以及周末还需要去学习其他的东西，也因此博客会粗糙一些（记录下来花费的时间比我预想的要多很多）。一定会有许多地方理解不够或者存在问题，如发现问题或者不合适的地方十分欢迎联系我（低血压人群可放心食用，高血压人群慎追）\n该系列如无特殊情况每周日更新，你可以在这里找到这个系列所有的文章\n标签: rc-lang | Homura’s Blog\n项目地址：https://github.com/FusionBolt/Rc-lang\n我想一定会有人好奇为什么选择Ruby，对我来说Ruby写的很爽很开心，这就够了。能够开心的持续做下去这才是最重要的（不过VM还是要C++受苦就是了…）\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"所坚信的事情","url":"/2021/08/23/trust_self/","content":"唯有这一点，在我接下来的人生中一定会坚信不疑\n我一定能够做到无限接近理想的自己想了很久不知道该用什么词放在最后，聚聚，大佬，诸如此类的词想了很多，但好像并不符合我的心愿。虽然这种说法十分空洞，显得没有目标，但确确实实是我现在的想法，并不想成为别人眼中的谁，而是想要成为自己眼中的谁。理想自我是不可能抵达的，故只有无限接近\n现在理想的自己是什么样子的？我想起码是有坚固的自信，无论何时都能鼓起勇气，能够让自己的朋友会为认识我感到开心，能够专精某些领域。\n为什么要发一篇这样的博客呢？\n乔布斯说过这样一段话\n\nYou have to trust in something, your gut, destiny, life, karma, whatever.\nBecause believing that dots will connect down the road will give you the confidence to follow your heart even when it leads you off the well-worn path. \nAnd that will make all the difference.\n\n我选择它作为我一生的信念，同时这也是值得花费一生去做的事情。\n从今天、现在开始，又是新的起点\n希望这能够带给我信心与勇气\n带上一份歪歪扭扭的签名\n\n","categories":["Thinking"]},{"title":"2021年终总结","url":"/2021/12/26/summary-2021/","content":"下周末就是明年了，今年的事情不能拖到明年做，于是趁早把总结赶了出来。2021年对我来说算是各方面变化比较大的一年，还是有不少值得回顾的内容\n专业、工作与学习最大的变化莫过于大学毕业成为社畜了，找工作的过程算是十分坎坷，不过好在最终找到了一份合适的工作。工作中也学到了不少东西，自己也有了许多进步。看着自己的改变，看着自己的GitHub，今年总算可以说自己入门编程了。最大的遗憾是这一时间点来得太晚，每天下班回家留给写代码的时间只有一个多小时，如果还是学生的话时间能多太多。今年的习惯养成比较晚，所以只有最后的时间格子是填满的，明年的话会坚持每天下班后写代码，填满小格子\n\n今年的Github \n\n年初做了一个ast解释器作为毕业设计，随后随着找工作以及各种事情渐渐停止了维护。而年底又开始基于之前的内容添加编译的部分，希望明年能达到自己对于这个项目的初步目标，并且在这个过程中学习到更多编译器相关的知识。同时我开始每周写一篇博客记录本周开发的内容，序言链接在这里\nRc-lang开发周记 序 | Homura’s Blog\n今年开始读一些书，做到了平均一个月读一本专业之外的书，遗憾是读书笔记大都咕咕咕了，不过还有一些自己的思维片段，有时间会整理成文。明年的话会继续维持这个进度，会试着写一些读书笔记（在新建文件了）\n尝试入门GTD，但遗憾的是并没有用好，明年还要在这方面继续努力。\n尽管GTD运用不佳，但是年底的时候开始养成了一些习惯，这些习惯能够很大程度的帮助我抵抗自身的“懒惰”。其中一些习惯的养成受到《微习惯》和《原子习惯》这两本书的影响，后者比较推荐，能够涵盖了很多前者的内容。书中提到了一个让我印象深刻的概念：习惯叠加，意思是养成一个习惯之后可以在这个习惯之后接另一个习惯，而且很容易养成，像我现在每天晚上回家的时间都是数个习惯叠加在一起，养成的过程也没有太痛苦。\n生活由于成为了社畜，最显著的变化就是要自己租房住了。和宿舍生活相比，入睡时间再也不需要受到别人的影响了，同时住的地方肯定是比宿舍要大的，体验好的多\n另一个变化则是有了收入，因此能做的事情变得更多了\n比如说年底入手了种草许久的相机，开始尝试摄影，拍到了一些满意的照片，尽管其中也有许多瑕疵品。希望明年年底的时候能够自己设计出一个相册来展示自己笨拙的作品。\n除了能做的事情变多，同时还需要关心自己的开支情况。今年第一年工作，总之就是疯狂支出，月月实现负收入。买了各种以前就想买的东西，这个状态感觉还会维持一两年。明年开始大概会花很多钱在自己身上，通过氪金变强，存钱感觉比较困难，只能说尽力存一些吧\n年底渐渐开始接触各种各样的新事物，而这些事物又会激发我的各种想法（我逐渐理解一切了）。除了新事物，年底开始叠加了一些习惯使得我越来越忙碌。越来越多的事情我进入了我的生活中，可以说是有些充实，但是充实的不只有要做的事情，焦虑也是一样，对于事情做不完做不好的焦虑又逐步放大了起来，这也是我需要克服的点。\n除此之外，今年也有幸在推特上认识了一些新朋友，对于他们不嫌弃我这件事情深表感激\n自我好转一个很重点的问题就是自己的身心感受。比起去年或许有了一些好转，在一些事情上情绪波动也没有那么大了，我想这一定和感受到内心的不合理有关。至于治愈之法，上面提到的《神经症与人性的成长》书中也有提到\n\n所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。此地我们同样地要问，病人必须要知道什么才能铲除他的自负系统，以及除去由此所衍生的一切附带影响？我们可以简单地说，他必须晓得我在本书中所提到的每一件事：他对荣誉的探求，他的“要求”，他的冲突，他个人的特别解决法，以及所有这些因素在他的人际关系方面与创造力方面所具有的影响此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互的作用\n\n我的理解是当你彻底理解各个组建之间的联系的时就会慢慢破除。可惜的是这本书我只是年初读过一遍，许多地方理解并不到位。对我现在来说读过一遍的书还是挺难再花时间去读第二遍的，更偏向于去读新的书，但是鉴于这本书的重要性明年一定要再读一遍。\n还有一个想到的好转是破除了一些所谓的“完美主义”的误区。我自己并没有什么完美主义，只是之前会以这个作为幌子，找借口逃避问题罢了。现在一些东西哪怕做的很烂，也会开始行动了，就像这篇总结以及目前正在维护的开发周记一样\n也许是冥想所带来的习惯，我渐渐开始体会自己的不同感受，发现了自己内心空无一物。能够发现这一问题就是一个很大的进步，希望明年能够通过更多的行动给自己的内部逐渐填充些什么\n顽固除了好转，自己依然有一些顽固成分无法脱离。比如说仍有许多无法避免也无法与之相处的执念，这对我造成了很严重的负面影响，经常会因此沉溺于痛苦之中\n以及今年还是比较“自闭”，这个好像没什么好办法。所谓的“不适合和别人相处”只是一个逃避问题的幌子罢了，更深的原因是内心里还残留的一些性格扭曲，这个问题比起无力处理更准确地说是我不想处理，也先这样吧\n上面说的内容很大一部分要归咎与身体与睡眠。睡眠这个对我来说是一直无法解决的问题，长期的睡眠质量差导致我很多时候状态并不好，这和我的焦虑、以及焦虑的应对措施都有着联系。\n目前的应对措施是每日冥想加周日的跑步锻炼，这样的运动量是不太够的，但是时间确实不够用以及日常是步行上下班因此削减了运动时间，明年的话准备采取一些新的方案来对抗这些严重的问题。\n这一年这么写下来，今年好像做了一些事情却又好像并没有做多少事情。做了一些事情是因为确实有一点成果，比如说读了书，思维发生了转变，专业方面有了进步，养成了一些习惯等；而没有做多少事情是因为这些事情对于一年这个周期来讲并不多，而且大半年里自己的周末时间很明显并没有怎么用好，基本上都是在无意义的消耗时间。\n另外许多事情是年底才开始做，起步比较晚，但是对于明年来说可以开一个好头\n明年愿景不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的\n想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升\n想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西\n自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈\n想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等\n明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战\n最后自己的年终总结也没什么特别的感受与想法，只是简单地以流水帐的风格写了一下今年的事情，不过这就够了\n比较期待明年的到来（MBP，我的MBP）虽说回首过去与展望未来都会扰乱内心的平静，但我还是按耐不住自己的期待。\n明年一定是更加忙碌的一年，也是自己会有更多成长的一年\n","categories":["Thinking"]},{"title":"iPhone Ultra Max(iPad mini)体验","url":"/2022/01/30/iPadminiReview/","content":"曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。但iPad mini在我看来就是一个大号手机，某种意义上还是没错\niPad mini也已经入手有半个月了，半个月内重度使用，过了那阵新鲜劲以及各种问题踩坑也踩的差不多了，这个时候写下的体验我觉得应该是相对比较全面的了\n我的痛点我觉得iPad mini解决了我目前使用手机的各种痛点。我的iPhone8plus目前有存储不够，电池容量太小，只能单卡而我自己的卡流量又不够。如果只是这些问题可能有人说换新机不就完美解决了？但是换新机也不能解决屏幕太小的问题，想看点文章或者需要跨app处理一些内容iPhone这么小的一个屏幕实在不方便\n周末需要频繁挤地铁，地铁上的时间非常久，没有座位的时候拿iPad Pro非常不方便，即便有座位从包里拿出来也是很麻烦的事情，手机屏幕又太小，iPad mini的大小可以说是完美。\n所以我实质上是将iPad mini当作我的新手机，我的iPhone8plus还能再战好多年。以下体验更多是从手机的视角来看待\n\n实际体验首先：不玩手游，所以并不会提到相关的内容，想看手游相关的建议你去看各种评测视频\n重量感觉拿着没有任何压力，只比带着保护套的手机重了几十克。这个大小能够装到兜里，出门的时候看地图也非常方便。受益于大屏幕，看文章非常方便，不知道比iPhone高到哪里去了。\n电量够我出门用一天，再也不用挂着移动电源到处走了。这是我某一周的使用情况，如果开了省电模式一天非常稳妥，更何况我出门的时候电只有80左右\n\n出门在外，iPhone直接扔包里，有什么电话或者短信可以直接转接到iPad mini上\n网上所说的什么果冻屏至少我没什么感知，尽管有这也是显示技术不可避免的问题，120刷新率对于iPad mini来说不太可能用上（而且绝大部分情况不需要刷那么快）这一点争议非常大，建议你去实体店体验一下\n曾经我以为iPad正确的解释姿势就是Face ID，但直到出现了疫情…iPhone已经支持戴口罩解锁了，iPad pro什么时候才能用上？指纹解锁在现在这个到处需要戴口罩的情况下还是很棒的（但是我手指各种掉皮就还是白给\n谈一点没什么关联的，直到我用上了iPad mini才发现iPad Pro是多么大，以及各方面是多么好……不论是扬声器还是屏幕刷新率，这些我之前都毫无感觉，真的是没有对比就没有伤害\n不可避免的问题极其多余且愚蠢的设计这是我一定要着重说的一个问题。\n所谓的智能音量键调整位置，我的感受就是多此一举，用了一周并没有觉得多么方便，反而每次调整音量不仅要想按哪里，在屏幕没锁定旋转的情况下大概率会按反。我听的不同来源的音频声音响度是不同的，如果忘了提前调整音量则需要快速反应按下减音量，而这种设计又会导致你大概率要先思考或者先按错一次才能按到正确的地方，对于耳朵损伤还是非常大的\n因为有Touch ID，开屏的时候会提示按键位置在哪里，这个本身是好事，但是如果屏幕方向是竖直摆放这个提示则会导致无法看到电量，只是想打开屏幕看一下电量的时候非常难受\n上面这两条，我开始怀疑苹果的人机交互工程师有没有真的自己用一下，一家曾经以设计闻名的公司（个人看法）额外添加的这些设计却反而添加了负面体验，这么大的公司应该有合理的流程避免一些问题，尤其是对于apple来说。但是这种不良设计依然出现了，不知道该怎么评价了\n大屏幕大屏幕随之而来的就是你在看的东西更容易被其他人看到，对于非常重视隐私的人来说是灾难。另一个就是便携性不可避免的要下降一些，很多场景不能单手握持，但是只是读文章，单手下滑是没问题的，这是必须做出的取舍。还有就是我衣服兜比较浅，总觉得要掉（后来有一天不知道为什么过于大意，在同一个地方摔了两次….），装到裤子兜又麻烦，到了夏天衣物可能更难携带iPad mini\n字体略小，将字体调到了最大还算可以接受（除了一些app字体并没有适配好）\n到户外这个屏幕亮度不够用。这是我个人觉得最难受的\n双手握持打字略微有些头重脚轻的感觉（竖屏），而且有一种要滑出去的趋势。以及键盘还不是完全一样的，需要一点时间适应。但对我来说键盘录入大量内容可能还是偏少数，更多的是用它去阅读\nOS与应用iOS应用仍有一些不适配的情况，万幸的是可以手动放大到一个勉强能用的状态。但是更离谱的是支付宝只能登录一个设备，这产品经理是不是张小龙带出来的。当然这种环节不可避免要把微信拉出来挨打，目前iPad版和mac版是冲突的，干脆不用mac上的了，反正我的微信只用来联系家人。除此之外还有qq不能多个iPad上登陆，也有点小烦，等等还有很多类似的问题\n还有一些并非适配问题而是不能用的，比如说健康和Apple Watch的管理，这些还是要依赖于iPhone。以及就是iPad OS诟病已久的没有天气和计算器。以及某些离谱的应用，比如说企业微信第一次登陆还要手机确认……\n代替手机由于不能打电话的硬伤，你并不能真的完全离开你的手机。尽管现在的人电话场景是“十个里面九个骚扰电话，还有一个是快递”\n周末坐地铁的时候意识到不能刷nfc，突然想到还可以刷Apple Watch，但我戴在左手刷起来略显别扭。什么，你说扫码？\n\n购买相关如果去官网购买，很可能需要等待两个月才能到货，这个着实比较离谱了，因此我选择了京东购入，也就错失了刻上iPhone Ultra Max的机会\n本来想要购入一个紫色，但是去实体店查看跟示意图完全是两个样子…如果想要购入我建议你还是去实体店亲自看一下\n我会用它完全代替iPhone吗除了初拿到的欣喜，用了一段时间以后发现很多时候还是用手机方便，但是我依然没有后悔买了这个iPad mini，尽管在上面吐槽了它这么多问题，但我对它实在是非常满意（售价除外）。某种意义上可以说是因为没有竞争对手，我们只能忍受它的所有缺点。如果你有类似的需求，那非常推荐你。如果没有，那我还是推荐买大屏\n最后加一个小技巧：如果你的iPhone像我一样只是需要维持最低限度功能，你可以在快捷指令里面设置自动化，当断开电源的时候自动开启低电量模式，平常充电超过80%IPhone会自动关闭低电量模式\n本文绝大部分在地铁上一口气用iPad mini写完，再也不想用iPad mini打这么多字了\n","categories":["Life"],"tags":["iPadmini","Apple"]},{"title":"论柳比歇夫","url":"/2022/02/04/Lyubishchev/","content":"也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解\n大部分人看到标题，一定只有一个问题：柳比歇夫是谁？\n他是一个大半生都在支配时间的人。我想你一定会对支配时间这个词摸不着头脑，还会有人在想时间面前人人平等，时间怎么可能被他支配？\n那么我们先从他的成就谈起吧\n他的成就\n前苏联的昆虫学家、哲学家、数学家。毕业于圣彼得堡国立大学，一生发布了70余部学术著作，从分散分析、生物分类学到昆虫学等。业余时间研究地蚤的分类，还写过不少科学回忆录。 各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。\n\n除了这些，数学、历史与诗歌他都十分擅长。毫无疑问，他是一个全才，并且在一生中做出了超乎想象的成就。他是怎么达到这样的成就的呢？\n开始早在他28岁的时候他就已经找到了他一生的奋斗的目标：创造生物自然分类法。尽管遭受怀疑他依然开始着手他的任务，并且将一生投身到其中。\n\n他当然相信他能做到，但总是要从另外什么地方再去挖掘一些力量，再去挖掘一些时间。\n\n而为了完成这一切，他选择了“支配时间”\n时间完成事情需要时间，这是一个不可避免的内容。而对于时间的使用，很自然会想到利用好各种时间，他自然是做到了，将各种碎片时间利用到了极致。但只是利用碎片时间自然是不足以使他获得如此成就\n\n应当不断挖掘一切时间潜力。明摆着，人不能者是每天工作十四五个小时。应当正确利用工作时间。从时间中去找时间。\n\n接着他就开始了记录时间的生涯。他将自己做得几乎每件事情所需要的时间记录下来，进而达到能够十分清楚地了解自己做每件事情的时间，在了解自己的时间后进行十分周密的安排（注意，这是在他能够保证利用各种碎片时间的前提下）。\n这些内容我觉得比起我来讲不如来看摘录的原文\n\n计划就是挑选时间、规定节律，使一切都各得其所。头脑清醒的时候应当钻研数学，累了便看书。\n\n\n这个方法之所以能够存在，是依靠经常的计算和检查。没有计算的计划是盲目的计划，就象某些研究所那样，光会做计划，却不去操心这计划能不能完成。\n\n他对于时间的理解是非常深刻的。而最重要的则是他使用了一生来实践这样的方法。\n了解时间记录法后我偶然想到在一本书中看到的话：不是要达到什么目标，而是要形成一个自己想要的系统，目标会自然而然达到。再看柳比歇夫的经历，亦是如此\n而书中也有很多时间相关值得回味的内容，在这里摘录两段\n\n为了节约时间，实干家下了马车坐上火车，下了火车坐上飞机。发明了电报和电话来代替书信，电视代替了剧院，拉链代替了扣子，圆珠笔代替了鹅翎。电梯、计算机、百货公司、电传打字机、电动制刀——这一切发明，都是为了替人节省时间。然而，不知道为什么，人越来越感到时间不够用\n\n\n时间的分配几乎同两千年以前赛纳卡时代一摸一样：“我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事\n\n代价与幸福可能很多人会觉得，这样机械式的生活真的快乐幸福吗？这里可以肯定的回答，至少对他来说是这样的。这里我有一个比较奇特的视角来讲，他清晰的明白自己的能力边界，因此他不需要担心时间不足或者担心自己做不到，他不需要焦虑在这种事情上，减少了焦虑并且能够更好的发挥自己的才能。\n而在作者看来他亦是幸福的。在书的一开始，作者就提到\n\n我从中得到的一切，对于我来说，是一个新发现，使我参透了一个人一生的秘密。\n这个秘密是——怎么生活得更好。\n\n但是这一切是有一个前提：他不断的给自己设定更高的要求，并且他有着源源不断的好奇心和求知欲，而这样做正是满足了他的欲望，因此这一切对他来说是十分幸福的。\n在写下前面的部分，回顾文中的内容，在最后也看到了作者持有着同样的态度\n\n只有一个人向自己提出崇高目标时，这个时间统计法才能成立\n\n能力边界与高要求他持续对自己高要求，并且在明确自己能力边界的情况下不断在边界中前进\n\n 他不让自己负担过重，力不胜任；他总是循着他能力的边缘前进，他对自己能力的掂量愈来愈精确。这是一条永不停顿的自我认识的道路”“如果每个人都能知道自己能干些什么，那生活会变得多么美好！因为每个人的能力都比他自己感觉到的大得多。他会变得比自己想象的更为勇敢；他会变得更坚韧、更有力，更能适应环境”\n\n还有一段我觉得是非常棒的描述\n\n对于柳比歇夫，任何时候都不能说他已“成为”怎样一个人。他永远正在“逐步成为”怎样一个人。他一直在探索，一直在变化，他总是重新考虑，不断提高对自己和对自己理想的要求\n\n对知识的热爱以及偏离目标他学习知识，数学、历史、文学、音乐等等各种方面。\n他不善于克制自己，经常迷上同他完全无关的东西中。他无法抗拒周围环境的诱惑，他无法抗拒那些知识。但是关于这些，作者给出了很明确的观点\n\n“天哪，对于嗜癖和精力分散我们又能知道些什么呢！谁能说清楚“人应当是怎么样的”。我们从何知道人应当是怎么样的呢”\n\n不过有一点要注意，不论怎么样他最后都能够确保任务的完成，这也和他对自己能力有着清晰的认识有关。\n而“偏离目标”，也就是学习各种看似不相关的知识实际上也会产生一些意想不到的效果。达芬奇就是一个非常擅长将不同领域的知识融合在一起的人，他的许多创作都是如此。\n关于这本书作者在本书的开头就在提到如何吸引读者这一件事情，而毋庸置疑的作者达到了他的目的，不像我后来看的达芬奇传（作者沃尔特 艾萨克森）真的是无聊至极。\n正如作者所期望的那样，每读一点我就更加迫不及待的想要看到后面的内容，作者巧妙的描述出了一个饱满的柳比歇夫的形象。读完这本书后让我产生了更强烈的阅读其他传记的欲望，之后也就顺势读完了乔布斯传。\n读这本书的过程中自己被柳比歇夫所吸引，也许这就是我所理想的样子。他对自我的要求、他的自由、他的幸福、他对自己的严格要求、他不断增长的边界，无一例外充满了魅力。在写到这一段的时候越写下去越发不可收拾，我着了迷、入了魔，那段时间读到相关的部分都会感到非常兴奋。\n我希望这本书给别人的印象不仅仅是只有柳比歇夫的时间统计法，尽管是在读者的角度，我依然想要让其他阅读这本书的人更多的去体会、感受柳比歇夫的各种特质，而并非只是局限于时间统计法，时间统计法本质上是他的特质的衍生产物，是他为了完成自己的目的所选择的一条道路。\n而完美的是作者也将这些特质巧妙的讲了出来，也没有花费太大篇幅去描述时间统计法。我最初也并不知道柳比歇夫是怎么样的人，但至少读完本书之后对他的形象有了一个饱满的认识，尽管这些只是局限于作者所描述的部分。\n最后整理这篇文章花费的时间比预想的还要多很多，整理的过程中几度想要放弃了，但是整理的时候多少又找回了一些热情，又回想起了很多，最后还是坚持了下来。请原谅我个人能力有限，文中内容简陋，而且内容有所遗忘，无法在这么短的篇幅中将他的魅力讲述到极致，只能提及部分性格特点，而书中所讲述的他更为有趣。如果你是对自己有要求的人，那么我非常推荐你去读这本书，去感受他的人生，感受他的精神，也许你会和我一样着迷。\n虽然我做不到柳比歇夫的时间记录法，但是我可以学习他的高要求、不断在自己的边界进步、他对知识的热情，这些也足够我获得很大的成长了。我应该认真思考如何像他一样对自己不断的提出要求并且达到这些要求，而不只是空谈，写完这篇文章的今天我该拿出时间好好反思。\n最开始写这些文字的内容是几个月前我刚读完这本书的时候，现在将其整理成文。开头一段现在回头看多少有点怪异，但我最后还是决定保留。不过不论如何，我现在依然很为能看到这本书并且了解这个人而感到幸运。\n","categories":["Reading"],"tags":["柳比歇夫"]}]