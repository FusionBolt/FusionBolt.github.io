<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2023-07-02T08:45:39.060Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>令人劝退的自我介绍</title>
    <link href="https://fusionbolt.github.io/2023/07/02/Other/dissuasive-self-presentation/"/>
    <id>https://fusionbolt.github.io/2023/07/02/Other/dissuasive-self-presentation/</id>
    <published>2023-07-02T08:43:16.000Z</published>
    <updated>2023-07-02T08:45:39.060Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/dissuasive-self-presentation/9A95282B-E661-465F-B8CE-4469BD319FC9_4_5005_c.jpeg"                      alt="9A95282B-E661-465F-B8CE-4469BD319FC9_4_5005_c.jpeg"                ></p><p>思来想去，还是决定写这篇详尽的自我介绍。这里不会介绍我的兴趣爱好，如果想看那些请到我的博客<a class="link"   href="https://homura.live/about/" >关于<i class="fas fa-external-link-alt"></i></a>页面。这里不是作为某种特殊角色的我，并非程序员，并非一个社畜，并非一个二十多岁的青年，而是仅仅作为一个人，关于这个人到底是什么样的，或者说关于这个人在我的眼里到底是什么样的。</p><p>首先是很孤单的人。总的来说我一直是一个比较孤单的人，但和每个人一样十分渴求亲密关系，甚至渴求的程度比大部分人还要强烈。这样的我却又讨厌人，认为大部分人和自己一样无聊，或者比我更无趣，因此对大部分人会普通交流但不会有太强烈的热情。加上在只有自己的世界生活习惯了，在没有特别大的热情的情况下，会不太适应一些场景下的交流，更别说去主动推进关系了。</p><p>比较自卑，没有信心，但有的时候又会有些自大。跟别人交流时，尤其是讨论问题时，无形中会认为自己就是对的，想要说服对方。除此之外在交流上很多时候比较有障碍，我个人经常觉得没什么可以说的，个人知识量和见识都很少，加上认为很多事情都无所谓，因此偶尔说不上话的时候会强行交流而说出一些不适当的话。</p><p>上面的这些因素也促成了我的赛博精神病，情绪到了不能控制的痛苦时，无法排解，因此会在社交平台上发一些很烦人的东西。原因也很简单，觉得很无助，但我也无法去依靠某个人，如果理解为网络精神乞丐那我也认，自己也是这么想的。</p><p>基于以上这些问题，我经常会在一些来不及思考自己说的话是否合适的情况说出不合适的话。</p><p>除此之外，我会关注自身的想法，近年来也开始逐渐关注感受，理性的想法和感性的感受缺一不可。关注的同时也会为自身的一些想法痛苦不已，很多时候也非常想去改正，只是很难。尽管在关注自己，但也不是很明白自己，对前路还是有些迷茫，不过这初入社会不久的人来说也是常态了。同时注重自己的想法，较少受到环境的影响，不在乎他人看法，除非特别在乎对方对自己的态度的情况下。脑袋里每天也会有各种乱七八糟的想法，其中一部分也会通过各种途径输出，目前输出频率最高的大概就是推特了。</p><p>这样的我，活着只是活着，对我目前来讲没什么目的和意义，对一切也毫无牵挂。如果一定要说一个活着的目的那就是顺着自己的心愿，尽可能去做想做的事情，要说我现在想做什么的话除了找到伴侣我还真没什么想做的，绝大部分事情其实都无所谓。几乎没有什么特别喜欢的事情，但同时也没什么特别讨厌的。尽管很多事情无所谓，自身的道德感却会重一些，一些情况下会给自己施加过多的道德约束，自身行为也会尽可能的符合自身认知中的道德标准，经常会使得自己徒增烦恼。</p><p>另外过于理想主义，讨厌这种现实世界，很多情况也不愿去接受。这种不愿接受有些孩子气了，但我也没有抛弃的念头，继续这样也没什么不好。但问题是也不愿接受现在这样无能的自己，对自己许多时候也过于严苛，也不认为他人能完全接受这样的自己。</p><p>尽管这么多问题，但我还是想成为一个更好的人，包括更能接纳自己，能力达到自己满意的程度，自己的一些问题都解决掉，等等，但是前方的路还要走非常非常远。虽然也在尝试去控制自己，但自己的一些本质问题无法改正的情况下还是很难做到的，这些都不是靠意志力就能做到的事情，许多时候人对于自己行为的掌控，远比自己所想象的要弱小很多。当然这不是在找借口，想要改变也是我的另一面。</p><p>不论好坏，不可避免的都会偏离现实。对于我来说，以自己看到或感知到的自己为主。对于读者来说，以读者所看到或感知到的我为主。别人的自我介绍都是表现出自己最好的一面，但这篇介绍却是有劝退的成分。看到了我是这样的人，如果你选择与我接触，那么希望你能做好心理预期，如果借此劝退，也无妨，避免双方留下不愉快的回忆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/dissuasive-sel</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="自我" scheme="https://fusionbolt.github.io/tags/%E8%87%AA%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十一  relr and dynsym</title>
    <link href="https://fusionbolt.github.io/2023/07/02/mold/mold-11-rel-and-dynsym/"/>
    <id>https://fusionbolt.github.io/2023/07/02/mold/mold-11-rel-and-dynsym/</id>
    <published>2023-07-02T08:04:13.000Z</published>
    <updated>2023-07-02T08:07:43.172Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-11-rel-and-dynsym/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">推特画师Lyytoaoitori</center> <h1 id="construct-relr"><a href="#construct-relr" class="headerlink" title="construct_relr"></a>construct_relr</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --packed_dyn_relocs=relr was given, base relocations are stored</span></span><br><span class="line"><span class="comment">// to a .relr.dyn section in a compressed form. Construct a compressed</span></span><br><span class="line"><span class="comment">// relocations now so that we can fix section sizes and file layout.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.pack_dyn_relocs_relr)</span><br><span class="line">  <span class="built_in">construct_relr</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>-z pack-relative-relocs Alias for –pack-dyn-relocs=relr<br>-z nopack-relative-relocs</p></blockquote><p>将OutputSection以及Got中的relocations以压缩的形式存储到relr.dyn，在这之后rel段的大小和layout就固定了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_relr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;construct_relr&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      osec-&gt;<span class="built_in">construct_relr</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.got-&gt;<span class="built_in">construct_relr</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output-section"><a href="#output-section" class="headerlink" title="output section"></a>output section</h2><p>将output section中所有符合条件的rel段收集起来，最后再压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">construct_relr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.pic)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span>-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_addralign % <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip it if it is a text section because .text doesn&#x27;t usually</span></span><br><span class="line">  <span class="comment">// contain any dynamic relocations.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_flags &amp; SHF_EXECINSTR)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Collect base relocations</span></span><br><span class="line">  std::vector&lt;std::vector&lt;u64&gt;&gt; <span class="built_in">shards</span>(members.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *members[i];</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; isec.p2align) &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r : isec.<span class="built_in">get_rels</span>(ctx))</span><br><span class="line">      <span class="keyword">if</span> (r.r_type == E::R_ABS &amp;&amp; (r.r_offset % <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[r.r_sym];</span><br><span class="line">            !sym.<span class="built_in">is_absolute</span>() &amp;&amp; !sym.is_imported)</span><br><span class="line">          shards[i].<span class="built_in">push_back</span>(isec.offset + r.r_offset);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compress them</span></span><br><span class="line">  std::vector&lt;u64&gt; pos = <span class="built_in">flatten</span>(shards);</span><br><span class="line">  relr = <span class="built_in">encode_relr</span>(pos, <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要讲的是开头是否为pic的判断</p><blockquote><p>–pie, –pic-executable Create a position independent executable<br>–no-pie, –no-pic-executable</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_flag</span>(<span class="string">&quot;pie&quot;</span>) || <span class="built_in">read_flag</span>(<span class="string">&quot;pic-executable&quot;</span>)) &#123;</span><br><span class="line">  ctx.arg.pic = <span class="literal">true</span>;</span><br><span class="line">  ctx.arg.pie = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_flag</span>(<span class="string">&quot;no-pie&quot;</span>) || <span class="built_in">read_flag</span>(<span class="string">&quot;no-pic-executable&quot;</span>)) &#123;</span><br><span class="line">  ctx.arg.pic = <span class="literal">false</span>;</span><br><span class="line">  ctx.arg.pie = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>有两个概念，pic和pie</p><p>pic：position-independent code</p><p>pie：position-independent executable</p><p>pic和pie是看似类似却是完全冲突的两个选项。</p><p>pie是生成位置无关的可执行程序，所有变量（静态和全局变量，或者说局部变量外的变量）的地址在executable中已经确定，由于这个位置确定因此不需要got表，尽管地址确定但是executable可以加载到任意地址，因为确定的是executable的内部偏移。</p><p>而pic通常是一个动态库，在运行时可以加载到任意位置，也就是说相对于加载这个pic库的executable的地址也是未知的，可能加载到前面，也可能加载到后面，确定的地址只有相对于这个pic库内部起始地址的偏移，因此需要利用got中的信息再计算具体加载后的地址。</p><p>看到这些内容也就明白为什么不是pic的话就返回了，因为pie的话并不需要进行重定位来支持动态加载</p><h2 id="got"><a href="#got" class="headerlink" title="got"></a>got</h2><p>got(global offset table)，保存了global符号的内存地址，比如说function或者全局变量，用于运行时重定位来解析这些地址。程序首次运行时got被初始化为未解析的地址，调用函数的时候通过rel.plt/rela.plt解析对应符号的地址，之后地址会被保存到got，供下次解析使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GotSection&lt;E&gt;::<span class="built_in">construct_relr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(ctx.arg.pack_dyn_relocs_relr);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;u64&gt; pos;</span><br><span class="line">  <span class="keyword">for</span> (GotEntry&lt;E&gt; &amp;ent : <span class="built_in">get_got_entries</span>(ctx))</span><br><span class="line">    <span class="keyword">if</span> (ent.<span class="built_in">is_relr</span>(ctx))</span><br><span class="line">      pos.<span class="built_in">push_back</span>(ent.idx * <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  relr = <span class="built_in">encode_relr</span>(pos, <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-got-entries"><a href="#get-got-entries" class="headerlink" title="get_got_entries"></a>get_got_entries</h3><p>这个过程主要是从各个位置获取GotEntry</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GotEntry</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_relr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r_type == E::R_RELATIVE &amp;&amp; ctx.arg.pack_dyn_relocs_relr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i64 idx = <span class="number">0</span>;</span><br><span class="line">  u64 val = <span class="number">0</span>;</span><br><span class="line">  i64 r_type = R_NONE;</span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于rel_type</p><blockquote><p>Relocation entries describe how to alter the following instruction and data fields (bit numbers appear in the lower box corners).</p></blockquote><p>这里提前引用部分elf spec中提到的在i386中下面会用到的几种rel type的含义</p><p>R*_386_GLOB_DAT*</p><blockquote><p><em>This relocation type is used to set a global offset table entry to the address of the specified symbol. The special relocation type allows one to determine the correspondence between symbols and global offset table entries.</em></p></blockquote><p><em>R_386_RELATIVE</em></p><blockquote><p><em>The link editor creates this relocation type for dynamic linking. Its offset member gives a location within a shared object that contains a value representing a relative address. The dynamic linker computes the corresponding virtual address by adding the virtual address at which the shared object was loaded to the relative address. Relocation entries for this type must specify 0 for the symbol table index.</em></p></blockquote><p>关于其他的rel type参考信息</p><p><a class="link"   href="https://docs.oracle.com/cd/E19683-01/817-3677/x-j1h4h/index.html" >https://docs.oracle.com/cd/E19683-01/817-3677/x-j1h4h/index.html<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>A R_386_TLS_TPOFF relocation is left outstanding against the GOT table for the runtime linker to fill in with the static TLS offset for symbol x.</p></blockquote><ol><li><p>ordinary symbols</p><ol><li><p>针对imported的符号：需要dynamic linker resolve，因此rel_type设置为GLOB_DAT。同时链接时地址未知，因此地址为0</p></li><li><p>ifunc的符号，通常需要dynamic linker fix up，因此rel_type为R_IRELATIVE</p><p>ifun: 间接函数。支持对一个函数创建多个实现，通过自己编写的resolver在运行时选择实现</p><p><a class="link"   href="http://sourceware.org/glibc/wiki/GNU_IFUNC" >http://sourceware.org/glibc/wiki/GNU_IFUNC<i class="fas fa-external-link-alt"></i></a></p></li><li><p>pic且relative的情况，需要rel_type为R_IRELATIVE，否则不需要rel_type</p></li></ol><p>针对ordinary symbols获取地址时都是NO_PLT的，因为都是已知实现和地址，不需要动态链接。</p></li><li><p>TLVs</p><p>TLV: thread local variarble</p><p>根据是否为static的情况做不同的处理，是否为static由这两个编译选项所控制</p><blockquote><p>–Bdynamic, –dy Link against shared libraries (default)<br>–Bstatic, –dn, –static Do not link against shared libraries</p></blockquote></li><li><p>tls</p><ol><li>针对符号是否为_TLS_MODULE_BASE_进行处理，唯一的区别是是否将符号关联进去，但是两者都需要设置rel_type为TLS_DESC</li></ol></li><li><p>gottp_syms</p><p>tp: thread pointer</p><ol><li>imported，这种符号所有信息未知，需要dynamic linker填充got entry，rel_type为R_TPOFF</li><li>shared，知道offset，需要dynamic linker调整，rel_type为R_TPOFF</li><li>other，链接时知道相对于tp的offset，所以能直接填写got entry</li></ol></li><li><p>tlsld_idx</p><ol><li>是否为static。static的情况下不需要rel，同时设置地址为1（表示main executable)否则需要设置rel为R_DTPMOD</li></ol></li></ol><p>总结一下</p><p>不需要设置rel_type的情况如下</p><ol><li>ordinary symbol，pic且非relative符号的情况下，也就是说非pic或者pic但是没有relative符号（即不需要重定位）的情况下），不需要设置rel_type</li><li>TLVS为static的情况下不需要设置rel_type</li><li>非shared以及imported的gottp symbol</li><li>tlsld_idx不为1且是static的情况</li></ol><p>不过这里我有一个不明白的地方，为什么不需要rel_type的符号会在got中。查到的答案是</p><ol><li>作为函数的间接跳转入口:<br>所有函数,包括不需要重定位的函数,在第一次调用时都需要通过.got表来间接跳转。即使函数在链接时就已经获得了绝对地址,但仍需要通过.got表调用。</li><li>访问全局变量:<br>程序中所有全局变量,包括不需要重定位的变量,都需要通过基址寄存器加上.got中的偏移量来访问。<br>即使变量的值在链接时就已经确定,但程序仍需要通过.got表访问。</li><li>作为函数指针:<br>函数的地址可以被用作函数指针。而所有的函数指针,包括指向不需要重定位的函数的函数指针,都需要通过.got表来存取。</li><li>链接器的要求:<br>链接器要求所有函数和变量,无论是否需要重定位,都需要一个.got表项。这样它才能在程序加载时准确构建.got表。</li><li>兼容性考虑:<br>加入所有符号大大提高程序的兼容性。如果后续添加了需要重定位的符号,程序无需任何改动。<br>所以,总之,.got表中的所有符号都是程序加载时解析的。<br>即使符号不需要重定位,但仍需要通过.got表间接存取。主要是作为函数入口和变量、函数指针的访问入口。<br>另外链接器及兼容性的要求也促使符号加入.got表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get .got and .rel.dyn contents.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// .got is a linker-synthesized constant pool whose entry is of pointer</span></span><br><span class="line"><span class="comment">// size. If we know a correct value for an entry, we&#x27;ll just set that value</span></span><br><span class="line"><span class="comment">// to the entry. Otherwise, we&#x27;ll create a dynamic relocation and let the</span></span><br><span class="line"><span class="comment">// dynamic linker to fill the entry at load-time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Most GOT entries contain addresses of global variable. If a global</span></span><br><span class="line"><span class="comment">// variable is an imported symbol, we don&#x27;t know its address until runtime.</span></span><br><span class="line"><span class="comment">// GOT contains the addresses of such variables at runtime so that we can</span></span><br><span class="line"><span class="comment">// access imported global variables via GOT.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Thread-local variables (TLVs) also use GOT entries. We need them because</span></span><br><span class="line"><span class="comment">// TLVs are accessed in a different way than the ordinary global variables.</span></span><br><span class="line"><span class="comment">// Their addresses are not unique; each thread has its own copy of TLVs.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::vector&lt;GotEntry&lt;E&gt;&gt; <span class="built_in">get_got_entries</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  std::vector&lt;GotEntry&lt;E&gt;&gt; entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create GOT entries for ordinary symbols</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;got_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_got_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a symbol is imported, let the dynamic linker to resolve it.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_GLOB_DAT, sym&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IFUNC always needs to be fixed up by the dynamic linker.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;<span class="built_in">is_ifunc</span>()) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT), E::R_IRELATIVE&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know an address at link-time, fill that GOT entry now.</span></span><br><span class="line">    <span class="comment">// It may need a base relocation, though.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.pic &amp;&amp; sym-&gt;<span class="built_in">is_relative</span>())</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT), E::R_RELATIVE&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT)&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create GOT entries for TLVs.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;tlsgd_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_tlsgd_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.is_static) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">1</span>&#125;); <span class="comment">// One indicates the main executable file</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx + <span class="number">1</span>, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.dtp_addr&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_DTPMOD, sym&#125;);</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx + <span class="number">1</span>, <span class="number">0</span>, E::R_DTPOFF, sym&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(supports_tlsdesc&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;tlsdesc_syms) &#123;</span><br><span class="line">      <span class="comment">// _TLS_MODULE_BASE_ is a linker-synthesized virtual symbol that</span></span><br><span class="line">      <span class="comment">// refers the begining of the TLS block.</span></span><br><span class="line">      <span class="keyword">if</span> (sym == ctx._TLS_MODULE_BASE_)</span><br><span class="line">        entries.<span class="built_in">push_back</span>(&#123;sym-&gt;<span class="built_in">get_tlsdesc_idx</span>(ctx), <span class="number">0</span>, E::R_TLSDESC&#125;);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        entries.<span class="built_in">push_back</span>(&#123;sym-&gt;<span class="built_in">get_tlsdesc_idx</span>(ctx), <span class="number">0</span>, E::R_TLSDESC, sym&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;gottp_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_gottp_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know nothing about the symbol, let the dynamic linker</span></span><br><span class="line">    <span class="comment">// to fill the GOT entry.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_TPOFF, sym&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know the offset within the current thread vector,</span></span><br><span class="line">    <span class="comment">// let the dynamic linker to adjust it.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.tls_begin, E::R_TPOFF&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, we know the offset from the thread pointer (TP) at</span></span><br><span class="line">    <span class="comment">// link-time, so we can fill the GOT entry directly.</span></span><br><span class="line">    entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.tp_addr&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.got-&gt;tlsld_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.is_static)</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;ctx.got-&gt;tlsld_idx, <span class="number">1</span>&#125;); <span class="comment">// 1 means the main executable</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;ctx.got-&gt;tlsld_idx, <span class="number">0</span>, E::R_DTPMOD&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-addr"><a href="#get-addr" class="headerlink" title="get_addr"></a>get_addr</h2><p>这个函数是确定地址的过程。</p><p>首先说明PLT（Procedure Linkage Table），用于存放函数调用的跳转指令。主要用于提供函数入口点，实现间接调用。第一次调用对应函数时plt段被链接器处理，链接到函数的真实地址，也就是GOT中存放的具体值。</p><p>比如说某些符号在链接的时候是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call fun@PLT</span><br></pre></td></tr></table></figure><p>当调用fun后，这里的代码就会变成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *foo@GOT</span><br></pre></td></tr></table></figure><p>另外是absolute符号，简单来说就是有一个固定的绝对地址的符号，因此可以直接获得其地址</p><p><a class="link"   href="https://stackoverflow.com/questions/33324076/what-is-absolute-symbol-and-how-to-define-it-in-c" >https://stackoverflow.com/questions/33324076/what-is-absolute-symbol-and-how-to-define-it-in-c<i class="fas fa-external-link-alt"></i></a></p><ol><li>针对frag，非alive则是0，否则从frag中获取地址，</li><li>has copy rel，去从ctx中的copy_rel获取基地址</li><li>PPC64</li><li>plt，直接get_plt_addr</li><li>input section为空，absolute符号直接返回value的地址</li><li>input section非alive的情况<ol><li>killed by icf，从leader中获取地址</li><li>eh_frame，根据符号名获取eh_frame中对应位置的地址</li><li>否则返回0</li></ol></li><li>普通的input section，直接isec→get_addr + value</li></ol><p>下面代码中出现的value的含义如下，属于Symbol的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `value` contains symbol value. If it&#x27;s an absolute symbol, it is</span></span><br><span class="line"><span class="comment">// equivalent to its address. If it belongs to an input section or a</span></span><br><span class="line"><span class="comment">// section fragment, value is added to the base of the input section</span></span><br><span class="line"><span class="comment">// to yield an address.</span></span><br><span class="line"><span class="comment">// u64 value = 0;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 SectionFragment&lt;E&gt;::<span class="built_in">get_addr</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> output_section.shdr.sh_addr + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `value` contains symbol value. If it&#x27;s an absolute symbol, it is</span></span><br><span class="line"><span class="comment">// equivalent to its address. If it belongs to an input section or a</span></span><br><span class="line"><span class="comment">// section fragment, value is added to the base of the input section</span></span><br><span class="line"><span class="comment">// to yield an address.</span></span><br><span class="line"><span class="comment">// u64 value = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 Symbol&lt;E&gt;::<span class="built_in">get_plt_addr</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i32 idx = <span class="built_in">get_plt_idx</span>(ctx); idx != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.plt-&gt;shdr.sh_addr + E::plt_hdr_size + idx * E::plt_size;</span><br><span class="line">  <span class="keyword">return</span> ctx.pltgot-&gt;shdr.sh_addr + <span class="built_in">get_pltgot_idx</span>(ctx) * E::pltgot_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i32 Symbol&lt;E&gt;::<span class="built_in">get_pltgot_idx</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (aux_idx == <span class="number">-1</span>) ? <span class="number">-1</span> : ctx.symbol_aux[aux_idx].pltgot_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> InputSection&lt;E&gt;::<span class="built_in">is_killed_by_icf</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;leader &amp;&amp; <span class="keyword">this</span>-&gt;leader != <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 Symbol&lt;E&gt;::<span class="built_in">get_addr</span>(Context&lt;E&gt; &amp;ctx, i64 flags) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = <span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!frag-&gt;is_alive) &#123;</span><br><span class="line">      <span class="comment">// This condition is met if a non-alloc section refers an</span></span><br><span class="line">      <span class="comment">// alloc section and if the referenced piece of data is</span></span><br><span class="line">      <span class="comment">// garbage-collected. Typically, this condition occurs if a</span></span><br><span class="line">      <span class="comment">// debug info section refers a string constant in .rodata.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frag-&gt;<span class="built_in">get_addr</span>(ctx) + value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has_copyrel) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyrel_readonly</span><br><span class="line">      ? ctx.copyrel_relro-&gt;shdr.sh_addr + value</span><br><span class="line">      : ctx.copyrel-&gt;shdr.sh_addr + value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!(flags &amp; NO_OPD) &amp;&amp; has_opd(ctx))</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="title">get_opd_addr</span><span class="params">(ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; NO_PLT) &amp;&amp; <span class="built_in">has_plt</span>(ctx)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(is_imported || <span class="built_in">is_ifunc</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_plt_addr</span>(ctx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InputSection&lt;E&gt; *isec = <span class="built_in">get_input_section</span>();</span><br><span class="line">  <span class="keyword">if</span> (!isec)</span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// absolute symbol</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isec-&gt;is_alive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isec-&gt;<span class="built_in">is_killed_by_icf</span>())</span><br><span class="line">      <span class="keyword">return</span> isec-&gt;leader-&gt;<span class="built_in">get_addr</span>() + value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isec-&gt;<span class="built_in">name</span>() == <span class="string">&quot;.eh_frame&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// .eh_frame contents are parsed and reconstructed by the linker,</span></span><br><span class="line">      <span class="comment">// so pointing to a specific location in a source .eh_frame</span></span><br><span class="line">      <span class="comment">// section doesn&#x27;t make much sense. However, CRT files contain</span></span><br><span class="line">      <span class="comment">// symbols pointing to the very beginning and ending of the section.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_BEGIN__&quot;</span> || <span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_LIST__&quot;</span> ||</span><br><span class="line">          <span class="built_in">name</span>() == <span class="string">&quot;.eh_frame_seg&quot;</span> || <span class="built_in">esym</span>().st_type == STT_SECTION)</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;__FRAME_END__&quot;</span> || <span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_LIST_END__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr + ctx.eh_frame-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ARM object files contain &quot;$d&quot; local symbol at the beginning</span></span><br><span class="line">      <span class="comment">// of data sections. Their values are not significant for .eh_frame,</span></span><br><span class="line">      <span class="comment">// so we just treat them as offset 0.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;$d&quot;</span> || <span class="built_in">name</span>().<span class="built_in">starts_with</span>(<span class="string">&quot;$d.&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;symbol referring .eh_frame is not supported: &quot;</span></span><br><span class="line">                 &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The control can reach here if there&#x27;s a relocation that refers</span></span><br><span class="line">    <span class="comment">// a local symbol belonging to a comdat group section. This is a</span></span><br><span class="line">    <span class="comment">// violation of the spec, as all relocations should use only global</span></span><br><span class="line">    <span class="comment">// symbols of comdat members. However, .eh_frame tends to have such</span></span><br><span class="line">    <span class="comment">// relocations.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isec-&gt;<span class="built_in">get_addr</span>() + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dynsym-finalize"><a href="#dynsym-finalize" class="headerlink" title="dynsym finalize"></a>dynsym finalize</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reserve a space for dynamic symbol strings in .dynstr and sort</span></span><br><span class="line"><span class="comment">// .dynsym contents if necessary. Beyond this point, no symbol will</span></span><br><span class="line"><span class="comment">// be added to .dynsym.</span></span><br><span class="line">ctx.dynsym-&gt;<span class="built_in">finalize</span>(ctx);</span><br></pre></td></tr></table></figure><p>为dynamic symbol的字符串在dynstr中留出空间，并且排序dynsym的内容。在这之后不会有符号被加入到dynsym，因此这里dynstr section的大小以及排布确定下来了。</p><p>具体的处理过程如下</p><ol><li>symbols排序，local在前global在后，和elf中的格式一样。</li><li>处理gnu_hash的情况</li><li>设置dynsym_offset后计算dynstr的size</li><li>更新DynsymSection的shdr的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> DynsymSection&lt;E&gt;::<span class="built_in">finalize</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;DynsymSection::finalize&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (symbols.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort symbols. In any symtab, local symbols must precede global symbols.</span></span><br><span class="line">  <span class="keyword">auto</span> first_global = std::<span class="built_in">stable_partition</span>(symbols.<span class="built_in">begin</span>() + <span class="number">1</span>, symbols.<span class="built_in">end</span>(),</span><br><span class="line">                                            [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">return</span> sym-&gt;<span class="built_in">is_local</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We also place undefined symbols before defined symbols for .gnu.hash.</span></span><br><span class="line">  <span class="comment">// Defined symbols are sorted by their hashes for .gnu.hash.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.gnu_hash) &#123;</span><br><span class="line">    <span class="comment">// Count the number of exported symbols to compute the size of .gnu.hash.</span></span><br><span class="line">    i64 num_exported = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; symbols.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span> (symbols[i]-&gt;is_exported)</span><br><span class="line">        num_exported++;</span><br><span class="line"></span><br><span class="line">    u32 num_buckets = num_exported / ctx.gnu_hash-&gt;LOAD_FACTOR + <span class="number">1</span>;</span><br><span class="line">    ctx.gnu_hash-&gt;num_buckets = num_buckets;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((i64)(first_global - symbols.<span class="built_in">begin</span>()), (i64)symbols.<span class="built_in">size</span>(),</span><br><span class="line">                      [&amp;](i64 i) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *symbols[i];</span><br><span class="line">      sym.<span class="built_in">set_dynsym_idx</span>(ctx, i);</span><br><span class="line">      sym.<span class="built_in">set_djb_hash</span>(ctx, <span class="built_in">djb_hash</span>(sym.<span class="built_in">name</span>()));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_sort</span>(first_global, symbols.<span class="built_in">end</span>(),</span><br><span class="line">                       [&amp;](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a-&gt;is_exported != b-&gt;is_exported)</span><br><span class="line">        <span class="keyword">return</span> b-&gt;is_exported;</span><br><span class="line"></span><br><span class="line">      u32 h1 = a-&gt;<span class="built_in">get_djb_hash</span>(ctx) % num_buckets;</span><br><span class="line">      u32 h2 = b-&gt;<span class="built_in">get_djb_hash</span>(ctx) % num_buckets;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">tuple</span>(h1, a-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)) &lt;</span><br><span class="line">             std::<span class="built_in">tuple</span>(h2, b-&gt;<span class="built_in">get_dynsym_idx</span>(ctx));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute .dynstr size</span></span><br><span class="line">  ctx.dynstr-&gt;dynsym_offset = ctx.dynstr-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    symbols[i]-&gt;<span class="built_in">set_dynsym_idx</span>(ctx, i);</span><br><span class="line">    ctx.dynstr-&gt;shdr.sh_size += symbols[i]-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ELF&#x27;s symbol table sh_info holds the offset of the first global symbol.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_info = first_global - symbols.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_dynsym_idx</span>(Context&lt;E&gt; &amp;ctx, i32 idx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(aux_idx != <span class="number">-1</span>);</span><br><span class="line">  ctx.symbol_aux[aux_idx].dynsym_idx = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ctx.symbol_aux[aux_idx].dynsym_idx是在之前的scan_relocations的过程中设置的，对应的dynsym_idx默认为-1</p><h1 id="report-undef-error"><a href="#report-undef-error" class="headerlink" title="report_undef_error"></a>report_undef_error</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print reports about undefined symbols, if needed.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_ERROR)</span><br><span class="line">  <span class="built_in">report_undef_errors</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Report all undefined symbols, grouped by symbol.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_undef_errors</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> i64 max_errors = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : ctx.undef_errors) &#123;</span><br><span class="line">    std::string_view sym_name = pair.first;</span><br><span class="line">    std::span&lt;std::string&gt; errors = pair.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.demangle)</span><br><span class="line">      sym_name = <span class="built_in">demangle</span>(sym_name);</span><br><span class="line"></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;undefined symbol: &quot;</span> &lt;&lt; sym_name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; errors.<span class="built_in">size</span>() &amp;&amp; i &lt; max_errors; i++)</span><br><span class="line">      ss &lt;&lt; errors[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="built_in">size</span>() &gt; max_errors)</span><br><span class="line">      ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced &quot;</span> &lt;&lt; (errors.<span class="built_in">size</span>() - max_errors) &lt;&lt; <span class="string">&quot; more times\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_ERROR)</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_WARN)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报告之前在claim_unresolved_symbols中收集的undef的错误信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-11-rel-an</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="got" scheme="https://fusionbolt.github.io/tags/got/"/>
    
    <category term="rel" scheme="https://fusionbolt.github.io/tags/rel/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十 段排序</title>
    <link href="https://fusionbolt.github.io/2023/06/24/mold/mold-10-sort-section/"/>
    <id>https://fusionbolt.github.io/2023/06/24/mold/mold-10-sort-section/</id>
    <published>2023-06-24T12:39:10.000Z</published>
    <updated>2023-06-24T13:29:25.093Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:76218989</center> <h1 id="段排序"><a href="#段排序" class="headerlink" title="段排序"></a>段排序</h1><p>本篇文章提到的mold中出现的段排序，包含了一个chunk内的段与段的排序，还包含了chunk与chunk之间的排序。或者也可以说是对于输入角度来看待的排序，以及从输出角度看待的段进行排序。对于输入来讲，段的基本单位是InputSection，比如说一个输入文件中的一个text段，而对于输出来讲，也就是目标文件来讲，段的基本单位是一个chunk，而一个chunk是由多个输入的段组成的，比如说大的text段是由所有的输入文件中的text段组合而成。</p><p>首先要说明为什么需要进行排序</p><p>sort_init_fini，sort_ctor_dtor以及shuffle_sections属于chunk内的段与段之间的排序，在这里来说是为了满足mold的特殊需求。不过完全随机以及reverse的shuffle我还是不明白为什么需要这样来做。对于init这样的段来说，链接器需要将所有输入文件的同名段合并到同一个输出段中，因此必须要在chunk内的段与段之间的排序。</p><p>sort_output_sections属于chunk与chunk之间的排序，这里排序的目的很大一部分是为了满足特定规则的需要，不论是regular顺序的还是指定的顺序都会使得ehdr/phdr在最前，而shdr在最后。</p><p>对于中间灵活可变的部分，和对齐以及跳转指令都有关系。跳转指令这个问题我在实际遇到过，JAL指令的立即数字段的长度是固定的，而所要跳转的地址超出了JAL这个字段所能代表的长度，最后通过修改链接脚本中相关段的顺序使得地址控制在了立即数的范围之内。</p><h1 id="sort-init-fini"><a href="#sort-init-fini" class="headerlink" title="sort_init_fini"></a>sort_init_fini</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_init_fini</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_init_fini&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_priority = [](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::regex <span class="built_in">re</span>(<span class="string">R&quot;(\.(\d+)$)&quot;</span>, std::regex_constants::optimize);</span><br><span class="line">    std::string_view name = isec-&gt;<span class="built_in">name</span>();</span><br><span class="line">    std::cmatch m;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(name.<span class="built_in">data</span>(), name.<span class="built_in">data</span>() + name.<span class="built_in">size</span>(), m, re))</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">stoi</span>(m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (osec-&gt;name == <span class="string">&quot;.init_array&quot;</span> || osec-&gt;name == <span class="string">&quot;.preinit_array&quot;</span> ||</span><br><span class="line">          osec-&gt;name == <span class="string">&quot;.fini_array&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.shuffle_sections == SHUFFLE_SECTIONS_REVERSE)</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(osec-&gt;members, [&amp;](InputSection&lt;E&gt; *a, InputSection&lt;E&gt; *b) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get_priority</span>(a) &lt; <span class="built_in">get_priority</span>(b);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的chunk转换为OutputSection，其中对init_array，preinit_array，fini_array段的所有成员按照priority进行排序。</p><blockquote><p>–shuffle-sections[=SEED]   Randomize the output by shuffling input sections</p></blockquote><p>关于init以及后面ctor相关的段，参考maskray聚聚的博客</p><p><a class="link"   href="https://maskray.me/blog/2021-11-07-init-ctors-init-array" >.init, .ctors, and .init_array<i class="fas fa-external-link-alt"></i></a></p><p>其中有这样一段示例汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.section.text.startup,&quot;ax&quot;,@progbits</span><br><span class="line">_GLOBAL__sub_I_a.cc:</span><br><span class="line">  callq_Znwm</span><br><span class="line">  callq_ZN1SC1Ev</span><br><span class="line">  callqgetpid</span><br><span class="line"></span><br><span class="line">.section.init_array.101,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors.65434,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z7init101v</span><br><span class="line"></span><br><span class="line">.section.init_array.102,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors.65433,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z7init102v</span><br><span class="line"></span><br><span class="line">.section.init_array,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z4initv</span><br><span class="line">.quad_GLOBAL__sub_I_a.cc</span><br></pre></td></tr></table></figure><p>这里面的init_array根据不同的priority增加不同的后缀数字，而这里的排序正是针对这些</p><h1 id="sort-ctor-dtor"><a href="#sort-ctor-dtor" class="headerlink" title="sort_ctor_dtor"></a>sort_ctor_dtor</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_ctor_dtor</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_ctor_dtor&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_priority = [](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> opts = std::regex_constants::optimize | std::regex_constants::ECMAScript;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re1</span><span class="params">(<span class="string">R&quot;((?:clang_rt\.)?crtbegin)&quot;</span>, opts)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re2</span><span class="params">(<span class="string">R&quot;((?:clang_rt\.)?crtend)&quot;</span>, opts)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re3</span><span class="params">(<span class="string">R&quot;(\.(\d+)$)&quot;</span>, opts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// crtbegin.o and crtend.o contain marker symbols such as</span></span><br><span class="line">    <span class="comment">// __CTOR_LIST__ or __DTOR_LIST__. So they have to be at the</span></span><br><span class="line">    <span class="comment">// beginning or end of the section.</span></span><br><span class="line">    std::smatch m;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(isec-&gt;file.filename, m, re1))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(isec-&gt;file.filename, m, re2))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">(isec-&gt;name())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(name, m, re3))</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">stoi</span>(m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (osec-&gt;name == <span class="string">&quot;.ctors&quot;</span> || osec-&gt;name == <span class="string">&quot;.dtors&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.shuffle_sections != SHUFFLE_SECTIONS_REVERSE)</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(osec-&gt;members, [&amp;](InputSection&lt;E&gt; *a, InputSection&lt;E&gt; *b) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get_priority</span>(a) &lt; <span class="built_in">get_priority</span>(b);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和sort init类似的逻辑，除了priority的计算方式不同。这里针对了clang_rt的crtbegin和crtend做了特殊的处理，最后再对其余的按照编号进行排序。</p><h1 id="shuffle-sections"><a href="#shuffle-sections" class="headerlink" title="shuffle_sections"></a>shuffle_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --shuffle-sections</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.shuffle_sections != SHUFFLE_SECTIONS_NONE)</span><br><span class="line">  <span class="built_in">shuffle_sections</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>-shuffle-sections[=SEED] Randomize the output by shuffling input sections</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;shuffle_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> is_eligible = [](OutputSection&lt;E&gt; &amp;osec) &#123;</span><br><span class="line">    <span class="keyword">return</span> osec.name != <span class="string">&quot;.init&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.fini&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.ctors&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.dtors&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.init_array&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.preinit_array&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.fini_array&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.shuffle_sections) &#123;</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_NONE:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_SHUFFLE: &#123;</span><br><span class="line">    u64 seed;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shuffle_sections_seed)</span><br><span class="line">      seed = *ctx.arg.shuffle_sections_seed;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      seed = ((u64)std::<span class="built_in">random_device</span>()() &lt;&lt; <span class="number">32</span>) | std::<span class="built_in">random_device</span>()();</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_eligible</span>(*osec))</span><br><span class="line">          <span class="built_in">shuffle</span>(osec-&gt;members, seed + <span class="built_in">hash_string</span>(osec-&gt;name));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_REVERSE:</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_eligible</span>(*osec))</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里跳过了上面sort_init_fini以及sort_ctor_dtor的特殊段，对剩下段的members根据shuffle_sections选项进行shuffle或者reverse</p><h1 id="copy-str"><a href="#copy-str" class="headerlink" title="copy str"></a>copy str</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy string referred by .dynamic to .dynstr.</span></span><br><span class="line"><span class="keyword">for</span> (SharedFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(file-&gt;soname);</span><br><span class="line"><span class="keyword">for</span> (std::string_view str : ctx.arg.auxiliary)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(str);</span><br><span class="line"><span class="keyword">for</span> (std::string_view str : ctx.arg.filter)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(str);</span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.rpaths.<span class="built_in">empty</span>())</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(ctx.arg.rpaths);</span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.soname.<span class="built_in">empty</span>())</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(ctx.arg.soname);</span><br></pre></td></tr></table></figure><p>拷贝所有动态库所需要用的字符串到dynstr中，主要是soname和一些路径之类的信息，而这些信息只是通过段合并是无法添加到dynstr中的，因为这些属于链接时的信息，无法通过链接输入的编译产物获取。</p><p>关于这几个链接选项的介绍</p><blockquote><p>-f SHLIB, –auxiliary SHLIB Set DT_AUXILIARY to the specified value</p></blockquote><blockquote><p>-F LIBNAME, –filter LIBNAME<br>Set DT_FILTER to the specified value</p></blockquote><blockquote><p>–rpath DIR                 Add DIR to runtime search path</p></blockquote><blockquote><p>h LIBNAME, –soname LIBNAME Set shared library name</p></blockquote><h1 id="scan-relocations"><a href="#scan-relocations" class="headerlink" title="scan_relocations"></a>scan_relocations</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scan relocations to find symbols that need entries in .got, .plt,</span></span><br><span class="line"><span class="comment">// .got.plt, .dynsym, .dynstr, etc.</span></span><br><span class="line"><span class="built_in">scan_relocations</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;scan_relocations&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations to find dynamic symbols.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证输出文件中的got和plt等section包含对应rel的信息，递归所有所有的rel找到在got和plt中需要的符号，并且添加到got/plt中。而got和plt本身就是synthetic的段，无法从编译产物中获取，只能在链接的时候产生，为了确保rel段符号的正确查找，一定需要这一步骤。</p><p>这里主要做了三部分</p><ol><li>扫描每个obj里所有段中的符号，另外标记rel段中要处理的符合条件的符号为NEEDS_PLT</li><li>将flag不为空，或者是imported/exported的符号保留，过滤掉其他符号</li><li>对过滤后的符号，根据其flga添加到对应的chunk中，比如说got或者plt等，最后再清空其flag</li></ol><h2 id="rel-scan"><a href="#rel-scan" class="headerlink" title="rel scan"></a>rel scan</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;scan_relocations&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations to find dynamic symbols.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exit if there was a relocation that refers an undefined symbol.</span></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每个obj进行scan_relocations</p><h3 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">scan_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Scan relocations against seciton contents</span></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections)</span><br><span class="line">    <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      isec-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations against exception frames</span></span><br><span class="line">  <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : cies) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;rel : cie.<span class="built_in">get_rels</span>()) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.is_imported) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() != STT_FUNC)</span><br><span class="line">          <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sym</span><br><span class="line">                     &lt;&lt; <span class="string">&quot;: .eh_frame CIE record with an external data reference&quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot; is not supported&quot;</span>;</span><br><span class="line">        sym.flags |= NEEDS_PLT;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲InputSection之前先看一下CIE的部分。CIE的代码中也会包含rel的部分。</p><h3 id="InputSection"><a href="#InputSection" class="headerlink" title="InputSection"></a>InputSection</h3><p>isec-&gt;scan_relocations(ctx);</p><p>这里针对不同的arch有着不同的特化实现</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled%201.png"                      alt="Untitled"                ></p><p>这里我们拿i386和riscv的实现做对比看一下差异</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled%202.png"                      alt="Untitled"                ></p><p>可以看到前面的内容几乎一致，获取rels之后遍历，针对不同的rel type做出不同的处理</p><p>关于riscv的rel type，可以参考这两个链接</p><p><a class="link"   href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc" >https://github.com/riscv-non-isa/riscv-elf-psabi-doc<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.risc-v1.com/thread-906-1-1.html" >RISC-V ELF规范和函数调用规范 - 国内芯片技术交流 - RISC-V单片机中文网——全球首家只专注于RISC-V单片机行业应用的中文网站<i class="fas fa-external-link-alt"></i></a></p><p>然后我们看针对不同rel type处理的部分</p><p>本质都是调用了InputSection的一些辅助函数，挑几个看一下。在此之前先补充两个缩写的全拼</p><p>absrel: absolute relocations</p><p>pcrel: PC-relative relocations</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (rel.r_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_32:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(E::is_64)</span></span></span><br><span class="line"><span class="function">      <span class="title">scan_absrel</span><span class="params">(ctx, sym, rel)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">scan_dyn_absrel</span>(ctx, sym, rel);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_HI20:</span><br><span class="line">    <span class="built_in">scan_absrel</span>(ctx, sym, rel);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_64:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!E::is_64)</span></span></span><br><span class="line"><span class="function">      <span class="title">Fatal</span><span class="params">(ctx)</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; &quot;: R_RISCV_64 cannot be used on RV32<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="function">    scan_dyn_absrel(ctx, sym, rel);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_CALL:</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_CALL_PLT:</span></span></span><br><span class="line"><span class="string"><span class="function">    if (sym.is_imported)</span></span></span><br><span class="line"><span class="string"><span class="function">      sym.flags.fetch_or(NEEDS_PLT, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_GOT_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_GOT, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_TLS_GOT_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    ctx.has_gottp_rel.store(true, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_GOTTP, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_TLS_GD_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_TLSGD, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_32_PCREL:</span></span></span><br><span class="line"><span class="string"><span class="function">    scan_pcrel(ctx, sym, rel);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br></pre></td></tr></table></figure><p>fetch_or是执行按位or运算，可以简单视为 flags |= NEEDS_XXX，相当于更新了flag，前面也说过在这个scan的过程本质就是要更新其flag</p><p>这里主要的内容就是scan_xxx，而这些scan的实现都是调用的scan_rel，区别是传入了不同的action</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_pcrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                 <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_pcrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_absrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                  <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_absrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_dyn_absrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                      <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_dyn_absrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_toc_rel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                   <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_ppc64_toc_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不同的action则是通过查表的方式来获取。每个不同的类别有着自己的表，将这个表传递给get_rel_action后进行获取。在get_rel_action中则是通过output type和sym type进行查表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_pcrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is for PC-relative relocations (e.g. R_X86_64_PC32).</span></span><br><span class="line">  <span class="comment">// We cannot promote them to dynamic relocations because the dynamic</span></span><br><span class="line">  <span class="comment">// linker generally does not support PC-relative relocations.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  ERROR,    NONE,    ERROR,         PLT    &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  ERROR,    NONE,    COPYREL,       PLT    &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    COPYREL,       CPLT   &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_absrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a decision table for absolute relocations that is smaller</span></span><br><span class="line">  <span class="comment">// than the word size (e.g. R_X86_64_32). Since the dynamic linker</span></span><br><span class="line">  <span class="comment">// generally does not support dynamic relocations smaller than the</span></span><br><span class="line">  <span class="comment">// word size, we need to report an error if a relocation cannot be</span></span><br><span class="line">  <span class="comment">// resolved at link-time.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     ERROR,   ERROR,         ERROR &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     ERROR,   ERROR,         ERROR &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    COPYREL,       CPLT  &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_dyn_absrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">is_ifunc</span>())</span><br><span class="line">    <span class="keyword">return</span> IFUNC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a decision table for absolute relocations for the word</span></span><br><span class="line">  <span class="comment">// size data (e.g. R_X86_64_64). Unlike the absrel_table, we can emit</span></span><br><span class="line">  <span class="comment">// a dynamic relocation if we cannot resolve an address at link-time.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL   &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL   &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    DYN_COPYREL,   DYN_CPLT &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_ppc64_toc_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">is_ifunc</span>())</span><br><span class="line">    <span class="keyword">return</span> IFUNC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As a special case, we do not create copy relocations nor canonical</span></span><br><span class="line">  <span class="comment">// PLTs for .toc sections. PPC64&#x27;s .toc is a compiler-generated</span></span><br><span class="line">  <span class="comment">// GOT-like section, and no user-generated code directly uses values</span></span><br><span class="line">  <span class="comment">// in it.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    DYNREL,        DYNREL &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_rel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Action table[<span class="number">3</span>][<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> get_output_type = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.pie)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_sym_type = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">is_absolute</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sym.is_imported)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() != STT_FUNC)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> table[<span class="built_in">get_output_type</span>()][<span class="built_in">get_sym_type</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scan-rel"><a href="#scan-rel" class="headerlink" title="scan_rel"></a>scan_rel</h3><p>这里是对符号进行标记的地方，根据传入的不同action使用不同处理以及标记方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scan_rel</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec, Symbol&lt;E&gt; &amp;sym,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel, Action action)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> writable = (isec.<span class="built_in">shdr</span>().sh_flags &amp; SHF_WRITE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> error = [&amp;] &#123;</span><br><span class="line">    std::string msg = sym.<span class="built_in">is_absolute</span>() ? <span class="string">&quot;-fno-PIC&quot;</span> : <span class="string">&quot;-fPIC&quot;</span>;</span><br><span class="line">    <span class="built_in">Error</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; rel &lt;&lt; <span class="string">&quot; relocation at offset 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; rel.r_offset &lt;&lt; <span class="string">&quot; against symbol `&quot;</span></span><br><span class="line">               &lt;&lt; sym &lt;&lt; <span class="string">&quot;&#x27; can not be used; recompile with &quot;</span> &lt;&lt; msg;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check_textrel = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (!writable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.z_text) &#123;</span><br><span class="line">        <span class="built_in">error</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.warn_textrel) &#123;</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: relocation against symbol `&quot;</span> &lt;&lt; sym</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&#x27; in read-only section&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.has_textrel = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> copyrel = [&amp;] &#123;</span><br><span class="line">    <span class="built_in">assert</span>(sym.is_imported);</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().st_visibility == STV_PROTECTED) &#123;</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; isec</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;: cannot make copy relocation for protected symbol &#x27;&quot;</span> &lt;&lt; sym</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;&#x27;, defined in &quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot;; recompile with -fPIC&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sym.flags |= NEEDS_COPYREL;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dynrel = [&amp;] &#123;</span><br><span class="line">    <span class="built_in">check_textrel</span>();</span><br><span class="line">    isec.file.num_dynrel++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> NONE:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ERROR:</span><br><span class="line">    <span class="built_in">error</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COPYREL:</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.z_copyreloc)</span><br><span class="line">      <span class="built_in">error</span>();</span><br><span class="line">    <span class="built_in">copyrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYN_COPYREL:</span><br><span class="line">    <span class="keyword">if</span> (writable || !ctx.arg.z_copyreloc)</span><br><span class="line">      <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copyrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PLT:</span><br><span class="line">    sym.flags |= NEEDS_PLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CPLT:</span><br><span class="line">    sym.flags |= NEEDS_CPLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYN_CPLT:</span><br><span class="line">    <span class="keyword">if</span> (writable)</span><br><span class="line">      <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sym.flags |= NEEDS_CPLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYNREL:</span><br><span class="line">  <span class="keyword">case</span> IFUNC:</span><br><span class="line">    <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> BASEREL:</span><br><span class="line">    <span class="built_in">check_textrel</span>();</span><br><span class="line">    <span class="keyword">if</span> (!isec.<span class="built_in">is_relr_reloc</span>(ctx, rel))</span><br><span class="line">      isec.file.num_dynrel++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symbols-to-a-vec"><a href="#symbols-to-a-vec" class="headerlink" title="symbols to a vec"></a>symbols to a vec</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregate dynamic symbols to a single vector.</span></span><br><span class="line">std::vector&lt;InputFile&lt;E&gt; *&gt; files;</span><br><span class="line"><span class="built_in">append</span>(files, ctx.objs);</span><br><span class="line"><span class="built_in">append</span>(files, ctx.dsos);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;Symbol&lt;E&gt; *&gt;&gt; <span class="built_in">vec</span>(files.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)files.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : files[i]-&gt;symbols)</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == files[i])</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;flags || sym-&gt;is_imported || sym-&gt;is_exported)</span><br><span class="line">        vec[i].<span class="built_in">push_back</span>(sym);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">std::vector&lt;Symbol&lt;E&gt; *&gt; syms = <span class="built_in">flatten</span>(vec);</span><br><span class="line">ctx.symbol_aux.<span class="built_in">reserve</span>(syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将所有的文件中所有符合条件的symbol收集起来，其中flag则是在前面的阶段进行标记的</p><p>关于这里的symbol_aux</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol auxiliary data</span></span><br><span class="line">std::vector&lt;SymbolAux&gt; symbol_aux;</span><br></pre></td></tr></table></figure><p>SymbolAux</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Additional class members for dynamic symbols. Because most symbols</span></span><br><span class="line"><span class="comment">// don&#x27;t need them and we allocate tens of millions of symbol objects</span></span><br><span class="line"><span class="comment">// for large programs, we separate them from `Symbol` class to save</span></span><br><span class="line"><span class="comment">// memory.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SymbolAux</span> &#123;</span></span><br><span class="line">  i32 got_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 gottp_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 tlsgd_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 tlsdesc_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 plt_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 pltgot_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 opd_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 dynsym_idx = <span class="number">-1</span>;</span><br><span class="line">  u32 djb_hash = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="add-to-table"><a href="#add-to-table" class="headerlink" title="add to table"></a>add to table</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assign offsets in additional tables for each dynamic symbol.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : syms) &#123;</span><br><span class="line">    <span class="built_in">add_aux</span>(sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported || sym-&gt;is_exported)</span><br><span class="line">      ctx.dynsym-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOT)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_got_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_CPLT) &#123;</span><br><span class="line">      sym-&gt;is_canonical = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A canonical PLT needs to be visible from DSOs.</span></span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can&#x27;t use .plt.got for a canonical PLT because otherwise</span></span><br><span class="line">      <span class="comment">// .plt.got and .got would refer each other, resulting in an</span></span><br><span class="line">      <span class="comment">// infinite loop at runtime.</span></span><br><span class="line">      ctx.plt-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_PLT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOT)</span><br><span class="line">        ctx.pltgot-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.plt-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOTTP)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_gottp_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_TLSGD)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_tlsgd_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_TLSDESC)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_tlsdesc_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_COPYREL) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(sym-&gt;file-&gt;is_dso);</span><br><span class="line">      SharedFile&lt;E&gt; *file = (SharedFile&lt;E&gt; *)sym-&gt;file;</span><br><span class="line">      sym-&gt;copyrel_readonly = file-&gt;<span class="built_in">is_readonly</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;copyrel_readonly)</span><br><span class="line">        ctx.copyrel_relro-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.copyrel-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If a symbol needs copyrel, it is considered both imported</span></span><br><span class="line">      <span class="comment">// and exported.</span></span><br><span class="line">      <span class="built_in">assert</span>(sym-&gt;is_imported);</span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Aliases of this symbol are also copied so that they will be</span></span><br><span class="line">      <span class="comment">// resolved to the same address at runtime.</span></span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *alias : file-&gt;<span class="built_in">find_aliases</span>(sym)) &#123;</span><br><span class="line">        <span class="built_in">add_aux</span>(alias);</span><br><span class="line">        alias-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;has_copyrel = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;value = sym-&gt;value;</span><br><span class="line">        alias-&gt;copyrel_readonly = sym-&gt;copyrel_readonly;</span><br><span class="line">        ctx.dynsym-&gt;<span class="built_in">add_symbol</span>(ctx, alias);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">      <span class="title">if</span> <span class="params">(sym-&gt;flags &amp; NEEDS_OPD)</span></span></span><br><span class="line"><span class="function">        ctx.ppc64_opd-&gt;<span class="title">add_symbol</span><span class="params">(ctx, sym)</span></span>;</span><br><span class="line"></span><br><span class="line">    sym-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.needs_tlsld)</span><br><span class="line">    ctx.got-&gt;<span class="built_in">add_tlsld</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.has_textrel &amp;&amp; ctx.arg.warn_textrel)</span><br><span class="line">    <span class="built_in">Warn</span>(ctx) &lt;&lt; <span class="string">&quot;creating a DT_TEXTREL in an output file&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有符合条件的符号添加到ctx.symbol_aux中，之后加入到对应的表中</p><h1 id="compute-section-sizes"><a href="#compute-section-sizes" class="headerlink" title="compute_section_sizes"></a>compute_section_sizes</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute sizes of output sections while assigning offsets</span></span><br><span class="line"><span class="comment">// within an output section to input sections.</span></span><br><span class="line"><span class="built_in">compute_section_sizes</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里做了如下几件事情</p><ol><li>chunks里面找到所有符合条件的osec进行处理<ol><li>划分group并且处理每个group的size和p2align</li><li>计算与设置group的offset以及p2align</li></ol></li><li>处理ARM的特殊情况</li><li>根据arg的section_align设定特定osec的sh_addralign</li></ol><h2 id="chunks的处理"><a href="#chunks的处理" class="headerlink" title="chunks的处理"></a>chunks的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_section_sizes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Group</span> &#123;</span></span><br><span class="line">    i64 size = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    std::span&lt;InputSection&lt;E&gt; *&gt; members;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>();</span><br><span class="line">    <span class="keyword">if</span> (!osec)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This pattern will be processed in the next loop.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (needs_thunk&lt;E&gt;)</span><br><span class="line">      <span class="keyword">if</span> ((osec-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since one output section may contain millions of input sections,</span></span><br><span class="line">    <span class="comment">// we first split input sections into groups and assign offsets to</span></span><br><span class="line">    <span class="comment">// groups.</span></span><br><span class="line">    std::vector&lt;Group&gt; groups;</span><br><span class="line">    <span class="keyword">constexpr</span> i64 group_size = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::span&lt;InputSection&lt;E&gt; *&gt; span : <span class="built_in">split</span>(osec-&gt;members, group_size))</span><br><span class="line">      groups.<span class="built_in">push_back</span>(Group&#123;.members = span&#125;);</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(groups, [](Group &amp;group) &#123;</span><br><span class="line">      <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : group.members) &#123;</span><br><span class="line">        group.size = <span class="built_in">align_to</span>(group.size, <span class="number">1</span> &lt;&lt; isec-&gt;p2align) + isec-&gt;sh_size;</span><br><span class="line">        group.p2align = std::max&lt;i64&gt;(group.p2align, isec-&gt;p2align);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; groups.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; groups[i].p2align);</span><br><span class="line">      groups[i].offset = offset;</span><br><span class="line">      offset += groups[i].size;</span><br><span class="line">      p2align = std::<span class="built_in">max</span>(p2align, groups[i].p2align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    osec-&gt;shdr.sh_size = offset;</span><br><span class="line">    osec-&gt;shdr.sh_addralign = <span class="number">1</span> &lt;&lt; p2align;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign offsets to input sections.</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(groups, [](Group &amp;group) &#123;</span><br><span class="line">      i64 offset = group.offset;</span><br><span class="line">      <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : group.members) &#123;</span><br><span class="line">        offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; isec-&gt;p2align);</span><br><span class="line">        isec-&gt;offset = offset;</span><br><span class="line">        offset += isec-&gt;sh_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol><li>找到chunks中的osec</li><li>将osec中的InputSections拆分为几个group并行计算</li><li>针对每个group的每个InputSection<ol><li>将group size根据isec的p2align计算出一个对齐的size，之后加上当前isec的size</li><li>p2align更新为最大值</li></ol></li><li>更新所有group的offset以及p2align</li><li>更新osec的size和addralign</li><li>对所有group中的input section设置offset</li></ol><h2 id="ARM的处理"><a href="#ARM的处理" class="headerlink" title="ARM的处理"></a>ARM的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On ARM32 or ARM64, we may need to create so-called &quot;range extension</span></span><br><span class="line">  <span class="comment">// thunks&quot; to extend branch instructions reach, as they can jump only</span></span><br><span class="line">  <span class="comment">// to ±16 MiB or ±128 MiB, respecitvely.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In the following loop, We compute the sizes of sections while</span></span><br><span class="line">  <span class="comment">// inserting thunks. This pass cannot be parallelized. That is,</span></span><br><span class="line">  <span class="comment">// create_range_extension_thunks is parallelized internally, but the</span></span><br><span class="line">  <span class="comment">// function itself is not thread-safe.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">      OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>();</span><br><span class="line">      <span class="keyword">if</span> (osec &amp;&amp; (osec-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">        <span class="built_in">create_range_extension_thunks</span>(ctx, *osec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : osec-&gt;members)</span><br><span class="line">          osec-&gt;shdr.sh_addralign =</span><br><span class="line">            std::max&lt;u32&gt;(osec-&gt;shdr.sh_addralign, <span class="number">1</span> &lt;&lt; isec-&gt;p2align);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设定osec的sh-addralign"><a href="#设定osec的sh-addralign" class="headerlink" title="设定osec的sh_addralign"></a>设定osec的sh_addralign</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      <span class="keyword">if</span> (u32 align = ctx.arg.section_align[osec-&gt;name])</span><br><span class="line">        osec-&gt;shdr.sh_addralign = std::max&lt;u32&gt;(osec-&gt;shdr.sh_addralign, align);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-output-sections"><a href="#sort-output-sections" class="headerlink" title="sort_output_sections"></a>sort_output_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort sections by section attributes so that we&#x27;ll have to</span></span><br><span class="line"><span class="comment">// create as few segments as possible.</span></span><br><span class="line"><span class="built_in">sort_output_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">sort_output_sections_regular</span>(ctx);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">sort_output_sections_by_order</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对所有chunk进行了排序。</p><p>其中顺序为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ELF Header</span><br><span class="line">program header</span><br><span class="line">normal memory allocated sections</span><br><span class="line">non-memory-allocated sections</span><br><span class="line">section header</span><br></pre></td></tr></table></figure><p>normal memory allocated sections的顺序会根据用户指定的顺序，或者使用一套regular的规则</p><h2 id="regular"><a href="#regular" class="headerlink" title="regular"></a>regular</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections_regular</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">sort</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *a, Chunk&lt;E&gt; *b) &#123;</span><br><span class="line">    <span class="comment">// Sort sections by segments</span></span><br><span class="line">    i64 x = <span class="built_in">get_rank1</span>(a);</span><br><span class="line">    i64 y = <span class="built_in">get_rank1</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x != y)</span><br><span class="line">      <span class="keyword">return</span> x &lt; y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ties are broken by additional rules</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_rank2</span>(a) &lt; <span class="built_in">get_rank2</span>(b);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中对排序的规则进行了说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We want to sort output chunks in the following order.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;ELF header&gt;</span></span><br><span class="line"><span class="comment">//   &lt;program header&gt;</span></span><br><span class="line"><span class="comment">//   .interp</span></span><br><span class="line"><span class="comment">//   .note</span></span><br><span class="line"><span class="comment">//   .hash</span></span><br><span class="line"><span class="comment">//   .gnu.hash</span></span><br><span class="line"><span class="comment">//   .dynsym</span></span><br><span class="line"><span class="comment">//   .dynstr</span></span><br><span class="line"><span class="comment">//   .gnu.version</span></span><br><span class="line"><span class="comment">//   .gnu.version_r</span></span><br><span class="line"><span class="comment">//   .rela.dyn</span></span><br><span class="line"><span class="comment">//   .rela.plt</span></span><br><span class="line"><span class="comment">//   &lt;readonly data&gt;</span></span><br><span class="line"><span class="comment">//   &lt;readonly code&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable tdata&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable tbss&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable RELRO data&gt;</span></span><br><span class="line"><span class="comment">//   .got</span></span><br><span class="line"><span class="comment">//   .toc</span></span><br><span class="line"><span class="comment">//   &lt;writable RELRO bss&gt;</span></span><br><span class="line"><span class="comment">//   .relro_padding</span></span><br><span class="line"><span class="comment">//   &lt;writable non-RELRO data&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable non-RELRO bss&gt;</span></span><br><span class="line"><span class="comment">//   &lt;non-memory-allocated sections&gt;</span></span><br><span class="line"><span class="comment">//   &lt;section header&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_rank1 = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">  u64 type = chunk-&gt;shdr.sh_type;</span><br><span class="line">  u64 flags = chunk-&gt;shdr.sh_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.ehdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.phdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.interp)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (type == SHT_NOTE &amp;&amp; (flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.gnu_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.dynsym)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.dynstr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.versym)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.verneed)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.reldyn)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.relplt)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.shdr)</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> alloc = (flags &amp; SHF_ALLOC);</span><br><span class="line">  <span class="keyword">bool</span> writable = (flags &amp; SHF_WRITE);</span><br><span class="line">  <span class="keyword">bool</span> exec = (flags &amp; SHF_EXECINSTR);</span><br><span class="line">  <span class="keyword">bool</span> tls = (flags &amp; SHF_TLS);</span><br><span class="line">  <span class="keyword">bool</span> relro = <span class="built_in">is_relro</span>(ctx, chunk);</span><br><span class="line">  <span class="keyword">bool</span> is_bss = (type == SHT_NOBITS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) | (!alloc &lt;&lt; <span class="number">9</span>) | (writable &lt;&lt; <span class="number">8</span>) | (exec &lt;&lt; <span class="number">7</span>) |</span><br><span class="line">         (!tls &lt;&lt; <span class="number">6</span>) | (!relro &lt;&lt; <span class="number">5</span>) | (is_bss &lt;&lt; <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> get_rank2 = [&amp;](Chunk&lt;E&gt; *chunk) -&gt; i64 &#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk-&gt;shdr.sh_type == SHT_NOTE)</span><br><span class="line">    <span class="keyword">return</span> -chunk-&gt;shdr.sh_addralign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.relro_padding)</span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">  <span class="keyword">if</span> (chunk-&gt;name == <span class="string">&quot;.toc&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.got)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>tls: This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data.</p></blockquote><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort sections according to a --section-order argument.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections_by_order</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// It is an error if a section order cannot be determined by a given</span></span><br><span class="line"><span class="comment">// section order list.</span></span><br><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">  chunk-&gt;sect_order = <span class="built_in">get_rank</span>(chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort output sections by --section-order</span></span><br><span class="line"><span class="built_in">sort</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *a, Chunk&lt;E&gt; *b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a-&gt;sect_order &lt; b-&gt;sect_order;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的chunk设置sect_order，之后根据这个排序。这个功能我觉得就是类似于在链接脚本中按顺序写下段的名字然后按照脚本的顺序来排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_rank = [&amp;](Chunk&lt;E&gt; *chunk) -&gt; i64 &#123;</span><br><span class="line">  u64 flags = chunk-&gt;shdr.sh_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.ehdr &amp;&amp; !(chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.phdr &amp;&amp; !(chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.shdr)</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX;</span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; <span class="keyword">const</span> SectionOrder &amp;arg : ctx.arg.section_order) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.type == SectionOrder::SECTION &amp;&amp; arg.name == chunk-&gt;name)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string_view group = <span class="built_in">get_section_order_group</span>(*chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.section_order.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    SectionOrder arg = ctx.arg.section_order[i];</span><br><span class="line">    <span class="keyword">if</span> (arg.type == SectionOrder::GROUP &amp;&amp; arg.name == group)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--section-order: missing section specification for &quot;</span></span><br><span class="line">             &lt;&lt; chunk-&gt;name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对ehdr，phdr，以及shdr强制指定一个rank</p><p>之后根据arg的order查找优先级。如果没指定，则根据section_order_group再查优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> std::string_view <span class="title">get_section_order_group</span><span class="params">(Chunk&lt;E&gt; &amp;chunk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_type == SHT_NOBITS)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BSS&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_flags &amp; SHF_EXECINSTR)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;TEXT&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_flags &amp; SHF_WRITE)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DATA&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;RODATA&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-10-sort-s</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读九 未解析符号的处理</title>
    <link href="https://fusionbolt.github.io/2023/06/19/mold/mold-9-unresolve-symbol/"/>
    <id>https://fusionbolt.github.io/2023/06/19/mold/mold-9-unresolve-symbol/</id>
    <published>2023-06-19T13:54:17.000Z</published>
    <updated>2023-06-19T13:55:07.319Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-9-unresolve-symbol/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341_p16</center> <p>本期内容主要是claim_unresolved_symbols的部分，其次是其他一些简单的处理</p><h1 id="claim-unresolved-symbols"><a href="#claim-unresolved-symbols" class="headerlink" title="claim_unresolved_symbols"></a>claim_unresolved_symbols</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are linking a .so file, remaining undefined symbols does</span></span><br><span class="line"><span class="comment">// not cause a linker error. Instead, they are treated as if they</span></span><br><span class="line"><span class="comment">// were imported symbols.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we are linking an executable, weak undefs are converted to</span></span><br><span class="line"><span class="comment">// weakly imported symbols so that they&#x27;ll have another chance to be</span></span><br><span class="line"><span class="comment">// resolved.</span></span><br><span class="line"><span class="built_in">claim_unresolved_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">claim_unresolved_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;claim_unresolved_symbols&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">claim_unresolved_symbols</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要还是针对需要在链接期就确定定义的符号进行检查，针对部分符号产生一些修改，在这个过程之后，不会再有符号发生新的变动了</p><p>对so来说undef是可以存在的，因此将避免报错，将undef的符号转换为imported，并且修改相关信息。</p><p>但是如果是protected或者hidden的符号即便链接了运行时也无法访问到，此时即便是undef也无法再在运行时找到定义，因此需要在链接时确定定义。也正因为这些条件，这里只需要对global符号做检查即可。</p><p>以下是具体处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">claim_unresolved_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;is_alive)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a protected/hidden undefined symbol is resolved to an</span></span><br><span class="line">    <span class="comment">// imported symbol, it&#x27;s handled as if no symbols were found.</span></span><br><span class="line">    <span class="keyword">if</span> (sym.file &amp;&amp; sym.file-&gt;is_dso &amp;&amp;</span><br><span class="line">        (sym.visibility == STV_PROTECTED || sym.visibility == STV_HIDDEN)) &#123;</span><br><span class="line">      <span class="built_in">report_undef</span>(sym);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file &amp;&amp;</span><br><span class="line">        (!sym.<span class="built_in">esym</span>().<span class="built_in">is_undef</span>() || sym.file-&gt;priority &lt;= <span class="keyword">this</span>-&gt;priority))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a symbol name is in the form of &quot;foo@version&quot;, search for</span></span><br><span class="line">    <span class="comment">// symbol &quot;foo&quot; and check if the symbol has version &quot;version&quot;.</span></span><br><span class="line">    std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">    <span class="keyword">if</span> (i64 pos = key.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != key.npos) &#123;</span><br><span class="line">      Symbol&lt;E&gt; *sym2 = <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">      <span class="keyword">if</span> (sym2-&gt;file &amp;&amp; sym2-&gt;file-&gt;is_dso &amp;&amp;</span><br><span class="line">          sym2-&gt;<span class="built_in">get_version</span>() == key.<span class="built_in">substr</span>(pos + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;symbols[i] = sym2;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef_weak</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym.visibility != STV_HIDDEN &amp;&amp;</span><br><span class="line">          ctx.arg.z_dynamic_undefined_weak) &#123;</span><br><span class="line">        <span class="comment">// Global weak undefined symbols are promoted to dynamic symbols</span></span><br><span class="line">        <span class="comment">// when when linking a DSO, unless `-z nodynamic_undefined_weak`</span></span><br><span class="line">        <span class="comment">// was given.</span></span><br><span class="line">        <span class="built_in">claim</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise, weak undefs are converted to absolute symbols with value 0.</span></span><br><span class="line">        <span class="built_in">claim</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_WARN)</span><br><span class="line">      <span class="built_in">report_undef</span>(sym);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traditionally, remaining undefined symbols cause a link failure</span></span><br><span class="line">    <span class="comment">// only when we are creating an executable. Undefined symbols in</span></span><br><span class="line">    <span class="comment">// shared objects are promoted to dynamic symbols, so that they&#x27;ll</span></span><br><span class="line">    <span class="comment">// get another chance to be resolved at run-time. You can change the</span></span><br><span class="line">    <span class="comment">// behavior by passing `-z defs` to the linker.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Even if `-z defs` is given, weak undefined symbols are still</span></span><br><span class="line">    <span class="comment">// promoted to dynamic symbols for compatibility with other linkers.</span></span><br><span class="line">    <span class="comment">// Some major programs, notably Firefox, depend on the behavior</span></span><br><span class="line">    <span class="comment">// (they use this loophole to export symbols from libxul.so).</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym.visibility != STV_HIDDEN &amp;&amp;</span><br><span class="line">        (!ctx.arg.z_defs || ctx.arg.unresolved_symbols != UNRESOLVED_ERROR)) &#123;</span><br><span class="line">      <span class="built_in">claim</span>(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert remaining undefined symbols to absolute symbols with value 0.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols != UNRESOLVED_ERROR || ctx.arg.noinhibit_exec)</span><br><span class="line">      <span class="built_in">claim</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面所说，整个过程描述如下</p><ol><li><p>从全局符号开始，先跳过了已经有定义的esym</p></li><li><p>将protected和hidden的符号进行报错</p></li><li><p>对esym对应位置的sym进行判断，如果sym所对应的esym是有定义的也跳过。</p><p>这种情况是esym实际的定义在其他位置，sym是esym resolve的结果</p></li><li><p>解析符号名，如果带有版本信息则再次尝试进行重新将esym和sym进行关联。这个关联体现在esym对应index的symbols重新设置值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sym2-&gt;file &amp;&amp; sym2-&gt;file-&gt;is_dso &amp;&amp;</span><br><span class="line">    sym2-&gt;<span class="built_in">get_version</span>() == key.<span class="built_in">substr</span>(pos + <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = sym2;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对undef_weak进行claim</p></li><li><p>剩下的undef的符号在创建executable的时候导致链接失败，但在dso中会被提升为dynamic symbols</p></li></ol><p>claim和report_undef的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> report_undef = [&amp;](Symbol&lt;E&gt; &amp;sym) &#123;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  <span class="keyword">if</span> (std::string_view source = <span class="keyword">this</span>-&gt;<span class="built_in">get_source_name</span>(); !source.<span class="built_in">empty</span>())</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced by &quot;</span> &lt;&lt; source &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced by &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.undef_errors)</span>::accessor acc</span>;</span><br><span class="line">  ctx.undef_errors.<span class="built_in">insert</span>(acc, &#123;sym.<span class="built_in">name</span>(), &#123;&#125;&#125;);</span><br><span class="line">  acc-&gt;second.<span class="built_in">push_back</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tbb::concurrent_hash_map&lt;std::string_view, std::vector&lt;std::string&gt;&gt; undef_errors;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> claim = [&amp;](<span class="keyword">bool</span> is_imported) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.traced)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unresolved&quot;</span></span><br><span class="line">                 &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&quot; weak&quot;</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; symbol &quot;</span> &lt;&lt; sym;</span><br><span class="line"></span><br><span class="line">  sym.file = <span class="keyword">this</span>;</span><br><span class="line">  sym.origin = <span class="number">0</span>;</span><br><span class="line">  sym.value = <span class="number">0</span>;</span><br><span class="line">  sym.sym_idx = i;</span><br><span class="line">  sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">  sym.is_imported = is_imported;</span><br><span class="line">  sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">  sym.ver_idx = is_imported ? <span class="number">0</span> : ctx.default_version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="print-dependencies"><a href="#print-dependencies" class="headerlink" title="print dependencies"></a>print dependencies</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --print-dependencies</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.print_dependencies == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print_dependencies</span>(ctx);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.print_dependencies == <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print_dependencies_full</span>(ctx);</span><br></pre></td></tr></table></figure><p>针对所有的obj和dso打印其依赖，那么具体怎么样才算依赖呢？在一个obj a里面，有一个未定义的符号，链接的时候另一个obj b包含了这个符号的定义，那么这就算是a依赖b。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dependencies</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt;</span><br><span class="line"><span class="string">R&quot;(# This is an output of the mold linker&#x27;s --print-dependencies option.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Each line consists of three fields, &lt;file1&gt;, &lt;file2&gt; and &lt;symbol&gt;</span></span><br><span class="line"><span class="string"># separated by tab characters. It indicates that &lt;file1&gt; depends on</span></span><br><span class="line"><span class="string"># &lt;file2&gt; to use &lt;symbol&gt;.)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> print = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line">      <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="built_in">print</span>(file);</span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">    <span class="built_in">print</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是最简单的遍历所有文件打印其依赖，包含了obj a，obj b以及对应符号的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dependencies_full</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt;</span><br><span class="line"><span class="string">R&quot;(# This is an output of the mold linker&#x27;s --print-dependencies=full option.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Each line consists of 4 fields, &lt;section1&gt;, &lt;section2&gt;, &lt;symbol-type&gt; and</span></span><br><span class="line"><span class="string"># &lt;symbol&gt;, separated by tab characters. It indicates that &lt;section1&gt; depends</span></span><br><span class="line"><span class="string"># on &lt;section2&gt; to use &lt;symbol&gt;. &lt;symbol-type&gt; is either &quot;u&quot; or &quot;w&quot; for</span></span><br><span class="line"><span class="string"># regular undefined or weak undefined, respectively.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># If you want to obtain dependency information per function granularity,</span></span><br><span class="line"><span class="string"># compile source files with the -ffunction-sections compiler flag.)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> println = [&amp;](<span class="keyword">auto</span> &amp;src, Symbol&lt;E&gt; &amp;sym, ElfSym&lt;E&gt; &amp;esym) &#123;</span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="built_in">SyncOut</span>(ctx) &lt;&lt; src &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *isec</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">SyncOut</span>(ctx) &lt;&lt; src &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::unordered_set&lt;<span class="keyword">void</span> *&gt; visited;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.r_type == R_NONE)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[r.r_sym];</span><br><span class="line">        Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[r.r_sym];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file &amp;&amp;</span><br><span class="line">            visited.<span class="built_in">insert</span>((<span class="keyword">void</span> *)&amp;sym).second)</span><br><span class="line">          <span class="built_in">println</span>(*isec, sym, esym);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (SharedFile&lt;E&gt; *file : ctx.dsos) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line">      <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file)</span><br><span class="line">        <span class="built_in">println</span>(*file, sym, esym);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种更复杂一些，不仅打印依赖，还包含了符号到底是undefined还是weak这一信息。</p><p>另外遍历objs的时候还针对每个obj遍历InputSection及其包含的rel，根据这些信息来进行打印。</p><p>遍历dsos的判断条件则是和上面最简单的打印是相同的。</p><h1 id="write-repro-file"><a href="#write-repro-file" class="headerlink" title="write_repro_file"></a>write_repro_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle -repro</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.repro)</span><br><span class="line">  <span class="built_in">write_repro_file</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>–repro                     Embed input files to .repro section</p></blockquote><p>repro file是Reproducible Example Routine file的简称，包含最小可复现用例，用于调试。具体写的过程并非这里关注的重点，有兴趣可以自行查看更多细节，这里只简单看一下由哪些部分组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_repro_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::string path = ctx.arg.output + <span class="string">&quot;.repro.tar&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;TarWriter&gt; tar =</span><br><span class="line">    TarWriter::<span class="built_in">open</span>(path, <span class="built_in">filepath</span>(ctx.arg.output).<span class="built_in">filename</span>().<span class="built_in">string</span>() + <span class="string">&quot;.repro&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tar)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;cannot open &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">errno_string</span>();</span><br><span class="line"></span><br><span class="line">  tar-&gt;<span class="built_in">append</span>(<span class="string">&quot;response.txt&quot;</span>, <span class="built_in">save_string</span>(ctx, <span class="built_in">create_response_file</span>(ctx)));</span><br><span class="line">  tar-&gt;<span class="built_in">append</span>(<span class="string">&quot;version.txt&quot;</span>, <span class="built_in">save_string</span>(ctx, mold_version + <span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  std::unordered_set&lt;std::string&gt; seen;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mf-&gt;parent) &#123;</span><br><span class="line">      std::string path = <span class="built_in">to_abs_path</span>(mf-&gt;name).<span class="built_in">string</span>();</span><br><span class="line">      <span class="keyword">if</span> (seen.<span class="built_in">insert</span>(path).second) &#123;</span><br><span class="line">        <span class="comment">// We reopen a file because we may have modified the contents of mf</span></span><br><span class="line">        <span class="comment">// in memory, which is mapped with PROT_WRITE and MAP_PRIVATE.</span></span><br><span class="line">        MappedFile&lt;Context&lt;E&gt;&gt; *mf2 = MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, path);</span><br><span class="line">        tar-&gt;<span class="built_in">append</span>(path, mf2-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">        mf2-&gt;<span class="built_in">unmap</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> std::string <span class="title">create_response_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::string buf;</span><br><span class="line">  std::stringstream out;</span><br><span class="line"></span><br><span class="line">  std::string cwd = std::filesystem::<span class="built_in">current_path</span>().<span class="built_in">string</span>();</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;-C &quot;</span> &lt;&lt; cwd.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cwd != <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;--chroot ..&quot;</span>;</span><br><span class="line">    i64 depth = std::<span class="built_in">count</span>(cwd.<span class="built_in">begin</span>(), cwd.<span class="built_in">end</span>(), <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; depth; i++)</span><br><span class="line">      out &lt;&lt; <span class="string">&quot;/..&quot;</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; ctx.cmdline_args.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    std::string_view arg = ctx.cmdline_args[i];</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="string">&quot;-repro&quot;</span> &amp;&amp; arg != <span class="string">&quot;--repro&quot;</span>)</span><br><span class="line">      out &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码我们得知，主要分为三部分</p><ol><li>response_file，本质上是编译命令以及参数</li><li>mold的version info</li><li>所有的输入文件</li></ol><p>也就表示这三者就是确定问题的必要条件，另外还可以认为执行到这里之后符号不会再发生什么改动，也不会产生新的用户引发的问题（比如说少链接文件，或者什么参数错了导致符号决议出问题等）</p><h1 id="required-defined"><a href="#required-defined" class="headerlink" title="required-defined"></a>required-defined</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --require-defined</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, name)-&gt;file)</span><br><span class="line">    <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--require-defined: undefined symbol: &quot;</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure><p>强制要求某些符号是必须在链接时就包含定义的，对这些符号进行检查并且进行报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-9-unresol</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读八 创建输出段</title>
    <link href="https://fusionbolt.github.io/2023/06/10/mold/mold-8-create-output-section/"/>
    <id>https://fusionbolt.github.io/2023/06/10/mold/mold-8-create-output-section/</id>
    <published>2023-06-10T08:24:45.000Z</published>
    <updated>2023-06-10T08:26:12.044Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-8-create-output-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341_p18</center> <p>上一期介绍了一些创建输出段之前的工作，本期主要是把创建输出相关的最后一些前置准备讲解完成。根据代码中的注释，add_synthetic_symbols以后，不会再有任何新的文件添加到ctx.objs和ctx.dsos中了。之后会再讲解简单的命令行参数处理，下一期再讲对于输出chunk中的一些处理</p><h1 id="create-output-sections"><a href="#create-output-sections" class="headerlink" title="create output sections"></a>create output sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create output sections for input sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_output_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;create_output_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> OutputSectionKey &amp;k)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      u64 h = <span class="built_in">hash_string</span>(k.name);</span><br><span class="line">      h = <span class="built_in">combine_hash</span>(h, std::hash&lt;u64&gt;&#123;&#125;(k.type));</span><br><span class="line">      h = <span class="built_in">combine_hash</span>(h, std::hash&lt;u64&gt;&#123;&#125;(k.flags));</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::unordered_map&lt;OutputSectionKey, OutputSection&lt;E&gt; *, Cmp&gt; map;</span><br><span class="line">  std::shared_mutex mu;</span><br></pre></td></tr></table></figure><ol><li>首先针对所有的InputSection生成一个key，并且根据key创建所有的OutputSection</li><li>将所有obj中的InputSection加入到对应OutputSection的members中</li><li>对所有的output section和mergeable section加入到chunks</li><li>将所有的chunk进行排序</li><li>所有的chunk加入到ctx.chunks中（在加入之前chunks中有一些synthetic的chunk，在上一期中有提及）</li></ol><p>以下是这五个过程的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate output sections</span></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    OutputSectionKey key = <span class="built_in">get_output_section_key</span>(ctx, *isec);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      std::shared_lock <span class="built_in">lock</span>(mu);</span><br><span class="line">      <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        isec-&gt;output_section = it-&gt;second;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;OutputSection&lt;E&gt;&gt; osec =</span><br><span class="line">      std::make_unique&lt;OutputSection&lt;E&gt;&gt;(key.name, key.type, key.flags);</span><br><span class="line">    std::unique_lock <span class="built_in">lock</span>(mu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = map.<span class="built_in">insert</span>(&#123;key, osec.<span class="built_in">get</span>()&#125;);</span><br><span class="line">    isec-&gt;output_section = it-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (inserted)</span><br><span class="line">      ctx.osec_pool.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(osec));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add input sections to output sections</span></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive)</span><br><span class="line">        isec-&gt;output_section-&gt;members.<span class="built_in">push_back</span>(isec.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add output sections and mergeable sections to ctx.chunks</span></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; vec;</span><br><span class="line">  <span class="keyword">for</span> (std::pair&lt;<span class="keyword">const</span> OutputSectionKey, OutputSection&lt;E&gt; *&gt; &amp;kv : map)</span><br><span class="line">    vec.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;osec : ctx.merged_sections)</span><br><span class="line">    <span class="keyword">if</span> (osec-&gt;shdr.sh_size)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(osec.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sections are added to the section lists in an arbitrary order</span></span><br><span class="line">  <span class="comment">// because they are created in parallel. Sort them to to make the</span></span><br><span class="line">  <span class="comment">// output deterministic.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](Chunk&lt;E&gt; *x, Chunk&lt;E&gt; *y) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(x-&gt;name, x-&gt;shdr.sh_type, x-&gt;shdr.sh_flags) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(y-&gt;name, y-&gt;shdr.sh_type, y-&gt;shdr.sh_flags);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>(ctx.chunks, vec);</span><br></pre></td></tr></table></figure><h2 id="get-output-section-key"><a href="#get-output-section-key" class="headerlink" title="get_output_section_key"></a>get_output_section_key</h2><p>这个函数的作用是从一个InputSection构造一个OutputSectionKey</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> OutputSectionKey</span></span><br><span class="line"><span class="function"><span class="title">get_output_section_key</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = isec.<span class="built_in">shdr</span>();</span><br><span class="line">  std::string_view name = <span class="built_in">get_output_name</span>(ctx, isec.<span class="built_in">name</span>(), shdr.sh_flags);</span><br><span class="line">  u64 type = canonicalize_type&lt;E&gt;(name, shdr.sh_type);</span><br><span class="line">  u64 flags = shdr.sh_flags &amp; ~(u64)SHF_COMPRESSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.relocatable)</span><br><span class="line">    flags &amp;= ~(u64)SHF_GROUP &amp; ~(u64)SHF_GNU_RETAIN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .init_array is usually writable. We don&#x27;t want to create multiple</span></span><br><span class="line">  <span class="comment">// .init_array output sections, so make it always writable.</span></span><br><span class="line">  <span class="comment">// So is .fini_array.</span></span><br><span class="line">  <span class="keyword">if</span> (type == SHT_INIT_ARRAY || type == SHT_FINI_ARRAY)</span><br><span class="line">    flags |= SHF_WRITE;</span><br><span class="line">  <span class="keyword">return</span> &#123;name, type, flags&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputSectionKey</span> &#123;</span></span><br><span class="line">  std::string_view name;</span><br><span class="line">  u64 type;</span><br><span class="line">  u64 flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> OutputSectionKey &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name == other.name &amp;&amp; type == other.type &amp;&amp; flags == other.flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从InputSection获取的output name。这里有以下几种情况</p><ol><li><p>返回原始名字</p></li><li><p>忽略段名字的后缀</p><p>不知道这里应该用什么术语，还是举个例子，比如说里面的.ARM.exidx，如果有.ARM.exidx.f1以及.ARM.exidx.f2，那么这两个的名字都会归为.ARM.exidx</p></li><li><p>将一些特殊的text段单独分开，而不是合并为一个text。这里涉及到了一个z_keep_text_section_prefix的编译选项，命令行的介绍是</p><blockquote><p>z keep-text-section-prefix Keep .text.{hot,unknown,unlikely,startup,exit} as separate sections in the final binary</p></blockquote></li><li><p>对于text等特定段则是只保留原始前缀，比如说所有的.text.xxx最后都会合并到一个.text段。这个对于函数定义非常常见，查看编译产物的时候，经常会看到一些.text.function_name，最后都会合并为一个.text，这种合并其实就是这里实现的。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">std::string_view</span></span><br><span class="line"><span class="function"><span class="title">get_output_name</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view name, u64 flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.relocatable &amp;&amp; !ctx.arg.relocatable_merge_sections)</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.unique &amp;&amp; ctx.arg.unique-&gt;<span class="built_in">match</span>(name))</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SHF_MERGE)</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ARM.exidx&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.ARM.exidx&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ARM.extab&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.ARM.extab&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_keep_text_section_prefix) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::string_view prefixes[] = &#123;</span><br><span class="line">      <span class="string">&quot;.text.hot.&quot;</span>, <span class="string">&quot;.text.unknown.&quot;</span>, <span class="string">&quot;.text.unlikely.&quot;</span>, <span class="string">&quot;.text.startup.&quot;</span>,</span><br><span class="line">      <span class="string">&quot;.text.exit.&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::string_view prefix : prefixes) &#123;</span><br><span class="line">      std::string_view stem = prefix.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (name == stem || name.<span class="built_in">starts_with</span>(prefix))</span><br><span class="line">        <span class="keyword">return</span> stem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> std::string_view prefixes[] = &#123;</span><br><span class="line">    <span class="string">&quot;.text.&quot;</span>, <span class="string">&quot;.data.rel.ro.&quot;</span>, <span class="string">&quot;.data.&quot;</span>, <span class="string">&quot;.rodata.&quot;</span>, <span class="string">&quot;.bss.rel.ro.&quot;</span>, <span class="string">&quot;.bss.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.init_array.&quot;</span>, <span class="string">&quot;.fini_array.&quot;</span>, <span class="string">&quot;.tbss.&quot;</span>, <span class="string">&quot;.tdata.&quot;</span>, <span class="string">&quot;.gcc_except_table.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.ctors.&quot;</span>, <span class="string">&quot;.dtors.&quot;</span>, <span class="string">&quot;.gnu.warning.&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view prefix : prefixes) &#123;</span><br><span class="line">    std::string_view stem = prefix.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name == stem || name.<span class="built_in">starts_with</span>(prefix))</span><br><span class="line">      <span class="keyword">return</span> stem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="add-synthetic-symbols"><a href="#add-synthetic-symbols" class="headerlink" title="add synthetic symbols"></a>add synthetic symbols</h1><p>这里的功能如名字一样，就是添加一些synthetic的符号，添加后将这些符号关联到ctx.symtab中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_synthetic_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  ObjectFile&lt;E&gt; &amp;obj = *ctx.internal_obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> add = [&amp;](std::string_view name) &#123;</span><br><span class="line">    ElfSym&lt;E&gt; esym;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">    esym.st_type = STT_NOTYPE;</span><br><span class="line">    esym.st_shndx = SHN_ABS;</span><br><span class="line">    esym.st_bind = STB_GLOBAL;</span><br><span class="line">    esym.st_visibility = STV_HIDDEN;</span><br><span class="line">    ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, name);</span><br><span class="line">    sym-&gt;value = <span class="number">0xdeadbeef</span>; <span class="comment">// unique dummy value</span></span><br><span class="line">    obj.symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line">    <span class="keyword">return</span> sym;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ctx.__ehdr_start = <span class="built_in">add</span>(<span class="string">&quot;__ehdr_start&quot;</span>);</span><br><span class="line">ctx.__init_array_start = <span class="built_in">add</span>(<span class="string">&quot;__init_array_start&quot;</span>);</span><br><span class="line">ctx.__init_array_end = <span class="built_in">add</span>(<span class="string">&quot;__init_array_end&quot;</span>);</span><br><span class="line">ctx.__fini_array_start = <span class="built_in">add</span>(<span class="string">&quot;__fini_array_start&quot;</span>);</span><br><span class="line">ctx.__fini_array_end = <span class="built_in">add</span>(<span class="string">&quot;__fini_array_end&quot;</span>);</span><br><span class="line">ctx.__preinit_array_start = <span class="built_in">add</span>(<span class="string">&quot;__preinit_array_start&quot;</span>);</span><br><span class="line">ctx.__preinit_array_end = <span class="built_in">add</span>(<span class="string">&quot;__preinit_array_end&quot;</span>);</span><br><span class="line">ctx._DYNAMIC = <span class="built_in">add</span>(<span class="string">&quot;_DYNAMIC&quot;</span>);</span><br><span class="line">ctx._GLOBAL_OFFSET_TABLE_ = <span class="built_in">add</span>(<span class="string">&quot;_GLOBAL_OFFSET_TABLE_&quot;</span>);</span><br><span class="line">ctx._PROCEDURE_LINKAGE_TABLE_ = <span class="built_in">add</span>(<span class="string">&quot;_PROCEDURE_LINKAGE_TABLE_&quot;</span>);</span><br><span class="line">ctx.__bss_start = <span class="built_in">add</span>(<span class="string">&quot;__bss_start&quot;</span>);</span><br><span class="line">ctx._end = <span class="built_in">add</span>(<span class="string">&quot;_end&quot;</span>);</span><br><span class="line">ctx._etext = <span class="built_in">add</span>(<span class="string">&quot;_etext&quot;</span>);</span><br><span class="line">ctx._edata = <span class="built_in">add</span>(<span class="string">&quot;_edata&quot;</span>);</span><br><span class="line">ctx.__executable_start = <span class="built_in">add</span>(<span class="string">&quot;__executable_start&quot;</span>);</span><br><span class="line"></span><br><span class="line">ctx.__rel_iplt_start =</span><br><span class="line">  <span class="built_in">add</span>(is_rela&lt;E&gt; ? <span class="string">&quot;__rela_iplt_start&quot;</span> : <span class="string">&quot;__rel_iplt_start&quot;</span>);</span><br><span class="line">ctx.__rel_iplt_end =</span><br><span class="line">  <span class="built_in">add</span>(is_rela&lt;E&gt; ? <span class="string">&quot;__rela_iplt_end&quot;</span> : <span class="string">&quot;__rel_iplt_end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.eh_frame_hdr)</span><br><span class="line">  ctx.__GNU_EH_FRAME_HDR = <span class="built_in">add</span>(<span class="string">&quot;__GNU_EH_FRAME_HDR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;end&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.end = <span class="built_in">add</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;etext&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.etext = <span class="built_in">add</span>(<span class="string">&quot;etext&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;edata&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.edata = <span class="built_in">add</span>(<span class="string">&quot;edata&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__dso_handle&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.__dso_handle = <span class="built_in">add</span>(<span class="string">&quot;__dso_handle&quot;</span>);</span><br></pre></td></tr></table></figure><p>添加通用的特殊符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(supports_tlsdesc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  ctx._TLS_MODULE_BASE_ </span>= <span class="built_in">add</span>(<span class="string">&quot;_TLS_MODULE_BASE_&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(!ctx.arg.shared)</span></span></span><br><span class="line"><span class="function">    ctx.__global_pointer </span>= <span class="built_in">add</span>(<span class="string">&quot;__global_pointer$&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span> </span>&#123;</span><br><span class="line">  ctx.__exidx_start = <span class="built_in">add</span>(<span class="string">&quot;__exidx_start&quot;</span>);</span><br><span class="line">  ctx.__exidx_end = <span class="built_in">add</span>(<span class="string">&quot;__exidx_end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_ppc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  ctx.TOC </span>= <span class="built_in">add</span>(<span class="string">&quot;.TOC.&quot;</span>);</span><br></pre></td></tr></table></figure><p>针对特殊平台添加特定的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;std::string&gt; name = <span class="built_in">get_start_stop_name</span>(ctx, *chunk)) &#123;</span><br><span class="line">      <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__start_&quot;</span> + *name));</span><br><span class="line">      <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__stop_&quot;</span> + *name));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.physical_image_base) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_start_&quot;</span> + *name));</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_stop_&quot;</span> + *name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>针对特殊名字的trunk的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.elf_syms = ctx.internal_esyms;</span><br><span class="line">obj.symvers.<span class="built_in">resize</span>(ctx.internal_esyms.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">obj.<span class="built_in">resolve_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><p>对internal_obj进行symbol resolve</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make all synthetic symbols relative ones by associating them to</span></span><br><span class="line"><span class="comment">// a dummy output section.</span></span><br><span class="line"><span class="keyword">for</span> (Symbol&lt;E&gt; *sym : obj.symbols)</span><br><span class="line">  <span class="keyword">if</span> (sym-&gt;file == &amp;obj)</span><br><span class="line">    sym-&gt;<span class="built_in">set_output_section</span>(ctx.symtab);</span><br></pre></td></tr></table></figure><p>符号关联到symtab这个output section里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --defsym symbols.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  Symbol&lt;E&gt; *sym = ctx.arg.defsyms[i].first;</span><br><span class="line">  std::variant&lt;Symbol&lt;E&gt; *, u64&gt; val = ctx.arg.defsyms[i].second;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *target = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (Symbol&lt;E&gt; **ref = std::get_if&lt;Symbol&lt;E&gt; *&gt;(&amp;val))</span><br><span class="line">    target = *ref;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the alias refers another symobl, copy ELF symbol attributes.</span></span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    ElfSym&lt;E&gt; &amp;esym = obj.elf_syms[i + <span class="number">1</span>];</span><br><span class="line">    esym.st_type = target-&gt;<span class="built_in">esym</span>().st_type;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">requires</span> &#123; esym.ppc_local_entry; &#125;)</span></span></span><br><span class="line"><span class="function">      esym.ppc_local_entry </span>= target-&gt;<span class="built_in">esym</span>().ppc_local_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the target absolute if necessary.</span></span><br><span class="line">  <span class="keyword">if</span> (!target || target-&gt;<span class="built_in">is_absolute</span>())</span><br><span class="line">    sym-&gt;origin = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于—defsym指定的符号进行处理</p><h1 id="check-cet-errors"><a href="#check-cet-errors" class="headerlink" title="check_cet_errors"></a>check_cet_errors</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle `-z cet-report`.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_cet_report != CET_REPORT_NONE)</span><br><span class="line">    <span class="built_in">check_cet_errors</span>(ctx);</span><br></pre></td></tr></table></figure><p>首先，cet是Control Flow Enforcement Technology的缩写。简单来说就是预防控制流攻击的一种技术</p><blockquote><p>Control-flow Enforcement Technology (CET) covers several related x86 processor features that provide protection against control flow hijacking attacks. CET can protect both applications and the kernel.</p><p>CET introduces shadow stack and indirect branch tracking (IBT). A shadow stack is a secondary stack allocated from memory which cannot be directly modified by applications. When executing a CALL instruction, the processor pushes the return address to both the normal stack and the shadow stack. Upon function return, the processor pops the shadow stack copy and compares it to the normal stack copy. If the two differ, the processor raises a control-protection fault. IBT verifies indirect CALL/JMP targets are intended as marked by the compiler with ‘ENDBR’ opcodes. Not all CPU’s have both Shadow Stack and Indirect Branch Tracking. Today in the 64-bit kernel, only userspace shadow stack and kernel IBT are supported.</p></blockquote><p><a class="link"   href="https://www.kernel.org/doc/html/next/x86/shstk.html" >Control-flow Enforcement Technology (CET) Shadow Stack — The Linux Kernel  documentation<i class="fas fa-external-link-alt"></i></a></p><p>cet_report有三类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  CET_REPORT_NONE,</span><br><span class="line">  CET_REPORT_WARNING,</span><br><span class="line">  CET_REPORT_ERROR,</span><br><span class="line">&#125; CetReportKind;</span><br></pre></td></tr></table></figure><p>这个函数是用于进行针对每个file检查对应的gnu_properties，如果没有满足特定feature的话抛出warning或者error。</p><p>ELF中必须包含GNU_PROPERTY_X86_FEATURE_1_IBT和GNU_PROPERTY_X86_FEATURE_1_SHSTK属性才能支持cet。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_cet_errors</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> warning = (ctx.arg.z_cet_report == CET_REPORT_WARNING);</span><br><span class="line">  <span class="built_in">assert</span>(warning || (ctx.arg.z_cet_report == CET_REPORT_ERROR));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> has_feature = [](ObjectFile&lt;E&gt; *file, u32 feature) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">any_of</span>(file-&gt;gnu_properties.<span class="built_in">begin</span>(), file-&gt;gnu_properties.<span class="built_in">end</span>(),</span><br><span class="line">                       [&amp;](<span class="keyword">auto</span> kv) &#123;</span><br><span class="line">                         <span class="keyword">return</span> kv.first == GNU_PROPERTY_X86_FEATURE_1_AND</span><br><span class="line">                             &amp;&amp; (kv.second &amp; feature);</span><br><span class="line">                       &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file == ctx.internal_obj)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has_feature</span>(file, GNU_PROPERTY_X86_FEATURE_1_IBT)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (warning)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=warning: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_IBT&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=error: &quot;</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_IBT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has_feature</span>(file, GNU_PROPERTY_X86_FEATURE_1_SHSTK)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (warning)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=warning: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_SHSTK&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=error: &quot;</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_SHSTK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="execstack-if-needed"><a href="#execstack-if-needed" class="headerlink" title="execstack-if-needed"></a>execstack-if-needed</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle `-z execstack-if-needed`.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.z_execstack_if_needed)</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;needs_executable_stack)</span><br><span class="line">      ctx.arg.z_execstack = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>所有的obj中，如果有needs_executable_stack为true的情况，那么设置ctx中的arg。obj中的这个属性是在ObjectFile::initialize_sections中设置的。而全局的z_execstack会在后面被用到，此时先不过多提及。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .note.GNU-stack section controls executable-ness of the stack</span></span><br><span class="line"><span class="comment">// area in GNU linkers. We ignore that section because silently</span></span><br><span class="line"><span class="comment">// making the stack area executable is too dangerous. Tell our</span></span><br><span class="line"><span class="comment">// users about the difference if that matters.</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;.note.GNU-stack&quot;</span> &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.z_execstack &amp;&amp; !ctx.arg.z_execstack_if_needed)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: this file may cause a segmentation&quot;</span></span><br><span class="line">        <span class="string">&quot; fault because it requires an executable stack. See&quot;</span></span><br><span class="line">        <span class="string">&quot; https://github.com/rui314/mold/tree/main/docs/execstack.md&quot;</span></span><br><span class="line">        <span class="string">&quot; for more info.&quot;</span>;</span><br><span class="line">    needs_executable_stack = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-8-create-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读七 创建输出段之前</title>
    <link href="https://fusionbolt.github.io/2023/05/20/mold/mold-7-before-create-output-section/"/>
    <id>https://fusionbolt.github.io/2023/05/20/mold/mold-7-before-create-output-section/</id>
    <published>2023-05-20T08:06:32.000Z</published>
    <updated>2023-05-20T08:07:46.442Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-7-before-create-output-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341 p7</center> <p>上期的内容主要是section size相关的优化，这期内容是创建输出段前的最后一些处理</p><h1 id="Compute-Merged-Section-Size"><a href="#Compute-Merged-Section-Size" class="headerlink" title="Compute Merged Section Size"></a>Compute Merged Section Size</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute sizes of sections containing mergeable strings.</span></span><br><span class="line"><span class="built_in">compute_merged_section_sizes</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_merged_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_merged_section_sizes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark section fragments referenced by live objects.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.gc_sections) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : file-&gt;mergeable_sections)</span><br><span class="line">        <span class="keyword">if</span> (m)</span><br><span class="line">          <span class="keyword">for</span> (SectionFragment&lt;E&gt; *frag : m-&gt;fragments)</span><br><span class="line">            frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an identification string to .comment.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary)</span><br><span class="line">    <span class="built_in">add_comment_string</span>(ctx, mold_version);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Embed command line arguments for debugging.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">char</span> *env = <span class="built_in">getenv</span>(<span class="string">&quot;MOLD_DEBUG&quot;</span>); env &amp;&amp; env[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">add_comment_string</span>(ctx, <span class="string">&quot;mold command line: &quot;</span> + <span class="built_in">get_cmdline_args</span>(ctx));</span><br><span class="line"></span><br><span class="line">  <span class="function">Timer <span class="title">t2</span><span class="params">(ctx, <span class="string">&quot;MergedSection assign_offsets&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.merged_sections,</span><br><span class="line">                         [&amp;](std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;sec) &#123;</span><br><span class="line">    sec-&gt;<span class="built_in">assign_offsets</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程做了三件事情</p><ol><li>对非gc_sections的情况下标记fragment，在开启这个选项时会在之前的过程标记过</li><li>之后是添加comment string。</li><li>最后是针对每一个merged_section调用assign_offsets</li></ol><p>关于上面的oformat，其命令行的描述如下</p><blockquote><p>-oformat=binary Omit ELF, section and program headers</p></blockquote><p>add_comment_string的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_comment_string</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string str)</span> </span>&#123;</span><br><span class="line">  MergedSection&lt;E&gt; *sec =</span><br><span class="line">    MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(ctx, <span class="string">&quot;.comment&quot;</span>, SHT_PROGBITS,</span><br><span class="line">                                   SHF_MERGE | SHF_STRINGS);</span><br><span class="line"></span><br><span class="line">  std::string_view buf = <span class="built_in">save_string</span>(ctx, str);</span><br><span class="line">  <span class="function">std::string_view <span class="title">data</span><span class="params">(buf.data(), buf.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">  SectionFragment&lt;E&gt; *frag = sec-&gt;<span class="built_in">insert</span>(data, <span class="built_in">hash_string</span>(data), <span class="number">0</span>);</span><br><span class="line">  frag-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程获取对应的MergeSecgtion的instance，之后插入comment str中一个新的fragment。</p><p>接下来看一下assign_offsets的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> MergedSection&lt;E&gt;::<span class="built_in">assign_offsets</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">sizes</span><span class="params">(map.NUM_SHARDS)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">max_p2aligns</span><span class="params">(map.NUM_SHARDS)</span></span>;</span><br><span class="line">  shard_offsets.<span class="built_in">resize</span>(map.NUM_SHARDS + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  i64 shard_size = map.nbuckets / map.NUM_SHARDS;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, map.NUM_SHARDS, [&amp;](i64 i) &#123;</span><br><span class="line">    struct KeyVal &#123;</span><br><span class="line">      std::string_view key;</span><br><span class="line">      SectionFragment&lt;E&gt; *val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;KeyVal&gt; fragments;</span><br><span class="line">    fragments.<span class="built_in">reserve</span>(shard_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = shard_size * i; j &lt; shard_size * (i + <span class="number">1</span>); j++)</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; &amp;frag = map.values[j]; frag.is_alive)</span><br><span class="line">        fragments.<span class="built_in">push_back</span>(&#123;&#123;map.keys[j], map.key_sizes[j]&#125;, &amp;frag&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort fragments to make output deterministic.</span></span><br><span class="line">    tbb::<span class="built_in">parallel_sort</span>(fragments.<span class="built_in">begin</span>(), fragments.<span class="built_in">end</span>(),</span><br><span class="line">                       [](<span class="keyword">const</span> KeyVal &amp;a, <span class="keyword">const</span> KeyVal &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> std::tuple&#123;(u32)a.val-&gt;p2align, a.key.<span class="built_in">size</span>(), a.key&#125; &lt;</span><br><span class="line">             std::tuple&#123;(u32)b.val-&gt;p2align, b.key.<span class="built_in">size</span>(), b.key&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign offsets.</span></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (KeyVal &amp;kv : fragments) &#123;</span><br><span class="line">      SectionFragment&lt;E&gt; &amp;frag = *kv.val;</span><br><span class="line">      offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; frag.p2align);</span><br><span class="line">      frag.offset = offset;</span><br><span class="line">      offset += kv.key.<span class="built_in">size</span>();</span><br><span class="line">      p2align = std::max&lt;i64&gt;(p2align, frag.p2align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sizes[i] = offset;</span><br><span class="line">    max_p2aligns[i] = p2align;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Counter <span class="built_in">merged_strings</span>(<span class="string">&quot;merged_strings&quot;</span>);</span><br><span class="line">    merged_strings += fragments.<span class="built_in">size</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  i64 p2align = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 x : max_p2aligns)</span><br><span class="line">    p2align = std::<span class="built_in">max</span>(p2align, x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; map.NUM_SHARDS + <span class="number">1</span>; i++)</span><br><span class="line">    shard_offsets[i] =</span><br><span class="line">      <span class="built_in">align_to</span>(shard_offsets[i - <span class="number">1</span>] + sizes[i - <span class="number">1</span>], <span class="number">1</span> &lt;&lt; p2align);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">1</span>, map.NUM_SHARDS, [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 j = shard_size * i; j &lt; shard_size * (i + <span class="number">1</span>); j++)</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; &amp;frag = map.values[j]; frag.is_alive)</span><br><span class="line">        frag.offset += shard_offsets[i];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = shard_offsets[map.NUM_SHARDS];</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">1</span> &lt;&lt; p2align;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assign_offsets主要目的是设置对应MergedSection的section header中的sh_size和sh_addralign</p><p>这里的实现首先为了并行计算，将数据划分为了map.NUM_SHARDS个shard块。在每个并行的body中，先构建了对应的KeyVal，之后为了输出的确定性进行排序，最后计算其section fragment的p2aligns，以及将其长度设置为offset的初始值</p><p>在这之后算出一个最大的p2align用于设置MergedSection的section header的sh_addralign，以及计算出每一个shard块中fragment的shared_offset，最后将最后一个shard的offset(下标为n的元素，类似于vector的end的位置）作为整个MergedSection的size</p><h1 id="Create-Synthetic-Sections"><a href="#Create-Synthetic-Sections" class="headerlink" title="Create Synthetic Sections"></a>Create Synthetic Sections</h1><p>这里主要创建一些特殊的段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create linker-synthesized sections such as .got or .plt.</span></span><br><span class="line">  <span class="built_in">create_synthetic_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_synthetic_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> push = [&amp;]&lt;<span class="keyword">typename</span> T&gt;(T *x) &#123;</span><br><span class="line">    ctx.chunks.<span class="built_in">push_back</span>(x);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary) &#123;</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](std::string_view name) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">        <span class="keyword">if</span> (ord.type == SectionOrder::SECTION &amp;&amp; ord.name == name)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>() || <span class="built_in">find</span>(<span class="string">&quot;EHDR&quot;</span>))</span><br><span class="line">      ctx.ehdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputEhdr&lt;E&gt;(SHF_ALLOC));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ctx.ehdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputEhdr&lt;E&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>() || <span class="built_in">find</span>(<span class="string">&quot;PHDR&quot;</span>))</span><br><span class="line">      ctx.phdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputPhdr&lt;E&gt;(SHF_ALLOC));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ctx.phdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputPhdr&lt;E&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ctx.shdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputShdr&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.got = <span class="built_in">push</span>(<span class="keyword">new</span> GotSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!is_sparc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">    ctx.gotplt </span>= <span class="built_in">push</span>(<span class="keyword">new</span> GotPltSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.reldyn = <span class="built_in">push</span>(<span class="keyword">new</span> RelDynSection&lt;E&gt;);</span><br><span class="line">  ctx.relplt = <span class="built_in">push</span>(<span class="keyword">new</span> RelPltSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.pack_dyn_relocs_relr)</span><br><span class="line">    ctx.relrdyn = <span class="built_in">push</span>(<span class="keyword">new</span> RelrDynSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.strtab = <span class="built_in">push</span>(<span class="keyword">new</span> StrtabSection&lt;E&gt;);</span><br><span class="line">  ctx.plt = <span class="built_in">push</span>(<span class="keyword">new</span> PltSection&lt;E&gt;);</span><br><span class="line">  ctx.pltgot = <span class="built_in">push</span>(<span class="keyword">new</span> PltGotSection&lt;E&gt;);</span><br><span class="line">  ctx.symtab = <span class="built_in">push</span>(<span class="keyword">new</span> SymtabSection&lt;E&gt;);</span><br><span class="line">  ctx.dynsym = <span class="built_in">push</span>(<span class="keyword">new</span> DynsymSection&lt;E&gt;);</span><br><span class="line">  ctx.dynstr = <span class="built_in">push</span>(<span class="keyword">new</span> DynstrSection&lt;E&gt;);</span><br><span class="line">  ctx.eh_frame = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameSection&lt;E&gt;);</span><br><span class="line">  ctx.copyrel = <span class="built_in">push</span>(<span class="keyword">new</span> CopyrelSection&lt;E&gt;(<span class="literal">false</span>));</span><br><span class="line">  ctx.copyrel_relro = <span class="built_in">push</span>(<span class="keyword">new</span> CopyrelSection&lt;E&gt;(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary)</span><br><span class="line">    ctx.shstrtab = <span class="built_in">push</span>(<span class="keyword">new</span> ShstrtabSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.dynamic_linker.<span class="built_in">empty</span>())</span><br><span class="line">    ctx.interp = <span class="built_in">push</span>(<span class="keyword">new</span> InterpSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.build_id.kind != BuildId::NONE)</span><br><span class="line">    ctx.buildid = <span class="built_in">push</span>(<span class="keyword">new</span> BuildIdSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.eh_frame_hdr)</span><br><span class="line">    ctx.eh_frame_hdr = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameHdrSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.gdb_index)</span><br><span class="line">    ctx.gdb_index = <span class="built_in">push</span>(<span class="keyword">new</span> GdbIndexSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_relro &amp;&amp; ctx.arg.section_order.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">      ctx.arg.z_separate_code != SEPARATE_LOADABLE_SEGMENTS)</span><br><span class="line">    ctx.relro_padding = <span class="built_in">push</span>(<span class="keyword">new</span> RelroPaddingSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.hash_style_sysv)</span><br><span class="line">    ctx.hash = <span class="built_in">push</span>(<span class="keyword">new</span> HashSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.hash_style_gnu)</span><br><span class="line">    ctx.gnu_hash = <span class="built_in">push</span>(<span class="keyword">new</span> GnuHashSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.version_definitions.<span class="built_in">empty</span>())</span><br><span class="line">    ctx.verdef = <span class="built_in">push</span>(<span class="keyword">new</span> VerdefSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.emit_relocs)</span><br><span class="line">    ctx.eh_frame_reloc = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameRelocSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.shared || !ctx.dsos.<span class="built_in">empty</span>() || ctx.arg.pie)</span><br><span class="line">    ctx.dynamic = <span class="built_in">push</span>(<span class="keyword">new</span> DynamicSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.versym = <span class="built_in">push</span>(<span class="keyword">new</span> VersymSection&lt;E&gt;);</span><br><span class="line">  ctx.verneed = <span class="built_in">push</span>(<span class="keyword">new</span> VerneedSection&lt;E&gt;);</span><br><span class="line">  ctx.note_package = <span class="built_in">push</span>(<span class="keyword">new</span> NotePackageSection&lt;E&gt;);</span><br><span class="line">  ctx.note_property = <span class="built_in">push</span>(<span class="keyword">new</span> NotePropertySection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.is_static) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_s390x&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">      ctx.s390x_tls_get_offset </span>= <span class="built_in">push</span>(<span class="keyword">new</span> S390XTlsGetOffsetSection);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_sparc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">      ctx.sparc_tls_get_addr </span>= <span class="built_in">push</span>(<span class="keyword">new</span> SparcTlsGetAddrSection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">    ctx.ppc64_opd </span>= <span class="built_in">push</span>(<span class="keyword">new</span> PPC64OpdSection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If .dynamic exists, .dynsym and .dynstr must exist as well</span></span><br><span class="line">  <span class="comment">// since .dynamic refers them.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.dynamic) &#123;</span><br><span class="line">    ctx.dynstr-&gt;<span class="built_in">keep</span>();</span><br><span class="line">    ctx.dynsym-&gt;<span class="built_in">keep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.tls_get_addr = <span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__tls_get_addr&quot;</span>);</span><br><span class="line">  ctx.tls_get_offset = <span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__tls_get_offset&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里其实已经开始创建输出的内容了，因为是直接push到chunk中。在mold中chunk则是表示用于输出的一片区域，关于Chunk类源码中有这样的注释</p><blockquote><p>Chunk represents a contiguous region in an output file.</p></blockquote><p>首先是oformat_binary选项控制的EHDR和PHDR。</p><p>EHDR和PHDR分别是ELF Header和Program Header</p><p>EHDR和PHDR在不指定section_order或者指定的情况下存在对应的section则作为一个ALLOC的chunk加入到chunks中。</p><p>之后是添加了一些常见的段，以及各种参数控制的段，不再一一赘述。</p><p>最后提一下如果dynamic section存在的话，那么保留dynstr和dynsym段，也就是设置其size为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keep</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="Check-Duplicate-Symbol"><a href="#Check-Duplicate-Symbol" class="headerlink" title="Check Duplicate Symbol"></a>Check Duplicate Symbol</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make sure that there&#x27;s no duplicate symbol</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.allow_multiple_definition)</span><br><span class="line">  <span class="built_in">check_duplicate_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_duplicate_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;check_duplicate_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip if our symbol is undef or weak</span></span><br><span class="line">      <span class="keyword">if</span> (sym.file == file || sym.file == ctx.internal_obj ||</span><br><span class="line">          esym.<span class="built_in">is_undef</span>() || esym.<span class="built_in">is_common</span>() || (esym.st_bind == STB_WEAK))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip if our symbol is in a dead section. In most cases, the</span></span><br><span class="line">      <span class="comment">// section has been eliminated due to comdat deduplication.</span></span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>()) &#123;</span><br><span class="line">        InputSection&lt;E&gt; *isec = file-&gt;<span class="built_in">get_section</span>(esym);</span><br><span class="line">        <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;duplicate symbol: &quot;</span> &lt;&lt; *file &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有的obj进行检查，遍历所有的global symbol。</p><p>首先通过sym.file ==file 检查符号owner是否为当前文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol is owned by a file. If two or more files define the</span></span><br><span class="line"><span class="comment">// same symbol, the one with the strongest definition owns the symbol.</span></span><br><span class="line"><span class="comment">// If `file` is null, the symbol is equivalent to nonexistent.</span></span><br><span class="line">InputFile&lt;E&gt; *file = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>以及如果是internal_obj中的符号，也进行跳过。剩下的就是可能有冲突的情况，但undef、weak、common的符号冲突不会造成影响，只有重复定义会导致冲突，因此这些情况也进行跳过。</p><p>最后跳过在dead section的符号，未满足前面条件的符号则是重复符号</p><h1 id="Check-Symbol-Types"><a href="#Check-Symbol-Types" class="headerlink" title="Check Symbol Types"></a>Check Symbol Types</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warn if symbols with different types are defined under the same name.</span></span><br><span class="line">  <span class="built_in">check_symbol_types</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_symbol_types</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;check_symbol_types&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> normalize_type = [](u32 type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == STT_GNU_IFUNC)</span><br><span class="line">      <span class="keyword">return</span> STT_FUNC;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sym.file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      u32 their_type = <span class="built_in">normalize_type</span>(sym.<span class="built_in">esym</span>().st_type);</span><br><span class="line">      u32 our_type = <span class="built_in">normalize_type</span>(esym.st_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (their_type != STT_NOTYPE &amp;&amp; our_type != STT_NOTYPE &amp;&amp;</span><br><span class="line">          their_type != our_type)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; <span class="string">&quot;symbol type mismatch: &quot;</span> &lt;&lt; sym &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; defined in &quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot; as &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">stt_to_string</span>(sym.<span class="built_in">esym</span>().st_type) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; defined in &quot;</span> &lt;&lt; *file &lt;&lt; <span class="string">&quot; as &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">stt_to_string</span>(esym.st_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, check);</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, check);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里针对的是所有的obj和dso里的所有global_symbol进行检查。检查实际的Symbol和ElfSym中的type是否一致，但这里只是warning，而不像之前重复符号的检查一样直接报错。检查的方式是首先对两者的type进行normalize的操作，之后进行比较，都不为空NOTYPE的情况下判断相等性。我觉得这里更像是一种针对resolve的结果检查，因为一个esym是不会被修改的，只有Symbol引用的esym对象会发生改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-7-before-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读六 section size优化</title>
    <link href="https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/"/>
    <id>https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/</id>
    <published>2023-05-07T15:59:24.000Z</published>
    <updated>2023-05-07T16:16:54.092Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-6-section-size-reduce/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341 p2</center> <p>上一期我们讲解了一些符号相关的处理，这一期我们来讲一些对于section size的优化处理。</p><h1 id="mark-addrsig"><a href="#mark-addrsig" class="headerlink" title="mark_addrsig"></a>mark_addrsig</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read address-significant section information.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf &amp;&amp; !ctx.arg.icf_all)</span><br><span class="line">  <span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_addrsig</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_addrsig&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的命令行参数</p><blockquote><p>-icf=[all,safe,none] Fold identical code<br>–no-icf</p></blockquote><p>针对所有的obj处理，因为dso的地址相关信息是在运行时加载进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">mark_addrsig</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Parse a .llvm_addrsig section.</span></span><br><span class="line">  <span class="keyword">if</span> (llvm_addrsig) &#123;</span><br><span class="line">    u8 *cur = (u8 *)llvm_addrsig-&gt;contents.<span class="built_in">data</span>();</span><br><span class="line">    u8 *end = cur + llvm_addrsig-&gt;contents.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[<span class="built_in">read_uleb</span>(cur)];</span><br><span class="line">      <span class="keyword">if</span> (sym.file == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We treat a symbol&#x27;s address as significant if</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 1. we have no address significance information for the symbol, or</span></span><br><span class="line">  <span class="comment">// 2. the symbol can be referenced from the outside in an address-</span></span><br><span class="line">  <span class="comment">//    significant manner.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="keyword">this</span>-&gt;symbols)</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>())</span><br><span class="line">        <span class="keyword">if</span> (!llvm_addrsig || sym-&gt;is_exported)</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于llvm_addrsig，处理的是一个范围的Symbol，将这个范围的Symbol的address_significant设置为True</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ObjectFile&lt;E&gt;::initialize_sections</span></span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; llvm_addrsig;</span><br><span class="line"><span class="comment">// Save .llvm_addrsig for --icf=safe.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_type == SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">  llvm_addrsig = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的symbol address，针对非llvm_addrsig或者exported的symbol将address_significant为True</p><p>那么address_significant是什么呢</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table" >https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>the address of the symbol is used in a comparison or leaks outside the translation unit</p></blockquote><p>简单来说就是这个地址会被用于比较或者用于翻译单元之外，这个变量的具体含义到后面使用的时候会结合场景进一步讲述。</p><h1 id="gc-sections"><a href="#gc-sections" class="headerlink" title="gc_sections"></a>gc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Garbage-collect unreachable sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.gc_sections)</span><br><span class="line">  <span class="built_in">gc_sections</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_nonalloc_fragments</span>(ctx);</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; rootset;</span><br><span class="line">  <span class="built_in">collect_root_set</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">mark</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">sweep</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gc_sections主要是对section像GC一样进行mark and sweep，清理掉未被使用的段，关于gc_sections的选项</p><blockquote><p>–gc-sections               Remove unreferenced sections</p></blockquote><h2 id="mark-nonalloc-fragments"><a href="#mark-nonalloc-fragments" class="headerlink" title="mark_nonalloc_fragments"></a>mark_nonalloc_fragments</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-alloc section fragments are not subject of garbage collection.</span></span><br><span class="line"><span class="comment">// This function marks such fragments.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_nonalloc_fragments</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_nonalloc_fragments&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : file-&gt;mergeable_sections)</span><br><span class="line">      <span class="keyword">if</span> (m)</span><br><span class="line">        <span class="keyword">for</span> (SectionFragment&lt;E&gt; *frag : m-&gt;fragments)</span><br><span class="line">          <span class="keyword">if</span> (!(frag-&gt;output_section.shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">            frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Non-alloc的fragment不是垃圾回收的对象，因此这里只是标记，避免后续被sweep</p><h2 id="collect-root-set"><a href="#collect-root-set" class="headerlink" title="collect_root_set"></a>collect_root_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect_root_set</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                             tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;collect_root_set&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_section = [&amp;](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mark_section</span>(isec))</span><br><span class="line">      rootset.<span class="built_in">push_back</span>(isec);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_symbol = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym-&gt;<span class="built_in">get_frag</span>())</span><br><span class="line">        frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">enqueue_section</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections that are not subject to garbage collection.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -gc-sections discards only SHF_ALLOC sections. If you want to</span></span><br><span class="line">      <span class="comment">// reduce the amount of non-memory-mapped segments, you should</span></span><br><span class="line">      <span class="comment">// use `strip` command, compile without debug info or use</span></span><br><span class="line">      <span class="comment">// -strip-all linker option.</span></span><br><span class="line">      u32 flags = isec-&gt;<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; SHF_ALLOC))</span><br><span class="line">        isec-&gt;is_visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">should_keep</span>(*isec))</span><br><span class="line">        <span class="built_in">enqueue_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections containing exported symbols</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols)</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file == file &amp;&amp; sym-&gt;is_exported)</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(sym);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections referenced by root symbols.</span></span><br><span class="line">  <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, ctx.arg.entry));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .eh_frame consists of variable-length records called CIE and FDE</span></span><br><span class="line">  <span class="comment">// records, and they are a unit of inclusion or exclusion.</span></span><br><span class="line">  <span class="comment">// We just keep all CIEs and everything that are referenced by them.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : cie.<span class="built_in">get_rels</span>())</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(file-&gt;symbols[rel.r_sym]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是进行收集root，以便之后进行mark and sweep。</p><p>主要收集的方向有两个</p><ol><li><p>对section直接添加，这里主要是针对一些不受垃圾回收影响的段。具体条件参考should_keep的实现。</p></li><li><p>针对符号进行处理，如果是在fragment中则会设置其为alive，因为fragment并非扫描的root。如果是在普通的段中则将符号引用的section添加到root中。</p><p>而符号的来源分为这么几种</p><ol><li>is_exported</li><li>undefined</li><li>require_defined</li><li>cie中的rel符号</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">should_keep</span><span class="params">(<span class="keyword">const</span> InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  u32 type = isec.<span class="built_in">shdr</span>().sh_type;</span><br><span class="line">  u32 flags = isec.<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (flags &amp; SHF_GNU_RETAIN) ||</span><br><span class="line">         type == SHT_NOTE ||</span><br><span class="line">         type == SHT_INIT_ARRAY ||</span><br><span class="line">         type == SHT_FINI_ARRAY ||</span><br><span class="line">         type == SHT_PREINIT_ARRAY ||</span><br><span class="line">         (std::is_same_v&lt;E, ARM32&gt; &amp;&amp; type == SHT_ARM_EXIDX) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ctors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.dtors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.init&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.fini&quot;</span>) ||</span><br><span class="line">         <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all reachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                 tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(rootset, [&amp;](InputSection&lt;E&gt; *isec,</span><br><span class="line">                                    tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(ctx, isec, feeder, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec,</span></span></span><br><span class="line"><span class="params"><span class="function">                  tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder, i64 depth)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;is_visited);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a text section, .eh_frame may contain records</span></span><br><span class="line">  <span class="comment">// describing how to handle exceptions for that function.</span></span><br><span class="line">  <span class="comment">// We want to keep associated .eh_frame records.</span></span><br><span class="line">  <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : isec-&gt;<span class="built_in">get_fdes</span>())</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : fde.<span class="built_in">get_rels</span>(isec-&gt;file).<span class="built_in">subspan</span>(<span class="number">1</span>))</span><br><span class="line">      <span class="keyword">if</span> (Symbol&lt;E&gt; *sym = isec-&gt;file.symbols[rel.r_sym])</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mark_section</span>(sym-&gt;<span class="built_in">get_input_section</span>()))</span><br><span class="line">          feeder.<span class="built_in">add</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec-&gt;file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol can refer either a section fragment or an input section.</span></span><br><span class="line">    <span class="comment">// Mark a fragment as alive.</span></span><br><span class="line">    <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">      frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mark_section</span>(sym.<span class="built_in">get_input_section</span>()))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark a section alive. For better performacne, we don&#x27;t call</span></span><br><span class="line">    <span class="comment">// `feeder.add` too often.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">visit</span>(ctx, sym.<span class="built_in">get_input_section</span>(), feeder, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      feeder.<span class="built_in">add</span>(sym.<span class="built_in">get_input_section</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从rootset出发</p><ol><li>针对fde record中的rel符号所在的section进行标记，并且添加到feeder中（本质是加到了rootset中，后续会继续从这些节点开始遍历）</li><li>针对rel段中的符号进行遍历，如果是fragment则设置其alive，之后对sym的input section进行标记，标记成功的话则继续递归执行。</li></ol><h2 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove unreachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sweep</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;garbage_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; !isec-&gt;is_visited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.print_gc_sections)</span><br><span class="line">          <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;removing unused section &quot;</span> &lt;&lt; *isec;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ehframe那一期提到会清理未用到的record，而在这里实际执行了fde的清理工作。</p><h1 id="icf-sections"><a href="#icf-sections" class="headerlink" title="icf_sections"></a>icf_sections</h1><p>这段内容比较长，建议单独查看源码对应位置进行对照，相关实现在elf/icf.cc中</p><p>icf的全拼推测是identical code folding</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge identical read-only sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf)</span><br><span class="line"><span class="built_in">icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icf_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;icf&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">uniquify_cies</span>(ctx);</span><br><span class="line">  <span class="built_in">merge_leaf_nodes</span>(ctx);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniquify-cies"><a href="#uniquify-cies" class="headerlink" title="uniquify_cies"></a>uniquify_cies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uniquify_cies</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;uniquify_cies&quot;</span>)</span></span>;</span><br><span class="line">  std::vector&lt;CieRecord&lt;E&gt; *&gt; cies;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; cies.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cie.<span class="built_in">equals</span>(*cies[i])) &#123;</span><br><span class="line">          cie.icf_idx = i;</span><br><span class="line">          <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cie.icf_idx = cies.<span class="built_in">size</span>();</span><br><span class="line">      cies.<span class="built_in">push_back</span>(&amp;cie);</span><br><span class="line">    found:;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中的所有cie，如果cie和cies中的任何一个相同，也就是出现了重复，则继续查看下一个cie是否重复，没有重复则将cie加进去。</p><p>这里我不太明白，为什么不保存一个CieRecord的Set，避免了再写一个循环的麻烦？如果有读者能解答我的疑惑欢迎邮件联系我。</p><h2 id="merge-leaf-nodes"><a href="#merge-leaf-nodes" class="headerlink" title="merge_leaf_nodes"></a>merge_leaf_nodes</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Early merge of leaf nodes, which can be processed without constructing the</span></span><br><span class="line"><span class="comment">// entire graph. This reduces the vertex count and improves memory efficiency.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_leaf_nodes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;merge_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eligible</span><span class="params">(<span class="string">&quot;icf_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">non_eligible</span><span class="params">(<span class="string">&quot;icf_non_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">leaf</span><span class="params">(<span class="string">&quot;icf_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_unordered_map&lt;InputSection&lt;E&gt; *, InputSection&lt;E&gt; *,</span><br><span class="line">                                LeafHasher&lt;E&gt;, LeafEq&lt;E&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_eligible</span>(ctx, *isec)) &#123;</span><br><span class="line">        non_eligible++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_leaf</span>(ctx, *isec)) &#123;</span><br><span class="line">        leaf++;</span><br><span class="line">        isec-&gt;icf_leaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> [it, inserted] = map.<span class="built_in">insert</span>(&#123;isec.<span class="built_in">get</span>(), isec.<span class="built_in">get</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">          it-&gt;second = isec.<span class="built_in">get</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eligible++;</span><br><span class="line">        isec-&gt;icf_eligible = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_leaf) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">        <span class="built_in">assert</span>(it != map.<span class="built_in">end</span>());</span><br><span class="line">        isec-&gt;leader = it-&gt;second;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中eligible的sections来处理。</p><p>是leaf则设置leaf并且插入到map中，但是如果insert失败，且priority更高，那么就更新对应的section</p><p>非leaf的情况下只设置eligible，留到后面进行处理。</p><p>之后针对所有obj的sections，如果是icf_leaf，那么更新其leader为map中对应的值</p><h3 id="关于其中出现的InputSection的字段"><a href="#关于其中出现的InputSection的字段" class="headerlink" title="关于其中出现的InputSection的字段"></a>关于其中出现的InputSection的字段</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in InputSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For ICF</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `leader` is the section that this section has been merged with.</span></span><br><span class="line"><span class="comment">// Three kind of values are possible:</span></span><br><span class="line"><span class="comment">// - `leader == nullptr`: This section was not eligible for ICF.</span></span><br><span class="line"><span class="comment">// - `leader == this`: This section was retained.</span></span><br><span class="line"><span class="comment">// - `leader != this`: This section was merged with another identical section.</span></span><br><span class="line">InputSection&lt;E&gt; *leader = <span class="literal">nullptr</span>;</span><br><span class="line">u32 icf_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_eligible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_leaf = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>简单来说这个leader实际上是用于指向当前section的一个唯一实现。</p><p>如果leader存在且为自己，那么对应内容的段只访问过一次，如果不为自己的话，那么代表这不是第一次访问对应内容的段了。</p><p>用实际实现结合注释来说明leader这个字段。</p><ol><li>==nullptr：这种情况表明这个section是not eligible的，也就是说会在上面的循环被忽略掉</li><li>==this：这种情况表明这个section是对应内容的段第一次出现，在后面更新leader的过程中是找到的section和自身相同。</li><li>≠this：这种情况表明后面更新leader的查找过程中，找到的section其实是其对应内容在前面第一次出现的段，也就是指向了对应的leader</li></ol><p>举个例子，假设有s1, s2, s3三个section，s1是not eligible的，s2和s3是相同的，按照s1-s3的顺序进行扫描</p><p>s1 = nullptr</p><p>s2 = s2 # leader</p><p>s3 = s2</p><h3 id="is-eligible"><a href="#is-eligible" class="headerlink" title="is_eligible"></a>is_eligible</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_eligible</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = isec.<span class="built_in">shdr</span>();</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_alloc = (shdr.sh_flags &amp; SHF_ALLOC);</span><br><span class="line">  <span class="keyword">bool</span> is_exec = (shdr.sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">                 ctx.arg.ignore_data_address_equality;</span><br><span class="line">  <span class="keyword">bool</span> is_relro = (name == <span class="string">&quot;.data.rel.ro&quot;</span> ||</span><br><span class="line">                   name.<span class="built_in">starts_with</span>(<span class="string">&quot;.data.rel.ro.&quot;</span>));</span><br><span class="line">  <span class="keyword">bool</span> is_readonly = !(shdr.sh_flags &amp; SHF_WRITE) || is_relro;</span><br><span class="line">  <span class="keyword">bool</span> is_bss = (shdr.sh_type == SHT_NOBITS);</span><br><span class="line">  <span class="keyword">bool</span> is_empty = (shdr.sh_size == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_init = (shdr.sh_type == SHT_INIT_ARRAY || name == <span class="string">&quot;.init&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_fini = (shdr.sh_type == SHT_FINI_ARRAY || name == <span class="string">&quot;.fini&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_enumerable = <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">  <span class="keyword">bool</span> is_addr_taken = !ctx.arg.icf_all &amp;&amp; isec.address_significant;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_alloc &amp;&amp; is_exec &amp;&amp; is_readonly &amp;&amp; !is_bss &amp;&amp; !is_empty &amp;&amp;</span><br><span class="line">         !is_init &amp;&amp; !is_fini &amp;&amp; !is_enumerable &amp;&amp; !is_addr_taken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不满足这些情况的话无法被fold，具体条件以及判断方式无需再多讲解，纯粹是对应的规则。</p><p>注意这里出现了上面说的address_significant，需要为false才能满足，也就是说需要用地址比较的情况是无法被fold的。</p><h2 id="gather-sections"><a href="#gather-sections" class="headerlink" title="gather_sections"></a>gather_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare for the propagation rounds.</span></span><br><span class="line">std::vector&lt;InputSection&lt;E&gt; *&gt; sections = <span class="built_in">gather_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">gather_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gather_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count the number of input sections for each input file.</span></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">num_sections</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        num_sections[i]++;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">section_indices</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    section_indices[i + <span class="number">1</span>] = section_indices[i] + num_sections[i];</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">sections</span>(</span><br><span class="line">    section_indices.<span class="built_in">back</span>() + num_sections.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill `sections` contents.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    i64 idx = section_indices[i];</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        sections[idx++] = isec.<span class="built_in">get</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    sections[i]-&gt;icf_idx = i;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了三个vector，先来理清对应的作用</p><ol><li>num_sections：每个obj中icf_eligible的input sections数量</li><li>section_indices：由前一个section_indices和num_sections的值决定，其实是用于标记每个位置的objs的input section的起始在最终的sections中的坐标</li><li>sections：初始化的容量是其实是section_indices[ctx.objs.size()]的值</li></ol><p>这样说可能比较抽象，举个例子</p><p>num_sections: 2, 3, 4, 5</p><p>section_indices: 0, 2+0, 3+2+0, 4+3+2+0</p><p>5+4+3+2+0</p><p>算出来的其实是所有obj中icf_eligible的input sections的数量</p><p>之后是fill content的部分，并行的获取每个obj中的所有icf_eligible的input section的指针</p><h2 id="Digest"><a href="#Digest" class="headerlink" title="Digest"></a>Digest</h2><p>接下来的部分都是在计算digest，具体算法有兴趣的可以去实现中自行查看细节。</p><p>什么是digest，这个链接中的一个回答说的比较明白了，我选取了关键内容放出来</p><p><a class="link"   href="https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function" >https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>The digest is the output of the hash function.<br>For example, sha256 has a digest of 256 bits, i.e. its digest has a length of 32 bytes.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="keyword">uint8_t</span>, HASH_SIZE&gt; Digest;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// We allocate 3 arrays to store hashes for each vertex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 0 and 1 are used for tree hashes from the previous</span></span><br><span class="line"><span class="comment">// iteration and the current iteration. They switch roles every</span></span><br><span class="line"><span class="comment">// iteration. See `slot` below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 2 stores the initial, single-vertex hash. This is combined</span></span><br><span class="line"><span class="comment">// with hashes from the connected vertices to form the tree hash</span></span><br><span class="line"><span class="comment">// described above.</span></span><br><span class="line">std::vector&lt;std::vector&lt;Digest&gt;&gt; <span class="built_in">digests</span>(<span class="number">3</span>);</span><br><span class="line">digests[<span class="number">0</span>] = compute_digests&lt;E&gt;(ctx, sections);</span><br><span class="line">digests[<span class="number">1</span>].<span class="built_in">resize</span>(digests[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">digests[<span class="number">2</span>] = digests[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">std::vector&lt;u32&gt; edges;</span><br><span class="line">std::vector&lt;u32&gt; edge_indices;</span><br><span class="line">gather_edges&lt;E&gt;(ctx, sections, edges, edge_indices);</span><br><span class="line"></span><br><span class="line"><span class="function">BitVector <span class="title">converged</span><span class="params">(digests[<span class="number">0</span>].size())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> slot = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the propagation rounds until convergence is obtained.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;propagate&quot;</span>)</span></span>;</span><br><span class="line">  tbb::affinity_partitioner ap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A cheap test that the graph hasn&#x27;t converged yet.</span></span><br><span class="line">  <span class="comment">// The loop after this one uses a strict condition, but it&#x27;s expensive</span></span><br><span class="line">  <span class="comment">// as it requires sorting the entire hash collection.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For nodes that have a cycle in downstream (i.e. recursive</span></span><br><span class="line">  <span class="comment">// functions and functions that calls recursive functions) will always</span></span><br><span class="line">  <span class="comment">// change with the iterations. Nodes that doesn&#x27;t (i.e. non-recursive</span></span><br><span class="line">  <span class="comment">// functions) will stop changing as soon as the propagation depth reaches</span></span><br><span class="line">  <span class="comment">// the call tree depth.</span></span><br><span class="line">  <span class="comment">// Here, we test whether we have reached sufficient depth for the latter,</span></span><br><span class="line">  <span class="comment">// which is a necessary (but not sufficient) condition for convergence.</span></span><br><span class="line">  i64 num_changed = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    i64 n = propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_changed)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_changed = n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Run the pass until the unique number of hashes stop increasing, at which</span></span><br><span class="line">  <span class="comment">// point we have achieved convergence (proof omitted for brevity).</span></span><br><span class="line">  i64 num_classes = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// count_num_classes requires sorting which is O(n log n), so do a little</span></span><br><span class="line">    <span class="comment">// more work beforehand to amortize that log factor.</span></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line"></span><br><span class="line">    i64 n = count_num_classes&lt;E&gt;(digests[slot], ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_classes)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_classes = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-sections"><a href="#group-sections" class="headerlink" title="group sections"></a>group sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group sections by SHA digest.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;group&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *map = <span class="keyword">new</span> tbb::concurrent_unordered_map&lt;Digest, InputSection&lt;E&gt; *&gt;;</span><br><span class="line">  std::span&lt;Digest&gt; digest = digests[slot];</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    InputSection&lt;E&gt; *isec = sections[i];</span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = map-&gt;<span class="built_in">insert</span>(&#123;digest[i], isec&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">      it-&gt;second = isec;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = map-&gt;<span class="built_in">find</span>(digest[i]);</span><br><span class="line">    <span class="built_in">assert</span>(it != map-&gt;<span class="built_in">end</span>());</span><br><span class="line">    sections[i]-&gt;leader = it-&gt;second;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since free&#x27;ing the map is slow, postpone it.</span></span><br><span class="line">  ctx.on_exit.<span class="built_in">push_back</span>([=] &#123; <span class="keyword">delete</span> map; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.print_icf_sections)</span><br><span class="line">  <span class="built_in">print_icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里我们暂时忽略digest是怎么来的细节，直接看这里使用的过程。将digest关联一个input section，这里的逻辑很像merge_leaf_nodes，只是key换成了Digest，本质更换了一种hash方式，另外不再是只针对leaf的了</p><h2 id="sweep-sections"><a href="#sweep-sections" class="headerlink" title="sweep sections"></a>sweep sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eliminate duplicate sections.</span></span><br><span class="line"><span class="comment">// Symbols pointing to eliminated sections will be redirected on the fly when</span></span><br><span class="line"><span class="comment">// exporting to the symtab.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eliminated</span><span class="params">(<span class="string">&quot;icf_eliminated&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;<span class="built_in">is_killed_by_icf</span>()) &#123;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        eliminated++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> InputSection&lt;E&gt;::<span class="built_in">is_killed_by_icf</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;leader &amp;&amp; <span class="keyword">this</span>-&gt;leader != <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后消除掉重复的section。判断重复的依据是leader不等于自身。</p><h2 id="icf-sections-总结"><a href="#icf-sections-总结" class="headerlink" title="icf_sections 总结"></a>icf_sections 总结</h2><ol><li>CieRecord去重</li><li>merge leaf node</li><li>取出所有需要处理的section</li><li>计算digest</li><li>根据digest处理所有需要处理的section</li><li>消除重复的section</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-6-section</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>”荒原狼训练者的奇迹“</title>
    <link href="https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/"/>
    <id>https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/</id>
    <published>2023-05-04T09:27:54.000Z</published>
    <updated>2023-05-04T09:42:17.441Z</updated>
    
    <content type="html"><![CDATA[<p>当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒原狼双重人格的痛苦，而这一切碎片，又唤醒了我疯狂的那一面。</p><p>哈里的个性使得他成为了一个非市民般的存在，但为了生存，依然住在市民所在的城市，银行里有着一定的财产，这些都约束住了他。而在市民之中，他那强烈的个性使得他与这个社会格格不入，无法被理解，亦无法被接受。</p><p>他既超脱于人，却又受限于人，对于他来说内心中人和狼的关系似乎也是如此矛盾，与他的身份不同，人和狼必须要有一方战胜另一方并且存在，为此他的内心中几乎每天都在上演一场人狼大战。但这场战争不可能有他想要的结果，除非他选择自我了断，使得这场战争成立的条件本身不复存在。</p><p>但他过去却一直未能注意到，即便不这样做，这场战争仍可以不复存在，而且本身其实是无意义的。因为人和狼的战争并非是为了争夺什么领土，它们本来是在这里和平相处，但受到了作为主观意识的哈里影响，所以他们认为必须要战胜对方，统一这个世界。除此之外哈里还未注意到的一个真相是这里除了人和狼之外，这里还有非常多种类的存在。</p><p>直到另一个“自己”，赫尔米娜的出现，这一切才开始发生改变。身为另一个哈里，她十分理解哈里所想，同时哈里带入崭新的世界，将他所忽视的、遗漏的东西再度展现在他的面前，哈里也因此开始看到自己内心中更多的角色。</p><p>这一切最终都在魔剧院中由哈里亲眼见证。当哈里暂时杀死了荒原狼的存在，哈里内心中的其他存在不再受到其抑制，因此它们全部从镜子中跳了出来，而哈里跟着内心中的无数个“我“前往了它们各自所在的区域，看到这些被遗忘、忽略了的自己。直到最后，哈里如另一个“自己”所想，亲手处决了另一个“自己”，并且迎来了自我的绞刑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="黑塞" scheme="https://fusionbolt.github.io/tags/%E9%BB%91%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>局外人</title>
    <link href="https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/"/>
    <id>https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/</id>
    <published>2023-05-03T09:03:59.000Z</published>
    <updated>2023-05-03T09:09:16.591Z</updated>
    
    <content type="html"><![CDATA[<p>对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种态度来传达给我们什么呢？是想表达出他所认为的人生无意义吗？</p><p>在序言中讲到局外人的直接含义是默尔索在审判过程被隔离在外，整个审判过程自己参与了但是又没有参与。想到了故事中律师说到了这样一句话：“这就是这场审讯的形象，所有一切都是真的，但又没有任何东西是真的！”网上一个评价的重点则是提到是因为对母亲的死无动于衷被判了死刑，这点过于荒谬。</p><p>在第一部分中出现了许多的角色，都有一些非常看似矛盾的行为：沙拉玛诺老头每天都在骂狗，但实际丢了又是那么牵挂。雷蒙虽然说这跟人打架自己没去惹对方，是对方来冒犯自己，但他却供养着对方的老婆，作者这里还添加了一句“我没有答言。”</p><blockquote><p>他对我说，他一直供养着这个女人。我没有答言。接着他又说，他知道附近一带关于他的流言飞语，但他问心无愧，他确实是一个仓库保管员。</p></blockquote><p>这个样子甚至还能问心无愧，我觉得实属荒谬。还有第二部中最后出现的神父，他不顾主角的心情和想法，只是想要将自己的想法强加，这可以说是他自大，但是最让人感到惊讶与荒谬的是他居然也是囚犯，身为神父还做出犯罪之举。</p><p>我感觉到默尔索与现实世界的分离，联想到文章后面的内容并且结合加缪的思想来看，也许是因为他觉得现实世界是无理的且不可掌控的。</p><blockquote><p>他的神气不是那么确信有把握吗？但他的确信不值女人的一根头发，他甚至连自己是否活着都没有把握，因为他干脆就像行尸走肉。而我，我好像是两手空空，一无所有，但我对自己很有把握，对我所有的一切都有把握，比他有把握得多，对我的生命，对我即将来到的死亡，都有把握。是的，我只有这份把握，但至少我掌握了这个真理，正如这个真理抓住了我一样。我以前有理，现在有理，将来永远有理。</p></blockquote><p>后面他对即将到来的死亡是有把握的，这种分离在后面也有谈及</p><blockquote><p>正当我的律师在继续发言时，一个卖冰的小贩吹响了喇叭，声音从街上穿过一个个大厅与法庭，传到了我耳边，对过去生活的种种回忆突然涌入我的脑海，那生活已经不属于我了。</p></blockquote><p>回到书名与故事中。局外人这个名字所象征的事情，在故事中的主角身上充分表现了出来。主角在许多发生的事情上像局外人一样存在，而他在这个世界像一个局外人一样存在。两章的内容中，第一章中默尔索那漠不关心的态度，像是在说默尔索自己主动选择作为一切的局外人，而第二章中则是处于审判中，虽然参与其中，但是整个过程并没有任何说话与行动的权利。</p><blockquote><p>我呢，我认为这仍然是把我这个人排斥出审判过程，把我化成一个零，又以某种方式，由他取代了我。</p></blockquote><p>我想加缪正是想要通过这样一则有些不讲理的故事来表达出他对这个世界的看法，他所认为的荒谬，在序言中译者也提到了</p><blockquote><p>人类对理性、和谐、永恒的渴求与向往和自然社会生存有限性之间的“断裂”，人类的奋斗作为与徒劳无功这一后果之间的断裂。</p></blockquote><p>这样一则不讲理的故事，正是这种看法的体现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="加缪" scheme="https://fusionbolt.github.io/tags/%E5%8A%A0%E7%BC%AA/"/>
    
  </entry>
  
  <entry>
    <title>艾尔登法环</title>
    <link href="https://fusionbolt.github.io/2023/05/03/elden-ring/"/>
    <id>https://fusionbolt.github.io/2023/05/03/elden-ring/</id>
    <published>2023-05-03T09:01:53.000Z</published>
    <updated>2023-05-03T09:02:43.804Z</updated>
    
    <content type="html"><![CDATA[<p>二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。</p><p>首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能找到一个传送点，再加上玛丽卡楔石的帮助，几乎不需要花费太多的时间在打boss的路上。</p><p>招魂机制可以通过骨灰召唤角色出来吸引仇恨，你可以安心输出，当然魂系列其他作品也是有召唤npc的机制存在，但是都远不如这作骨灰的强大，后期召唤大哥甚至可以单挑许多boss，玩家被称为摇铃仆人。其次由于开放世界的设计，你可以绕过绝大多数boss，同时可以提前跑到中后期的地区捡垃圾，把自己的装备和等级提升一下再回来砍boss。</p><p>不过说到这里就要提到宫崎英高的恶意了，开局的大树守卫估计是很多人的阴影，可能很多人也没想到可以直接绕过，不过我想这里的设计是为了让玩家理解后面遇到的许多boss是可以直接跑的。另外有的玩家会选择直接到史东威尔去打恶兆，恶兆对于低级入门玩家还是不太友好，我觉得这里也有让你再去其他区域多探索的一个想法，只是这些设计都比较隐晦。</p><p>不熟悉的玩家个人开荒还是有些费劲的，我一开始也吃了很多瘪，后来“学习”了一下装备选择以及跑路捡强化石，以及去龙墓升级，也慢慢开始舒服多了。从数值方面降低了受苦的要素，之后作为一个探索类游戏真的非常棒，地图是真的大，而且景色非常棒。尤其是当你一开始走出了漆黑的新手洞窟后，当你通过升降梯到达了王城后，看到的那美丽的景色。</p><p>整体来说还是有许多有特色的boss。恶兆王给我的印象是比较深刻的，除了早期受苦的原因，另外独特的配音，在整个故事中其所在的位置，整个角色的塑造，以及经典的怒斥众臣等让这个角色深深的引入了我的脑海。</p><p>除了boss，许多精英怪也让大家印象深刻，比如说虾薪王，熊薪王，王室幽魂等，虽然受苦，但是也给网上的视频创作添加了许多素材，通过这种方式也给玩家们带来了很多欢乐，虽然这点或许并不在设计的初衷内。</p><p>这一作内容非常多，最首先感受到这一点的地方是地图。当我第一次打开地图，心想地图就这吗？但是随着后来我收集了一块又一块的地图碎片，整个地图也逐渐显现出了它原本的样子，这个过程中逐渐意识到原来一开始所能看到的部分只是整个交界地的冰山一角。</p><p>这一作的细节也非常非常多，游戏内容远超以往的魂系列，我一周目认真收集花了一百个小时才结束，但依然漏了许多东西。尽管不可避免的有一些偏向重复的要素，或者有一些玩家觉得很应付的要素，比如说一个后期的精英怪作为前中期区域的一些小boss，但是瑕不掩瑜。</p><p>泥头车的设计者你这样搞晚上睡得着觉吗？！</p><p>同时法环继承了魂系列一如既往的叙事，尽管拥有非常庞大的故事背景，但将故事隐藏在各种支线，以及各种道具的说明之中，给足了玩家们发掘、思考和想象的空间。</p><p>总体来说《艾尔登法环》是当之无愧的2022年度最佳游戏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。&lt;/p&gt;
&lt;p&gt;首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能</summary>
      
    
    
    
    <category term="Game" scheme="https://fusionbolt.github.io/categories/Game/"/>
    
    
    <category term="魂系列" scheme="https://fusionbolt.github.io/tags/%E9%AD%82%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>游植物园</title>
    <link href="https://fusionbolt.github.io/2023/05/02/Life/china-national-botanical-garden/"/>
    <id>https://fusionbolt.github.io/2023/05/02/Life/china-national-botanical-garden/</id>
    <published>2023-05-02T12:10:44.000Z</published>
    <updated>2023-05-02T12:18:04.069Z</updated>
    
    <content type="html"><![CDATA[<p>到了植物园，最先映入眼帘的不是什么植物，而是人山人海，且颇为吵闹，坏了兴致，不过这也是在预料之中的事情。</p><p>在观光车排队排了很久，在大概还要等两车人的时候前面问有没有独自前来的，正好有一个空位。便因此“合理插队”，提前坐上了观光车。上了观光车后感受到的炎热被迎面而来的微风一扫而光，一直沉浸于风所带来的清凉中，不知不觉车辆就到站了。下了车也不知道附近哪里有花，就开始一边看地图一边乱转了起来。偶尔也看到了一些花，或许是前些天未能承受住风雨的洗礼，都已是风中残烛。</p><p>此时正好已是正午，天气炎热加上并没有看到预期的百花绽放，便开始失去了继续游玩的兴趣。不过这里本身并不是花园而是植物园，只为花而来，也颇为奇怪。并不是为了欣赏什么植物，认识什么植物，而是单纯为了出来走走，或者是为了看花而来，从这样的角度来说或许对植物园是一种大不敬。</p><p>总之走的很累了，找到一处树荫下的凳子坐下。听着旁边风吹树叶窸窸窣窣的声音，想着多久没有听到过这样的声音了呢？每天都在办公室，在家里，听着电子音乐，听着人声，和大自然距离实在太远了。没多久又听到了聒噪的鸟叫声，听到这阵声音想到的不是美好的大自然，反而是今天早上五点醒来的时候被鸟叫吵到睡不着的痛苦。</p><p>恢复一些精力后继续逛了下去，走到了郁金香区，看到了成片的郁金香总算觉得不枉此行。由于这边花开的状态比较好，人还是比较多的，到了郁金香区的高台，到处都是拍照的人，等了很久才勉强有一个适合拍照的位置。由于今天的着装比较特别，机会难得因此想用相机自拍纪念下，虽然最后也成功拍到了，但是拍的过程中总是会有旁边在拍花的人上镜，加上没什么自拍经验，拍了非常多次才拍到还算能看的照片。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/china-national-botanical-garden/DSCF6892.JPG"                      alt="DSCF6892"                ></p><p>之后又沿路拍了一些还算好看的花，决定要走了，发现温室还没去，于是匆匆赶往那边。一进热带植物区和热带雨林区感受到的只有炎热，相比之下，中午在室外的炎热已经算不上什么了。顾不上耐心拍照，只有拍几张感兴趣的然后匆匆出去，最后全身已被汗水湿透。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/china-national-botanical-garden/DSCF6922.JPG"                      alt="DSCF6922"                ></p><p>最后出了植物园大门的时候，由于水喝的比较少，嘴里已经开始渗出了苦味。今天没有装东西的兜，手里拿着相机和手机，还夹着伞，实在不方便拿水喝，尽管一直比较渴，但就喝了带的一小瓶水。看西郊线人比较多，因此约了滴滴。在等滴滴的路上看到门口有一个人因为孩子差点被人贩子直接拉走，好像还控制住对方一会，同时在喊警察，但警察一直没来。我看到的时候他已经带着孩子去找周围警察了，很生气，责备警察无用，也能理解他的愤怒，另外又觉得这些人真的是胆大妄为。之后车来了，我已经比较疲惫，也无心做些什么，就只是任由风将我的头发吹飞，看着窗外的风景，看着一片片绿色的树林，不加以任何思考与判断，只是这样看着过去的事物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;到了植物园，最先映入眼帘的不是什么植物，而是人山人海，且颇为吵闹，坏了兴致，不过这也是在预料之中的事情。&lt;/p&gt;
&lt;p&gt;在观光车排队排了很久，在大概还要等两车人的时候前面问有没有独自前来的，正好有一个空位。便因此“合理插队”，提前坐上了观光车。上了观光车后感受到的炎热被迎面</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="植物园" scheme="https://fusionbolt.github.io/tags/%E6%A4%8D%E7%89%A9%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读五 符号相关</title>
    <link href="https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/"/>
    <id>https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/</id>
    <published>2023-04-29T09:09:46.000Z</published>
    <updated>2023-05-07T16:16:43.191Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-5-symbol/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:73005507</center> <p>上期讲完了resolve_section_pieces，在这之后本应是combine_object，但是combine_object几乎包含了后面的所有过程，因此等到整个流程讲完后或许会再回来讲，这一期的内容以符号版本的处理为主。</p><h1 id="为common-symbol创建bss段"><a href="#为common-symbol创建bss段" class="headerlink" title="为common symbol创建bss段"></a>为common symbol创建bss段</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_common_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;convert_common_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="common-symbol"><a href="#common-symbol" class="headerlink" title="common symbol"></a>common symbol</h2><p>首先解释一下common symbol。根据mold的注释所讲，common symbols被用于C的tentative definition，tentative definition是指C语言在一个头文件中允许全局变量定义省略extern。header会存在于多个翻译单元中，但这个符号不会导致duplicate symbol error，相反linker会将他们merge到一个单一的实例中。</p><p>还给出了一个例子，比如说一个头文件中有一个tentative definition是int foo，在一个C文件中包含了其包含初始值定义，比如说int foo = 5（real definition），那么这个tentative definition的符号会被resolve到real definition上。如果没有real definition，那么tentative definition会得到默认值。</p><p><a class="link"   href="https://stackoverflow.com/questions/3095861/about-tentative-definition" >About Tentative definition<i class="fas fa-external-link-alt"></i></a></p><p>参考这个stackoverflow的回答，C语言中纯变量声明会被处理为extern的，我想这就是允许省略extern的原因，编译器帮你做了这件事情，尽管这或许与你的预期不符。</p><p>简单总结来说就是头文件中一个全局的声明在不同编译单元有不同定义的时候需要进行resolve一个单一实现，声明的symbol其实是属于多个文件的，因此是common的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">convert_common_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_common_symbol)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>has_common_symbol初始化的地方是在input-files.cc中的void ObjectFile<E>::initialize_symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize_symbols</span></span><br><span class="line"><span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的处理是针对所有global的common符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;elf_syms[i].<span class="built_in">is_common</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym.file != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.warn_common)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: multiple common symbols: &quot;</span> &lt;&lt; sym;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>提示warning</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in for</span></span><br><span class="line">elf_sections2.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">ElfShdr&lt;E&gt; &amp;shdr = elf_sections2.<span class="built_in">back</span>();</span><br><span class="line"><span class="built_in">memset</span>(&amp;shdr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(shdr));</span><br><span class="line"></span><br><span class="line">std::string_view name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() == STT_TLS) &#123;</span><br><span class="line">  name = <span class="string">&quot;.tls_common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE | SHF_TLS;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;.common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shdr.sh_type = SHT_NOBITS;</span><br><span class="line">shdr.sh_size = <span class="keyword">this</span>-&gt;elf_syms[i].st_size;</span><br><span class="line">shdr.sh_addralign = <span class="keyword">this</span>-&gt;elf_syms[i].st_value;</span><br></pre></td></tr></table></figure><p>关于SHF_TLS</p><blockquote><p>SHF_TLS: This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data. Implementations need not support this flag.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>对每个global common符号创建了一个ElfShdr后开始设置其基本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i64 idx = <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>() + elf_sections2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; isec =</span><br><span class="line">  std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, idx);</span><br><span class="line"></span><br><span class="line">sym.file = <span class="keyword">this</span>;</span><br><span class="line">sym.<span class="built_in">set_input_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">sym.value = <span class="number">0</span>;</span><br><span class="line">sym.sym_idx = i;</span><br><span class="line">sym.ver_idx = ctx.default_version;</span><br><span class="line">sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">sym.is_exported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sections.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(isec));</span><br><span class="line"><span class="comment">// for end</span></span><br></pre></td></tr></table></figure><p>创建了一个指向elf_sections的InputSecion，之后添加到sections中。</p><h1 id="apply-version-script"><a href="#apply-version-script" class="headerlink" title="apply_version_script"></a>apply_version_script</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br></pre></td></tr></table></figure><h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_version_script</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_version_script&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If all patterns are simple (i.e. not containing any meta-</span></span><br><span class="line">  <span class="comment">// characters and is not a C++ name), we can simply look up</span></span><br><span class="line">  <span class="comment">// symbols.</span></span><br><span class="line">  <span class="keyword">auto</span> is_simple = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns)</span><br><span class="line">      <span class="keyword">if</span> (v.is_cpp || v.pattern.<span class="built_in">find_first_of</span>(<span class="string">&quot;*?[&quot;</span>) != v.pattern.npos)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先定义了is_simple。</p><p>simple的定义</p><ol><li>非cpp name。VersionPattern是根据链接器参数创建与添加的，is_cpp也同样是在那时指定的。</li><li>不包含meta字符的名字。根据代码中，meta字符即是*[?中的char</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_simple</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns) &#123;</span><br><span class="line">      Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, v.pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sym-&gt;file &amp;&amp; !ctx.arg.undefined_version)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; v.source &lt;&lt; <span class="string">&quot;: cannot assign version `&quot;</span> &lt;&lt; v.ver_str</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;` to symbol `&quot;</span> &lt;&lt; *sym &lt;&lt; <span class="string">&quot;`: symbol not found&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso)</span><br><span class="line">        sym-&gt;ver_idx = v.ver_idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果是simple的那么直接针对所有的version_pattern找到对应的符号，并且将其通过设置ver_idx的方式与VersionPattern进行关联</p><h2 id="otherwise"><a href="#otherwise" class="headerlink" title="otherwise"></a>otherwise</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Otherwise, use glob pattern matchers.</span></span><br><span class="line">MultiGlob matcher;</span><br><span class="line">MultiGlob cpp_matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.version_patterns.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  VersionPattern &amp;v = ctx.version_patterns[i];</span><br><span class="line">  <span class="keyword">if</span> (v.is_cpp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将cpp和其他复杂的符号区分开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name = sym-&gt;<span class="built_in">name</span>();</span><br><span class="line">    i64 match = INT64_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = matcher.<span class="built_in">find</span>(name))</span><br><span class="line">      match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match non-mangled symbols against the C++ pattern as well.</span></span><br><span class="line">    <span class="comment">// Weird, but required to match other linkers&#x27; behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;std::string_view&gt; s = <span class="built_in">cpp_demangle</span>(name))</span><br><span class="line">        name = *s;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = cpp_matcher.<span class="built_in">find</span>(name))</span><br><span class="line">        match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match != INT64_MAX)</span><br><span class="line">      sym-&gt;ver_idx = ctx.version_patterns[match].ver_idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在所有obj文件中找到所有global symbol</p><p>如果普通matcher中能找到其名字，那么更新match的index</p><p>如果cpp matcher非空，那么对其进行demangle操作，之后在cpp matcher中寻找其名字并且更新match的index</p><p>最后将符号与对应VersionPattern进行关联。</p><p>而这里的demangle操作是直接调用对应平台的abi。starts_with(”_Z”)是代表这是一个mangling的名字。关于mangling的规则参考</p><p><a class="link"   href="https://github.com/gchatelet/gcc_cpp_mangling_documentation" >https://github.com/gchatelet/gcc_cpp_mangling_documentation<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string_view&gt; <span class="title">cpp_demangle</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">char</span> *buf;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">size_t</span> buflen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cwasser): Actually demangle Symbols on Windows using e.g.</span></span><br><span class="line">  <span class="comment">// `UnDecorateSymbolName` from Dbghelp, maybe even Itanium symbols?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;_Z&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> *p = abi::__cxa_demangle(std::<span class="built_in">string</span>(name).<span class="built_in">c_str</span>(), buf, &amp;buflen, &amp;status);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">      buf = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obj-only"><a href="#obj-only" class="headerlink" title="obj only"></a>obj only</h2><p>我在读到这里，很好奇为什么只针对的是obj而不考虑dso，看了下相关的命令行参数的介绍才明白过来</p><blockquote><p>-E, –export-dynamic Put symbols in the dynamic symbol table –no-export-dynamic</p></blockquote><h1 id="parse-symbol-version"><a href="#parse-symbol-version" class="headerlink" title="parse_symbol_version"></a>parse_symbol_version</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_symbol_version</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这是针对生成shared库的操作，因为只有动态链接才需要考虑加载符号版本的问题，符号版本是为了加载动态库的时候确保更新后符号的实现一致，如果和预想的实现不一致可能引起其他问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string_view, u16&gt; verdefs;</span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.version_definitions.<span class="built_in">size</span>(); i++)</span><br><span class="line">  verdefs[ctx.arg.version_definitions[i]] = i + VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>实现中首先是将每一个version信息绑定到一个i + VER_NDX_LAST_RESERVED + 1的值（其中的version_definitions则是在read_version_script中读取的）。</p><p>接下来是针对了所有的global object进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>() - file-&gt;first_global; i++) &#123;</span><br><span class="line">      <span class="comment">// Match VERSION part of symbol foo@VERSION with version definitions.</span></span><br><span class="line">      <span class="comment">// The symbols&#x27; VERSION parts are in file-&gt;symvers.</span></span><br><span class="line">      <span class="keyword">if</span> (!file-&gt;symvers[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      Symbol&lt;E&gt; *sym = file-&gt;symbols[i + file-&gt;first_global];</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view ver = file-&gt;symvers[i];</span><br><span class="line">...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>首先找到了对应文件的global符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_default = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>)) &#123;</span><br><span class="line">  is_default = <span class="literal">true</span>;</span><br><span class="line">  ver = ver.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取符号的版本具体的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = verdefs.<span class="built_in">find</span>(ver);</span><br><span class="line"><span class="keyword">if</span> (it == verdefs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: symbol &quot;</span> &lt;&lt; *sym &lt;&lt;  <span class="string">&quot; has undefined version &quot;</span></span><br><span class="line">             &lt;&lt; ver;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据具体的值查找到上面保存的index</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sym-&gt;ver_idx = it-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (!is_default)</span><br><span class="line">  sym-&gt;ver_idx |= VERSYM_HIDDEN;</span><br></pre></td></tr></table></figure><p>非default行为的版本，也就是非@开头的版本则ver_idx设置为HIDDEN。关于非default的情况，这种符号version则是在default_symver选项中添加的。</p><p>该选项对应的介绍以及代码实现处</p><blockquote><p>Use soname as a symbol version and append that version to all symbols.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.default_symver) &#123;</span><br><span class="line">    std::string ver = ctx.arg.soname.<span class="built_in">empty</span>() ?</span><br><span class="line">      <span class="built_in">filepath</span>(ctx.arg.output).<span class="built_in">filename</span>().<span class="built_in">string</span>() : std::<span class="built_in">string</span>(ctx.arg.soname);</span><br><span class="line">    ctx.arg.version_definitions.<span class="built_in">push_back</span>(ver);</span><br><span class="line">    ctx.default_version = VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If both symbol `foo` and `foo@VERSION` are defined, `foo@VERSION`</span></span><br><span class="line"><span class="comment">// hides `foo` so that all references to `foo` are resolved to a</span></span><br><span class="line"><span class="comment">// versioned symbol. Likewise, if `foo@VERSION` and `foo@@VERSION` are</span></span><br><span class="line"><span class="comment">// defined, the default one takes precedence.</span></span><br><span class="line">Symbol&lt;E&gt; *sym2 = <span class="built_in">get_symbol</span>(ctx, sym-&gt;<span class="built_in">name</span>());</span><br><span class="line"><span class="keyword">if</span> (sym2-&gt;file == file &amp;&amp; !file-&gt;symvers[sym2-&gt;sym_idx - file-&gt;first_global])</span><br><span class="line">  <span class="keyword">if</span> (sym2-&gt;ver_idx == ctx.default_version ||</span><br><span class="line">      (sym2-&gt;ver_idx &amp; ~VERSYM_HIDDEN) == (sym-&gt;ver_idx &amp; ~VERSYM_HIDDEN))</span><br><span class="line">    sym2-&gt;ver_idx = VER_NDX_LOCAL;</span><br></pre></td></tr></table></figure><p>最后是一个符号名同时存在带有version和没有version的两种定义，那么带有version信息的则会对外隐藏不带有特殊version信息的实现（设置为local）。通过当前sym的名字在ctx中查找同名符号，之后进行处理操作。</p><h1 id="compute-import-export"><a href="#compute-import-export" class="headerlink" title="compute_import_export"></a>compute_import_export</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_import_export</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_import_export&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we are creating an executable, we want to export symbols referenced</span></span><br><span class="line">  <span class="comment">// by DSOs unless they are explicitly marked as local by a version script.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso &amp;&amp; sym-&gt;visibility != STV_HIDDEN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sym-&gt;ver_idx != VER_NDX_LOCAL || !ctx.default_version_from_version_script) &#123;</span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">            sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在不生成shared库的情况下，针对所有的dso进行处理，在创建可执行文件的时候，导出被dso引用的且不被标记为local的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Export symbols that are not hidden or marked as local.</span></span><br><span class="line"><span class="comment">// We also want to mark imported symbols as such.</span></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sym-&gt;file || sym-&gt;visibility == STV_HIDDEN ||</span><br><span class="line">        sym-&gt;ver_idx == VER_NDX_LOCAL)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file &amp;&amp; sym-&gt;file-&gt;is_dso &amp;&amp; !sym-&gt;<span class="built_in">is_absolute</span>()) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are creating a DSO, all global symbols are exported by default.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == file) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym-&gt;visibility != STV_PROTECTED &amp;&amp;</span><br><span class="line">          !ctx.arg.Bsymbolic &amp;&amp;</span><br><span class="line">          !(ctx.arg.Bsymbolic_functions &amp;&amp; sym-&gt;<span class="built_in">get_type</span>() == STT_FUNC))</span><br><span class="line">        sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>objs中找到global符号，对于HIDDEN或者NDX_LOCAL的符号都跳过。</p><p>如果使用一个在dso中的符号，就需要运行时import它，因此需要设置对应符号为imported</p><p>如果创建dso，那么所有的global符号默认都要export。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>convert_common_symbols：给所有global的common符号创建一个对应的InputSection段</p><p>apply_version_script：将解析命令行参数产生的VersionPatten关联到对应的obj文件中的symbol</p><p>parse_symbol_version：读取symbol version信息，处理对应的ver_idx，以及针对不同版本符号的处理</p><p>compute_import_export：对所有符号计算对应的import和export信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-5-symbol/</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>斯通纳</title>
    <link href="https://fusionbolt.github.io/2023/04/18/Reading/Stoner/"/>
    <id>https://fusionbolt.github.io/2023/04/18/Reading/Stoner/</id>
    <published>2023-04-18T13:30:38.000Z</published>
    <updated>2023-04-18T13:32:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是找到故事中角色与自己的相似之处，又或是将自己代入到角色中。</p><p>文中讲述了斯通纳的一生，从大学开始，到爱情，事业，直至最后的死亡。他在大学结交了非常好的朋友，不论是精神上，还是实际行为上都对他有所支持。他经历了一见钟情的爱情，也顺势结了婚，但却毫无幸福可言，唯一的幸福也只有饱受非议的婚外情。他在事业上还算成功，兢兢业业工作直至退休。在这些过程中斯通纳的傲骨也是十分明显的，遇到问题不愿低头，一直保有自己的骄傲。我想大部分人读完这本书后，都会对斯通纳留下正直，不寻求权利，不愿低头，遇到什么事情都不愿让步的印象。面对舞弊的行为坚守原则，即便这导致了他频繁受到针对，甚至调离到了偏远的岗位。</p><p>他的人生充满坎坷，无法说是幸福的，但</p><blockquote><p>即使没有完美的一生，所幸追求过完整的自我</p></blockquote><p>不论他的一生经历了多少苦难，出现了多少问题，但他内心的自我，他的本性，他的灵魂仍未变质，这是让人十分欣慰的。</p><p>刚开始读的时候感觉略微不适应，后来发现是因为最初的部分没什么环境描写，对话相对较少，内容更倾向于流水账一样，和前段时间刚读完的《虞美人草》形成了非常明显的对比，这个问题读到后面觉得多少有些缓解。不过用这样篇幅的一本书讲述一个人的一生，同时想要保持细节是完全不可能的，也只能去掉许多描写性质的部分，同时只选取最典型的一些故事。另外不知是翻译问题还是原文就是这样写的，许多地方让我感觉比较粗糙。</p><p>读完整本书后最让我意外的感受是我开始害怕一切。看到斯通纳的经历，我觉得越阅读，越学习，反而越是害怕。害怕对人性的恶看的更透彻，害怕被人的恶所影响，害怕不平和的未来，害怕和一个不合适的人结婚，害怕自己也像书中的故事的痛苦的一面一般，害怕自己极度抑制的充满恶的本性泄漏出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="约翰·威廉斯" scheme="https://fusionbolt.github.io/tags/%E7%BA%A6%E7%BF%B0%C2%B7%E5%A8%81%E5%BB%89%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>莫失莫忘</title>
    <link href="https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/"/>
    <id>https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/</id>
    <published>2023-04-17T13:23:03.000Z</published>
    <updated>2023-04-17T13:26:10.734Z</updated>
    
    <content type="html"><![CDATA[<p>这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。</p><p>从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱有疑问，是否和我所想的一样，后来证明了这一点。不知道原版的用词带给母语者的感受是怎么样的，如果会让人引起和我相同的想法那或许是作者有意为之。在后面揭露更多真相的时候，作者都是用了类似的做法，先透露出一点似乎不那么令人意外的线索，后来又从对话中传达真相并使读者感到震惊。至于为什么这么写，或许是提前进行漫长的铺垫，使得读者读到这里的时候有更强烈的感受。</p><p>回到书中的内容。凯西、汤米、露丝显然是整个故事中最核心的角色。凯西和汤米对一切进行了思考，而不是一直只有接受。</p><p>露丝则是很明显被用于对比的角色，她的态度更倾向于接受外部的一切，不论是汤米和凯西的看法还是当汤米实际与她讨论可能的真相时她都表现出了如此的特质。但同时露丝也是一个传达许多真相并且推进的角色，当一切都铺垫好以后，也就不再需要这样一个只是接受的角色一起参与探索背后的真相，自然的将故事舞台的主导权完全交给了汤米和凯西。汤米则是推动这一切进展的角色，思考一切背后的真相，去做各种尝试。而”我“，也就是凯西，更像是观察这一切，关联起这一切的角色。不论是和汤米接触，还是和露丝的关系，又或者是直到最后看着这一切。最后提到了“我”记忆中的黑尔舍姆，“我”从未寻找黑尔舍姆，却到处都能发现黑尔舍姆的点点滴滴，到不同的地方，看到不同的东西，找到黑尔舍姆也许是意味着回忆起了曾经的时光。后面还有这样一段话</p><blockquote><p>就像是我对汤米和露丝的回忆。一旦我能够过上比较平静的生活，不论他们把我送到哪间康复中心，黑尔舍姆都会始终跟我在一起，安全的保留在我脑海中，这是任何人都无法拿走的。</p></blockquote><p>在书中一开始的剧情中，艺廊或许是一个令人疑惑的存在，而对艺廊的疑问直到最终才被揭开。在提及艺廊的真相时，不论是汤米的推论还是实际的真相，都谈到了从作品中揭示出人的灵魂，或者说证明他们有灵魂。那么我想可以反过来，换一个非常极端的说法：人若无法创造出什么，那么无法证明这个人有灵魂。或许是缺少内在、无法产生自己的想法、没有自我、无法对外部质疑，不论怎么说都无法被称为人，而是一类什么。</p><p>说到做了，我想再提及之前凯西提出的质疑：“如果我们反正只是为了捐献，然后死去，那么上那些课是为什么？”答案并没有直说，但我想是让学生通过这样的课程，能够在活着的时间内形成自己独特的灵魂，尽管是部分受限的（因为接收到的信息是经过挑选的）。而这个问题，即便对普通人也是一样的，我来换个问法：如果我们生来只是为了活几十年，然后死去，那么做现在这些事情是为什么？这件事情一定没有什么标准答案。首先我认同的是人生无意义的观点，但我认为人灵魂的存在可以选择在离去之前选择填充自己的灵魂并留下些什么，也并非一定要有什么意义，我们不需要满世界去寻找什么意义，这种东西本就不存在于任何地方，也不应当一切用意义来蒙蔽自己的眼睛。</p><p>看到最后的真相我才明白为什么这本书被归结为科幻小说。对于科幻小说的定位我起初也有些费解，认为科幻小说就是各种未来世界、充满了不存在的科技等等，尤其是当我看到最终真相之前，绝大部分的内容完全没有看到科技的痕迹。这本书与我所想的科幻小说相差巨大，尤其是在我没读到最后的时候。但偶然有一天我听到一档播客节目，里面谈到各种各样科幻小说的形式，提及作者石黑一雄的小说相比于科幻更注重于人与人之间的关系，才明白科幻小说还可以这样来写。</p><p>在这些正文后还有译后记，在这部分内容提到一个从我完全没想到的角度提到的细思恐极的事情</p><blockquote><p>当艾米丽小姐坐着轮椅从阴影中出来的时候，读者不禁期望她会有更多的情感流露。她为之奋斗终生的黑尔舍姆事业已经告终，但这两个孩子是她事业的成果，他们的成就值得她自豪。然而她一心都放在要卖掉的柜子上，甚至基本的待客礼仪都欠奉，终究“我们”和“他们”的壁垒如此森严，毕竟她要从轮椅上站起来、恢复健康，多半还要指望从“他们”身上收获的器官。</p></blockquote><p>写到这里我联想到了一个很重要的细节，当真相大白的时候，夫人和艾米丽小姐也都提到其实她们是和外人一样对他们是抱有恐惧的，甚至艾米丽小姐还会对他们感到厌恶。此时艾米丽小姐说“可我下决心不让这种情绪阻止我去做正确的事。我跟这些情绪作战，并且战胜了。”这句话在当时读的时候我没觉得有什么，但现在回头看来，她所说的正确的事情到底是什么，到底是让他们成为人，还是让他们成为捐献者呢？另外此时我才意识到过去夫人对他们的害怕也是真的对他们这些人自身，而不是其他东西感到害怕。许多事情和夫人对他们的害怕一样，在前面只是未提及，有的很晚才给出解释，有的甚至并未直白的给出解释。但当我们无意中发现真相时，又会感受到骇人。这种处处埋藏线索与问题的写法，除了让我们感受强烈，我认为可以有另一种过度的解读，这或许是作者刻意这样做的，是为了让我们去思考问题，而不只是去接受这一切。</p><p>另外译者认为他们不质疑人生，不反抗生来的宿命，关于这一点我有一些想法。他们获得的信息都是经过精挑细选的，因此对他们来说根本没有质疑人生和反抗宿命的概念。对他们来说，能去思考背后的真相以及想要尝试延迟几乎可以说是能做到的极限了。如果是作为反乌托邦小说来讲，和我之前看过的美丽新世界和1984相同，这样的设定下人们都是会被各种方式所影响，几乎不会产生这样的概念，我目前看的不多，但就我看过的几本来说，反乌托邦总是离不开人们被“教育”成接受一切，无法反抗的状态，同时主线也是类似探寻真相与反抗的故事，不知其他同类书籍怀有怎样的观点和故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。&lt;/p&gt;
&lt;p&gt;从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="石黑一雄" scheme="https://fusionbolt.github.io/tags/%E7%9F%B3%E9%BB%91%E4%B8%80%E9%9B%84/"/>
    
  </entry>
  
  <entry>
    <title>2023.4.10-4.16 下陷</title>
    <link href="https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/"/>
    <id>https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/</id>
    <published>2023-04-16T14:46:37.000Z</published>
    <updated>2023-04-17T13:28:37.114Z</updated>
    
    <content type="html"><![CDATA[<p>和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存在于这里。</p><h1 id="本周的变化"><a href="#本周的变化" class="headerlink" title="本周的变化"></a>本周的变化</h1><p>这周我几乎看到了自己从动力十足的状态逐渐一步步变烂的整个过程，我觉得有必要来回顾一下这周发生了什么。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>周一正常的工作，但是到点早早回到家开始修改自己的sideproj，难得的好状态，因此一直肝到了晚上十二点多，太上头甚至没怎么练琴。</p><p>周二正常的工作，大部分事情和周一相同，状态也是比较好。这天花了不少时间去练琴，练的是新的部分，还是比较吃力。</p><p>前两天都是打车上下班，大风加沙尘暴的恶劣天气加上早上起不来，仅有的一点运动都缺失了。</p><p>但周三开始就不对劲了，研究dwarf的时候迟迟没有什么所想的进展，渐渐开始紧张，烦躁，给自己加压，最后把自己逼迫到了出现负面想法的情况。之后出去走了一公里，情绪渐渐缓解了一点，但回来就开始感到疲惫，勉强看完书后身体就开始想要刷视频，刷完视频后练琴有些不在状态，很快就停下了。也没有精力去做sideproj，之后继续刷视频，最后晚睡。</p><p>周四也遇到了问题，开始觉得发懵，觉得意识与行动的联系变弱了，开始有一种恍惚感：不知道该做什么，不知道对错，无法深入理性思考，只能看到什么做什么，而且是不用脑子的那种。这一天也开始眼睛感到不适，除了休息不好以及最近可能用不干净的手频繁触摸眼睛周围外，高强度的用眼也是难逃其责。工作期间起身去厕所的时候也能明显感受到身体的疲劳。晚上迟迟搞不定工作上的问题，开始钻牛角尖，缺乏耐心，攻击自己，最后也是很晚回家，并且同样多走了一段路（都是为了一定程度的锻炼身体），但是这两天自我攻击比较严重，现在看来这个时候多走路反而是负担。到了家优先趴在了床上，勉强看了一点书，之后也没怎么练琴。</p><p>周五更是严重，前一天晚上睡眠平均心率增加到了79，早上到公司的时候开始有些轻微头晕，易怒。下午一直没有搞出周四没解决的问题，越来越钻牛角尖，感到更多压力，紧张，开始觉得任务会无法完成。其实这个时候已经几乎无法正常思考问题的解决方案了，但仍然只是在那里堆时间，胡乱操作。</p><h2 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h2><p>首先是写代码的时间，周一到周四线性的减少了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.png"                      alt="Untitled"                ></p><p>练琴开启节拍器的时间。但有两个部分没有记录，一个是识谱，另一个是在使用另一个app的时间没有记录，但是这两部分在周三和周四也都是没在用的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.jpeg"                      alt="Untitled"                ></p><p>睡眠心率平均值，最近的常规值是70出头，周四的晚上到了最高值79，不过这个的影响因素很多，很难直接断定。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.png"                      alt="Untitled"                ></p><p>另外则是睡眠的时间，这个难以准确记录。</p><p>根据其他信息记录，上床时间分别为</p><ol><li>1:26</li><li>1:00</li><li>1:30</li><li>1:40</li><li>1:40</li></ol><p>屏幕使用时间难以准确记录，但是周三开始回家就想看动画，刷视频，也刷了蛮久</p><h2 id="我出了什么问题？"><a href="#我出了什么问题？" class="headerlink" title="我出了什么问题？"></a>我出了什么问题？</h2><p>自大与碰壁。周一周二sideproj良好的进度让我觉得dwarf那边也能随便解决，但实际上我想要的资料几乎没有，开始觉得自己不行。</p><p>发现自己在钻牛角尖没能及时停下来。不论是dwarf的问题还是工作上的问题，我都多少有点意识到自己进入了死胡同，但是都没能及时停下，而是加速朝着墙冲过去。过度集中使得我反而迷失了方向。这是我一直以来的坏毛病。</p><p>没有根据自己身体的疲劳调整。这几天多次行动使得自己开始累积压力，积压疲劳，而此时我并没有停下，而是尽可能的再去做些什么。我就像一个机器人一样，只是给自己安排任务，不到难以控制的情况是不会停下来的。</p><h1 id="心理咨询的结束"><a href="#心理咨询的结束" class="headerlink" title="心理咨询的结束"></a>心理咨询的结束</h1><p>大概是最后一次心理咨询，谈了一下近况，聊了一些问题。</p><p>首先是最近的情况怎么样？我提到之前被人问及的最焦虑的事情，我一时之间不知道怎么回答，后来回答的是不安，工作的焦虑，但其实自己一方面觉得焦虑一方面又觉得无所谓，最近这种无所谓的态度特别强烈。而我不论是否那么关心这个问题，不论怎么折腾，现实也就这个样，没什么变化。</p><p>那你是觉得不论怎么样生活都是一样的，就因此不折腾了吗？并不是该折腾折腾，能折腾到什么样就是什么样。</p><p>又从我之前说过遇到问题时可能有人一起会更好开始，问我如果和别人在一起呢？而我前两天则开始觉得，似乎跟朋友在一起也是一样，女朋友又不可能有。后来讲下去谈到了找女朋友的问题，这部分还讲了半天。</p><p>之后问到我要解决的现实问题怎么办？我的答复是只能每个方面磨下去，自己没办法像钻头一样，逐个击破，所以需要自己在更漫长时间的努力，将每个方面一点点磨下去。有点像是无奈之举，除此之外只有等待什么机会，或者什么事件。</p><p>说到自我贬低的部分，我说自己不接受赞美只接受批评，因为我认为别人的赞美是因为看到了我的一些表象。</p><p>咨询师说别人看到的都是不对的吗？我的回答是有许多错觉的部分，当然也有正确的部分。</p><p>又问我那你能不能相信一下别人说的夸奖的内容？我说不信，本质上是我没有认同自己，主要是我发自内心不觉得自己是多么好的人。尽管有一点点好的部分，但自己有着数不尽的问题。自己做的好的那么一点点也都是“应该”，做的不好的地方就是自己的问题。</p><p>后来说到自己脑中一闪而过的“给别人挑刺，贬低别人”的想法，自己也正如这样对待自己。“如果自己变厉害了就不会这样不认同自己了”，如果一直怀有这样的想法，即便站上顶点也依然不会放过自己。因为即便在顶点，也可以站的更高，这也有一部分是因为人上进的本性，不接受自己，批评自己的想法也是有促进自己前进的正面意义，只是这样的自己像是严酷的监工（-1hp +2atk）。</p><p>又说到自己最近一周，由于不放过自己，持续逼迫自己，使得自己的情况十分清晰可见的越来越不好。我觉得自己要做的还是应该多放过自己一些，感受自己的想法，避免进入泥潭，而未掉入泥潭的我相比于掉入的我还是会多不少处理能力。</p><p>最后要结束的时候咨询师说我实际上很强大，希望我能记得。不过我对此其实还是没有什么实感，没有什么想法，还是会继续当监工，只是监督力度可能会开始有意识的减弱，否则我会继续倒下去。我的心理咨询大概到这里就彻底结束了。</p><h1 id="本周其他想法的一些记录"><a href="#本周其他想法的一些记录" class="headerlink" title="本周其他想法的一些记录"></a>本周其他想法的一些记录</h1><h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>dwarf没有什么我想要的例子，看了半天连个开头都没搞明白，瞬间变得特别沮丧了…又开始意识到自己是个废物，准备出门走走，起身来才意识到刚才自己看的时候压力多大，明显感到十分疲惫，呼吸短浅，渐渐察觉自己又到了这种极其负面的状态，意识到自己又在和以往一样遇到点解不出的难题就开始烦，给身体不断施加压力，同时想到自己只是想根据潜意识解决，或者找一个现有的东西抄，而没想过怎么用现有知识去进一步思考…</p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>感觉到自己的精力太少远远不够用的…前两天有些拼，这两天已经明显开始觉得身体在抗议，疲惫，想要享乐这个想法变得更强烈，更难抵抗，最近每日有效工作加学习时间逐日渐少…</p><p>今天我又感觉到那种因为疲劳而感到抽离于现实的感觉。这种时候能做的就是看到什么能做的去做什么，而没有办法去思考自己该怎么做，自己该做什么，如果工作996的话简直不敢想会变成什么样子</p><p>不仅是精力不足以及身体疲劳，昨天遇到搞不懂的东西后自己对自己的心理压迫也是一个很大的影响因素…</p><h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.jpeg"                      alt="Untitled"                ></p><p>这样说了，心里在欺骗自己说自己本来就是个废物，爱咋咋地，就这样摆烂吧。转去练琴的时候想到了自己练琴也都很慢，就潜意识中加快了速度，选择了我跟不上的节拍练习…</p><p>想起白天好几个同事来问我问题，我当时其实有点虚荣，觉得大家都来问我，这样好啊，但又知道自己也就那一点点东西。但是没办法，这件事情上并不是为了荣誉什么的，反而是觉得被人需要了很开心…虽然如此，但还是像我上面说的有虚荣心在，自己没有什么过硬的水准，只好从这种方面和角度给自己找信心，这样说出来也蛮丢人的</p><p>觉得比别人好的自己，觉得比别人差的自己，自傲的自己，自卑的自己，无一例外都是自己，真的是分裂</p><p>感觉负面想法开始冒出来了，这是我没有好好照顾自己，没有重视自己感受到一个结果吧。不知道这几天里疲劳和负面情绪是谁先动的手，反正现在是两败俱伤，我也一直没有太关注平常的身体状态。对我来说不论状态好还是不好，要做的事情都是一样的，只是说做多做少，逼不逼自己的区别罢了，只想无止境的压榨着远不如常人的精力</p><h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>看到别人在参与复杂的项目，讨论相关技术，想到自己只是一直在做自己的玩具项目，而且进度非常非常慢，觉得自己大概只有做这点玩具的份了，技术和其他条件都不行，以后能不能在编译器的岗位都很成问题…</p><p>担心失业，担心做什么都只能在入门处徘徊。虽然失业也不是就没路了，但我终归想在这条路走下去，也想做的更深入更好<br>想起两年前全程找工作的那个月，觉得以我的条件根本就找不到，也不可能找得上做编译器的工作，现在也这样觉得，只是之前运气好一点做了ai编译器，但霉运的我不可能以后都去依靠运气…</p><p>做玩具也挺开心的，能实现些什么东西我觉得很棒，不然我也不会花时间去做<br>只是当这件事情与生活的压力产生了交集，与我停滞不前的水平产生了交集，加上我的扭曲思考方式，最后这件事情产生了完全不一样的性质…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其四 mergeable section</title>
    <link href="https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/"/>
    <id>https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/</id>
    <published>2023-04-16T07:37:08.000Z</published>
    <updated>2023-04-16T07:39:34.874Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-4-mergeable-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:83834646</center> <p>上一期的内容讲完了一些针对文件的简单处理以及符号决议，这一期的主要内容是在这之后针对mergeable section的决议与合并。</p><h1 id="resolve-section-pieces"><a href="#resolve-section-pieces" class="headerlink" title="resolve_section_pieces"></a>resolve_section_pieces</h1><p>这个过程是将mergeable的section split到更小的pieces中，并且将每一个piece和其他来自不同文件的pieces进行合并，最典型的例子是不同object file中string段的合并。mold中称mergeable section原子单元为section pieces。</p><p>所以这里的过程分为了两部分</p><ol><li>将普通的section转换为MegeableSection</li><li>resolve and merge</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_section_pieces</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_section_pieces&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">initialize_mergeable_sections</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_section_pieces</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialize-mergeable-sections"><a href="#initialize-mergeable-sections" class="headerlink" title="initialize_mergeable_sections"></a>initialize_mergeable_sections</h1><p>mold中attach section pieces symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_mergeable_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  mergeable_sections.<span class="built_in">resize</span>(sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; m = <span class="built_in">split_section</span>(ctx, *isec)) &#123;</span><br><span class="line">        mergeable_sections[i] = std::<span class="built_in">move</span>(m);</span><br><span class="line">        isec-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每一个section进行split_section，转换为一个MergeableSection，之后将原始的section设置为非alive。</p><h2 id="MergeableSection"><a href="#MergeableSection" class="headerlink" title="MergeableSection"></a>MergeableSection</h2><p>首先我们来看和MergeableSection相关的数据结构，有如下三个</p><ol><li>MergeableSection</li><li>MergedSection</li><li>SectionFragment</li></ol><p>其中每个MergeableSection中包含了多个SectionFragment，又关联了其对应的MergedSection。MergedSection是一个chunk，而chunk则是在链接后期要输出到文件的时候的一个基本单位，暂时先不进一步讲解。SectionFragment则是MergedSection根据MergeableSection传入的信息构造的，并且返回给MergeableSection保存的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeableSection</span> &#123;</span></span><br><span class="line">  std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt; <span class="built_in">get_fragment</span>(i64 offset);</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; *parent;</span><br><span class="line">  u8 p2align = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;std::string_view&gt; strings;</span><br><span class="line">  std::vector&lt;u64&gt; hashes;</span><br><span class="line">  std::vector&lt;u32&gt; frag_offsets;</span><br><span class="line">  std::vector&lt;SectionFragment&lt;E&gt; *&gt; fragments;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> MergedSection&lt;E&gt; *</span></span><br><span class="line"><span class="function">  <span class="title">get_instance</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view name, u64 type, u64 flags)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SectionFragment&lt;E&gt; *<span class="title">insert</span><span class="params">(std::string_view data, u64 hash, i64 p2align)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assign_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_to</span><span class="params">(Context&lt;E&gt; &amp;ctx, u8 *buf)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_stats</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  HyperLogLog estimator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">MergedSection</span>(std::string_view name, u64 flags, u32 type);</span><br><span class="line"></span><br><span class="line">  ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br><span class="line">  std::vector&lt;i64&gt; shard_offsets;</span><br><span class="line">  std::once_flag once_flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionFragment</span> &#123;</span></span><br><span class="line">  <span class="built_in">SectionFragment</span>(MergedSection&lt;E&gt; *sec) : <span class="built_in">output_section</span>(*sec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SectionFragment</span>(<span class="keyword">const</span> SectionFragment &amp;other)</span><br><span class="line">    : <span class="built_in">output_section</span>(other.output_section), <span class="built_in">offset</span>(other.offset),</span><br><span class="line">      <span class="built_in">p2align</span>(other.p2align.<span class="built_in">load</span>()), <span class="built_in">is_alive</span>(other.is_alive.<span class="built_in">load</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">u64 <span class="title">get_addr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  u32 offset = <span class="number">-1</span>;</span><br><span class="line">  std::<span class="keyword">atomic_uint8_t</span> p2align = <span class="number">0</span>;</span><br><span class="line">  std::<span class="keyword">atomic_bool</span> is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MergedSection并不暴露对应的构造函数，而是通过对应的get_instance来获取实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(Context&lt;E&gt; &amp;ctx, std::string_view name,</span><br><span class="line">                               u64 type, u64 flags) &#123;</span><br><span class="line">  name = <span class="built_in">get_merged_output_name</span>(ctx, name, flags);</span><br><span class="line">  flags = flags &amp; ~(u64)SHF_GROUP &amp; ~(u64)SHF_COMPRESSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;]() -&gt; MergedSection * &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;osec : ctx.merged_sections)</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">tuple</span>(name, flags, type) ==</span><br><span class="line">          std::<span class="built_in">tuple</span>(osec-&gt;name, osec-&gt;shdr.sh_flags, osec-&gt;shdr.sh_type))</span><br><span class="line">        <span class="keyword">return</span> osec.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search for an exiting output section.</span></span><br><span class="line">  <span class="keyword">static</span> std::shared_mutex mu;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">      <span class="keyword">return</span> osec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new output section.</span></span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">    <span class="keyword">return</span> osec;</span><br><span class="line"></span><br><span class="line">  MergedSection *osec = <span class="keyword">new</span> <span class="built_in">MergedSection</span>(name, flags, type);</span><br><span class="line">  ctx.merged_sections.<span class="built_in">emplace_back</span>(osec);</span><br><span class="line">  <span class="keyword">return</span> osec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取的时候去ctx中寻找实例，不存在则创建新的并且返回。</p><h2 id="split-section"><a href="#split-section" class="headerlink" title="split_section"></a>split_section</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt;</span><br><span class="line"><span class="built_in">split_section</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;sec) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!sec.is_alive || sec.sh_size == <span class="number">0</span> || sec.relsec_idx != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = sec.<span class="built_in">shdr</span>();</span><br><span class="line">  <span class="keyword">if</span> (!(shdr.sh_flags &amp; SHF_MERGE))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>由于是针对mergeable section，而判断标准则是根据section header中的sh_flgas的值，因此先通过检查flga来进行过滤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; <span class="built_in">rec</span>(<span class="keyword">new</span> MergeableSection&lt;E&gt;);</span><br><span class="line">rec-&gt;parent = MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(ctx, sec.<span class="built_in">name</span>(), shdr.sh_type,</span><br><span class="line">                                             shdr.sh_flags);</span><br><span class="line">rec-&gt;p2align = sec.p2align;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If thes section contents are compressed, uncompress them.</span></span><br><span class="line">sec.<span class="built_in">uncompress</span>(ctx);</span><br><span class="line"></span><br><span class="line">std::string_view data = sec.contents;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *begin = data.<span class="built_in">data</span>();</span><br><span class="line">u64 entsize = shdr.sh_entsize;</span><br><span class="line">HyperLogLog estimator;</span><br></pre></td></tr></table></figure><p>做一些基本的初始化操作，包括创建了MergeableSection以及关联对应的MergedSection，取出数据等。</p><h3 id="split-string"><a href="#split-string" class="headerlink" title="split string"></a>split string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split sections</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_flags &amp; SHF_STRINGS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// GHC (Glasgow Haskell Compiler) sometimes creates a mergeable</span></span><br><span class="line">    <span class="comment">// string section with entsize of 0 instead of 1, though such</span></span><br><span class="line">    <span class="comment">// entsize is technically wrong. This is a workaround for the issue.</span></span><br><span class="line">    entsize = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> end = <span class="built_in">find_null</span>(data, entsize);</span><br><span class="line">    <span class="keyword">if</span> (end == data.npos)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: string is not null terminated&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, end + entsize);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(end + entsize);</span><br><span class="line"></span><br><span class="line">    rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">    rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">    u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">    rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">    estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">find_null</span><span class="params">(std::string_view data, u64 entsize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">find</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt;= data.<span class="built_in">size</span>() - entsize; i += entsize)</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">substr</span>(i, entsize).<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;\0&#x27;</span>) == data.npos)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data.npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到terminator（’\0’）</li><li>将对应的rec的strings添加找到的str</li><li>添加对应的frag_offsets</li><li>添加string的hash到estimator中</li></ol><p>estimator是用于优化时间的方案，等到最后会提及，不影响合并的正确性。</p><h3 id="split-other"><a href="#split-other" class="headerlink" title="split other"></a>split other</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// OCaml compiler seems to create a mergeable non-string section with</span></span><br><span class="line">    <span class="comment">// entisze of 0. Such section is malformed. We do not split such section.</span></span><br><span class="line">    <span class="keyword">if</span> (entsize == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % entsize)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: section size is not multiple of sh_entsize&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, entsize);</span><br><span class="line">      data = data.<span class="built_in">substr</span>(entsize);</span><br><span class="line"></span><br><span class="line">      rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">      rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">      u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">      rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">      estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>和split string的区别在于不是通过’\0’而是通过entsize判断一个piece的结束位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rec-&gt;parent-&gt;estimator.<span class="built_in">merge</span>(estimator);</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;string_fragments&quot;</span>)</span></span>;</span><br><span class="line">counter += rec-&gt;fragments.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> rec;</span><br></pre></td></tr></table></figure><p>最后的收尾</p><h1 id="ObjectFile-resolve-section-pieces"><a href="#ObjectFile-resolve-section-pieces" class="headerlink" title="ObjectFile::resolve_section_pieces"></a>ObjectFile::resolve_section_pieces</h1><ul><li><input disabled="" type="checkbox"> 如何判断是相同的字符串？？对应地址怎么办</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_section_pieces</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : mergeable_sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      m-&gt;fragments.<span class="built_in">reserve</span>(m-&gt;strings.<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; m-&gt;strings.<span class="built_in">size</span>(); i++)</span><br><span class="line">        m-&gt;fragments.<span class="built_in">push_back</span>(m-&gt;parent-&gt;<span class="built_in">insert</span>(m-&gt;strings[i], m-&gt;hashes[i],</span><br><span class="line">                                                 m-&gt;p2align));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Shrink vectors that we will never use again to reclaim memory.</span></span><br><span class="line">      m-&gt;strings.<span class="built_in">clear</span>();</span><br><span class="line">      m-&gt;hashes.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将所有MergableSection的数据merge到对应的parent中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_abs</span>() || esym.<span class="built_in">is_common</span>() || esym.<span class="built_in">is_undef</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">  <span class="keyword">if</span> (!m)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  i64 frag_offset;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frag)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad symbol value: &quot;</span> &lt;&lt; esym.st_value;</span><br><span class="line"></span><br><span class="line">  sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">  sym.value = frag_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是attach section piece to symbols的过程。本质的操作是将对应的有定义的且非abs的符号关联到对应的fragment。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the size of frag_syms.</span></span><br><span class="line">  i64 nfrag_syms = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections)</span><br><span class="line">    <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx))</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">            esym.st_type == STT_SECTION &amp;&amp; mergeable_sections[<span class="built_in">get_shndx</span>(esym)])</span><br><span class="line">          nfrag_syms++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">resize</span>(nfrag_syms);</span><br></pre></td></tr></table></figure><p>之后寻找满足条件的esym，统计对应的size。</p><p>注意寻找的是ElfRel中的esym，只有ElfRel中的esym才能被relocation，因为merge的过程中必然会修改各种地址信息。</p><p>这里根据sym得到的index获取对应的mergeable_section是在前一步init的过程中初始化的，也就是说这个index对于mergeable_section和原始的section是完全对应的，如果不是mergeable的section则返回的会是空指针。</p><p>接下来是引用mergeable section的relocation symbol，会针对每一个这样的symbol redirect rel sym到一个新创建的dummy到symbol上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For each relocation referring a mergeable section symbol, we create</span></span><br><span class="line"><span class="comment">// a new dummy non-section symbol and redirect the relocation to the</span></span><br><span class="line"><span class="comment">// newly-created symbol.</span></span><br><span class="line">i64 idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type != STT_SECTION)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">    <span class="keyword">if</span> (!m)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    i64 r_addend = <span class="built_in">get_addend</span>(*isec, r);</span><br><span class="line"></span><br><span class="line">    SectionFragment&lt;E&gt; *frag;</span><br><span class="line">    i64 in_frag_offset;</span><br><span class="line">    std::<span class="built_in">tie</span>(frag, in_frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value + r_addend);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frag)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad relocation at &quot;</span> &lt;&lt; r.r_sym;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;frag_syms[idx];</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.<span class="built_in">set_name</span>(<span class="string">&quot;&lt;fragment&gt;&quot;</span>);</span><br><span class="line">    sym.sym_idx = r.r_sym;</span><br><span class="line">    sym.visibility = STV_HIDDEN;</span><br><span class="line">    sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">    sym.value = in_frag_offset - r_addend;</span><br><span class="line">    r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line">    idx++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> i64 <span class="title">get_addend</span><span class="params">(u8 *loc, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rel.r_addend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt;</span><br><span class="line">MergeableSection&lt;E&gt;::<span class="built_in">get_fragment</span>(i64 offset) &#123;</span><br><span class="line">  std::vector&lt;u32&gt; &amp;vec = frag_offsets;</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), offset);</span><br><span class="line">  i64 idx = it - <span class="number">1</span> - vec.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;fragments[idx], offset - vec[idx]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的对新的sym设置了基本信息，主要是进行双向的关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sym.sym_idx = r.r_sym;</span><br><span class="line">r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol:sym_idx</span></span><br><span class="line"><span class="comment">// Index into the symbol table of the owner file.</span></span><br><span class="line">i32 sym_idx = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>这里将rel中的sym指向了elf_syms后面的位置，后面会将执行frag_syms逐一添加到elf_syms之后。</p><p>最后将frag_syms都添加到ObjectFile的symbols中，整个过程就全部结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(idx == <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Symbol&lt;E&gt; &amp;sym : <span class="keyword">this</span>-&gt;frag_syms)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(&amp;sym);</span><br></pre></td></tr></table></figure><h2 id="MergedSection-insert"><a href="#MergedSection-insert" class="headerlink" title="MergedSection::insert"></a>MergedSection::insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SectionFragment&lt;E&gt; *</span><br><span class="line">MergedSection&lt;E&gt;::<span class="built_in">insert</span>(std::string_view data, u64 hash, i64 p2align) &#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_flag, [&amp;] &#123;</span><br><span class="line">    <span class="comment">// We aim 2/3 occupation ratio</span></span><br><span class="line">    map.<span class="built_in">resize</span>(estimator.<span class="built_in">get_cardinality</span>() * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  <span class="keyword">bool</span> inserted;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, inserted) = map.<span class="built_in">insert</span>(data, hash, <span class="built_in">SectionFragment</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">assert</span>(frag);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_maximum</span>(frag-&gt;p2align, p2align);</span><br><span class="line">  <span class="keyword">return</span> frag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br></pre></td></tr></table></figure><p>第一次insert的时候进行预估大小，之后进行insert。</p><p>在看到这里的实现我在想，在merge string的时候是要比较长度吗，在这里我得到了答案，是直接通过之前保存的hash保证unique。</p><p>另外这里用到了estimator，estimator的类型是hyperloglog，根据注释</p><blockquote><p>This file implements HyperLogLog algorithm, which estimates the number of unique items in a given multiset.</p></blockquote><p>谷歌的结果是这样的</p><blockquote><p>HyperLogLog is <strong>an algorithm for the count-distinct problem, approximating the number of distinct elements in a multiset</strong><br>. Calculating the exact cardinality of the distinct elements of a multiset requires an amount of memory proportional to the cardinality, which is impractical for very large data sets.</p></blockquote><p>有兴趣的可以去看wiki或者更多资料，这不在此系列博客的研究范围内。</p><h1 id="整个过程的回顾"><a href="#整个过程的回顾" class="headerlink" title="整个过程的回顾"></a>整个过程的回顾</h1><p>resolve_section_pieces由两部分操作组成</p><ol><li>针对所有mergeable的段进行split，将InputSection转换为对应的MergeableSection</li><li>针对所有MergeableSection进行merge<ol><li>strings Merge到相关联的MergedSection中</li><li>symbols attach to piece section</li><li>针对rel的symbol关联到一个新创建的dummy的symbol上</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-4-mergeab</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="Section" scheme="https://fusionbolt.github.io/tags/Section/"/>
    
  </entry>
  
  <entry>
    <title>1984</title>
    <link href="https://fusionbolt.github.io/2023/04/09/Reading/1984/"/>
    <id>https://fusionbolt.github.io/2023/04/09/Reading/1984/</id>
    <published>2023-04-09T09:16:34.000Z</published>
    <updated>2023-04-09T09:20:55.444Z</updated>
    
    <content type="html"><![CDATA[<p>未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。</p><blockquote><p>是老派改革家想象中那种愚蠢快乐主义乌托邦的精确对立面。一个恐惧、背叛与折磨的世界，一个践踏与被践踏的世界，一个在变得更精致的同时会变得更加残酷，而非更不残酷的世界。我们这个世界里的进步，会是朝向带来更多痛苦的进步。</p></blockquote><p>而人们所在的世界，其实更仅一步来说是由所在的社会构成，社会的构成又很大程度归结于所在国家的权力机构。我一直在想人们对于“关注政治和社会问题”这个问题本身应该怀有怎样的态度，至少我一直是不太关心，也不想去关心。但读完了这本书似乎让我对这个问题的想法产生了一些变化。起源于温斯顿和茱莉亚的交流过程，茱莉亚是一个学会在这种环境下生存的人，也会认为这个环境很蠢，但是不愿去谈论这些。当温斯顿和她讲述关于一些党的内容却是毫不关心。</p><blockquote><p>对于党内教条的种种分支，她连一点兴趣都没有。每次他开始讲到英社的种种原则、双重思想、过去的易变性、对客观现实的否定，还有用到新语字汇时，她就会变得既无聊又困惑，还说她从来不去注意那种事情。你知道那全都是废话，那么为什么要让自己去操心那个？</p></blockquote><p>而在后面的内容作者讲述了这样一段的内容</p><blockquote><p>他们可以被动地接受最明目张胆的违反现实，因为他们从来没有彻底掌握到他们受到的要求是多么大的罪恶，对于公共事件也不够有兴趣，不足以注意到发生了什么事。因为缺乏理解力，他们保持心智健全。他们就只是把什么都吞下去，就像一颗玉米粒完全未经消化，就通过了一只鸟的身体。</p></blockquote><p>这个世界是很残酷的，当读到这些内容，我觉得作者很明显是想告诉我们应该意识到问题，而不应该无视这一切。关于政治问题，基于国情似乎已经没什么办法，但是关于社会问题与我们越来越息息相关，比如说前两年的疫情的情况，比如说退休年龄的变动。而我想这个问题也可以引申为人们对于外在信息的态度，不应当照单全收，而是应该去思考，否则很容易受到欺骗。虽然受到过一些要敢于怀疑答案和质疑的教育，但是似乎并没有留下多深的印象，在我写这部分内容之前已经忘却了大半。不管你怎么处理，首先要自己主动去理解，遇到错误的时候也不是所有的事情都能去纠正的。</p><p>而书中也谈及了许多社会相关的一些根源问题。印象深刻的是阶级的固化这部分内容，我认为在上层的人想要巩固自己阶级的位置，下层的人未曾想过也很难去改变，中间层的人大多又向上爬，或许这也是阶级的本质。而作者也表达出了类似的观点：</p><blockquote><p>就算在极大的动乱与看似无法挽回的改变之后，同样的模式总是会自动重新确立，就像一个陀螺仪不管朝着此方或彼方推得多用力，总是会回归均衡状态。</p></blockquote><p>我想也正因如此，1984的世界中强权者才肯放任“最下层”的普罗阶级，因为他们不会去想改变这些，只想留在原地，同时在文化和信息的限制下他们也无法习得去改变这一行为，只是去对党员进行十分严格的管制。温斯顿一直认为“希望在普罗阶级”，“普罗阶级一直保持人性。他们并没有变得心如铁石。他们坚守着他自己必须刻意努力重新学习的那些原始情绪。“，换个角度来说为了维持稳定，党员们这些所谓的“人性”都要被扼杀。</p><p>前面提到了阶级，那么平等问题是不可避免要被提及的，产生了阶级就意味着不平等。但是平等的话上位人就无法获得权力，以下是作者的观点：</p><blockquote><p>不平等是文明的代价。然而随着机器制造的发展，状况改变了。就算人类还是必须做不同类型的工作，他们却不再有必要过着社会或经济水平不同的生活。所以，在即将攫取权力的新群体眼中，人类的平等不再是值得奋起争取的理想，而是一个必须回避的危险。</p></blockquote><p>本文开头提到的《美丽新世界》尽管是人们富足快乐的世界，但是同样存在着上面所诉说的一些问题，并且和1984一切同样都是建立在强权统治下。相对于《美丽新世界》来说1984有些许多可以对比谈论的问题。在两个世界中，强权者都做了许多事情来避免大多数人们来动摇自己的权力。</p><p>首先是文化与信息上。两者都在避免人们了解过去了，不过一个是隐藏，一个是修改与破坏。同时在通过各种手段“修改与限制”人们的<strong>独立思考</strong>，一个是从小开始进行反复洗脑催眠，另一个则是出动”思想警察“来限制人们。正如1984中所说</p><blockquote><p>因为要是所有人都享有同样的闲暇与安全，在常态下被贫困弄得傻头傻脑的绝大多数人类都会变得有文化学识，也将学会如何为自己思考，而他们一旦做到这件事，他们迟早会领悟到掌握特权的少数根本没有用处，他们会把那些人扫到一旁去。长期来说，阶级社会只有在贫穷与无知的基础上才可能成立</p></blockquote><p>两者都谈到了技术的停滞，新世界的技术是为了稳定，因为科技、真理代表破坏现有的平衡，而1984则是为了限制自由，甚至只有在技术产物能够透过某种方式缩减人类的自由时，技术的进步才会发生。但是对于强权者来说，本质都是为了巩固自己的权力。</p><p>但对待大多数人们的态度是完全不同的。一个类似于让人们共同富裕，催眠洗脑，乐不思蜀，另一个类似于压迫，强权，威吓。但是两者又都明确了阶级，在美丽新世界中是不同的人种，同时又会对这些人种进行催眠，让他们觉得自己就应该做当前的事情，1984中则是明确区分了党员和普罗阶级，对于违反规定的党员进行最恐怖的制裁，使得他们“心甘情愿”产生改变。让我印象最深刻的是这样一句话：</p><blockquote><p>早就期待着的子弹进入了他的大脑。</p></blockquote><p>相比起1984来说，新世界确实非常美好。这个世界到底会走向什么样子呢？就目前的情况来说我想并不会那么乐观，至少对于大部分的地方如此。想要超越别人、掌控别人我觉得是人类作为动物的兽性中衍生出的一部分，那么也不可避免的有许多人会去追求权力，最后有人为了巩固强权做出什么也不奇怪。而在这样的世界中，大部分人能做的或许只有去学着不被动接受外部的信息，多进行独立思考，作者也许是想要警醒人们，并且试着影响读者们这样来做，至少能够一定程度上推迟或者避免这样的世界到来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是老派改革家想象中那种愚蠢快乐主义乌托邦的</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="赫胥黎" scheme="https://fusionbolt.github.io/tags/%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其三 符号决议</title>
    <link href="https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/"/>
    <id>https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/</id>
    <published>2023-04-09T08:06:20.000Z</published>
    <updated>2023-04-09T08:11:35.212Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-3-symbol-resolve/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:72272420</center> <p>前面两期将读取输入的部分全部讲完了，本期开始涉及链接过程中的处理。在讲主要的符号决议之前，先讲一下mold在符号决议执行之前做的一些其他处理。</p><h1 id="dso-uniquely"><a href="#dso-uniquely" class="headerlink" title="dso uniquely"></a>dso uniquely</h1><p>在读取完输入后首先做的是将shared object根据soname进行去重，因此我们可以在链接的过程中链接多个相同soname的库而不会产生冲突。</p><p>elf/main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unordered_set&lt;std::string_view&gt; seen;</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">return</span> !seen.<span class="built_in">insert</span>(file-&gt;soname).second;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="apply-exclude-libs"><a href="#apply-exclude-libs" class="headerlink" title="apply_exclude_libs"></a>apply_exclude_libs</h1><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_exclude_libs</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_exclude_libs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.exclude_libs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unordered_set&lt;std::string_view&gt; <span class="title">set</span><span class="params">(ctx.arg.exclude_libs.begin(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ctx.arg.exclude_libs.end())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;archive_name.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">if</span> (set.<span class="built_in">contains</span>(<span class="string">&quot;ALL&quot;</span>) ||</span><br><span class="line">          set.<span class="built_in">contains</span>(<span class="built_in">filepath</span>(file-&gt;archive_name).<span class="built_in">filename</span>().<span class="built_in">string</span>()))</span><br><span class="line">        file-&gt;exclude_libs = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是简单将所有包含在exclude-libs里的lib名字对应的exclude_libs设置为true，而这个设置在后面符号决议的过程会用到。</p><p>exclude_libs是命令行中获取的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_arg</span>(<span class="string">&quot;exclude-libs&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">append</span>(ctx.arg.exclude_libs, <span class="built_in">split_by_comma_or_colon</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="create-internal-file"><a href="#create-internal-file" class="headerlink" title="create_internal_file"></a>create_internal_file</h1><h2 id="internal-file是什么"><a href="#internal-file是什么" class="headerlink" title="internal file是什么"></a>internal file是什么</h2><p>内部的文件，用来保存linker-synthesized符号。linker-synthesized符号或许也可以理解为编译产物中不存在的符号。作为一个并不实际存在的文件，依然会作为一个普通的ObjFile加入到obj_pool中，主要用途是在create_output_sections以后来add_synthetic_symbol，与之相关联的有一个internal_esyms，里面都是具体相关的符号。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在main函数中调用是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.arg.relocatable)</span><br><span class="line">  <span class="built_in">create_internal_file</span>(ctx);</span><br></pre></td></tr></table></figure><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_internal_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;;</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  ctx.internal_obj = obj;</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(obj);</span><br><span class="line"></span><br><span class="line">  ctx.internal_esyms.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(<span class="keyword">new</span> Symbol&lt;E&gt;);</span><br><span class="line">  obj-&gt;first_global = <span class="number">1</span>;</span><br><span class="line">  obj-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  obj-&gt;priority = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>首先创建了基本的ObjectFile对象并且进行了一些初始化的处理。</p><p>之后添加从命令行参数中读取的–defsym里的所有的defsym</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  std::pair&lt;Symbol&lt;E&gt; *, std::variant&lt;Symbol&lt;E&gt; *, u64&gt;&gt; &amp;defsym = ctx.arg.defsyms[i];</span><br><span class="line">  <span class="built_in">add</span>(defsym.first);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::holds_alternative&lt;Symbol&lt;E&gt; *&gt;(defsym.second)) &#123;</span><br><span class="line">    <span class="comment">// Add an undefined symbol to keep a reference to the defsym target.</span></span><br><span class="line">    <span class="comment">// This prevents elimination by e.g. LTO or gc-sections.</span></span><br><span class="line">    <span class="comment">// The undefined symbol will never make to the final object file; we</span></span><br><span class="line">    <span class="comment">// double-check that the defsym target is not undefined in</span></span><br><span class="line">    <span class="comment">// fix_synthetic_symbols.</span></span><br><span class="line">    <span class="keyword">auto</span> sym = std::get&lt;Symbol&lt;E&gt; *&gt;(defsym.second);</span><br><span class="line">    <span class="built_in">add_undef</span>(sym);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完defsym后再从命令行参数中读取的SectionOrder的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">  <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">get_symbol</span>(ctx, ord.name));</span><br></pre></td></tr></table></figure><p>关于SectionOrder的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOrder</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br><span class="line">  std::string name;</span><br><span class="line">  u64 value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后设置obj类的一些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;elf_syms = ctx.internal_esyms;</span><br><span class="line">obj-&gt;symvers.<span class="built_in">resize</span>(ctx.internal_esyms.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="defsym"><a href="#defsym" class="headerlink" title="defsym"></a>defsym</h2><p>关于前面提到的defsym，我们来看一下mold的测试代码一部分来理解其作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | $CC -fPIC -o $t/a.o -c -xc -</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> foo;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %p %p\n&quot;</span>, &amp;foo, &amp;bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">baz</span>();</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$CC -B. -o $t/exe $t/a.o -pie -Wl,-defsym=foo=<span class="number">16</span> \</span><br><span class="line">  -Wl,-defsym=bar=<span class="number">0x2000</span> -Wl,-defsym=baz=print</span><br><span class="line"></span><br><span class="line">$QEMU $t/exe | grep -q <span class="string">&#x27;^Hello 0x10 0x2000$&#x27;</span></span><br></pre></td></tr></table></figure><p>通过defsym指定了符号名以及其实现的位置，尽管对应的符号在代码中并没有实现。</p><p>关于这里的add和add_undef的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An actual value will be set to a linker-synthesized symbol by</span></span><br><span class="line">  <span class="comment">// fix_synthetic_symbols(). Until then, `value` doesn&#x27;t have a valid</span></span><br><span class="line">  <span class="comment">// value. 0xdeadbeef is a unique dummy value to make debugging easier</span></span><br><span class="line">  <span class="comment">// if the field is accidentally used before it gets a valid one.</span></span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_ABS;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_undef = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_UNDEF;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过add和add_undef函数把defsym指定的符号添加到symbols中，并且设定为了特殊值，关联到了一个esym里。主要的差别就在于st_shndx被设置为了不同的值。</p><h1 id="符号决议"><a href="#符号决议" class="headerlink" title="符号决议"></a>符号决议</h1><p>接下来是链接过程中比较重要的一个环节，符号决议（symbol resolve）</p><p>在mold中，这个部分做了四件事情</p><ol><li>检测所有需要使用的objet files</li><li>移除重复的COMDAT段</li><li>进行符号决议的过程。在多个不同的esym中选择出一个更高priority的关联到sym中</li><li>LTO的处理，处理后再次执行决议</li></ol><h2 id="resolve-symbols"><a href="#resolve-symbols" class="headerlink" title="resolve_symbols"></a>resolve_symbols</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">  std::vector&lt;SharedFile&lt;E&gt; *&gt; dsos = ctx.dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先省略lto相关的具体处理，很多处理和do_resolve_symbols中是类似的，因此放到后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> for_each_file = [&amp;](std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; fn) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, fn);</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 1. 检测object files</span></span><br><span class="line"><span class="comment">// 2. 消除重复COMDAT</span></span><br><span class="line"><span class="comment">// 3. 符号决议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-检测object-files"><a href="#1-检测object-files" class="headerlink" title="1. 检测object files"></a>1. 检测object files</h2><p>archive extraction: .a成员只会在满足非archive object文件未定义符号之一的情况下才会被包含在最终的二进制文件中</p><p>链接时为了满足archive extraction的规则，mold采取的策略是：</p><ol><li>初步resolve：假设全部include，match undef符号</li><li>mark sweep消除无需使用的archive成员</li><li>删除掉非archive成员</li></ol><p>下面是具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;extract_archive_members&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register symbols</span></span><br><span class="line">    for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark reachable objects to decide which files to include into an output.</span></span><br><span class="line">    <span class="comment">// This also merges symbol visibility.</span></span><br><span class="line">    <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup. The rule used for archive extraction isn&#x27;t accurate for the</span></span><br><span class="line">    <span class="comment">// general case of symbol extraction, so reset the resolution to be redone</span></span><br><span class="line">    <span class="comment">// later.</span></span><br><span class="line">    for_each_file([](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">clear_symbols</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that the symbol references are gone, remove the eliminated files from</span></span><br><span class="line">    <span class="comment">// the file list.</span></span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.objs, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>for_each_file针对objs和dsos处理resolve，mark live，clear，erase file</li><li>标记所有可访问的输出到文件的object，之后合并可见性</li><li>清除file的symbols</li><li>最后清除掉objs和dsos中非alive的file</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;thread&quot;</span>)))</span><br><span class="line"><span class="keyword">void</span> InputFile&lt;E&gt;::<span class="built_in">clear_symbols</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="built_in">get_global_syms</span>())</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      sym-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mark-live-objects"><a href="#mark-live-objects" class="headerlink" title="mark_live_objects"></a>mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_live_objects</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mark_symbol = [&amp;](std::string_view name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (InputFile&lt;E&gt; *file = <span class="built_in">get_symbol</span>(ctx, name)-&gt;file)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputFile&lt;E&gt; *&gt; roots;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(roots, [&amp;](InputFile&lt;E&gt; *file,</span><br><span class="line">                                    tbb::feeder&lt;InputFile&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      file-&gt;<span class="built_in">mark_live_objects</span>(ctx, [&amp;](InputFile&lt;E&gt; *obj) &#123; feeder.<span class="built_in">add</span>(obj); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对所有参数中传入的undef以及require_define的符号所关联的文件进行mark，之后遍历所有alive的obj和dso，加入到root中，之后再进行mark_live_objects。部分文件会因为特殊的链接选项，比如说whole-archive会影响是否设置为is_alive，这部分会之后再以这个为主题单独讲一篇。</p><p>对于ObjectFile和SharedFile的mark方式也是不同的。</p><h3 id="ObjectFile-mark-live-objects"><a href="#ObjectFile-mark-live-objects" class="headerlink" title="ObjectFile::mark_live_objects"></a>ObjectFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;is_alive);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>() &amp;&amp; exclude_libs)</span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, STV_HIDDEN);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, esym.st_visibility);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_weak</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sym.file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> keep = esym.<span class="built_in">is_undef</span>() || (esym.<span class="built_in">is_common</span>() &amp;&amp; !sym.<span class="built_in">esym</span>().<span class="built_in">is_common</span>());</span><br><span class="line">    <span class="keyword">if</span> (keep &amp;&amp; <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有global的符号进行处理。</p><ol><li><p>首先对esym进行merge_visibility，对于存在定义的exclude_libs的符号来说是HIDDEN的，关于这一点在命令行参数处有说明。</p><blockquote><p>-exclude-libs LIB,LIB,.. Mark all symbols in given libraries hidden</p></blockquote></li><li><p>跳过弱符号以及文件不存在的符号。</p></li><li><p>keep并且fast_mark成功的符号加入到root中。</p></li></ol><p>keep这里需要是undef的情况，我认为是因为如果esym存在定义，那么定义就是存在于当前的ObjectFile中，也就不需要再重复加入到root中了。common我想同样是因为这种情况下所在的文件已经加入到root中了。</p><p>关于merge_visibility</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">merge_visibility</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                     u8 visibility) &#123;</span><br><span class="line">  <span class="comment">// Canonicalize visibility</span></span><br><span class="line">  <span class="keyword">if</span> (visibility == STV_INTERNAL)</span><br><span class="line">    visibility = STV_HIDDEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = [&amp;](u8 visibility) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (visibility) &#123;</span><br><span class="line">    <span class="keyword">case</span> STV_HIDDEN:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_PROTECTED:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_DEFAULT:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unknown symbol visibility: &quot;</span> &lt;&lt; sym;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_minimum</span>(sym.visibility, visibility, [&amp;](u8 a, u8 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">priority</span>(a) &lt; <span class="built_in">priority</span>(b);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先将INTERNAL转换为HIDDEN，之后按照最小的priority来更新visibility。</p><p>update_minimum只是一个针对多线程的封装，本质上是一个compare and exchange操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">update_minimum</span>(std::atomic&lt;T&gt; &amp;atomic, u64 new_val, Compare cmp = &#123;&#125;) &#123;</span><br><span class="line">  T old_val = atomic.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cmp</span>(new_val, old_val) &amp;&amp;</span><br><span class="line">         !atomic.<span class="built_in">compare_exchange_weak</span>(old_val, new_val,</span><br><span class="line">                                       std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fast_mark也是针对多线程的一个封装，如果是false则更新为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An optimized &quot;mark&quot; operation for parallel mark-and-sweep algorithms.</span></span><br><span class="line"><span class="comment">// Returns true if `visited` was false and updated to true.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fast_mark</span><span class="params">(std::atomic&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A relaxed load + branch (assuming miss) takes only around 20 cycles,</span></span><br><span class="line">  <span class="comment">// while an atomic RMW can easily take hundreds on x86. We note that it&#x27;s</span></span><br><span class="line">  <span class="comment">// common that another thread beat us in marking, so doing an optimistic</span></span><br><span class="line">  <span class="comment">// early test tends to improve performance in the ~20% ballpark.</span></span><br><span class="line">  <span class="keyword">return</span> !visited.<span class="built_in">load</span>(std::memory_order_relaxed) &amp;&amp;</span><br><span class="line">         !visited.<span class="built_in">exchange</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SharedFile-mark-live-objects"><a href="#SharedFile-mark-live-objects" class="headerlink" title="SharedFile::mark_live_objects"></a>SharedFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; !sym.file-&gt;is_dso &amp;&amp;</span><br><span class="line">        <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说的唯一一点是因为mark的是object而不是shared file，因此dso的情况下不会进行mark</p><h2 id="2-移除重复的COMDAT段"><a href="#2-移除重复的COMDAT段" class="headerlink" title="2. 移除重复的COMDAT段"></a>2. 移除重复的COMDAT段</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;eliminate_comdats&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">eliminate_duplicate_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="built_in">update_minimum</span>(ref.group-&gt;owner, <span class="keyword">this</span>-&gt;priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新所有comdat_groups的priority</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">eliminate_duplicate_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="keyword">if</span> (ref.group-&gt;owner != <span class="keyword">this</span>-&gt;priority)</span><br><span class="line">      <span class="keyword">for</span> (u32 i : ref.members)</span><br><span class="line">        <span class="keyword">if</span> (sections[i])</span><br><span class="line">          sections[i]-&gt;<span class="built_in">kill</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eliminate重复的section。将section和fde的is_alive都设置为false。</p><p>这里将fde设置为false正对应了上期提到单独解析eh_frame的原因之一：消除重复的fde。</p><h2 id="3-实际进行符号决议的过程"><a href="#3-实际进行符号决议的过程" class="headerlink" title="3. 实际进行符号决议的过程"></a>3. 实际进行符号决议的过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>resolve_symbols的实现对于ObjectFile和SharedFile是不同的</p><h3 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    InputSection&lt;E&gt; *isec = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>() &amp;&amp; !esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">      isec = <span class="built_in">get_section</span>(esym);</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, !<span class="keyword">this</span>-&gt;is_alive) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(isec);</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = ctx.default_version;</span><br><span class="line">      sym.is_weak = esym.<span class="built_in">is_weak</span>();</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号决议是针对global symbol的elf_sym的。未定义的esym都跳过了，它们都不需要参与resolve的过程，因为resolve本质是找到需要加入到生成产物的符号实现，但是注意在前面mark的时候还是需要的。</p><p>也就是说Symbol类的sym其实是保留的最终唯一定义。而在决议的过程，不断的将esym和对应的sym进行比较。如果esym的rank小，也就是更加优先，那么就将sym中的信息更新为对应的esym的信息，这就是实际决议过程中做的事情。而这里也是实际初始化symbols成员里global的值的地方，local的部分初始化在parse的阶段就做好了，因为local的符号并不需要进行resolve。</p><h3 id="get-rank"><a href="#get-rank" class="headerlink" title="get_rank"></a>get_rank</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(<span class="keyword">const</span> Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!sym.file)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rank</span>(sym.file, sym.<span class="built_in">esym</span>(), !sym.file-&gt;is_alive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols with higher priorities overwrites symbols with lower priorities.</span></span><br><span class="line"><span class="comment">// Here is the list of priorities, from the highest to the lowest.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Strong defined symbol</span></span><br><span class="line"><span class="comment">//  2. Weak defined symbol</span></span><br><span class="line"><span class="comment">//  3. Strong defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  4. Weak Defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  5. Common symbol</span></span><br><span class="line"><span class="comment">//  6. Common symbol in an archive</span></span><br><span class="line"><span class="comment">//  7. Unclaimed (nonexistent) symbol</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ties are broken by file priority.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(InputFile&lt;E&gt; *file, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym, <span class="keyword">bool</span> is_lazy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!file-&gt;is_dso);</span><br><span class="line">    <span class="keyword">if</span> (is_lazy)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">6</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file-&gt;is_dso || is_lazy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">4</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_rank的实现，根据注释我们可以看到不同类别符号的优先级。</p><h3 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, <span class="literal">false</span>) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.origin = <span class="number">0</span>;</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = versyms[i];</span><br><span class="line">      sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于SharedFile中的符号中不需要考虑是否是global的问题，上期解析SharedFile的部分也有提到，对应的first_global就是0。相对于</p><h2 id="4-LTO的处理"><a href="#4-LTO的处理" class="headerlink" title="4. LTO的处理"></a>4. LTO的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">  <span class="comment">// Do link-time optimization. We pass all IR object files to the</span></span><br><span class="line">  <span class="comment">// compiler backend to compile them into a few ELF object files.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The compiler backend needs to know how symbols are resolved,</span></span><br><span class="line">  <span class="comment">// so compute symbol visibility, import/export bits, etc early.</span></span><br><span class="line">  <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line">  <span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line">  <span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line">  <span class="built_in">compute_import_export</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do LTO. It compiles IR object files into a few big ELF files.</span></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; lto_objs = <span class="built_in">do_lto</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do_resolve_symbols() have removed unreferenced files. Restore the</span></span><br><span class="line">  <span class="comment">// original files here because some of them may have to be resurrected</span></span><br><span class="line">  <span class="comment">// because they are referenced by the ELF files returned from do_lto().</span></span><br><span class="line">  ctx.objs = objs;</span><br><span class="line">  ctx.dsos = dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">append</span>(ctx.objs, lto_objs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redo name resolution from scratch.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_needed;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove IR object files.</span></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_lto_obj)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> file-&gt;is_lto_obj; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于apply_version_script, parse_symbol_version, compute_import_export这三个过程，会在之后的过程中讲解。这里简单来讲就是获取符号对应的版本信息以及对应import/export的属性。</p><p>这个部分做了这么几件事情</p><ol><li>计算出符号所需的基本信息</li><li>实际执行lto</li><li>将lto结果的object加入到全局</li><li>清理旧的lto文件</li><li>再次执行do_resolve_symbols整个过程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-3-symbol-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="symbol_resolve" scheme="https://fusionbolt.github.io/tags/symbol-resolve/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其二 读取SharedFile</title>
    <link href="https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/"/>
    <id>https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/</id>
    <published>2023-04-05T08:35:27.000Z</published>
    <updated>2023-04-05T08:50:32.743Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:70054356</center> <p>这期的内容主要是讲完读取输入的部分，有一些之前遗漏的信息，以及之前未讲完的初始化ehframe以及shared object读取的部分。有许多地方默认读者读过上期内容，建议先阅读上期内容后再来查看本期。</p><p><a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/" >https://homura.live/2023/02/26/mold/mold-1-read-input-files/<i class="fas fa-external-link-alt"></i></a></p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="get-string"><a href="#get-string" class="headerlink" title="get_string"></a>get_string</h2><p>之前在读取符号表的时候是通过这种方式读取的，但我们没有讲解这个读取的细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br></pre></td></tr></table></figure><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(idx &lt; elf_sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index: &quot;</span> &lt;&lt; idx;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  u8 *begin = mf-&gt;data + shdr.sh_offset;</span><br><span class="line">  u8 *end = begin + shdr.sh_size;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; end)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: section header is out of range: &quot;</span> &lt;&lt; shdr.sh_offset;</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)begin, (<span class="keyword">size_t</span>)(end - begin)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是找到文件中对应offset的data作为开始，根据长度构造一个<strong>string_view</strong>，注意这里并不是实际构造了一个string，因此返回的string并没有这块空间的所有权。</p><p>由get_string衍生出来的方法还有get_data，之前在读取elfsyms的时候就是使用了get_data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  std::string_view view = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shdr);</span><br><span class="line">  <span class="keyword">if</span> (view.<span class="built_in">size</span>() % <span class="built_in"><span class="keyword">sizeof</span></span>(T))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted section&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;(T *)view.<span class="built_in">data</span>(), view.<span class="built_in">size</span>() / <span class="built_in"><span class="keyword">sizeof</span></span>(T)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt; InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;T&gt;(elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接获取了get_string的结果，并且将对应的结果映射为了一个对应数据的span</p><h2 id="get-shndx"><a href="#get-shndx" class="headerlink" title="get_shndx"></a>get_shndx</h2><p>在之前从符号表取数据的时候是通过get_shndx实现的</p><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 ObjectFile&lt;E&gt;::<span class="built_in">get_shndx</span>(<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(&amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>] &lt;= &amp;esym);</span><br><span class="line">  <span class="built_in">assert</span>(&amp;esym &lt;= &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.st_shndx == SHN_XINDEX)</span><br><span class="line">    <span class="keyword">return</span> symtab_shndx_sec[&amp;esym - &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">return</span> esym.st_shndx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然符号中是有对应的shndx字段，但是这个字段的长度为16bit，如果超出这个长度的index那么需要去symtab_shndx_sec中获取。</p><p>这个限制在之前读取输入的时候多次遇到，比如说在构造InputFile类，读取shstrtab_idx的时候</p><p>input-files.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line"><span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">  ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br></pre></td></tr></table></figure><h2 id="eh-frame"><a href="#eh-frame" class="headerlink" title="eh_frame"></a>eh_frame</h2><p>eh_frame段对于大多数人来说比较陌生，因此首先来讲解eh_frame是什么。eh_frame是包含了记录如何处理异常信息的段，当异常抛出的时候runtime会寻找一个eh_frame记录的信息并且来处理。</p><p>我们来看一下hello world的汇编</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.section__TEXT,__text,regu</span><br><span class="line">lar,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">12</span>, <span class="number">0</span>sdk_version <span class="number">12</span>, <span class="number">1</span></span><br><span class="line">.globl_main                           ; -- Begin function main</span><br><span class="line">.p2align<span class="number">2</span></span><br><span class="line">_main:                                  ; @main</span><br><span class="line">.cfi_startproc</span><br><span class="line">; %bb<span class="number">.0</span>:</span><br><span class="line">subsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">stpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Spill</span><br><span class="line">addx29, sp, #<span class="number">16</span>                    ; =<span class="number">16</span></span><br><span class="line">.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">.cfi_offset w30, <span class="number">-8</span></span><br><span class="line">.cfi_offset w29, <span class="number">-16</span></span><br><span class="line">movw8, #<span class="number">0</span></span><br><span class="line">strw8, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Spill</span><br><span class="line">sturwzr, [x29, #<span class="number">-4</span>]</span><br><span class="line">adrpx0, l_.str@PAGE</span><br><span class="line">addx0, x0, l_.str@PAGEOFF</span><br><span class="line">bl_printf</span><br><span class="line">ldrw0, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Reload</span><br><span class="line">ldpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Reload</span><br><span class="line">addsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">.section__TEXT,__cstring,cstring_literals</span><br><span class="line">l_.str:                                 ; @.str</span><br><span class="line">.asciz<span class="string">&quot;Hello world\n&quot;</span></span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>关于eh_frame我有一个疑问，是否能像符号一样被strip掉？手动strip以后发现elf大小并没有发生改变。关于这个问题stackoverflow有这样一条回答</p><p><a class="link"   href="https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section" >Why GCC compiled C program needs .eh_frame section?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>You can disable generation of .eh_frame with -fno-asynchronous-unwind-tables for individual translation units, and this mostly eliminates the size cost</p></blockquote><blockquote><p>You cannot strip them with the strip command later; since .eh_frame is a section that lives in the loaded part of the program (this is the whole point), stripping it modifies the binary in ways that break it at runtime.</p></blockquote><p>大意是不能通过strip消除，但是eh_frame在gcc中可以通过开启特殊的编译选项避免生成。</p><h3 id="eh-frame的结构"><a href="#eh-frame的结构" class="headerlink" title="eh_frame的结构"></a>eh_frame的结构</h3><p><a class="link"   href="https://refspecs.linuxbase.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html" >Exception Frames<i class="fas fa-external-link-alt"></i></a></p><p>这里不详细介绍里面的具体字段了。简单来说，每个eh_frame段中会包含至少一个CFI（Call Frame Information），而每个CFI包含一个CIE（Common Information Entry），之后紧接着跟着许多FDE（Frame Description Entry）</p><p>一个CFI对应了一个单一的object文件，如果是多个object文件合并那么就会有多个，因此至少存在一个。CFI中包含了一个CIE，也就是这个object里的common information，而后面跟随的许多FDE则是对应了各个function。</p><p>这里引用一下MaskRay聚聚的资料，里面包含了更具体严谨的描述。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%201.png"                      alt="Untitled"                ></p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>对于链接器来说，ehframe和其他段不同是单独进行parse的。注释中给出了以下几条原因</p><ol><li>避免大量dead section的字段。如果只是最后拷贝所有的eh_frame则会有许多针对dead section的字段。</li><li>减少section的大小。删除function的时候顺便删除FDE，所以eh_frame不包含dead FDE。</li><li>增加搜索效率。扫描eh_frame段查找一个record是一个O(n)操作，通过linker创建一个sorted list后可以通过二分查找降低复杂度到O(log n)。</li></ol><p>接下来我们看一下具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">read_ehframe</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec) &#123;</span><br><span class="line">  std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  i64 cies_begin = cies.<span class="built_in">size</span>();</span><br><span class="line">  i64 fdes_begin = fdes.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// Read CIEs and FDEs until empty.</span></span><br><span class="line">std::string_view contents = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, isec.<span class="built_in">shdr</span>());</span><br><span class="line">i64 rel_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::string_view data = contents; !data.<span class="built_in">empty</span>();) &#123;</span><br><span class="line">    i64 size = *(U32&lt;E&gt; *)data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    i64 begin_offset = data.<span class="built_in">data</span>() - contents.<span class="built_in">data</span>();</span><br><span class="line">    i64 end_offset = begin_offset + size + <span class="number">4</span>;</span><br><span class="line">    i64 id = *(U32&lt;E&gt; *)(data.<span class="built_in">data</span>() + <span class="number">4</span>);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(size + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    i64 rel_begin = rel_idx;</span><br><span class="line">    <span class="keyword">while</span> (rel_idx &lt; rels.<span class="built_in">size</span>() &amp;&amp; rels[rel_idx].r_offset &lt; end_offset)</span><br><span class="line">      rel_idx++;</span><br><span class="line">    <span class="built_in">assert</span>(rel_idx == rels.<span class="built_in">size</span>() || begin_offset &lt;= rels[rel_begin].r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// This is CIE.</span></span><br><span class="line">      cies.<span class="built_in">emplace_back</span>(ctx, *<span class="keyword">this</span>, isec, begin_offset, rels, rel_begin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is FDE.</span></span><br><span class="line">      <span class="keyword">if</span> (rel_begin == rel_idx || rels[rel_begin].r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// FDE has no valid relocation, which means FDE is dead from</span></span><br><span class="line">        <span class="comment">// the beginning. Compilers usually don&#x27;t create such FDE, but</span></span><br><span class="line">        <span class="comment">// `ld -r` tend to generate such dead FDEs.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[rel_begin].r_offset - begin_offset != <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: FDE&#x27;s first relocation should have offset 8&quot;</span>;</span><br><span class="line"></span><br><span class="line">      fdes.<span class="built_in">emplace_back</span>(begin_offset, rel_begin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据这个解析过程以及参考格式描述我们能够画出这样一张图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%202.png"                      alt="Untitled"                ></p><p>在读取完所有基本的段以后，将CIE关联到FDE中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> find_cie = [&amp;](i64 offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = cies_begin; i &lt; cies.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (cies[i].input_offset == offset)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: bad FDE pointer&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  i64 cie_offset = *(I32&lt;E&gt; *)(contents.<span class="built_in">data</span>() + fdes[i].input_offset + <span class="number">4</span>);</span><br><span class="line">  fdes[i].cie_idx = <span class="built_in">find_cie</span>(fdes[i].input_offset + <span class="number">4</span> - cie_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将FDE关联到InputSection中。注意这里进行了stable_sort，上面提到的第三条增加搜索效率就是通过这里实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">stable_sort</span>(fdes.<span class="built_in">begin</span>() + fdes_begin, fdes.<span class="built_in">end</span>(),</span><br><span class="line">                 [&amp;](<span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;a, <span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_isec</span>(a)-&gt;<span class="built_in">get_priority</span>() &lt; <span class="built_in">get_isec</span>(b)-&gt;<span class="built_in">get_priority</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>();) &#123;</span><br><span class="line">  InputSection&lt;E&gt; *isec = <span class="built_in">get_isec</span>(fdes[i]);</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;fde_begin == <span class="number">-1</span>);</span><br><span class="line">  isec-&gt;fde_begin = i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; fdes.<span class="built_in">size</span>() &amp;&amp; isec == <span class="built_in">get_isec</span>(fdes[i]))</span><br><span class="line">    i++;</span><br><span class="line">  isec-&gt;fde_end = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个eh_frame部分的初始化就完毕了。</p><h1 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先我们来看一下SharedFile的构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt; *</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf) &#123;</span><br><span class="line">  SharedFile&lt;E&gt; *obj = <span class="keyword">new</span> <span class="built_in">SharedFile</span>(ctx, mf);</span><br><span class="line">  ctx.dso_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">SharedFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_needed = ctx.as_needed;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !ctx.as_needed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分没什么特别要讲的，关于is_needed和is_alive会涉及到关于whole-archive这个选项，之后会再单独开文章讲解。构造基类InputFile之前在ObjectFile的部分已经讲过了，不再赘述。接着来看parse的部分。</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是找到DYNSYM段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNSYM);</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>之后读取符号表和ver信息，这些是Shared only的成员。而soname是针对一个dso的，所以个dso关联一个soname</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">soname = <span class="built_in">get_soname</span>(ctx);</span><br><span class="line">version_strings = <span class="built_in">read_verdef</span>(ctx);</span><br></pre></td></tr></table></figure><p>读取具体的符号信息以及符号版本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read a symbol table.</span></span><br><span class="line">std::span&lt;ElfSym&lt;E&gt;&gt; esyms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line"></span><br><span class="line">std::span&lt;U16&lt;E&gt;&gt; vers;</span><br><span class="line"><span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERSYM))</span><br><span class="line">  vers = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U16&lt;E&gt;&gt;(ctx, *sec);</span><br></pre></td></tr></table></figure><p>对于DYNSYM来说symtab_sec-&gt;sh_info是开始的符号数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = symtab_sec-&gt;sh_info; i &lt; esyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  u16 ver;</span><br><span class="line">  <span class="keyword">if</span> (vers.<span class="built_in">empty</span>() || esyms[i].<span class="built_in">is_undef</span>())</span><br><span class="line">    ver = VER_NDX_GLOBAL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ver = (vers[i] &amp; ~VERSYM_HIDDEN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ver == VER_NDX_LOCAL)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::string_view name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esyms[i].st_name;</span><br><span class="line">  <span class="keyword">bool</span> is_hidden = (!vers.<span class="built_in">empty</span>() &amp;&amp; (vers[i] &amp; VERSYM_HIDDEN));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;elf_syms2.<span class="built_in">push_back</span>(esyms[i]);</span><br><span class="line">  <span class="keyword">this</span>-&gt;versyms.<span class="built_in">push_back</span>(ver);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_hidden) &#123;</span><br><span class="line">    std::string_view mangled_name = <span class="built_in">save_string</span>(</span><br><span class="line">      ctx, std::<span class="built_in">string</span>(name) + <span class="string">&quot;@&quot;</span> + std::<span class="built_in">string</span>(version_strings[ver]));</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, mangled_name, name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个for循环中针对每个符号信息来说做了以下几件事情</p><ol><li><p>处理version信息。</p><ol><li>跳过只有一个VER_NDX_LOCAL属性的</li><li>vers为空或esym未定义，则是global的（大概用于symbol resolve去寻找定义。因此设为了GLOBAL</li><li>不为空且有定义，那么就不是HIDDEN的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_LOCAL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_GLOBAL = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VERSYM_HIDDEN = <span class="number">0x8000</span>;</span><br></pre></td></tr></table></figure></li><li><p>添加elf_syms2（Shared Only的字段）以及versysms</p></li><li><p>处理hidden的符号，hidden的话要mangled才行</p><ul><li><input disabled="" type="checkbox"> 为什么呢…</li></ul></li></ol><p>设置基本信息后结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = elf_syms2;</span><br><span class="line"><span class="keyword">this</span>-&gt;first_global = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;dso_syms&quot;</span>)</span></span>;</span><br><span class="line">counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>这里first_global设置为0，也就是说dso中所有的符号都是global的。</p><h2 id="get-soname"><a href="#get-soname" class="headerlink" title="get_soname"></a>get_soname</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::string SharedFile&lt;E&gt;::<span class="built_in">get_soname</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNAMIC))</span><br><span class="line">    <span class="keyword">for</span> (ElfDyn&lt;E&gt; &amp;dyn : <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfDyn&lt;E&gt;&gt;(ctx, *sec))</span><br><span class="line">      <span class="keyword">if</span> (dyn.d_tag == DT_SONAME)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + dyn.d_val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mf-&gt;given_fullpath)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;filename;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">filepath</span>(<span class="keyword">this</span>-&gt;filename).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到DYNAMIC段，从里面的ElfDyn中查找tag为DT_SONAME的，找不到就用依靠完整文件路径作为soname。</p><p>关于ElfDyn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ElfDyn</span>&lt;</span>RV64LE&gt;     : EL64Dyn &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EL64Dyn</span> &#123;</span></span><br><span class="line">  ul64 d_tag;</span><br><span class="line">  ul64 d_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在elf规范中关于DT_SONAME这个tag的信息</p><table><thead><tr><th>Name</th><th>d_un</th><th>Executable</th><th>Shared Object</th></tr></thead><tbody><tr><td>DT_SONAME</td><td>d_val</td><td>ignored</td><td>optional</td></tr></tbody></table><blockquote><p>This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the DT_STRTAB entry. See “Shared Object Dependencies” below for more information about these names.</p></blockquote><h2 id="verdef"><a href="#verdef" class="headerlink" title="verdef"></a>verdef</h2><blockquote><p>Symbol versioning is a <strong>GNU extension</strong> to the ELF file format.</p></blockquote><blockquote><p>Versions are just strings, and no ordering is defined between them. For example, “GLIBC_2.15” is not considered a newer version of “GLIBC_2.2.5” or vice versa. They are considered just different.</p></blockquote><blockquote><p>If a shared object file has versioned symbols, it contains a parallel array for the symbol table. Version strings can be found in that parallel table.</p></blockquote><blockquote><p>One version is considered the “default” version for each shared object. If an undefiend symbol <code>foo</code> is resolved to a symbol defined by the shared object, it’s marked so that it’ll be resolved to (<code>foo</code>, the default version of the library) at load-time.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::vector&lt;std::string_view&gt; SharedFile&lt;E&gt;::<span class="built_in">read_verdef</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">std::vector&lt;std::string_view&gt; <span class="title">ret</span><span class="params">(VER_NDX_LAST_RESERVED + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *verdef_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERDEF);</span><br><span class="line">  <span class="keyword">if</span> (!verdef_sec)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  std::string_view verdef = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, *verdef_sec);</span><br><span class="line">  std::string_view strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, verdef_sec-&gt;sh_link);</span><br><span class="line"></span><br><span class="line">  ElfVerdef&lt;E&gt; *ver = (ElfVerdef&lt;E&gt; *)verdef.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.<span class="built_in">size</span>() &lt;= ver-&gt;vd_ndx)</span><br><span class="line">      ret.<span class="built_in">resize</span>(ver-&gt;vd_ndx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ElfVerdaux&lt;E&gt; *aux = (ElfVerdaux&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_aux);</span><br><span class="line">    ret[ver-&gt;vd_ndx] = strtab.<span class="built_in">data</span>() + aux-&gt;vda_name;</span><br><span class="line">    <span class="keyword">if</span> (!ver-&gt;vd_next)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ver = (ElfVerdef&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿一个helloworld的elf看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ./a.out</span><br><span class="line"></span><br><span class="line">[ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000516</span>  <span class="number">00000516</span></span><br><span class="line">     <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里的全体大小为2，我们再看一下符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line">w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line">U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>其中两个是重复的符号，去重后也就是2个符号</p><h1 id="对比ObjectFile和SharedFile"><a href="#对比ObjectFile和SharedFile" class="headerlink" title="对比ObjectFile和SharedFile"></a>对比ObjectFile和SharedFile</h1><p>最后我们通过分析ObjectFile和SharedFile相关的异同来结束这期内容。</p><p>相比于ObjectFile的复杂解析过程，SharedFile的整个过程显得十分简单。这和文件本身的性质与使用场景都有关系。dso加载符号的定义以及其他信息绝大部分都是在运行时，因此在链接期间并不需要做太多操作，其主要用途是将会被引用的符号加入到决议过程，同时将对应符号的版本信息和dso的soname加入到生成的产物中，以便在运行时进行加载。在谷歌搜索的时候搜到了这样一句话，我觉得概括的更好</p><blockquote><p>A DSO can be used in place of archive libraries and will minimize overall memory usage because code is shared.</p></blockquote><p>在链接的时候dso的作用是in place of archive libraries，所以并不需要太多的信息。</p><p>虽然SharedFile在链接的时候并没有解析ObjectFile中许多信息，但是那些信息仍然是存在的，只是在链接的时候无需参与，而是全部交给运行时加载来处理。虽然在mold的类结构中ObjectFile和SharedFile都是直接继承自InputFile，但对于实际的object和dso来说我觉得dso更倾向于是特别的object，不过这个从dso的全名（dynamic shared object）也能看出来了。</p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a class="link"   href="https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w" >https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-2-read-sh</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="eh_frame" scheme="https://fusionbolt.github.io/tags/eh-frame/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其一 读取输入文件</title>
    <link href="https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/"/>
    <id>https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/</id>
    <published>2023-02-26T09:40:55.000Z</published>
    <updated>2023-02-26T09:45:10.272Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg"                      alt="图像"                >上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。</p><p>首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可能从代码中去捋清不同结构之间的联系。</p><p>我们从elf_main函数中的read_input_files开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_input_files</span>(ctx, file_args);</span><br></pre></td></tr></table></figure><h1 id="read-input-files"><a href="#read-input-files" class="headerlink" title="read_input_files"></a>read_input_files</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_input_files</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::span&lt;std::string&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;read_input_files&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>&gt;&gt; state;</span><br><span class="line">  ctx.is_static = ctx.arg.is_static;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string_view arg = args[<span class="number">0</span>];</span><br><span class="line">    args = args.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="string">&quot;--as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bstatic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bdynamic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--start-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--end-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--version-script=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--version-script: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_version_script</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--dynamic-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dynamic-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol=&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">        ctx.default_version = VER_NDX_GLOBAL;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.version_patterns.<span class="built_in">push_back</span>(&#123;arg, <span class="string">&quot;--export-dynamic-symbol&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;global&quot;</span>, VER_NDX_GLOBAL, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--export-dynamic-symbol-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--push-state&quot;</span>) &#123;</span><br><span class="line">      state.<span class="built_in">push_back</span>(&#123;ctx.as_needed, ctx.whole_archive, ctx.is_static,</span><br><span class="line">                       ctx.in_lib&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--pop-state&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no state pushed before popping&quot;</span>;</span><br><span class="line">      std::<span class="built_in">tie</span>(ctx.as_needed, ctx.whole_archive, ctx.is_static, ctx.in_lib) =</span><br><span class="line">        state.<span class="built_in">back</span>();</span><br><span class="line">      state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;-l&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_library</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      mf-&gt;given_fullpath = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, std::<span class="built_in">string</span>(arg)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no input files&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.tg.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是根据命令行参数确定要读取的输入文件，这里大部分的分支是为了读取符号version信息相关的，主要是看read_file的实现。在看实现之前可以看到传入了一个MappedFile，而这个类的实现其实就是在打开文件的时候使用了mmap进行映射，而must_open则是进行判断，失败了直接报错，这里也不贴具体细节代码了。</p><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.visited.<span class="built_in">contains</span>(mf-&gt;name))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  FileType type = <span class="built_in">get_file_type</span>(mf);</span><br><span class="line">... 省略对不同type的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是get_file_type，这个是通过文件开头的值确定文件的类型，我们这里以ELF的代码为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">FileType <span class="title">get_file_type</span><span class="params">(MappedFile&lt;C&gt; *mf)</span> </span>&#123;</span><br><span class="line">  std::string_view data = mf-&gt;<span class="built_in">get_contents</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> FileType::EMPTY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;\177ELF&quot;</span>)) &#123;</span><br><span class="line">    u8 byte_order = ((elf::EL32Ehdr *)data.<span class="built_in">data</span>())-&gt;e_ident[elf::EI_DATA];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (byte_order == elf::ELFDATA2LSB) &#123;</span><br><span class="line">      elf::EL32Ehdr &amp;ehdr = *(elf::EL32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::I386&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::X86_64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elf::EB32Ehdr &amp;ehdr = *(elf::EB32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::M68K&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::SPARC64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FileType::UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  ... 省略其他格式的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从数据开头的“\177ELF”确定为ELF文件，之后根据ELFHeader里面的内容读取更多的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FileType</span> &#123;</span></span><br><span class="line">  UNKNOWN,</span><br><span class="line">  EMPTY,</span><br><span class="line">  ELF_OBJ,</span><br><span class="line">  ELF_DSO,</span><br><span class="line">  MACH_OBJ,</span><br><span class="line">  MACH_EXE,</span><br><span class="line">  MACH_DYLIB,</span><br><span class="line">  MACH_BUNDLE,</span><br><span class="line">  MACH_UNIVERSAL,</span><br><span class="line">  AR,</span><br><span class="line">  THIN_AR,</span><br><span class="line">  TAPI,</span><br><span class="line">  TEXT,</span><br><span class="line">  GCC_LTO_OBJ,</span><br><span class="line">  LLVM_BITCODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mold当前所支持的FileType就是这些，但是注意，GitHub中mold项目下只存在elf文件的支持，mach的格式则是在sold这个项目中处理。除此之外的文件格式都在以下的switch中进行处理</p><p><a class="link"   href="https://github.com/bluewhalesystems/sold" >https://github.com/bluewhalesystems/sold<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, mf, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_DSO:</span><br><span class="line">  ctx.dsos.<span class="built_in">push_back</span>(<span class="built_in">new_shared_file</span>(ctx, mf));</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::AR:</span><br><span class="line"><span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">  <span class="keyword">for</span> (MappedFile&lt;Context&lt;E&gt;&gt; *child : <span class="built_in">read_archive_members</span>(ctx, mf)) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(child)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">      ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, child, mf-&gt;name));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line">    <span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">      <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, child, mf-&gt;name))</span><br><span class="line">        ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::TEXT:</span><br><span class="line">  <span class="built_in">parse_linker_script</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line"><span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">  <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, mf, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: unknown file type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化下来这里主要分为这么几类文件</p><ol><li>archive file</li><li>lto</li><li>linker_script</li><li>object_file</li><li>shared_file</li></ol><h2 id="archive-file"><a href="#archive-file" class="headerlink" title="archive file"></a>archive file</h2><p>archive file，也就是俗称的.a文件，其实就是许多个object文件塞到一起只需要解析其中所有member，之后将每个member进行读取即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">std::vector&lt;MappedFile&lt;C&gt; *&gt;</span><br><span class="line"><span class="built_in">read_archive_members</span>(C &amp;ctx, MappedFile&lt;C&gt; *mf) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(mf)) &#123;</span><br><span class="line">  <span class="keyword">case</span> FileType::AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_fat_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_thin_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ar和thin ar</p><p><a class="link"   href="https://sourceware.org/binutils/docs/binutils/ar.html" >ar (GNU Binary Utilities)<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>An archive can either be <em>thin</em> or it can be normal. It cannot be both at the same time. Once an archive is created its format cannot be changed without first deleting it and then creating a new archive in its place.</p></blockquote><p>这里的具体细节暂且略过，如感兴趣可自行查看源码</p><h2 id="lto"><a href="#lto" class="headerlink" title="lto"></a>lto</h2><p>lto是用于link time optimization的文件，而本质上还是一个object文件，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_lto_obj</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_lto_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.ignore_ir_file.<span class="built_in">count</span>(mf-&gt;<span class="built_in">get_identifier</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  ObjectFile&lt;E&gt; *file = <span class="built_in">read_lto_object</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  file-&gt;archive_name = archive_name;</span><br><span class="line">  file-&gt;is_in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  ctx.has_lto_object = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mold中解析lto的方式是通过指定plugin，加载对应的so来进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">ObjectFile&lt;E&gt; *<span class="title">read_lto_object</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// V0 API&#x27;s claim_file is not thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_gcc_linker_api_v1)</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.plugin.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: don&#x27;t know how to handle this LTO object file &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;because no -plugin option was given. Please make sure you &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;added -flto not only for creating object files but also for &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;creating the final executable.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dlopen the linker plugin file</span></span><br><span class="line">  <span class="keyword">static</span> std::once_flag flag;</span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;] &#123; <span class="built_in">load_plugin</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>学习解析文件的实现主要是要进一步了解ELF的格式，所以这里具体细节就不进行考据了。</p><h2 id="linker-script"><a href="#linker-script" class="headerlink" title="linker script"></a>linker script</h2><p>mold的linker script根据解析的过程来看比较简单，没有在ld的脚本中的指定SECTION地址之类的内容，主要是对format以及符号version的一些控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_linker_script</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  current_file&lt;E&gt; = mf;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string_view&gt; vec = <span class="built_in">tokenize</span>(ctx, mf-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">  std::span&lt;std::string_view&gt; tok = vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!tok.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;OUTPUT_FORMAT&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_output_format</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;INPUT&quot;</span> || tok[<span class="number">0</span>] == <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_group</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;VERSION&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">      <span class="built_in">read_version_script</span>(ctx, tok);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok.<span class="built_in">size</span>() &gt; <span class="number">3</span> &amp;&amp; tok[<span class="number">1</span>] == <span class="string">&quot;=&quot;</span> &amp;&amp; tok[<span class="number">3</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      ctx.arg.defsyms.<span class="built_in">emplace_back</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">0</span>])),</span><br><span class="line">                                   <span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">2</span>])));</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SyntaxError</span>(ctx, tok[<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;unknown linker script token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h2><p>object file是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_object_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  ObjectFile&lt;E&gt; *file = ObjectFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf, archive_name, in_lib);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mold以链接速度快出名，而其快的原因之一就是充分利用了多线程，实际进行多线程操作的地方是在这里，ctx.tg.run，tg则是一个tbb::task_group，简而言之就是在这里开启了多线程的解析input file。</p><p>做了一些简单的in_lib参数处理，因为archive的链接机制默认是按需链接，而不是像shared file一样全部链接，之后在这里创建了object file并且开始parse。关于创建和parse的细节在后面再说。</p><h2 id="shared-file"><a href="#shared-file" class="headerlink" title="shared file"></a>shared file</h2><p>shared file同样是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SharedFile&lt;E&gt; *</span></span><br><span class="line"><span class="function"><span class="title">new_shared_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  SharedFile&lt;E&gt; *file = SharedFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里做了和object file类似的事情。</p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>在详细讲解object file和shared file创建以及解析之前先介绍一下他们和InputFile类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled.png"                      alt="Untitled"                ></p><p>ObjectFile和SharedFile都是简单的从InputFile中继承下来的。而这里的InputFile更像是代表了一个输入的ELF文件，构造的过程中做了一些ELF的基础解析，同时还提供了一些通用的接口，交由ObjectFile和SharedFile各自实现。</p><p>我们来看一下InputFile的构造函数部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">InputFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : <span class="built_in">mf</span>(mf), <span class="built_in">filename</span>(mf-&gt;name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfEhdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: file too small&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(mf-&gt;data, <span class="string">&quot;\177ELF&quot;</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: not an ELF file&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfEhdr&lt;E&gt; &amp;ehdr = *(ElfEhdr&lt;E&gt; *)mf-&gt;data;</span><br><span class="line">  is_dso = (ehdr.e_type == ET_DYN);</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *sh_begin = (ElfShdr&lt;E&gt; *)(mf-&gt;data + ehdr.e_shoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shnum contains the total number of sections in an object file.</span></span><br><span class="line">  <span class="comment">// Since it is a 16-bit integer field, it&#x27;s not large enough to</span></span><br><span class="line">  <span class="comment">// represent &gt;65535 sections. If an object file contains more than 65535</span></span><br><span class="line">  <span class="comment">// sections, the actual number is stored to sh_size field.</span></span><br><span class="line">  i64 num_sections = (ehdr.e_shnum == <span class="number">0</span>) ? sh_begin-&gt;sh_size : ehdr.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; (u8 *)(sh_begin + num_sections))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: e_shoff or e_shnum corrupted: &quot;</span></span><br><span class="line">               &lt;&lt; mf-&gt;size &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_sections;</span><br><span class="line">  elf_sections = &#123;sh_begin, sh_begin + num_sections&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line">  <span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">  i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">    ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br><span class="line"></span><br><span class="line">  shstrtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shstrtab_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从文件大小和文件头部标识信息进行ELF的校验，其次是做一些简单的解析。根据代码中可知，整个文件最开始的部分即可作为一个ElfEhdr（Ehdr：Elf Header）</p><p>根据header的信息可以解析出是否为dso文件，ElfShdr（Shdr：Section Header）的起始地址和长度，以及shstrtab（Section Header String Table）的位置。</p><p>大多数的参数直接可以获取，但是对于e_shnum和e_shstrndx来说，由于长度只有16bit的限制，因此如果值过大，则会分别存到第一个Shdr的sh_size以及sh_link中。</p><p>那么根据这段代码我们可以看出ELF的文件信息是这样的</p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先是ObjectFile的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt; *</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                      std::string archive_name, <span class="keyword">bool</span> is_in_lib) &#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;(ctx, mf, archive_name, is_in_lib);</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">ObjectFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                          std::string archive_name, <span class="keyword">bool</span> is_in_lib)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf), <span class="built_in">archive_name</span>(archive_name), <span class="built_in">is_in_lib</span>(is_in_lib) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !is_in_lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数被放入了private中，因此必须通过静态的create方法来创建实例。在每次创建的时候会将对应的obj对象放入到全局的ctx.obj_pool中，mold中的内存与生命周期的管理方式则是全部交由ctx保有，到最后一起释放。而对应的obj_pool为了多线程的设计也都使用了并发的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbb::concurrent_vector&lt;std::unique_ptr&lt;ObjectFile&lt;E&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数只是传递了参数，大部分的解析还是在InputFile的构造函数中执行。</p><h2 id="parse过程开始"><a href="#parse过程开始" class="headerlink" title="parse过程开始"></a>parse过程开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  sections.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>());</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_SYMTAB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (symtab_sec) &#123;</span><br><span class="line">    <span class="comment">// In ELF, all local symbols precede global symbols in the symbol table.</span></span><br><span class="line">    <span class="comment">// sh_info has an index of the first global symbol.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;first_global = symtab_sec-&gt;sh_info;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialize_sections</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_symbols</span>(ctx);</span><br><span class="line">  <span class="built_in">sort_relocations</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_ehframe_sections</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symtab-sec"><a href="#symtab-sec" class="headerlink" title="symtab_sec"></a>symtab_sec</h2><p>首先是寻找symtab_sec的过程，寻找段的过程非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ElfShdr&lt;E&gt; *InputFile&lt;E&gt;::<span class="built_in">find_section</span>(i64 type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ElfShdr&lt;E&gt; &amp;sec : elf_sections)</span><br><span class="line">    <span class="keyword">if</span> (sec.sh_type == type)</span><br><span class="line">      <span class="keyword">return</span> &amp;sec;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>symtab_sec不存在的情况多半是strip了，直接在elf中搜索symtab是能搜到的，但是如果strip以后就无法找到这个段了，也就是为空的情况</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%201.png"                      alt="Untitled"                ></p><p>sh_link和sh_info对于不同的section有不同的含义，对于这里的symtab来说sh_info就是保存了第一个global symbol的index，而sh_link就是保存了symbol_strtab的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%202.png"                      alt="Untitled"                ></p><h2 id="initialize-sections"><a href="#initialize-sections" class="headerlink" title="initialize_sections"></a>initialize_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Read sections</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br></pre></td></tr></table></figure><p>针对所有的sections开始处理，以下内容都在个循环体之中</p><h3 id="特殊SHT的处理"><a href="#特殊SHT的处理" class="headerlink" title="特殊SHT的处理"></a>特殊SHT的处理</h3><p>SHT（Section Header Type）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((shdr.sh_flags &amp; SHF_EXCLUDE) &amp;&amp; !(shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">    shdr.sh_type != SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这几个段无法在ELF标准中查到，后来查到了这么一段介绍</p><p>SHF_EXCLUDE：This section is excluded from input to the link-edit of an executable or shared object. This flag is ignored if the SHF_ALLOC flag is also set, or if relocations exist against the section.</p><ol><li>如果alloc被set则失效，因此这里要SHF_EXCLUDE以及SHF_ALLOC都满足条件</li><li>同时sh_type为SHF_LLVM_ADDRSIG且不是relocatable</li></ol><p>关于SHF_LLVM_ADDRSIG</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#id20" >LLVM Extensions — LLVM 17.0.0git documentation<i class="fas fa-external-link-alt"></i></a></p><h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p>首先是关于Group的介绍</p><blockquote><p>This section defines a section group. A section group is a set of sections that are related and that must be treated specially by the linker (see <a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html#section_groups" >below<i class="fas fa-external-link-alt"></i></a> for further details). Sections of type <code>SHT_GROUP</code> may appear only in relocatable objects (objects with the ELF header <code>e_type</code> member set to <code>ET_REL</code>). The section header table entry for a group section must appear in the section header table before the entries for any of the sections that are members of the group.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>在实现中首先是寻找对应group的签名，签名是关联到了一个esym上，而这个符号的索引则是记录在sh_info中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the signature of this section group.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_info &gt;= <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid symbol index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[shdr.sh_info];</span><br><span class="line"></span><br><span class="line">std::string_view signature;</span><br><span class="line"><span class="keyword">if</span> (esym.st_type == STT_SECTION) &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() +</span><br><span class="line">              <span class="keyword">this</span>-&gt;elf_sections[esym.st_shndx].sh_name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些特殊情况的处理。</p><ol><li>跳过wm4</li><li>跳过entries[0]为0的情况</li><li>如果[0]不是GRP_COMDAT则是错误</li></ol><p>之后获取comdat group members，并使用signature来关联一个ComdatGroup</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ignore a broken comdat group GCC emits for .debug_macros.</span></span><br><span class="line"><span class="comment">// https://github.com/rui314/mold/issues/438</span></span><br><span class="line"><span class="keyword">if</span> (signature.<span class="built_in">starts_with</span>(<span class="string">&quot;wm4.&quot;</span>))</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get comdat group members.</span></span><br><span class="line">std::span&lt;U32&lt;E&gt;&gt; entries = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U32&lt;E&gt;&gt;(ctx, shdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: empty SHT_GROUP&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] != GRP_COMDAT)</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported SHT_GROUP format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.comdat_groups)</span>::const_accessor acc</span>;</span><br><span class="line">ctx.comdat_groups.<span class="built_in">insert</span>(acc, &#123;signature, <span class="built_in">ComdatGroup</span>()&#125;);</span><br><span class="line">ComdatGroup *group = <span class="keyword">const_cast</span>&lt;ComdatGroup *&gt;(&amp;acc-&gt;second);</span><br><span class="line">comdat_groups.<span class="built_in">push_back</span>(&#123;group, (u32)i, entries.<span class="built_in">subspan</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>关于上面处理过程中出现的成员的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in context</span></span><br><span class="line">tbb::concurrent_hash_map&lt;std::string_view, ComdatGroup, HashCmp&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ObjectFile</span></span><br><span class="line">std::vector&lt;ComdatGroupRef&lt;E&gt;&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComdatGroupRef</span> &#123;</span></span><br><span class="line">  ComdatGroup *group;</span><br><span class="line">  u32 sect_idx;</span><br><span class="line">  std::span&lt;U32&lt;E&gt;&gt; members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是根据签名关联一个group空，之后将对应group的引用传递给ObjectFile中的comdat_groups</p><p>里面的i就是section的index</p><p>来看一下这个group段的排布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| SectionSize | Group1SectionIndex | Group2SectionIndex | … |</span><br></pre></td></tr></table></figure><p>关于GRP_COMDAT文档中也有提到</p><blockquote><p>This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded.</p></blockquote><h3 id="常规SHT处理"><a href="#常规SHT处理" class="headerlink" title="常规SHT处理"></a>常规SHT处理</h3><p>此处还有很长的特殊段以及开启—gdb-index后需要处理的内容，并非重点，此处先跳过。</p><p>常规处理就是简单创建了一个InputSection</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;sections[i] = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br></pre></td></tr></table></figure><h3 id="Attach-relocation-sections-to-their-target-sections"><a href="#Attach-relocation-sections-to-their-target-sections" class="headerlink" title="Attach relocation sections to their target sections."></a>Attach relocation sections to their target sections.</h3><p>到这里，所有的section已经执行过了一遍，最后再进行关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach relocation sections to their target sections.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_info &gt;= sections.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid relocated section index: &quot;</span></span><br><span class="line">               &lt;&lt; (u32)shdr.sh_info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;target = sections[shdr.sh_info]) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(target-&gt;relsec_idx == <span class="number">-1</span>);</span><br><span class="line">    target-&gt;relsec_idx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对RELA和REL处理，设置上对应的relsec_idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_rela = <span class="built_in"><span class="keyword">requires</span></span>(ElfRel&lt;E&gt; r) &#123; r.r_addend; &#125;;</span><br></pre></td></tr></table></figure><h2 id="initialize-symbols"><a href="#initialize-symbols" class="headerlink" title="initialize_symbols"></a>initialize_symbols</h2><p>这部分的过程主要是将esym转换为Symbol。esym则是ElfSym的缩写，也就是Elf文件中的Symbol定义，而Symbol则是mold中自己定义的，相当于转换为自己想要的格式。</p><p>这里的symtab_sec是parse刚开始的时候寻找的section，对应的符号表不存在则不进行这个过程。首先初始化了local_syms以及第0个符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;all_syms&quot;</span>)</span></span>;</span><br><span class="line">  counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize local symbols</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;first_global);</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].file = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].sym_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="local-symbol"><a href="#local-symbol" class="headerlink" title="local symbol"></a>local symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: common local symbol?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type == STT_SECTION)</span><br><span class="line">      name = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() + <span class="keyword">this</span>-&gt;elf_sections[<span class="built_in">get_shndx</span>(esym)].sh_name;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;local_syms[i];</span><br><span class="line">    sym.<span class="built_in">set_name</span>(name);</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.value = esym.st_value;</span><br><span class="line">    sym.sym_idx = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>())</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(sections[<span class="built_in">get_shndx</span>(esym)].<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先是对于common符号的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_COMMON; &#125;</span><br></pre></td></tr></table></figure><p>关于这个SHN_COMMON</p><blockquote><p>SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.</p></blockquote><p>大意是common的话不能是local，比如这里说的unallocated C external variables，external和local就是冲突的。</p><p>除了报错的common符号之外，其他符号在后面获取对应的名字，如果是section name则去shstrtab中寻找，否则就是常规的符号名，去symbol_strtab中寻找。这里的名字本质上是一个距离对应字符串段的offset，因为字符串相关的数据都统一保存在这shstrtab和symbol_strtab中了。</p><p>之后就是获取local_syms的引用，开始设置对应的信息。</p><p>在最后，对非abs符号的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_ABS; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have <strong>absolute values and are not affected by relocation.</strong></p></blockquote><p>非abs符号，也就是说都是相对地址，会affected by relocation。</p><p>而实际set_input_section则是设置其mask位，用于区分什么性质的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_input_section</span>(InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> addr = (<span class="keyword">uintptr_t</span>)isec;</span><br><span class="line">  <span class="built_in">assert</span>((addr &amp; TAG_MASK) == <span class="number">0</span>);</span><br><span class="line">  origin = addr | TAG_ISEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用2bit区分不同情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol usually belongs to an input section, but it can belong</span></span><br><span class="line"><span class="comment">// to a section fragment, an output section or nothing</span></span><br><span class="line"><span class="comment">// (i.e. absolute symbol). `origin` holds one of them. We use the</span></span><br><span class="line"><span class="comment">// least significant two bits to distinguish type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">  TAG_ABS  = <span class="number">0b00</span>,</span><br><span class="line">  TAG_ISEC = <span class="number">0b01</span>,</span><br><span class="line">  TAG_OSEC = <span class="number">0b10</span>,</span><br><span class="line">  TAG_FRAG = <span class="number">0b11</span>,</span><br><span class="line">  TAG_MASK = <span class="number">0b11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-symbol"><a href="#global-symbol" class="headerlink" title="global symbol"></a>global symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbols.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">i64 num_globals = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="keyword">this</span>-&gt;first_global;</span><br><span class="line">symvers.<span class="built_in">resize</span>(num_globals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = &amp;<span class="keyword">this</span>-&gt;local_syms[i];</span><br></pre></td></tr></table></figure><p>在开始处理之前可以看到这里又有两个resize容器的位置，目前为止有三处，这里写明了对应的容器以及所处的类，用于区分这个信息是否为ObjectFile only的</p><ol><li>local symbols(InputFile)</li><li>symbols(InputFile)</li><li>symvers (ObjectFile)</li></ol><p>之后将local_sym绑定到symbols中</p><p>之后是详细的处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize global symbols</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a symbol name</span></span><br><span class="line">  std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">  std::string_view name = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse symbol version after atsign</span></span><br><span class="line">  <span class="keyword">if</span> (i64 pos = name.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != name.npos) &#123;</span><br><span class="line">    std::string_view ver = name.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    name = name.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ver.<span class="built_in">empty</span>() &amp;&amp; ver != <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">        key = name;</span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">        symvers[i - <span class="keyword">this</span>-&gt;first_global] = ver.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">    has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; symvers;</span><br></pre></td></tr></table></figure><p>这里不需要再区分是否为Section的符号，因为global符号不包含section符号。</p><p>这里最主要的是需要解析symbol version，因为有的符号会依赖于版本号。要注意的是这个东西并非ELF的官方定义，而是GNU的一个扩展，因此去看elf specification是找不到的。关于名称规范也很简单，常规符号名后接@加符号版本</p><p>解析符号版本完成后设置到symvers中，关于这个版本号，最常见的就是GLIBC，以下是本机helloworld代码的示范</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/tmp &gt; nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line"> w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"> U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line"> U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>之后是insert symbol，并且设置其common属性。要注意除了这些解析方式外，global symbol和local symbol相比还有一个比较隐藏的不同，global symbol没有设置对应的file，后面很多符号的处理会进行判断file。</p><p>接下来是insert symbol的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a symbol object for a given key. This function handles</span></span><br><span class="line"><span class="comment">// the -wrap option.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Symbol&lt;E&gt; *<span class="title">insert_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string_view key, std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; name.<span class="built_in">starts_with</span>(<span class="string">&quot;__real_&quot;</span>) &amp;&amp;</span><br><span class="line">      ctx.arg.wrap.<span class="built_in">contains</span>(name.<span class="built_in">substr</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">7</span>), name.<span class="built_in">substr</span>(<span class="number">7</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym-&gt;wrap) &#123;</span><br><span class="line">    key = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(key));</span><br><span class="line">    name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(name));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">save_string</span><span class="params">(C &amp;ctx, <span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">  u8 *buf = <span class="keyword">new</span> u8[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">  buf[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  ctx.string_pool.<span class="built_in">push_back</span>(std::unique_ptr&lt;u8[]&gt;(buf));</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)buf, str.<span class="built_in">size</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不只是不存在key就创建key并返回那么简单。</p><ol><li>关于save_string的问题，这里也是和之前一样，创建了string后由ctx来管理生命周期，返回一个string_view提供使用。</li><li>除此之外get_symbol的部分是实际执行了符号不存在则创建新符号并且返回的工作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we haven&#x27;t seen the same `key` before, create a new instance</span></span><br><span class="line"><span class="comment">// of Symbol and returns it. Otherwise, returns the previously-</span></span><br><span class="line"><span class="comment">// instantiated object. `key` is usually the same as `name`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">Symbol&lt;E&gt; *<span class="title">get_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.symbol_map)</span>::const_accessor acc</span>;</span><br><span class="line">  ctx.symbol_map.<span class="built_in">insert</span>(acc, &#123;key, Symbol&lt;E&gt;(name)&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Symbol&lt;E&gt; *&gt;(&amp;acc-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最后提一下-wrap option选项</li></ol><p>这个-wrap是在main中read_input_files之前的地方设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --wrap options if any.</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.wrap)</span><br><span class="line">  <span class="built_in">get_symbol</span>(ctx, name)-&gt;wrap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>关于这个选项我参考了这个回答里的内容，虽然是gcc的介绍，但是本质是相同的</p><p><a href="https://stackoverflow.com/questions/46444052/how-to-wrap-functions-with-the-wrap-option-correctly">How to wrap functions with the <code>--wrap</code> option correctly?</a></p><p>我摘选了一些关键的段落</p><blockquote><p>-wrap=symbol<br>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.<br>…<br>If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.</p></blockquote><blockquote><p>… Any <strong>undefined reference</strong> to symbol will be resolved to “__wrap_symbol”. Any <strong>undefined reference</strong>  to “__real_symbol” will be resolved to symbol.</p></blockquote><p>至此，initialize_symbols就结束了</p><h2 id="sort-relocations"><a href="#sort-relocations" class="headerlink" title="sort_relocations"></a>sort_relocations</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relocations are usually sorted by r_offset in relocation tables,</span></span><br><span class="line"><span class="comment">// but for some reason only RISC-V does not follow that convention.</span></span><br><span class="line"><span class="comment">// We expect them to be sorted, so sort them if necessary.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">sort_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> less = [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.r_offset &lt; b.r_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i];</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">is_sorted</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), less))</span><br><span class="line">        <span class="built_in">sort</span>(rels, less);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，这里的sort是为了将不遵守约定没按照r_offset排序的rv的relocations转换为遵循约定的格式</p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>关于这里的内容比较长，不仅要包含解析本身，还有ehframe本身的内容，因此留到下期再继续讲。</p><h1 id="图解总结"><a href="#图解总结" class="headerlink" title="图解总结"></a>图解总结</h1><p>画了一些比较粗糙的图示将今天的内容串联起来（未标记长度信息，部分大小不标准，没精力画了）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%203.png"                      alt="Untitled"                ></p><p>首先是读取InputFile时的流程，主要是ElfHeader指向ELF文件的哪一部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%204.png"                      alt="Untitled"                ></p><p>其次是读取Section的时候符号表相关的查找流程，这里还没来得及画具体取名字的部分</p><p>从Section Header Table中找到对应sh_type为SHT_SYMTAB的段，之后根据offset和size找到具体存放symbol的位置，同时通过sh_info确定第一个global symbol的index</p><h1 id="参考资料汇总"><a href="#参考资料汇总" class="headerlink" title="参考资料汇总"></a>参考资料汇总</h1><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >Sections<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://refspecs.linuxfoundation.org/elf/elf.pdf" >Elf Specification 1.2<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-1-read-in</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
</feed>
