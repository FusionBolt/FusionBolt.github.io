<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2023-04-29T09:11:32.284Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mold源码阅读五 符号相关</title>
    <link href="https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/"/>
    <id>https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/</id>
    <published>2023-04-29T09:09:46.000Z</published>
    <updated>2023-04-29T09:11:32.284Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-5-symbol/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:73005507</center> <p>上期讲完了resolve_section_pieces，在这之后本应是combine_object，但是combine_object几乎包含了后面的所有过程，因此等到整个流程讲完后或许会再回来讲，这一期的内容以符号版本的处理为主。</p><h1 id="为common-symbol创建bss段"><a href="#为common-symbol创建bss段" class="headerlink" title="为common symbol创建bss段"></a>为common symbol创建bss段</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_common_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;convert_common_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="common-symbol"><a href="#common-symbol" class="headerlink" title="common symbol"></a>common symbol</h2><p>首先解释一下common symbol。根据mold的注释所讲，common symbols被用于C的tentative definition，tentative definition是指C语言在一个头文件中允许全局变量定义省略extern。header会存在于多个翻译单元中，但这个符号不会导致duplicate symbol error，相反linker会将他们merge到一个单一的实例中。</p><p>还给出了一个例子，比如说一个头文件中有一个tentative definition是int foo，在一个C文件中包含了其包含初始值定义，比如说int foo = 5（real definition），那么这个tentative definition的符号会被resolve到real definition上。如果没有real definition，那么tentative definition会得到默认值。</p><p><a class="link"   href="https://stackoverflow.com/questions/3095861/about-tentative-definition" >About Tentative definition<i class="fas fa-external-link-alt"></i></a></p><p>参考这个stackoverflow的回答，C语言中纯变量声明会被处理为extern的，我想这就是允许省略extern的原因，编译器帮你做了这件事情，尽管这或许与你的预期不符。</p><p>简单总结来说就是头文件中一个全局的声明在不同编译单元有不同定义的时候需要进行resolve一个单一实现，声明的symbol其实是属于多个文件的，因此是common的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">convert_common_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_common_symbol)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>has_common_symbol初始化的地方是在input-files.cc中的void ObjectFile<E>::initialize_symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize_symbols</span></span><br><span class="line"><span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的处理是针对所有global的common符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;elf_syms[i].<span class="built_in">is_common</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym.file != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.warn_common)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: multiple common symbols: &quot;</span> &lt;&lt; sym;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>提示warning</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in for</span></span><br><span class="line">elf_sections2.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">ElfShdr&lt;E&gt; &amp;shdr = elf_sections2.<span class="built_in">back</span>();</span><br><span class="line"><span class="built_in">memset</span>(&amp;shdr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(shdr));</span><br><span class="line"></span><br><span class="line">std::string_view name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() == STT_TLS) &#123;</span><br><span class="line">  name = <span class="string">&quot;.tls_common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE | SHF_TLS;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;.common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shdr.sh_type = SHT_NOBITS;</span><br><span class="line">shdr.sh_size = <span class="keyword">this</span>-&gt;elf_syms[i].st_size;</span><br><span class="line">shdr.sh_addralign = <span class="keyword">this</span>-&gt;elf_syms[i].st_value;</span><br></pre></td></tr></table></figure><p>关于SHF_TLS</p><blockquote><p>SHF_TLS: This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data. Implementations need not support this flag.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>对每个global common符号创建了一个ElfShdr后开始设置其基本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i64 idx = <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>() + elf_sections2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; isec =</span><br><span class="line">  std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, idx);</span><br><span class="line"></span><br><span class="line">sym.file = <span class="keyword">this</span>;</span><br><span class="line">sym.<span class="built_in">set_input_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">sym.value = <span class="number">0</span>;</span><br><span class="line">sym.sym_idx = i;</span><br><span class="line">sym.ver_idx = ctx.default_version;</span><br><span class="line">sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">sym.is_exported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sections.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(isec));</span><br><span class="line"><span class="comment">// for end</span></span><br></pre></td></tr></table></figure><p>创建了一个指向elf_sections的InputSecion，之后添加到sections中。</p><h1 id="apply-version-script"><a href="#apply-version-script" class="headerlink" title="apply_version_script"></a>apply_version_script</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br></pre></td></tr></table></figure><h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_version_script</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_version_script&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If all patterns are simple (i.e. not containing any meta-</span></span><br><span class="line">  <span class="comment">// characters and is not a C++ name), we can simply look up</span></span><br><span class="line">  <span class="comment">// symbols.</span></span><br><span class="line">  <span class="keyword">auto</span> is_simple = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns)</span><br><span class="line">      <span class="keyword">if</span> (v.is_cpp || v.pattern.<span class="built_in">find_first_of</span>(<span class="string">&quot;*?[&quot;</span>) != v.pattern.npos)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先定义了is_simple。</p><p>simple的定义</p><ol><li>非cpp name。VersionPattern是根据链接器参数创建与添加的，is_cpp也同样是在那时指定的。</li><li>不包含meta字符的名字。根据代码中，meta字符即是*[?中的char</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_simple</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns) &#123;</span><br><span class="line">      Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, v.pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sym-&gt;file &amp;&amp; !ctx.arg.undefined_version)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; v.source &lt;&lt; <span class="string">&quot;: cannot assign version `&quot;</span> &lt;&lt; v.ver_str</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;` to symbol `&quot;</span> &lt;&lt; *sym &lt;&lt; <span class="string">&quot;`: symbol not found&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso)</span><br><span class="line">        sym-&gt;ver_idx = v.ver_idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果是simple的那么直接针对所有的version_pattern找到对应的符号，并且将其通过设置ver_idx的方式与VersionPattern进行关联</p><h2 id="otherwise"><a href="#otherwise" class="headerlink" title="otherwise"></a>otherwise</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Otherwise, use glob pattern matchers.</span></span><br><span class="line">MultiGlob matcher;</span><br><span class="line">MultiGlob cpp_matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.version_patterns.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  VersionPattern &amp;v = ctx.version_patterns[i];</span><br><span class="line">  <span class="keyword">if</span> (v.is_cpp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将cpp和其他复杂的符号区分开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name = sym-&gt;<span class="built_in">name</span>();</span><br><span class="line">    i64 match = INT64_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = matcher.<span class="built_in">find</span>(name))</span><br><span class="line">      match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match non-mangled symbols against the C++ pattern as well.</span></span><br><span class="line">    <span class="comment">// Weird, but required to match other linkers&#x27; behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;std::string_view&gt; s = <span class="built_in">cpp_demangle</span>(name))</span><br><span class="line">        name = *s;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = cpp_matcher.<span class="built_in">find</span>(name))</span><br><span class="line">        match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match != INT64_MAX)</span><br><span class="line">      sym-&gt;ver_idx = ctx.version_patterns[match].ver_idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在所有obj文件中找到所有global symbol</p><p>如果普通matcher中能找到其名字，那么更新match的index</p><p>如果cpp matcher非空，那么对其进行demangle操作，之后在cpp matcher中寻找其名字并且更新match的index</p><p>最后将符号与对应VersionPattern进行关联。</p><p>而这里的demangle操作是直接调用对应平台的abi。starts_with(”_Z”)是代表这是一个mangling的名字。关于mangling的规则参考</p><p><a class="link"   href="https://github.com/gchatelet/gcc_cpp_mangling_documentation" >https://github.com/gchatelet/gcc_cpp_mangling_documentation<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string_view&gt; <span class="title">cpp_demangle</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">char</span> *buf;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">size_t</span> buflen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cwasser): Actually demangle Symbols on Windows using e.g.</span></span><br><span class="line">  <span class="comment">// `UnDecorateSymbolName` from Dbghelp, maybe even Itanium symbols?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;_Z&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> *p = abi::__cxa_demangle(std::<span class="built_in">string</span>(name).<span class="built_in">c_str</span>(), buf, &amp;buflen, &amp;status);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">      buf = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obj-only"><a href="#obj-only" class="headerlink" title="obj only"></a>obj only</h2><p>我在读到这里，很好奇为什么只针对的是obj而不考虑dso，看了下相关的命令行参数的介绍才明白过来</p><blockquote><p>-E, –export-dynamic Put symbols in the dynamic symbol table –no-export-dynamic</p></blockquote><h1 id="parse-symbol-version"><a href="#parse-symbol-version" class="headerlink" title="parse_symbol_version"></a>parse_symbol_version</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_symbol_version</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这是针对生成shared库的操作，因为只有动态链接才需要考虑加载符号版本的问题，符号版本是为了加载动态库的时候确保更新后符号的实现一致，如果和预想的实现不一致可能引起其他问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string_view, u16&gt; verdefs;</span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.version_definitions.<span class="built_in">size</span>(); i++)</span><br><span class="line">  verdefs[ctx.arg.version_definitions[i]] = i + VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>实现中首先是将每一个version信息绑定到一个i + VER_NDX_LAST_RESERVED + 1的值（其中的version_definitions则是在read_version_script中读取的）。</p><p>接下来是针对了所有的global object进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>() - file-&gt;first_global; i++) &#123;</span><br><span class="line">      <span class="comment">// Match VERSION part of symbol foo@VERSION with version definitions.</span></span><br><span class="line">      <span class="comment">// The symbols&#x27; VERSION parts are in file-&gt;symvers.</span></span><br><span class="line">      <span class="keyword">if</span> (!file-&gt;symvers[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      Symbol&lt;E&gt; *sym = file-&gt;symbols[i + file-&gt;first_global];</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view ver = file-&gt;symvers[i];</span><br><span class="line">...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>首先找到了对应文件的global符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_default = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>)) &#123;</span><br><span class="line">  is_default = <span class="literal">true</span>;</span><br><span class="line">  ver = ver.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取符号的版本具体的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = verdefs.<span class="built_in">find</span>(ver);</span><br><span class="line"><span class="keyword">if</span> (it == verdefs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: symbol &quot;</span> &lt;&lt; *sym &lt;&lt;  <span class="string">&quot; has undefined version &quot;</span></span><br><span class="line">             &lt;&lt; ver;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据具体的值查找到上面保存的index</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sym-&gt;ver_idx = it-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (!is_default)</span><br><span class="line">  sym-&gt;ver_idx |= VERSYM_HIDDEN;</span><br></pre></td></tr></table></figure><p>非default行为的版本，也就是非@开头的版本则ver_idx设置为HIDDEN。关于非default的情况，这种符号version则是在default_symver选项中添加的。</p><p>该选项对应的介绍以及代码实现处</p><blockquote><p>Use soname as a symbol version and append that version to all symbols.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.default_symver) &#123;</span><br><span class="line">    std::string ver = ctx.arg.soname.<span class="built_in">empty</span>() ?</span><br><span class="line">      <span class="built_in">filepath</span>(ctx.arg.output).<span class="built_in">filename</span>().<span class="built_in">string</span>() : std::<span class="built_in">string</span>(ctx.arg.soname);</span><br><span class="line">    ctx.arg.version_definitions.<span class="built_in">push_back</span>(ver);</span><br><span class="line">    ctx.default_version = VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If both symbol `foo` and `foo@VERSION` are defined, `foo@VERSION`</span></span><br><span class="line"><span class="comment">// hides `foo` so that all references to `foo` are resolved to a</span></span><br><span class="line"><span class="comment">// versioned symbol. Likewise, if `foo@VERSION` and `foo@@VERSION` are</span></span><br><span class="line"><span class="comment">// defined, the default one takes precedence.</span></span><br><span class="line">Symbol&lt;E&gt; *sym2 = <span class="built_in">get_symbol</span>(ctx, sym-&gt;<span class="built_in">name</span>());</span><br><span class="line"><span class="keyword">if</span> (sym2-&gt;file == file &amp;&amp; !file-&gt;symvers[sym2-&gt;sym_idx - file-&gt;first_global])</span><br><span class="line">  <span class="keyword">if</span> (sym2-&gt;ver_idx == ctx.default_version ||</span><br><span class="line">      (sym2-&gt;ver_idx &amp; ~VERSYM_HIDDEN) == (sym-&gt;ver_idx &amp; ~VERSYM_HIDDEN))</span><br><span class="line">    sym2-&gt;ver_idx = VER_NDX_LOCAL;</span><br></pre></td></tr></table></figure><p>最后是一个符号名同时存在带有version和没有version的两种定义，那么带有version信息的则会对外隐藏不带有特殊version信息的实现（设置为local）。通过当前sym的名字在ctx中查找同名符号，之后进行处理操作。</p><h1 id="compute-import-export"><a href="#compute-import-export" class="headerlink" title="compute_import_export"></a>compute_import_export</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_import_export</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_import_export&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we are creating an executable, we want to export symbols referenced</span></span><br><span class="line">  <span class="comment">// by DSOs unless they are explicitly marked as local by a version script.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso &amp;&amp; sym-&gt;visibility != STV_HIDDEN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sym-&gt;ver_idx != VER_NDX_LOCAL || !ctx.default_version_from_version_script) &#123;</span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">            sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在不生成shared库的情况下，针对所有的dso进行处理，在创建可执行文件的时候，导出被dso引用的且不被标记为local的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Export symbols that are not hidden or marked as local.</span></span><br><span class="line"><span class="comment">// We also want to mark imported symbols as such.</span></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sym-&gt;file || sym-&gt;visibility == STV_HIDDEN ||</span><br><span class="line">        sym-&gt;ver_idx == VER_NDX_LOCAL)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file &amp;&amp; sym-&gt;file-&gt;is_dso &amp;&amp; !sym-&gt;<span class="built_in">is_absolute</span>()) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are creating a DSO, all global symbols are exported by default.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == file) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym-&gt;visibility != STV_PROTECTED &amp;&amp;</span><br><span class="line">          !ctx.arg.Bsymbolic &amp;&amp;</span><br><span class="line">          !(ctx.arg.Bsymbolic_functions &amp;&amp; sym-&gt;<span class="built_in">get_type</span>() == STT_FUNC))</span><br><span class="line">        sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>objs中找到global符号，对于HIDDEN或者NDX_LOCAL的符号都跳过。</p><p>如果使用一个在dso中的符号，就需要运行时import它，因此需要设置对应符号为imported</p><p>如果创建dso，那么所有的global符号默认都要export。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>convert_common_symbols：给所有global的common符号创建一个对应的InputSection段</p><p>apply_version_script：将解析命令行参数产生的VersionPatten关联到对应的obj文件中的symbol</p><p>parse_symbol_version：读取symbol version信息，处理对应的ver_idx，以及针对不同版本符号的处理</p><p>compute_import_export：对所有符号计算对应的import和export信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-5-symbol/</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>斯通纳</title>
    <link href="https://fusionbolt.github.io/2023/04/18/Reading/Stoner/"/>
    <id>https://fusionbolt.github.io/2023/04/18/Reading/Stoner/</id>
    <published>2023-04-18T13:30:38.000Z</published>
    <updated>2023-04-18T13:32:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是找到故事中角色与自己的相似之处，又或是将自己代入到角色中。</p><p>文中讲述了斯通纳的一生，从大学开始，到爱情，事业，直至最后的死亡。他在大学结交了非常好的朋友，不论是精神上，还是实际行为上都对他有所支持。他经历了一见钟情的爱情，也顺势结了婚，但却毫无幸福可言，唯一的幸福也只有饱受非议的婚外情。他在事业上还算成功，兢兢业业工作直至退休。在这些过程中斯通纳的傲骨也是十分明显的，遇到问题不愿低头，一直保有自己的骄傲。我想大部分人读完这本书后，都会对斯通纳留下正直，不寻求权利，不愿低头，遇到什么事情都不愿让步的印象。面对舞弊的行为坚守原则，即便这导致了他频繁受到针对，甚至调离到了偏远的岗位。</p><p>他的人生充满坎坷，无法说是幸福的，但</p><blockquote><p>即使没有完美的一生，所幸追求过完整的自我</p></blockquote><p>不论他的一生经历了多少苦难，出现了多少问题，但他内心的自我，他的本性，他的灵魂仍未变质，这是让人十分欣慰的。</p><p>刚开始读的时候感觉略微不适应，后来发现是因为最初的部分没什么环境描写，对话相对较少，内容更倾向于流水账一样，和前段时间刚读完的《虞美人草》形成了非常明显的对比，这个问题读到后面觉得多少有些缓解。不过用这样篇幅的一本书讲述一个人的一生，同时想要保持细节是完全不可能的，也只能去掉许多描写性质的部分，同时只选取最典型的一些故事。另外不知是翻译问题还是原文就是这样写的，许多地方让我感觉比较粗糙。</p><p>读完整本书后最让我意外的感受是我开始害怕一切。看到斯通纳的经历，我觉得越阅读，越学习，反而越是害怕。害怕对人性的恶看的更透彻，害怕被人的恶所影响，害怕不平和的未来，害怕和一个不合适的人结婚，害怕自己也像书中的故事的痛苦的一面一般，害怕自己极度抑制的充满恶的本性泄漏出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="约翰·威廉斯" scheme="https://fusionbolt.github.io/tags/%E7%BA%A6%E7%BF%B0%C2%B7%E5%A8%81%E5%BB%89%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>莫失莫忘</title>
    <link href="https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/"/>
    <id>https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/</id>
    <published>2023-04-17T13:23:03.000Z</published>
    <updated>2023-04-17T13:26:10.734Z</updated>
    
    <content type="html"><![CDATA[<p>这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。</p><p>从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱有疑问，是否和我所想的一样，后来证明了这一点。不知道原版的用词带给母语者的感受是怎么样的，如果会让人引起和我相同的想法那或许是作者有意为之。在后面揭露更多真相的时候，作者都是用了类似的做法，先透露出一点似乎不那么令人意外的线索，后来又从对话中传达真相并使读者感到震惊。至于为什么这么写，或许是提前进行漫长的铺垫，使得读者读到这里的时候有更强烈的感受。</p><p>回到书中的内容。凯西、汤米、露丝显然是整个故事中最核心的角色。凯西和汤米对一切进行了思考，而不是一直只有接受。</p><p>露丝则是很明显被用于对比的角色，她的态度更倾向于接受外部的一切，不论是汤米和凯西的看法还是当汤米实际与她讨论可能的真相时她都表现出了如此的特质。但同时露丝也是一个传达许多真相并且推进的角色，当一切都铺垫好以后，也就不再需要这样一个只是接受的角色一起参与探索背后的真相，自然的将故事舞台的主导权完全交给了汤米和凯西。汤米则是推动这一切进展的角色，思考一切背后的真相，去做各种尝试。而”我“，也就是凯西，更像是观察这一切，关联起这一切的角色。不论是和汤米接触，还是和露丝的关系，又或者是直到最后看着这一切。最后提到了“我”记忆中的黑尔舍姆，“我”从未寻找黑尔舍姆，却到处都能发现黑尔舍姆的点点滴滴，到不同的地方，看到不同的东西，找到黑尔舍姆也许是意味着回忆起了曾经的时光。后面还有这样一段话</p><blockquote><p>就像是我对汤米和露丝的回忆。一旦我能够过上比较平静的生活，不论他们把我送到哪间康复中心，黑尔舍姆都会始终跟我在一起，安全的保留在我脑海中，这是任何人都无法拿走的。</p></blockquote><p>在书中一开始的剧情中，艺廊或许是一个令人疑惑的存在，而对艺廊的疑问直到最终才被揭开。在提及艺廊的真相时，不论是汤米的推论还是实际的真相，都谈到了从作品中揭示出人的灵魂，或者说证明他们有灵魂。那么我想可以反过来，换一个非常极端的说法：人若无法创造出什么，那么无法证明这个人有灵魂。或许是缺少内在、无法产生自己的想法、没有自我、无法对外部质疑，不论怎么说都无法被称为人，而是一类什么。</p><p>说到做了，我想再提及之前凯西提出的质疑：“如果我们反正只是为了捐献，然后死去，那么上那些课是为什么？”答案并没有直说，但我想是让学生通过这样的课程，能够在活着的时间内形成自己独特的灵魂，尽管是部分受限的（因为接收到的信息是经过挑选的）。而这个问题，即便对普通人也是一样的，我来换个问法：如果我们生来只是为了活几十年，然后死去，那么做现在这些事情是为什么？这件事情一定没有什么标准答案。首先我认同的是人生无意义的观点，但我认为人灵魂的存在可以选择在离去之前选择填充自己的灵魂并留下些什么，也并非一定要有什么意义，我们不需要满世界去寻找什么意义，这种东西本就不存在于任何地方，也不应当一切用意义来蒙蔽自己的眼睛。</p><p>看到最后的真相我才明白为什么这本书被归结为科幻小说。对于科幻小说的定位我起初也有些费解，认为科幻小说就是各种未来世界、充满了不存在的科技等等，尤其是当我看到最终真相之前，绝大部分的内容完全没有看到科技的痕迹。这本书与我所想的科幻小说相差巨大，尤其是在我没读到最后的时候。但偶然有一天我听到一档播客节目，里面谈到各种各样科幻小说的形式，提及作者石黑一雄的小说相比于科幻更注重于人与人之间的关系，才明白科幻小说还可以这样来写。</p><p>在这些正文后还有译后记，在这部分内容提到一个从我完全没想到的角度提到的细思恐极的事情</p><blockquote><p>当艾米丽小姐坐着轮椅从阴影中出来的时候，读者不禁期望她会有更多的情感流露。她为之奋斗终生的黑尔舍姆事业已经告终，但这两个孩子是她事业的成果，他们的成就值得她自豪。然而她一心都放在要卖掉的柜子上，甚至基本的待客礼仪都欠奉，终究“我们”和“他们”的壁垒如此森严，毕竟她要从轮椅上站起来、恢复健康，多半还要指望从“他们”身上收获的器官。</p></blockquote><p>写到这里我联想到了一个很重要的细节，当真相大白的时候，夫人和艾米丽小姐也都提到其实她们是和外人一样对他们是抱有恐惧的，甚至艾米丽小姐还会对他们感到厌恶。此时艾米丽小姐说“可我下决心不让这种情绪阻止我去做正确的事。我跟这些情绪作战，并且战胜了。”这句话在当时读的时候我没觉得有什么，但现在回头看来，她所说的正确的事情到底是什么，到底是让他们成为人，还是让他们成为捐献者呢？另外此时我才意识到过去夫人对他们的害怕也是真的对他们这些人自身，而不是其他东西感到害怕。许多事情和夫人对他们的害怕一样，在前面只是未提及，有的很晚才给出解释，有的甚至并未直白的给出解释。但当我们无意中发现真相时，又会感受到骇人。这种处处埋藏线索与问题的写法，除了让我们感受强烈，我认为可以有另一种过度的解读，这或许是作者刻意这样做的，是为了让我们去思考问题，而不只是去接受这一切。</p><p>另外译者认为他们不质疑人生，不反抗生来的宿命，关于这一点我有一些想法。他们获得的信息都是经过精挑细选的，因此对他们来说根本没有质疑人生和反抗宿命的概念。对他们来说，能去思考背后的真相以及想要尝试延迟几乎可以说是能做到的极限了。如果是作为反乌托邦小说来讲，和我之前看过的美丽新世界和1984相同，这样的设定下人们都是会被各种方式所影响，几乎不会产生这样的概念，我目前看的不多，但就我看过的几本来说，反乌托邦总是离不开人们被“教育”成接受一切，无法反抗的状态，同时主线也是类似探寻真相与反抗的故事，不知其他同类书籍怀有怎样的观点和故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。&lt;/p&gt;
&lt;p&gt;从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="石黑一雄" scheme="https://fusionbolt.github.io/tags/%E7%9F%B3%E9%BB%91%E4%B8%80%E9%9B%84/"/>
    
  </entry>
  
  <entry>
    <title>2023.4.10-4.16 下陷</title>
    <link href="https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/"/>
    <id>https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/</id>
    <published>2023-04-16T14:46:37.000Z</published>
    <updated>2023-04-17T13:28:37.114Z</updated>
    
    <content type="html"><![CDATA[<p>和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存在于这里。</p><h1 id="本周的变化"><a href="#本周的变化" class="headerlink" title="本周的变化"></a>本周的变化</h1><p>这周我几乎看到了自己从动力十足的状态逐渐一步步变烂的整个过程，我觉得有必要来回顾一下这周发生了什么。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>周一正常的工作，但是到点早早回到家开始修改自己的sideproj，难得的好状态，因此一直肝到了晚上十二点多，太上头甚至没怎么练琴。</p><p>周二正常的工作，大部分事情和周一相同，状态也是比较好。这天花了不少时间去练琴，练的是新的部分，还是比较吃力。</p><p>前两天都是打车上下班，大风加沙尘暴的恶劣天气加上早上起不来，仅有的一点运动都缺失了。</p><p>但周三开始就不对劲了，研究dwarf的时候迟迟没有什么所想的进展，渐渐开始紧张，烦躁，给自己加压，最后把自己逼迫到了出现负面想法的情况。之后出去走了一公里，情绪渐渐缓解了一点，但回来就开始感到疲惫，勉强看完书后身体就开始想要刷视频，刷完视频后练琴有些不在状态，很快就停下了。也没有精力去做sideproj，之后继续刷视频，最后晚睡。</p><p>周四也遇到了问题，开始觉得发懵，觉得意识与行动的联系变弱了，开始有一种恍惚感：不知道该做什么，不知道对错，无法深入理性思考，只能看到什么做什么，而且是不用脑子的那种。这一天也开始眼睛感到不适，除了休息不好以及最近可能用不干净的手频繁触摸眼睛周围外，高强度的用眼也是难逃其责。工作期间起身去厕所的时候也能明显感受到身体的疲劳。晚上迟迟搞不定工作上的问题，开始钻牛角尖，缺乏耐心，攻击自己，最后也是很晚回家，并且同样多走了一段路（都是为了一定程度的锻炼身体），但是这两天自我攻击比较严重，现在看来这个时候多走路反而是负担。到了家优先趴在了床上，勉强看了一点书，之后也没怎么练琴。</p><p>周五更是严重，前一天晚上睡眠平均心率增加到了79，早上到公司的时候开始有些轻微头晕，易怒。下午一直没有搞出周四没解决的问题，越来越钻牛角尖，感到更多压力，紧张，开始觉得任务会无法完成。其实这个时候已经几乎无法正常思考问题的解决方案了，但仍然只是在那里堆时间，胡乱操作。</p><h2 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h2><p>首先是写代码的时间，周一到周四线性的减少了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.png"                      alt="Untitled"                ></p><p>练琴开启节拍器的时间。但有两个部分没有记录，一个是识谱，另一个是在使用另一个app的时间没有记录，但是这两部分在周三和周四也都是没在用的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.jpeg"                      alt="Untitled"                ></p><p>睡眠心率平均值，最近的常规值是70出头，周四的晚上到了最高值79，不过这个的影响因素很多，很难直接断定。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.png"                      alt="Untitled"                ></p><p>另外则是睡眠的时间，这个难以准确记录。</p><p>根据其他信息记录，上床时间分别为</p><ol><li>1:26</li><li>1:00</li><li>1:30</li><li>1:40</li><li>1:40</li></ol><p>屏幕使用时间难以准确记录，但是周三开始回家就想看动画，刷视频，也刷了蛮久</p><h2 id="我出了什么问题？"><a href="#我出了什么问题？" class="headerlink" title="我出了什么问题？"></a>我出了什么问题？</h2><p>自大与碰壁。周一周二sideproj良好的进度让我觉得dwarf那边也能随便解决，但实际上我想要的资料几乎没有，开始觉得自己不行。</p><p>发现自己在钻牛角尖没能及时停下来。不论是dwarf的问题还是工作上的问题，我都多少有点意识到自己进入了死胡同，但是都没能及时停下，而是加速朝着墙冲过去。过度集中使得我反而迷失了方向。这是我一直以来的坏毛病。</p><p>没有根据自己身体的疲劳调整。这几天多次行动使得自己开始累积压力，积压疲劳，而此时我并没有停下，而是尽可能的再去做些什么。我就像一个机器人一样，只是给自己安排任务，不到难以控制的情况是不会停下来的。</p><h1 id="心理咨询的结束"><a href="#心理咨询的结束" class="headerlink" title="心理咨询的结束"></a>心理咨询的结束</h1><p>大概是最后一次心理咨询，谈了一下近况，聊了一些问题。</p><p>首先是最近的情况怎么样？我提到之前被人问及的最焦虑的事情，我一时之间不知道怎么回答，后来回答的是不安，工作的焦虑，但其实自己一方面觉得焦虑一方面又觉得无所谓，最近这种无所谓的态度特别强烈。而我不论是否那么关心这个问题，不论怎么折腾，现实也就这个样，没什么变化。</p><p>那你是觉得不论怎么样生活都是一样的，就因此不折腾了吗？并不是该折腾折腾，能折腾到什么样就是什么样。</p><p>又从我之前说过遇到问题时可能有人一起会更好开始，问我如果和别人在一起呢？而我前两天则开始觉得，似乎跟朋友在一起也是一样，女朋友又不可能有。后来讲下去谈到了找女朋友的问题，这部分还讲了半天。</p><p>之后问到我要解决的现实问题怎么办？我的答复是只能每个方面磨下去，自己没办法像钻头一样，逐个击破，所以需要自己在更漫长时间的努力，将每个方面一点点磨下去。有点像是无奈之举，除此之外只有等待什么机会，或者什么事件。</p><p>说到自我贬低的部分，我说自己不接受赞美只接受批评，因为我认为别人的赞美是因为看到了我的一些表象。</p><p>咨询师说别人看到的都是不对的吗？我的回答是有许多错觉的部分，当然也有正确的部分。</p><p>又问我那你能不能相信一下别人说的夸奖的内容？我说不信，本质上是我没有认同自己，主要是我发自内心不觉得自己是多么好的人。尽管有一点点好的部分，但自己有着数不尽的问题。自己做的好的那么一点点也都是“应该”，做的不好的地方就是自己的问题。</p><p>后来说到自己脑中一闪而过的“给别人挑刺，贬低别人”的想法，自己也正如这样对待自己。“如果自己变厉害了就不会这样不认同自己了”，如果一直怀有这样的想法，即便站上顶点也依然不会放过自己。因为即便在顶点，也可以站的更高，这也有一部分是因为人上进的本性，不接受自己，批评自己的想法也是有促进自己前进的正面意义，只是这样的自己像是严酷的监工（-1hp +2atk）。</p><p>又说到自己最近一周，由于不放过自己，持续逼迫自己，使得自己的情况十分清晰可见的越来越不好。我觉得自己要做的还是应该多放过自己一些，感受自己的想法，避免进入泥潭，而未掉入泥潭的我相比于掉入的我还是会多不少处理能力。</p><p>最后要结束的时候咨询师说我实际上很强大，希望我能记得。不过我对此其实还是没有什么实感，没有什么想法，还是会继续当监工，只是监督力度可能会开始有意识的减弱，否则我会继续倒下去。我的心理咨询大概到这里就彻底结束了。</p><h1 id="本周其他想法的一些记录"><a href="#本周其他想法的一些记录" class="headerlink" title="本周其他想法的一些记录"></a>本周其他想法的一些记录</h1><h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>dwarf没有什么我想要的例子，看了半天连个开头都没搞明白，瞬间变得特别沮丧了…又开始意识到自己是个废物，准备出门走走，起身来才意识到刚才自己看的时候压力多大，明显感到十分疲惫，呼吸短浅，渐渐察觉自己又到了这种极其负面的状态，意识到自己又在和以往一样遇到点解不出的难题就开始烦，给身体不断施加压力，同时想到自己只是想根据潜意识解决，或者找一个现有的东西抄，而没想过怎么用现有知识去进一步思考…</p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>感觉到自己的精力太少远远不够用的…前两天有些拼，这两天已经明显开始觉得身体在抗议，疲惫，想要享乐这个想法变得更强烈，更难抵抗，最近每日有效工作加学习时间逐日渐少…</p><p>今天我又感觉到那种因为疲劳而感到抽离于现实的感觉。这种时候能做的就是看到什么能做的去做什么，而没有办法去思考自己该怎么做，自己该做什么，如果工作996的话简直不敢想会变成什么样子</p><p>不仅是精力不足以及身体疲劳，昨天遇到搞不懂的东西后自己对自己的心理压迫也是一个很大的影响因素…</p><h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.jpeg"                      alt="Untitled"                ></p><p>这样说了，心里在欺骗自己说自己本来就是个废物，爱咋咋地，就这样摆烂吧。转去练琴的时候想到了自己练琴也都很慢，就潜意识中加快了速度，选择了我跟不上的节拍练习…</p><p>想起白天好几个同事来问我问题，我当时其实有点虚荣，觉得大家都来问我，这样好啊，但又知道自己也就那一点点东西。但是没办法，这件事情上并不是为了荣誉什么的，反而是觉得被人需要了很开心…虽然如此，但还是像我上面说的有虚荣心在，自己没有什么过硬的水准，只好从这种方面和角度给自己找信心，这样说出来也蛮丢人的</p><p>觉得比别人好的自己，觉得比别人差的自己，自傲的自己，自卑的自己，无一例外都是自己，真的是分裂</p><p>感觉负面想法开始冒出来了，这是我没有好好照顾自己，没有重视自己感受到一个结果吧。不知道这几天里疲劳和负面情绪是谁先动的手，反正现在是两败俱伤，我也一直没有太关注平常的身体状态。对我来说不论状态好还是不好，要做的事情都是一样的，只是说做多做少，逼不逼自己的区别罢了，只想无止境的压榨着远不如常人的精力</p><h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>看到别人在参与复杂的项目，讨论相关技术，想到自己只是一直在做自己的玩具项目，而且进度非常非常慢，觉得自己大概只有做这点玩具的份了，技术和其他条件都不行，以后能不能在编译器的岗位都很成问题…</p><p>担心失业，担心做什么都只能在入门处徘徊。虽然失业也不是就没路了，但我终归想在这条路走下去，也想做的更深入更好<br>想起两年前全程找工作的那个月，觉得以我的条件根本就找不到，也不可能找得上做编译器的工作，现在也这样觉得，只是之前运气好一点做了ai编译器，但霉运的我不可能以后都去依靠运气…</p><p>做玩具也挺开心的，能实现些什么东西我觉得很棒，不然我也不会花时间去做<br>只是当这件事情与生活的压力产生了交集，与我停滞不前的水平产生了交集，加上我的扭曲思考方式，最后这件事情产生了完全不一样的性质…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其四 mergeable section</title>
    <link href="https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/"/>
    <id>https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/</id>
    <published>2023-04-16T07:37:08.000Z</published>
    <updated>2023-04-16T07:39:34.874Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-4-mergeable-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:83834646</center> <p>上一期的内容讲完了一些针对文件的简单处理以及符号决议，这一期的主要内容是在这之后针对mergeable section的决议与合并。</p><h1 id="resolve-section-pieces"><a href="#resolve-section-pieces" class="headerlink" title="resolve_section_pieces"></a>resolve_section_pieces</h1><p>这个过程是将mergeable的section split到更小的pieces中，并且将每一个piece和其他来自不同文件的pieces进行合并，最典型的例子是不同object file中string段的合并。mold中称mergeable section原子单元为section pieces。</p><p>所以这里的过程分为了两部分</p><ol><li>将普通的section转换为MegeableSection</li><li>resolve and merge</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_section_pieces</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_section_pieces&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">initialize_mergeable_sections</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_section_pieces</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialize-mergeable-sections"><a href="#initialize-mergeable-sections" class="headerlink" title="initialize_mergeable_sections"></a>initialize_mergeable_sections</h1><p>mold中attach section pieces symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_mergeable_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  mergeable_sections.<span class="built_in">resize</span>(sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; m = <span class="built_in">split_section</span>(ctx, *isec)) &#123;</span><br><span class="line">        mergeable_sections[i] = std::<span class="built_in">move</span>(m);</span><br><span class="line">        isec-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每一个section进行split_section，转换为一个MergeableSection，之后将原始的section设置为非alive。</p><h2 id="MergeableSection"><a href="#MergeableSection" class="headerlink" title="MergeableSection"></a>MergeableSection</h2><p>首先我们来看和MergeableSection相关的数据结构，有如下三个</p><ol><li>MergeableSection</li><li>MergedSection</li><li>SectionFragment</li></ol><p>其中每个MergeableSection中包含了多个SectionFragment，又关联了其对应的MergedSection。MergedSection是一个chunk，而chunk则是在链接后期要输出到文件的时候的一个基本单位，暂时先不进一步讲解。SectionFragment则是MergedSection根据MergeableSection传入的信息构造的，并且返回给MergeableSection保存的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeableSection</span> &#123;</span></span><br><span class="line">  std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt; <span class="built_in">get_fragment</span>(i64 offset);</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; *parent;</span><br><span class="line">  u8 p2align = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;std::string_view&gt; strings;</span><br><span class="line">  std::vector&lt;u64&gt; hashes;</span><br><span class="line">  std::vector&lt;u32&gt; frag_offsets;</span><br><span class="line">  std::vector&lt;SectionFragment&lt;E&gt; *&gt; fragments;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> MergedSection&lt;E&gt; *</span></span><br><span class="line"><span class="function">  <span class="title">get_instance</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view name, u64 type, u64 flags)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SectionFragment&lt;E&gt; *<span class="title">insert</span><span class="params">(std::string_view data, u64 hash, i64 p2align)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assign_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_to</span><span class="params">(Context&lt;E&gt; &amp;ctx, u8 *buf)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_stats</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  HyperLogLog estimator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">MergedSection</span>(std::string_view name, u64 flags, u32 type);</span><br><span class="line"></span><br><span class="line">  ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br><span class="line">  std::vector&lt;i64&gt; shard_offsets;</span><br><span class="line">  std::once_flag once_flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionFragment</span> &#123;</span></span><br><span class="line">  <span class="built_in">SectionFragment</span>(MergedSection&lt;E&gt; *sec) : <span class="built_in">output_section</span>(*sec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SectionFragment</span>(<span class="keyword">const</span> SectionFragment &amp;other)</span><br><span class="line">    : <span class="built_in">output_section</span>(other.output_section), <span class="built_in">offset</span>(other.offset),</span><br><span class="line">      <span class="built_in">p2align</span>(other.p2align.<span class="built_in">load</span>()), <span class="built_in">is_alive</span>(other.is_alive.<span class="built_in">load</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">u64 <span class="title">get_addr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  u32 offset = <span class="number">-1</span>;</span><br><span class="line">  std::<span class="keyword">atomic_uint8_t</span> p2align = <span class="number">0</span>;</span><br><span class="line">  std::<span class="keyword">atomic_bool</span> is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MergedSection并不暴露对应的构造函数，而是通过对应的get_instance来获取实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(Context&lt;E&gt; &amp;ctx, std::string_view name,</span><br><span class="line">                               u64 type, u64 flags) &#123;</span><br><span class="line">  name = <span class="built_in">get_merged_output_name</span>(ctx, name, flags);</span><br><span class="line">  flags = flags &amp; ~(u64)SHF_GROUP &amp; ~(u64)SHF_COMPRESSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;]() -&gt; MergedSection * &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;osec : ctx.merged_sections)</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">tuple</span>(name, flags, type) ==</span><br><span class="line">          std::<span class="built_in">tuple</span>(osec-&gt;name, osec-&gt;shdr.sh_flags, osec-&gt;shdr.sh_type))</span><br><span class="line">        <span class="keyword">return</span> osec.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search for an exiting output section.</span></span><br><span class="line">  <span class="keyword">static</span> std::shared_mutex mu;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">      <span class="keyword">return</span> osec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new output section.</span></span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">    <span class="keyword">return</span> osec;</span><br><span class="line"></span><br><span class="line">  MergedSection *osec = <span class="keyword">new</span> <span class="built_in">MergedSection</span>(name, flags, type);</span><br><span class="line">  ctx.merged_sections.<span class="built_in">emplace_back</span>(osec);</span><br><span class="line">  <span class="keyword">return</span> osec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取的时候去ctx中寻找实例，不存在则创建新的并且返回。</p><h2 id="split-section"><a href="#split-section" class="headerlink" title="split_section"></a>split_section</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt;</span><br><span class="line"><span class="built_in">split_section</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;sec) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!sec.is_alive || sec.sh_size == <span class="number">0</span> || sec.relsec_idx != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = sec.<span class="built_in">shdr</span>();</span><br><span class="line">  <span class="keyword">if</span> (!(shdr.sh_flags &amp; SHF_MERGE))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>由于是针对mergeable section，而判断标准则是根据section header中的sh_flgas的值，因此先通过检查flga来进行过滤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; <span class="built_in">rec</span>(<span class="keyword">new</span> MergeableSection&lt;E&gt;);</span><br><span class="line">rec-&gt;parent = MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(ctx, sec.<span class="built_in">name</span>(), shdr.sh_type,</span><br><span class="line">                                             shdr.sh_flags);</span><br><span class="line">rec-&gt;p2align = sec.p2align;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If thes section contents are compressed, uncompress them.</span></span><br><span class="line">sec.<span class="built_in">uncompress</span>(ctx);</span><br><span class="line"></span><br><span class="line">std::string_view data = sec.contents;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *begin = data.<span class="built_in">data</span>();</span><br><span class="line">u64 entsize = shdr.sh_entsize;</span><br><span class="line">HyperLogLog estimator;</span><br></pre></td></tr></table></figure><p>做一些基本的初始化操作，包括创建了MergeableSection以及关联对应的MergedSection，取出数据等。</p><h3 id="split-string"><a href="#split-string" class="headerlink" title="split string"></a>split string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split sections</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_flags &amp; SHF_STRINGS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// GHC (Glasgow Haskell Compiler) sometimes creates a mergeable</span></span><br><span class="line">    <span class="comment">// string section with entsize of 0 instead of 1, though such</span></span><br><span class="line">    <span class="comment">// entsize is technically wrong. This is a workaround for the issue.</span></span><br><span class="line">    entsize = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> end = <span class="built_in">find_null</span>(data, entsize);</span><br><span class="line">    <span class="keyword">if</span> (end == data.npos)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: string is not null terminated&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, end + entsize);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(end + entsize);</span><br><span class="line"></span><br><span class="line">    rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">    rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">    u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">    rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">    estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">find_null</span><span class="params">(std::string_view data, u64 entsize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">find</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt;= data.<span class="built_in">size</span>() - entsize; i += entsize)</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">substr</span>(i, entsize).<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;\0&#x27;</span>) == data.npos)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data.npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到terminator（’\0’）</li><li>将对应的rec的strings添加找到的str</li><li>添加对应的frag_offsets</li><li>添加string的hash到estimator中</li></ol><p>estimator是用于优化时间的方案，等到最后会提及，不影响合并的正确性。</p><h3 id="split-other"><a href="#split-other" class="headerlink" title="split other"></a>split other</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// OCaml compiler seems to create a mergeable non-string section with</span></span><br><span class="line">    <span class="comment">// entisze of 0. Such section is malformed. We do not split such section.</span></span><br><span class="line">    <span class="keyword">if</span> (entsize == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % entsize)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: section size is not multiple of sh_entsize&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, entsize);</span><br><span class="line">      data = data.<span class="built_in">substr</span>(entsize);</span><br><span class="line"></span><br><span class="line">      rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">      rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">      u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">      rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">      estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>和split string的区别在于不是通过’\0’而是通过entsize判断一个piece的结束位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rec-&gt;parent-&gt;estimator.<span class="built_in">merge</span>(estimator);</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;string_fragments&quot;</span>)</span></span>;</span><br><span class="line">counter += rec-&gt;fragments.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> rec;</span><br></pre></td></tr></table></figure><p>最后的收尾</p><h1 id="ObjectFile-resolve-section-pieces"><a href="#ObjectFile-resolve-section-pieces" class="headerlink" title="ObjectFile::resolve_section_pieces"></a>ObjectFile::resolve_section_pieces</h1><ul><li><input disabled="" type="checkbox"> 如何判断是相同的字符串？？对应地址怎么办</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_section_pieces</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : mergeable_sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      m-&gt;fragments.<span class="built_in">reserve</span>(m-&gt;strings.<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; m-&gt;strings.<span class="built_in">size</span>(); i++)</span><br><span class="line">        m-&gt;fragments.<span class="built_in">push_back</span>(m-&gt;parent-&gt;<span class="built_in">insert</span>(m-&gt;strings[i], m-&gt;hashes[i],</span><br><span class="line">                                                 m-&gt;p2align));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Shrink vectors that we will never use again to reclaim memory.</span></span><br><span class="line">      m-&gt;strings.<span class="built_in">clear</span>();</span><br><span class="line">      m-&gt;hashes.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将所有MergableSection的数据merge到对应的parent中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_abs</span>() || esym.<span class="built_in">is_common</span>() || esym.<span class="built_in">is_undef</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">  <span class="keyword">if</span> (!m)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  i64 frag_offset;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frag)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad symbol value: &quot;</span> &lt;&lt; esym.st_value;</span><br><span class="line"></span><br><span class="line">  sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">  sym.value = frag_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是attach section piece to symbols的过程。本质的操作是将对应的有定义的且非abs的符号关联到对应的fragment。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the size of frag_syms.</span></span><br><span class="line">  i64 nfrag_syms = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections)</span><br><span class="line">    <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx))</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">            esym.st_type == STT_SECTION &amp;&amp; mergeable_sections[<span class="built_in">get_shndx</span>(esym)])</span><br><span class="line">          nfrag_syms++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">resize</span>(nfrag_syms);</span><br></pre></td></tr></table></figure><p>之后寻找满足条件的esym，统计对应的size。</p><p>注意寻找的是ElfRel中的esym，只有ElfRel中的esym才能被relocation，因为merge的过程中必然会修改各种地址信息。</p><p>这里根据sym得到的index获取对应的mergeable_section是在前一步init的过程中初始化的，也就是说这个index对于mergeable_section和原始的section是完全对应的，如果不是mergeable的section则返回的会是空指针。</p><p>接下来是引用mergeable section的relocation symbol，会针对每一个这样的symbol redirect rel sym到一个新创建的dummy到symbol上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For each relocation referring a mergeable section symbol, we create</span></span><br><span class="line"><span class="comment">// a new dummy non-section symbol and redirect the relocation to the</span></span><br><span class="line"><span class="comment">// newly-created symbol.</span></span><br><span class="line">i64 idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type != STT_SECTION)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">    <span class="keyword">if</span> (!m)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    i64 r_addend = <span class="built_in">get_addend</span>(*isec, r);</span><br><span class="line"></span><br><span class="line">    SectionFragment&lt;E&gt; *frag;</span><br><span class="line">    i64 in_frag_offset;</span><br><span class="line">    std::<span class="built_in">tie</span>(frag, in_frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value + r_addend);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frag)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad relocation at &quot;</span> &lt;&lt; r.r_sym;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;frag_syms[idx];</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.<span class="built_in">set_name</span>(<span class="string">&quot;&lt;fragment&gt;&quot;</span>);</span><br><span class="line">    sym.sym_idx = r.r_sym;</span><br><span class="line">    sym.visibility = STV_HIDDEN;</span><br><span class="line">    sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">    sym.value = in_frag_offset - r_addend;</span><br><span class="line">    r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line">    idx++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> i64 <span class="title">get_addend</span><span class="params">(u8 *loc, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rel.r_addend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt;</span><br><span class="line">MergeableSection&lt;E&gt;::<span class="built_in">get_fragment</span>(i64 offset) &#123;</span><br><span class="line">  std::vector&lt;u32&gt; &amp;vec = frag_offsets;</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), offset);</span><br><span class="line">  i64 idx = it - <span class="number">1</span> - vec.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;fragments[idx], offset - vec[idx]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的对新的sym设置了基本信息，主要是进行双向的关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sym.sym_idx = r.r_sym;</span><br><span class="line">r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol:sym_idx</span></span><br><span class="line"><span class="comment">// Index into the symbol table of the owner file.</span></span><br><span class="line">i32 sym_idx = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>这里将rel中的sym指向了elf_syms后面的位置，后面会将执行frag_syms逐一添加到elf_syms之后。</p><p>最后将frag_syms都添加到ObjectFile的symbols中，整个过程就全部结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(idx == <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Symbol&lt;E&gt; &amp;sym : <span class="keyword">this</span>-&gt;frag_syms)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(&amp;sym);</span><br></pre></td></tr></table></figure><h2 id="MergedSection-insert"><a href="#MergedSection-insert" class="headerlink" title="MergedSection::insert"></a>MergedSection::insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SectionFragment&lt;E&gt; *</span><br><span class="line">MergedSection&lt;E&gt;::<span class="built_in">insert</span>(std::string_view data, u64 hash, i64 p2align) &#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_flag, [&amp;] &#123;</span><br><span class="line">    <span class="comment">// We aim 2/3 occupation ratio</span></span><br><span class="line">    map.<span class="built_in">resize</span>(estimator.<span class="built_in">get_cardinality</span>() * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  <span class="keyword">bool</span> inserted;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, inserted) = map.<span class="built_in">insert</span>(data, hash, <span class="built_in">SectionFragment</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">assert</span>(frag);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_maximum</span>(frag-&gt;p2align, p2align);</span><br><span class="line">  <span class="keyword">return</span> frag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br></pre></td></tr></table></figure><p>第一次insert的时候进行预估大小，之后进行insert。</p><p>在看到这里的实现我在想，在merge string的时候是要比较长度吗，在这里我得到了答案，是直接通过之前保存的hash保证unique。</p><p>另外这里用到了estimator，estimator的类型是hyperloglog，根据注释</p><blockquote><p>This file implements HyperLogLog algorithm, which estimates the number of unique items in a given multiset.</p></blockquote><p>谷歌的结果是这样的</p><blockquote><p>HyperLogLog is <strong>an algorithm for the count-distinct problem, approximating the number of distinct elements in a multiset</strong><br>. Calculating the exact cardinality of the distinct elements of a multiset requires an amount of memory proportional to the cardinality, which is impractical for very large data sets.</p></blockquote><p>有兴趣的可以去看wiki或者更多资料，这不在此系列博客的研究范围内。</p><h1 id="整个过程的回顾"><a href="#整个过程的回顾" class="headerlink" title="整个过程的回顾"></a>整个过程的回顾</h1><p>resolve_section_pieces由两部分操作组成</p><ol><li>针对所有mergeable的段进行split，将InputSection转换为对应的MergeableSection</li><li>针对所有MergeableSection进行merge<ol><li>strings Merge到相关联的MergedSection中</li><li>symbols attach to piece section</li><li>针对rel的symbol关联到一个新创建的dummy的symbol上</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-4-mergeab</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="Section" scheme="https://fusionbolt.github.io/tags/Section/"/>
    
  </entry>
  
  <entry>
    <title>1984</title>
    <link href="https://fusionbolt.github.io/2023/04/09/Reading/1984/"/>
    <id>https://fusionbolt.github.io/2023/04/09/Reading/1984/</id>
    <published>2023-04-09T09:16:34.000Z</published>
    <updated>2023-04-09T09:20:55.444Z</updated>
    
    <content type="html"><![CDATA[<p>未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。</p><blockquote><p>是老派改革家想象中那种愚蠢快乐主义乌托邦的精确对立面。一个恐惧、背叛与折磨的世界，一个践踏与被践踏的世界，一个在变得更精致的同时会变得更加残酷，而非更不残酷的世界。我们这个世界里的进步，会是朝向带来更多痛苦的进步。</p></blockquote><p>而人们所在的世界，其实更仅一步来说是由所在的社会构成，社会的构成又很大程度归结于所在国家的权力机构。我一直在想人们对于“关注政治和社会问题”这个问题本身应该怀有怎样的态度，至少我一直是不太关心，也不想去关心。但读完了这本书似乎让我对这个问题的想法产生了一些变化。起源于温斯顿和茱莉亚的交流过程，茱莉亚是一个学会在这种环境下生存的人，也会认为这个环境很蠢，但是不愿去谈论这些。当温斯顿和她讲述关于一些党的内容却是毫不关心。</p><blockquote><p>对于党内教条的种种分支，她连一点兴趣都没有。每次他开始讲到英社的种种原则、双重思想、过去的易变性、对客观现实的否定，还有用到新语字汇时，她就会变得既无聊又困惑，还说她从来不去注意那种事情。你知道那全都是废话，那么为什么要让自己去操心那个？</p></blockquote><p>而在后面的内容作者讲述了这样一段的内容</p><blockquote><p>他们可以被动地接受最明目张胆的违反现实，因为他们从来没有彻底掌握到他们受到的要求是多么大的罪恶，对于公共事件也不够有兴趣，不足以注意到发生了什么事。因为缺乏理解力，他们保持心智健全。他们就只是把什么都吞下去，就像一颗玉米粒完全未经消化，就通过了一只鸟的身体。</p></blockquote><p>这个世界是很残酷的，当读到这些内容，我觉得作者很明显是想告诉我们应该意识到问题，而不应该无视这一切。关于政治问题，基于国情似乎已经没什么办法，但是关于社会问题与我们越来越息息相关，比如说前两年的疫情的情况，比如说退休年龄的变动。而我想这个问题也可以引申为人们对于外在信息的态度，不应当照单全收，而是应该去思考，否则很容易受到欺骗。虽然受到过一些要敢于怀疑答案和质疑的教育，但是似乎并没有留下多深的印象，在我写这部分内容之前已经忘却了大半。不管你怎么处理，首先要自己主动去理解，遇到错误的时候也不是所有的事情都能去纠正的。</p><p>而书中也谈及了许多社会相关的一些根源问题。印象深刻的是阶级的固化这部分内容，我认为在上层的人想要巩固自己阶级的位置，下层的人未曾想过也很难去改变，中间层的人大多又向上爬，或许这也是阶级的本质。而作者也表达出了类似的观点：</p><blockquote><p>就算在极大的动乱与看似无法挽回的改变之后，同样的模式总是会自动重新确立，就像一个陀螺仪不管朝着此方或彼方推得多用力，总是会回归均衡状态。</p></blockquote><p>我想也正因如此，1984的世界中强权者才肯放任“最下层”的普罗阶级，因为他们不会去想改变这些，只想留在原地，同时在文化和信息的限制下他们也无法习得去改变这一行为，只是去对党员进行十分严格的管制。温斯顿一直认为“希望在普罗阶级”，“普罗阶级一直保持人性。他们并没有变得心如铁石。他们坚守着他自己必须刻意努力重新学习的那些原始情绪。“，换个角度来说为了维持稳定，党员们这些所谓的“人性”都要被扼杀。</p><p>前面提到了阶级，那么平等问题是不可避免要被提及的，产生了阶级就意味着不平等。但是平等的话上位人就无法获得权力，以下是作者的观点：</p><blockquote><p>不平等是文明的代价。然而随着机器制造的发展，状况改变了。就算人类还是必须做不同类型的工作，他们却不再有必要过着社会或经济水平不同的生活。所以，在即将攫取权力的新群体眼中，人类的平等不再是值得奋起争取的理想，而是一个必须回避的危险。</p></blockquote><p>本文开头提到的《美丽新世界》尽管是人们富足快乐的世界，但是同样存在着上面所诉说的一些问题，并且和1984一切同样都是建立在强权统治下。相对于《美丽新世界》来说1984有些许多可以对比谈论的问题。在两个世界中，强权者都做了许多事情来避免大多数人们来动摇自己的权力。</p><p>首先是文化与信息上。两者都在避免人们了解过去了，不过一个是隐藏，一个是修改与破坏。同时在通过各种手段“修改与限制”人们的<strong>独立思考</strong>，一个是从小开始进行反复洗脑催眠，另一个则是出动”思想警察“来限制人们。正如1984中所说</p><blockquote><p>因为要是所有人都享有同样的闲暇与安全，在常态下被贫困弄得傻头傻脑的绝大多数人类都会变得有文化学识，也将学会如何为自己思考，而他们一旦做到这件事，他们迟早会领悟到掌握特权的少数根本没有用处，他们会把那些人扫到一旁去。长期来说，阶级社会只有在贫穷与无知的基础上才可能成立</p></blockquote><p>两者都谈到了技术的停滞，新世界的技术是为了稳定，因为科技、真理代表破坏现有的平衡，而1984则是为了限制自由，甚至只有在技术产物能够透过某种方式缩减人类的自由时，技术的进步才会发生。但是对于强权者来说，本质都是为了巩固自己的权力。</p><p>但对待大多数人们的态度是完全不同的。一个类似于让人们共同富裕，催眠洗脑，乐不思蜀，另一个类似于压迫，强权，威吓。但是两者又都明确了阶级，在美丽新世界中是不同的人种，同时又会对这些人种进行催眠，让他们觉得自己就应该做当前的事情，1984中则是明确区分了党员和普罗阶级，对于违反规定的党员进行最恐怖的制裁，使得他们“心甘情愿”产生改变。让我印象最深刻的是这样一句话：</p><blockquote><p>早就期待着的子弹进入了他的大脑。</p></blockquote><p>相比起1984来说，新世界确实非常美好。这个世界到底会走向什么样子呢？就目前的情况来说我想并不会那么乐观，至少对于大部分的地方如此。想要超越别人、掌控别人我觉得是人类作为动物的兽性中衍生出的一部分，那么也不可避免的有许多人会去追求权力，最后有人为了巩固强权做出什么也不奇怪。而在这样的世界中，大部分人能做的或许只有去学着不被动接受外部的信息，多进行独立思考，作者也许是想要警醒人们，并且试着影响读者们这样来做，至少能够一定程度上推迟或者避免这样的世界到来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是老派改革家想象中那种愚蠢快乐主义乌托邦的</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="赫胥黎" scheme="https://fusionbolt.github.io/tags/%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其三 符号决议</title>
    <link href="https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/"/>
    <id>https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/</id>
    <published>2023-04-09T08:06:20.000Z</published>
    <updated>2023-04-09T08:11:35.212Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-3-symbol-resolve/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:72272420</center> <p>前面两期将读取输入的部分全部讲完了，本期开始涉及链接过程中的处理。在讲主要的符号决议之前，先讲一下mold在符号决议执行之前做的一些其他处理。</p><h1 id="dso-uniquely"><a href="#dso-uniquely" class="headerlink" title="dso uniquely"></a>dso uniquely</h1><p>在读取完输入后首先做的是将shared object根据soname进行去重，因此我们可以在链接的过程中链接多个相同soname的库而不会产生冲突。</p><p>elf/main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unordered_set&lt;std::string_view&gt; seen;</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">return</span> !seen.<span class="built_in">insert</span>(file-&gt;soname).second;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="apply-exclude-libs"><a href="#apply-exclude-libs" class="headerlink" title="apply_exclude_libs"></a>apply_exclude_libs</h1><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_exclude_libs</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_exclude_libs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.exclude_libs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unordered_set&lt;std::string_view&gt; <span class="title">set</span><span class="params">(ctx.arg.exclude_libs.begin(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ctx.arg.exclude_libs.end())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;archive_name.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">if</span> (set.<span class="built_in">contains</span>(<span class="string">&quot;ALL&quot;</span>) ||</span><br><span class="line">          set.<span class="built_in">contains</span>(<span class="built_in">filepath</span>(file-&gt;archive_name).<span class="built_in">filename</span>().<span class="built_in">string</span>()))</span><br><span class="line">        file-&gt;exclude_libs = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是简单将所有包含在exclude-libs里的lib名字对应的exclude_libs设置为true，而这个设置在后面符号决议的过程会用到。</p><p>exclude_libs是命令行中获取的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_arg</span>(<span class="string">&quot;exclude-libs&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">append</span>(ctx.arg.exclude_libs, <span class="built_in">split_by_comma_or_colon</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="create-internal-file"><a href="#create-internal-file" class="headerlink" title="create_internal_file"></a>create_internal_file</h1><h2 id="internal-file是什么"><a href="#internal-file是什么" class="headerlink" title="internal file是什么"></a>internal file是什么</h2><p>内部的文件，用来保存linker-synthesized符号。linker-synthesized符号或许也可以理解为编译产物中不存在的符号。作为一个并不实际存在的文件，依然会作为一个普通的ObjFile加入到obj_pool中，主要用途是在create_output_sections以后来add_synthetic_symbol，与之相关联的有一个internal_esyms，里面都是具体相关的符号。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在main函数中调用是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.arg.relocatable)</span><br><span class="line">  <span class="built_in">create_internal_file</span>(ctx);</span><br></pre></td></tr></table></figure><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_internal_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;;</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  ctx.internal_obj = obj;</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(obj);</span><br><span class="line"></span><br><span class="line">  ctx.internal_esyms.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(<span class="keyword">new</span> Symbol&lt;E&gt;);</span><br><span class="line">  obj-&gt;first_global = <span class="number">1</span>;</span><br><span class="line">  obj-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  obj-&gt;priority = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>首先创建了基本的ObjectFile对象并且进行了一些初始化的处理。</p><p>之后添加从命令行参数中读取的–defsym里的所有的defsym</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  std::pair&lt;Symbol&lt;E&gt; *, std::variant&lt;Symbol&lt;E&gt; *, u64&gt;&gt; &amp;defsym = ctx.arg.defsyms[i];</span><br><span class="line">  <span class="built_in">add</span>(defsym.first);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::holds_alternative&lt;Symbol&lt;E&gt; *&gt;(defsym.second)) &#123;</span><br><span class="line">    <span class="comment">// Add an undefined symbol to keep a reference to the defsym target.</span></span><br><span class="line">    <span class="comment">// This prevents elimination by e.g. LTO or gc-sections.</span></span><br><span class="line">    <span class="comment">// The undefined symbol will never make to the final object file; we</span></span><br><span class="line">    <span class="comment">// double-check that the defsym target is not undefined in</span></span><br><span class="line">    <span class="comment">// fix_synthetic_symbols.</span></span><br><span class="line">    <span class="keyword">auto</span> sym = std::get&lt;Symbol&lt;E&gt; *&gt;(defsym.second);</span><br><span class="line">    <span class="built_in">add_undef</span>(sym);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完defsym后再从命令行参数中读取的SectionOrder的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">  <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">get_symbol</span>(ctx, ord.name));</span><br></pre></td></tr></table></figure><p>关于SectionOrder的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOrder</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br><span class="line">  std::string name;</span><br><span class="line">  u64 value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后设置obj类的一些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;elf_syms = ctx.internal_esyms;</span><br><span class="line">obj-&gt;symvers.<span class="built_in">resize</span>(ctx.internal_esyms.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="defsym"><a href="#defsym" class="headerlink" title="defsym"></a>defsym</h2><p>关于前面提到的defsym，我们来看一下mold的测试代码一部分来理解其作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | $CC -fPIC -o $t/a.o -c -xc -</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> foo;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %p %p\n&quot;</span>, &amp;foo, &amp;bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">baz</span>();</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$CC -B. -o $t/exe $t/a.o -pie -Wl,-defsym=foo=<span class="number">16</span> \</span><br><span class="line">  -Wl,-defsym=bar=<span class="number">0x2000</span> -Wl,-defsym=baz=print</span><br><span class="line"></span><br><span class="line">$QEMU $t/exe | grep -q <span class="string">&#x27;^Hello 0x10 0x2000$&#x27;</span></span><br></pre></td></tr></table></figure><p>通过defsym指定了符号名以及其实现的位置，尽管对应的符号在代码中并没有实现。</p><p>关于这里的add和add_undef的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An actual value will be set to a linker-synthesized symbol by</span></span><br><span class="line">  <span class="comment">// fix_synthetic_symbols(). Until then, `value` doesn&#x27;t have a valid</span></span><br><span class="line">  <span class="comment">// value. 0xdeadbeef is a unique dummy value to make debugging easier</span></span><br><span class="line">  <span class="comment">// if the field is accidentally used before it gets a valid one.</span></span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_ABS;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_undef = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_UNDEF;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过add和add_undef函数把defsym指定的符号添加到symbols中，并且设定为了特殊值，关联到了一个esym里。主要的差别就在于st_shndx被设置为了不同的值。</p><h1 id="符号决议"><a href="#符号决议" class="headerlink" title="符号决议"></a>符号决议</h1><p>接下来是链接过程中比较重要的一个环节，符号决议（symbol resolve）</p><p>在mold中，这个部分做了四件事情</p><ol><li>检测所有需要使用的objet files</li><li>移除重复的COMDAT段</li><li>进行符号决议的过程。在多个不同的esym中选择出一个更高priority的关联到sym中</li><li>LTO的处理，处理后再次执行决议</li></ol><h2 id="resolve-symbols"><a href="#resolve-symbols" class="headerlink" title="resolve_symbols"></a>resolve_symbols</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">  std::vector&lt;SharedFile&lt;E&gt; *&gt; dsos = ctx.dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先省略lto相关的具体处理，很多处理和do_resolve_symbols中是类似的，因此放到后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> for_each_file = [&amp;](std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; fn) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, fn);</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 1. 检测object files</span></span><br><span class="line"><span class="comment">// 2. 消除重复COMDAT</span></span><br><span class="line"><span class="comment">// 3. 符号决议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-检测object-files"><a href="#1-检测object-files" class="headerlink" title="1. 检测object files"></a>1. 检测object files</h2><p>archive extraction: .a成员只会在满足非archive object文件未定义符号之一的情况下才会被包含在最终的二进制文件中</p><p>链接时为了满足archive extraction的规则，mold采取的策略是：</p><ol><li>初步resolve：假设全部include，match undef符号</li><li>mark sweep消除无需使用的archive成员</li><li>删除掉非archive成员</li></ol><p>下面是具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;extract_archive_members&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register symbols</span></span><br><span class="line">    for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark reachable objects to decide which files to include into an output.</span></span><br><span class="line">    <span class="comment">// This also merges symbol visibility.</span></span><br><span class="line">    <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup. The rule used for archive extraction isn&#x27;t accurate for the</span></span><br><span class="line">    <span class="comment">// general case of symbol extraction, so reset the resolution to be redone</span></span><br><span class="line">    <span class="comment">// later.</span></span><br><span class="line">    for_each_file([](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">clear_symbols</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that the symbol references are gone, remove the eliminated files from</span></span><br><span class="line">    <span class="comment">// the file list.</span></span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.objs, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>for_each_file针对objs和dsos处理resolve，mark live，clear，erase file</li><li>标记所有可访问的输出到文件的object，之后合并可见性</li><li>清除file的symbols</li><li>最后清除掉objs和dsos中非alive的file</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;thread&quot;</span>)))</span><br><span class="line"><span class="keyword">void</span> InputFile&lt;E&gt;::<span class="built_in">clear_symbols</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="built_in">get_global_syms</span>())</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      sym-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mark-live-objects"><a href="#mark-live-objects" class="headerlink" title="mark_live_objects"></a>mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_live_objects</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mark_symbol = [&amp;](std::string_view name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (InputFile&lt;E&gt; *file = <span class="built_in">get_symbol</span>(ctx, name)-&gt;file)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputFile&lt;E&gt; *&gt; roots;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(roots, [&amp;](InputFile&lt;E&gt; *file,</span><br><span class="line">                                    tbb::feeder&lt;InputFile&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      file-&gt;<span class="built_in">mark_live_objects</span>(ctx, [&amp;](InputFile&lt;E&gt; *obj) &#123; feeder.<span class="built_in">add</span>(obj); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对所有参数中传入的undef以及require_define的符号所关联的文件进行mark，之后遍历所有alive的obj和dso，加入到root中，之后再进行mark_live_objects。部分文件会因为特殊的链接选项，比如说whole-archive会影响是否设置为is_alive，这部分会之后再以这个为主题单独讲一篇。</p><p>对于ObjectFile和SharedFile的mark方式也是不同的。</p><h3 id="ObjectFile-mark-live-objects"><a href="#ObjectFile-mark-live-objects" class="headerlink" title="ObjectFile::mark_live_objects"></a>ObjectFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;is_alive);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>() &amp;&amp; exclude_libs)</span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, STV_HIDDEN);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, esym.st_visibility);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_weak</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sym.file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> keep = esym.<span class="built_in">is_undef</span>() || (esym.<span class="built_in">is_common</span>() &amp;&amp; !sym.<span class="built_in">esym</span>().<span class="built_in">is_common</span>());</span><br><span class="line">    <span class="keyword">if</span> (keep &amp;&amp; <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有global的符号进行处理。</p><ol><li><p>首先对esym进行merge_visibility，对于存在定义的exclude_libs的符号来说是HIDDEN的，关于这一点在命令行参数处有说明。</p><blockquote><p>-exclude-libs LIB,LIB,.. Mark all symbols in given libraries hidden</p></blockquote></li><li><p>跳过弱符号以及文件不存在的符号。</p></li><li><p>keep并且fast_mark成功的符号加入到root中。</p></li></ol><p>keep这里需要是undef的情况，我认为是因为如果esym存在定义，那么定义就是存在于当前的ObjectFile中，也就不需要再重复加入到root中了。common我想同样是因为这种情况下所在的文件已经加入到root中了。</p><p>关于merge_visibility</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">merge_visibility</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                     u8 visibility) &#123;</span><br><span class="line">  <span class="comment">// Canonicalize visibility</span></span><br><span class="line">  <span class="keyword">if</span> (visibility == STV_INTERNAL)</span><br><span class="line">    visibility = STV_HIDDEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = [&amp;](u8 visibility) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (visibility) &#123;</span><br><span class="line">    <span class="keyword">case</span> STV_HIDDEN:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_PROTECTED:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_DEFAULT:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unknown symbol visibility: &quot;</span> &lt;&lt; sym;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_minimum</span>(sym.visibility, visibility, [&amp;](u8 a, u8 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">priority</span>(a) &lt; <span class="built_in">priority</span>(b);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先将INTERNAL转换为HIDDEN，之后按照最小的priority来更新visibility。</p><p>update_minimum只是一个针对多线程的封装，本质上是一个compare and exchange操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">update_minimum</span>(std::atomic&lt;T&gt; &amp;atomic, u64 new_val, Compare cmp = &#123;&#125;) &#123;</span><br><span class="line">  T old_val = atomic.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cmp</span>(new_val, old_val) &amp;&amp;</span><br><span class="line">         !atomic.<span class="built_in">compare_exchange_weak</span>(old_val, new_val,</span><br><span class="line">                                       std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fast_mark也是针对多线程的一个封装，如果是false则更新为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An optimized &quot;mark&quot; operation for parallel mark-and-sweep algorithms.</span></span><br><span class="line"><span class="comment">// Returns true if `visited` was false and updated to true.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fast_mark</span><span class="params">(std::atomic&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A relaxed load + branch (assuming miss) takes only around 20 cycles,</span></span><br><span class="line">  <span class="comment">// while an atomic RMW can easily take hundreds on x86. We note that it&#x27;s</span></span><br><span class="line">  <span class="comment">// common that another thread beat us in marking, so doing an optimistic</span></span><br><span class="line">  <span class="comment">// early test tends to improve performance in the ~20% ballpark.</span></span><br><span class="line">  <span class="keyword">return</span> !visited.<span class="built_in">load</span>(std::memory_order_relaxed) &amp;&amp;</span><br><span class="line">         !visited.<span class="built_in">exchange</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SharedFile-mark-live-objects"><a href="#SharedFile-mark-live-objects" class="headerlink" title="SharedFile::mark_live_objects"></a>SharedFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; !sym.file-&gt;is_dso &amp;&amp;</span><br><span class="line">        <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说的唯一一点是因为mark的是object而不是shared file，因此dso的情况下不会进行mark</p><h2 id="2-移除重复的COMDAT段"><a href="#2-移除重复的COMDAT段" class="headerlink" title="2. 移除重复的COMDAT段"></a>2. 移除重复的COMDAT段</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;eliminate_comdats&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">eliminate_duplicate_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="built_in">update_minimum</span>(ref.group-&gt;owner, <span class="keyword">this</span>-&gt;priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新所有comdat_groups的priority</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">eliminate_duplicate_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="keyword">if</span> (ref.group-&gt;owner != <span class="keyword">this</span>-&gt;priority)</span><br><span class="line">      <span class="keyword">for</span> (u32 i : ref.members)</span><br><span class="line">        <span class="keyword">if</span> (sections[i])</span><br><span class="line">          sections[i]-&gt;<span class="built_in">kill</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eliminate重复的section。将section和fde的is_alive都设置为false。</p><p>这里将fde设置为false正对应了上期提到单独解析eh_frame的原因之一：消除重复的fde。</p><h2 id="3-实际进行符号决议的过程"><a href="#3-实际进行符号决议的过程" class="headerlink" title="3. 实际进行符号决议的过程"></a>3. 实际进行符号决议的过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>resolve_symbols的实现对于ObjectFile和SharedFile是不同的</p><h3 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    InputSection&lt;E&gt; *isec = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>() &amp;&amp; !esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">      isec = <span class="built_in">get_section</span>(esym);</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, !<span class="keyword">this</span>-&gt;is_alive) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(isec);</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = ctx.default_version;</span><br><span class="line">      sym.is_weak = esym.<span class="built_in">is_weak</span>();</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号决议是针对global symbol的elf_sym的。未定义的esym都跳过了，它们都不需要参与resolve的过程，因为resolve本质是找到需要加入到生成产物的符号实现，但是注意在前面mark的时候还是需要的。</p><p>也就是说Symbol类的sym其实是保留的最终唯一定义。而在决议的过程，不断的将esym和对应的sym进行比较。如果esym的rank小，也就是更加优先，那么就将sym中的信息更新为对应的esym的信息，这就是实际决议过程中做的事情。而这里也是实际初始化symbols成员里global的值的地方，local的部分初始化在parse的阶段就做好了，因为local的符号并不需要进行resolve。</p><h3 id="get-rank"><a href="#get-rank" class="headerlink" title="get_rank"></a>get_rank</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(<span class="keyword">const</span> Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!sym.file)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rank</span>(sym.file, sym.<span class="built_in">esym</span>(), !sym.file-&gt;is_alive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols with higher priorities overwrites symbols with lower priorities.</span></span><br><span class="line"><span class="comment">// Here is the list of priorities, from the highest to the lowest.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Strong defined symbol</span></span><br><span class="line"><span class="comment">//  2. Weak defined symbol</span></span><br><span class="line"><span class="comment">//  3. Strong defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  4. Weak Defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  5. Common symbol</span></span><br><span class="line"><span class="comment">//  6. Common symbol in an archive</span></span><br><span class="line"><span class="comment">//  7. Unclaimed (nonexistent) symbol</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ties are broken by file priority.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(InputFile&lt;E&gt; *file, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym, <span class="keyword">bool</span> is_lazy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!file-&gt;is_dso);</span><br><span class="line">    <span class="keyword">if</span> (is_lazy)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">6</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file-&gt;is_dso || is_lazy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">4</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_rank的实现，根据注释我们可以看到不同类别符号的优先级。</p><h3 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, <span class="literal">false</span>) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.origin = <span class="number">0</span>;</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = versyms[i];</span><br><span class="line">      sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于SharedFile中的符号中不需要考虑是否是global的问题，上期解析SharedFile的部分也有提到，对应的first_global就是0。相对于</p><h2 id="4-LTO的处理"><a href="#4-LTO的处理" class="headerlink" title="4. LTO的处理"></a>4. LTO的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">  <span class="comment">// Do link-time optimization. We pass all IR object files to the</span></span><br><span class="line">  <span class="comment">// compiler backend to compile them into a few ELF object files.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The compiler backend needs to know how symbols are resolved,</span></span><br><span class="line">  <span class="comment">// so compute symbol visibility, import/export bits, etc early.</span></span><br><span class="line">  <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line">  <span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line">  <span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line">  <span class="built_in">compute_import_export</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do LTO. It compiles IR object files into a few big ELF files.</span></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; lto_objs = <span class="built_in">do_lto</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do_resolve_symbols() have removed unreferenced files. Restore the</span></span><br><span class="line">  <span class="comment">// original files here because some of them may have to be resurrected</span></span><br><span class="line">  <span class="comment">// because they are referenced by the ELF files returned from do_lto().</span></span><br><span class="line">  ctx.objs = objs;</span><br><span class="line">  ctx.dsos = dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">append</span>(ctx.objs, lto_objs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redo name resolution from scratch.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_needed;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove IR object files.</span></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_lto_obj)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> file-&gt;is_lto_obj; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于apply_version_script, parse_symbol_version, compute_import_export这三个过程，会在之后的过程中讲解。这里简单来讲就是获取符号对应的版本信息以及对应import/export的属性。</p><p>这个部分做了这么几件事情</p><ol><li>计算出符号所需的基本信息</li><li>实际执行lto</li><li>将lto结果的object加入到全局</li><li>清理旧的lto文件</li><li>再次执行do_resolve_symbols整个过程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-3-symbol-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="symbol_resolve" scheme="https://fusionbolt.github.io/tags/symbol-resolve/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其二 读取SharedFile</title>
    <link href="https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/"/>
    <id>https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/</id>
    <published>2023-04-05T08:35:27.000Z</published>
    <updated>2023-04-05T08:50:32.743Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:70054356</center> <p>这期的内容主要是讲完读取输入的部分，有一些之前遗漏的信息，以及之前未讲完的初始化ehframe以及shared object读取的部分。有许多地方默认读者读过上期内容，建议先阅读上期内容后再来查看本期。</p><p><a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/" >https://homura.live/2023/02/26/mold/mold-1-read-input-files/<i class="fas fa-external-link-alt"></i></a></p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="get-string"><a href="#get-string" class="headerlink" title="get_string"></a>get_string</h2><p>之前在读取符号表的时候是通过这种方式读取的，但我们没有讲解这个读取的细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br></pre></td></tr></table></figure><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(idx &lt; elf_sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index: &quot;</span> &lt;&lt; idx;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  u8 *begin = mf-&gt;data + shdr.sh_offset;</span><br><span class="line">  u8 *end = begin + shdr.sh_size;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; end)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: section header is out of range: &quot;</span> &lt;&lt; shdr.sh_offset;</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)begin, (<span class="keyword">size_t</span>)(end - begin)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是找到文件中对应offset的data作为开始，根据长度构造一个<strong>string_view</strong>，注意这里并不是实际构造了一个string，因此返回的string并没有这块空间的所有权。</p><p>由get_string衍生出来的方法还有get_data，之前在读取elfsyms的时候就是使用了get_data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  std::string_view view = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shdr);</span><br><span class="line">  <span class="keyword">if</span> (view.<span class="built_in">size</span>() % <span class="built_in"><span class="keyword">sizeof</span></span>(T))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted section&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;(T *)view.<span class="built_in">data</span>(), view.<span class="built_in">size</span>() / <span class="built_in"><span class="keyword">sizeof</span></span>(T)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt; InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;T&gt;(elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接获取了get_string的结果，并且将对应的结果映射为了一个对应数据的span</p><h2 id="get-shndx"><a href="#get-shndx" class="headerlink" title="get_shndx"></a>get_shndx</h2><p>在之前从符号表取数据的时候是通过get_shndx实现的</p><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 ObjectFile&lt;E&gt;::<span class="built_in">get_shndx</span>(<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(&amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>] &lt;= &amp;esym);</span><br><span class="line">  <span class="built_in">assert</span>(&amp;esym &lt;= &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.st_shndx == SHN_XINDEX)</span><br><span class="line">    <span class="keyword">return</span> symtab_shndx_sec[&amp;esym - &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">return</span> esym.st_shndx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然符号中是有对应的shndx字段，但是这个字段的长度为16bit，如果超出这个长度的index那么需要去symtab_shndx_sec中获取。</p><p>这个限制在之前读取输入的时候多次遇到，比如说在构造InputFile类，读取shstrtab_idx的时候</p><p>input-files.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line"><span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">  ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br></pre></td></tr></table></figure><h2 id="eh-frame"><a href="#eh-frame" class="headerlink" title="eh_frame"></a>eh_frame</h2><p>eh_frame段对于大多数人来说比较陌生，因此首先来讲解eh_frame是什么。eh_frame是包含了记录如何处理异常信息的段，当异常抛出的时候runtime会寻找一个eh_frame记录的信息并且来处理。</p><p>我们来看一下hello world的汇编</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.section__TEXT,__text,regu</span><br><span class="line">lar,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">12</span>, <span class="number">0</span>sdk_version <span class="number">12</span>, <span class="number">1</span></span><br><span class="line">.globl_main                           ; -- Begin function main</span><br><span class="line">.p2align<span class="number">2</span></span><br><span class="line">_main:                                  ; @main</span><br><span class="line">.cfi_startproc</span><br><span class="line">; %bb<span class="number">.0</span>:</span><br><span class="line">subsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">stpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Spill</span><br><span class="line">addx29, sp, #<span class="number">16</span>                    ; =<span class="number">16</span></span><br><span class="line">.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">.cfi_offset w30, <span class="number">-8</span></span><br><span class="line">.cfi_offset w29, <span class="number">-16</span></span><br><span class="line">movw8, #<span class="number">0</span></span><br><span class="line">strw8, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Spill</span><br><span class="line">sturwzr, [x29, #<span class="number">-4</span>]</span><br><span class="line">adrpx0, l_.str@PAGE</span><br><span class="line">addx0, x0, l_.str@PAGEOFF</span><br><span class="line">bl_printf</span><br><span class="line">ldrw0, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Reload</span><br><span class="line">ldpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Reload</span><br><span class="line">addsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">.section__TEXT,__cstring,cstring_literals</span><br><span class="line">l_.str:                                 ; @.str</span><br><span class="line">.asciz<span class="string">&quot;Hello world\n&quot;</span></span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>关于eh_frame我有一个疑问，是否能像符号一样被strip掉？手动strip以后发现elf大小并没有发生改变。关于这个问题stackoverflow有这样一条回答</p><p><a class="link"   href="https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section" >Why GCC compiled C program needs .eh_frame section?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>You can disable generation of .eh_frame with -fno-asynchronous-unwind-tables for individual translation units, and this mostly eliminates the size cost</p></blockquote><blockquote><p>You cannot strip them with the strip command later; since .eh_frame is a section that lives in the loaded part of the program (this is the whole point), stripping it modifies the binary in ways that break it at runtime.</p></blockquote><p>大意是不能通过strip消除，但是eh_frame在gcc中可以通过开启特殊的编译选项避免生成。</p><h3 id="eh-frame的结构"><a href="#eh-frame的结构" class="headerlink" title="eh_frame的结构"></a>eh_frame的结构</h3><p><a class="link"   href="https://refspecs.linuxbase.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html" >Exception Frames<i class="fas fa-external-link-alt"></i></a></p><p>这里不详细介绍里面的具体字段了。简单来说，每个eh_frame段中会包含至少一个CFI（Call Frame Information），而每个CFI包含一个CIE（Common Information Entry），之后紧接着跟着许多FDE（Frame Description Entry）</p><p>一个CFI对应了一个单一的object文件，如果是多个object文件合并那么就会有多个，因此至少存在一个。CFI中包含了一个CIE，也就是这个object里的common information，而后面跟随的许多FDE则是对应了各个function。</p><p>这里引用一下MaskRay聚聚的资料，里面包含了更具体严谨的描述。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%201.png"                      alt="Untitled"                ></p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>对于链接器来说，ehframe和其他段不同是单独进行parse的。注释中给出了以下几条原因</p><ol><li>避免大量dead section的字段。如果只是最后拷贝所有的eh_frame则会有许多针对dead section的字段。</li><li>减少section的大小。删除function的时候顺便删除FDE，所以eh_frame不包含dead FDE。</li><li>增加搜索效率。扫描eh_frame段查找一个record是一个O(n)操作，通过linker创建一个sorted list后可以通过二分查找降低复杂度到O(log n)。</li></ol><p>接下来我们看一下具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">read_ehframe</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec) &#123;</span><br><span class="line">  std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  i64 cies_begin = cies.<span class="built_in">size</span>();</span><br><span class="line">  i64 fdes_begin = fdes.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// Read CIEs and FDEs until empty.</span></span><br><span class="line">std::string_view contents = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, isec.<span class="built_in">shdr</span>());</span><br><span class="line">i64 rel_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::string_view data = contents; !data.<span class="built_in">empty</span>();) &#123;</span><br><span class="line">    i64 size = *(U32&lt;E&gt; *)data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    i64 begin_offset = data.<span class="built_in">data</span>() - contents.<span class="built_in">data</span>();</span><br><span class="line">    i64 end_offset = begin_offset + size + <span class="number">4</span>;</span><br><span class="line">    i64 id = *(U32&lt;E&gt; *)(data.<span class="built_in">data</span>() + <span class="number">4</span>);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(size + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    i64 rel_begin = rel_idx;</span><br><span class="line">    <span class="keyword">while</span> (rel_idx &lt; rels.<span class="built_in">size</span>() &amp;&amp; rels[rel_idx].r_offset &lt; end_offset)</span><br><span class="line">      rel_idx++;</span><br><span class="line">    <span class="built_in">assert</span>(rel_idx == rels.<span class="built_in">size</span>() || begin_offset &lt;= rels[rel_begin].r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// This is CIE.</span></span><br><span class="line">      cies.<span class="built_in">emplace_back</span>(ctx, *<span class="keyword">this</span>, isec, begin_offset, rels, rel_begin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is FDE.</span></span><br><span class="line">      <span class="keyword">if</span> (rel_begin == rel_idx || rels[rel_begin].r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// FDE has no valid relocation, which means FDE is dead from</span></span><br><span class="line">        <span class="comment">// the beginning. Compilers usually don&#x27;t create such FDE, but</span></span><br><span class="line">        <span class="comment">// `ld -r` tend to generate such dead FDEs.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[rel_begin].r_offset - begin_offset != <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: FDE&#x27;s first relocation should have offset 8&quot;</span>;</span><br><span class="line"></span><br><span class="line">      fdes.<span class="built_in">emplace_back</span>(begin_offset, rel_begin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据这个解析过程以及参考格式描述我们能够画出这样一张图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%202.png"                      alt="Untitled"                ></p><p>在读取完所有基本的段以后，将CIE关联到FDE中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> find_cie = [&amp;](i64 offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = cies_begin; i &lt; cies.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (cies[i].input_offset == offset)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: bad FDE pointer&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  i64 cie_offset = *(I32&lt;E&gt; *)(contents.<span class="built_in">data</span>() + fdes[i].input_offset + <span class="number">4</span>);</span><br><span class="line">  fdes[i].cie_idx = <span class="built_in">find_cie</span>(fdes[i].input_offset + <span class="number">4</span> - cie_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将FDE关联到InputSection中。注意这里进行了stable_sort，上面提到的第三条增加搜索效率就是通过这里实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">stable_sort</span>(fdes.<span class="built_in">begin</span>() + fdes_begin, fdes.<span class="built_in">end</span>(),</span><br><span class="line">                 [&amp;](<span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;a, <span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_isec</span>(a)-&gt;<span class="built_in">get_priority</span>() &lt; <span class="built_in">get_isec</span>(b)-&gt;<span class="built_in">get_priority</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>();) &#123;</span><br><span class="line">  InputSection&lt;E&gt; *isec = <span class="built_in">get_isec</span>(fdes[i]);</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;fde_begin == <span class="number">-1</span>);</span><br><span class="line">  isec-&gt;fde_begin = i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; fdes.<span class="built_in">size</span>() &amp;&amp; isec == <span class="built_in">get_isec</span>(fdes[i]))</span><br><span class="line">    i++;</span><br><span class="line">  isec-&gt;fde_end = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个eh_frame部分的初始化就完毕了。</p><h1 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先我们来看一下SharedFile的构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt; *</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf) &#123;</span><br><span class="line">  SharedFile&lt;E&gt; *obj = <span class="keyword">new</span> <span class="built_in">SharedFile</span>(ctx, mf);</span><br><span class="line">  ctx.dso_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">SharedFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_needed = ctx.as_needed;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !ctx.as_needed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分没什么特别要讲的，关于is_needed和is_alive会涉及到关于whole-archive这个选项，之后会再单独开文章讲解。构造基类InputFile之前在ObjectFile的部分已经讲过了，不再赘述。接着来看parse的部分。</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是找到DYNSYM段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNSYM);</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>之后读取符号表和ver信息，这些是Shared only的成员。而soname是针对一个dso的，所以个dso关联一个soname</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">soname = <span class="built_in">get_soname</span>(ctx);</span><br><span class="line">version_strings = <span class="built_in">read_verdef</span>(ctx);</span><br></pre></td></tr></table></figure><p>读取具体的符号信息以及符号版本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read a symbol table.</span></span><br><span class="line">std::span&lt;ElfSym&lt;E&gt;&gt; esyms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line"></span><br><span class="line">std::span&lt;U16&lt;E&gt;&gt; vers;</span><br><span class="line"><span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERSYM))</span><br><span class="line">  vers = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U16&lt;E&gt;&gt;(ctx, *sec);</span><br></pre></td></tr></table></figure><p>对于DYNSYM来说symtab_sec-&gt;sh_info是开始的符号数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = symtab_sec-&gt;sh_info; i &lt; esyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  u16 ver;</span><br><span class="line">  <span class="keyword">if</span> (vers.<span class="built_in">empty</span>() || esyms[i].<span class="built_in">is_undef</span>())</span><br><span class="line">    ver = VER_NDX_GLOBAL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ver = (vers[i] &amp; ~VERSYM_HIDDEN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ver == VER_NDX_LOCAL)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::string_view name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esyms[i].st_name;</span><br><span class="line">  <span class="keyword">bool</span> is_hidden = (!vers.<span class="built_in">empty</span>() &amp;&amp; (vers[i] &amp; VERSYM_HIDDEN));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;elf_syms2.<span class="built_in">push_back</span>(esyms[i]);</span><br><span class="line">  <span class="keyword">this</span>-&gt;versyms.<span class="built_in">push_back</span>(ver);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_hidden) &#123;</span><br><span class="line">    std::string_view mangled_name = <span class="built_in">save_string</span>(</span><br><span class="line">      ctx, std::<span class="built_in">string</span>(name) + <span class="string">&quot;@&quot;</span> + std::<span class="built_in">string</span>(version_strings[ver]));</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, mangled_name, name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个for循环中针对每个符号信息来说做了以下几件事情</p><ol><li><p>处理version信息。</p><ol><li>跳过只有一个VER_NDX_LOCAL属性的</li><li>vers为空或esym未定义，则是global的（大概用于symbol resolve去寻找定义。因此设为了GLOBAL</li><li>不为空且有定义，那么就不是HIDDEN的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_LOCAL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_GLOBAL = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VERSYM_HIDDEN = <span class="number">0x8000</span>;</span><br></pre></td></tr></table></figure></li><li><p>添加elf_syms2（Shared Only的字段）以及versysms</p></li><li><p>处理hidden的符号，hidden的话要mangled才行</p><ul><li><input disabled="" type="checkbox"> 为什么呢…</li></ul></li></ol><p>设置基本信息后结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = elf_syms2;</span><br><span class="line"><span class="keyword">this</span>-&gt;first_global = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;dso_syms&quot;</span>)</span></span>;</span><br><span class="line">counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>这里first_global设置为0，也就是说dso中所有的符号都是global的。</p><h2 id="get-soname"><a href="#get-soname" class="headerlink" title="get_soname"></a>get_soname</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::string SharedFile&lt;E&gt;::<span class="built_in">get_soname</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNAMIC))</span><br><span class="line">    <span class="keyword">for</span> (ElfDyn&lt;E&gt; &amp;dyn : <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfDyn&lt;E&gt;&gt;(ctx, *sec))</span><br><span class="line">      <span class="keyword">if</span> (dyn.d_tag == DT_SONAME)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + dyn.d_val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mf-&gt;given_fullpath)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;filename;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">filepath</span>(<span class="keyword">this</span>-&gt;filename).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到DYNAMIC段，从里面的ElfDyn中查找tag为DT_SONAME的，找不到就用依靠完整文件路径作为soname。</p><p>关于ElfDyn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ElfDyn</span>&lt;</span>RV64LE&gt;     : EL64Dyn &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EL64Dyn</span> &#123;</span></span><br><span class="line">  ul64 d_tag;</span><br><span class="line">  ul64 d_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在elf规范中关于DT_SONAME这个tag的信息</p><table><thead><tr><th>Name</th><th>d_un</th><th>Executable</th><th>Shared Object</th></tr></thead><tbody><tr><td>DT_SONAME</td><td>d_val</td><td>ignored</td><td>optional</td></tr></tbody></table><blockquote><p>This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the DT_STRTAB entry. See “Shared Object Dependencies” below for more information about these names.</p></blockquote><h2 id="verdef"><a href="#verdef" class="headerlink" title="verdef"></a>verdef</h2><blockquote><p>Symbol versioning is a <strong>GNU extension</strong> to the ELF file format.</p></blockquote><blockquote><p>Versions are just strings, and no ordering is defined between them. For example, “GLIBC_2.15” is not considered a newer version of “GLIBC_2.2.5” or vice versa. They are considered just different.</p></blockquote><blockquote><p>If a shared object file has versioned symbols, it contains a parallel array for the symbol table. Version strings can be found in that parallel table.</p></blockquote><blockquote><p>One version is considered the “default” version for each shared object. If an undefiend symbol <code>foo</code> is resolved to a symbol defined by the shared object, it’s marked so that it’ll be resolved to (<code>foo</code>, the default version of the library) at load-time.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::vector&lt;std::string_view&gt; SharedFile&lt;E&gt;::<span class="built_in">read_verdef</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">std::vector&lt;std::string_view&gt; <span class="title">ret</span><span class="params">(VER_NDX_LAST_RESERVED + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *verdef_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERDEF);</span><br><span class="line">  <span class="keyword">if</span> (!verdef_sec)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  std::string_view verdef = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, *verdef_sec);</span><br><span class="line">  std::string_view strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, verdef_sec-&gt;sh_link);</span><br><span class="line"></span><br><span class="line">  ElfVerdef&lt;E&gt; *ver = (ElfVerdef&lt;E&gt; *)verdef.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.<span class="built_in">size</span>() &lt;= ver-&gt;vd_ndx)</span><br><span class="line">      ret.<span class="built_in">resize</span>(ver-&gt;vd_ndx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ElfVerdaux&lt;E&gt; *aux = (ElfVerdaux&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_aux);</span><br><span class="line">    ret[ver-&gt;vd_ndx] = strtab.<span class="built_in">data</span>() + aux-&gt;vda_name;</span><br><span class="line">    <span class="keyword">if</span> (!ver-&gt;vd_next)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ver = (ElfVerdef&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿一个helloworld的elf看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ./a.out</span><br><span class="line"></span><br><span class="line">[ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000516</span>  <span class="number">00000516</span></span><br><span class="line">     <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里的全体大小为2，我们再看一下符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line">w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line">U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>其中两个是重复的符号，去重后也就是2个符号</p><h1 id="对比ObjectFile和SharedFile"><a href="#对比ObjectFile和SharedFile" class="headerlink" title="对比ObjectFile和SharedFile"></a>对比ObjectFile和SharedFile</h1><p>最后我们通过分析ObjectFile和SharedFile相关的异同来结束这期内容。</p><p>相比于ObjectFile的复杂解析过程，SharedFile的整个过程显得十分简单。这和文件本身的性质与使用场景都有关系。dso加载符号的定义以及其他信息绝大部分都是在运行时，因此在链接期间并不需要做太多操作，其主要用途是将会被引用的符号加入到决议过程，同时将对应符号的版本信息和dso的soname加入到生成的产物中，以便在运行时进行加载。在谷歌搜索的时候搜到了这样一句话，我觉得概括的更好</p><blockquote><p>A DSO can be used in place of archive libraries and will minimize overall memory usage because code is shared.</p></blockquote><p>在链接的时候dso的作用是in place of archive libraries，所以并不需要太多的信息。</p><p>虽然SharedFile在链接的时候并没有解析ObjectFile中许多信息，但是那些信息仍然是存在的，只是在链接的时候无需参与，而是全部交给运行时加载来处理。虽然在mold的类结构中ObjectFile和SharedFile都是直接继承自InputFile，但对于实际的object和dso来说我觉得dso更倾向于是特别的object，不过这个从dso的全名（dynamic shared object）也能看出来了。</p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a class="link"   href="https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w" >https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-2-read-sh</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="eh_frame" scheme="https://fusionbolt.github.io/tags/eh-frame/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其一 读取输入文件</title>
    <link href="https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/"/>
    <id>https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/</id>
    <published>2023-02-26T09:40:55.000Z</published>
    <updated>2023-02-26T09:45:10.272Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg"                      alt="图像"                >上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。</p><p>首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可能从代码中去捋清不同结构之间的联系。</p><p>我们从elf_main函数中的read_input_files开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_input_files</span>(ctx, file_args);</span><br></pre></td></tr></table></figure><h1 id="read-input-files"><a href="#read-input-files" class="headerlink" title="read_input_files"></a>read_input_files</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_input_files</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::span&lt;std::string&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;read_input_files&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>&gt;&gt; state;</span><br><span class="line">  ctx.is_static = ctx.arg.is_static;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string_view arg = args[<span class="number">0</span>];</span><br><span class="line">    args = args.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="string">&quot;--as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bstatic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bdynamic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--start-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--end-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--version-script=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--version-script: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_version_script</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--dynamic-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dynamic-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol=&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">        ctx.default_version = VER_NDX_GLOBAL;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.version_patterns.<span class="built_in">push_back</span>(&#123;arg, <span class="string">&quot;--export-dynamic-symbol&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;global&quot;</span>, VER_NDX_GLOBAL, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--export-dynamic-symbol-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--push-state&quot;</span>) &#123;</span><br><span class="line">      state.<span class="built_in">push_back</span>(&#123;ctx.as_needed, ctx.whole_archive, ctx.is_static,</span><br><span class="line">                       ctx.in_lib&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--pop-state&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no state pushed before popping&quot;</span>;</span><br><span class="line">      std::<span class="built_in">tie</span>(ctx.as_needed, ctx.whole_archive, ctx.is_static, ctx.in_lib) =</span><br><span class="line">        state.<span class="built_in">back</span>();</span><br><span class="line">      state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;-l&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_library</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      mf-&gt;given_fullpath = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, std::<span class="built_in">string</span>(arg)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no input files&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.tg.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是根据命令行参数确定要读取的输入文件，这里大部分的分支是为了读取符号version信息相关的，主要是看read_file的实现。在看实现之前可以看到传入了一个MappedFile，而这个类的实现其实就是在打开文件的时候使用了mmap进行映射，而must_open则是进行判断，失败了直接报错，这里也不贴具体细节代码了。</p><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.visited.<span class="built_in">contains</span>(mf-&gt;name))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  FileType type = <span class="built_in">get_file_type</span>(mf);</span><br><span class="line">... 省略对不同type的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是get_file_type，这个是通过文件开头的值确定文件的类型，我们这里以ELF的代码为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">FileType <span class="title">get_file_type</span><span class="params">(MappedFile&lt;C&gt; *mf)</span> </span>&#123;</span><br><span class="line">  std::string_view data = mf-&gt;<span class="built_in">get_contents</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> FileType::EMPTY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;\177ELF&quot;</span>)) &#123;</span><br><span class="line">    u8 byte_order = ((elf::EL32Ehdr *)data.<span class="built_in">data</span>())-&gt;e_ident[elf::EI_DATA];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (byte_order == elf::ELFDATA2LSB) &#123;</span><br><span class="line">      elf::EL32Ehdr &amp;ehdr = *(elf::EL32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::I386&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::X86_64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elf::EB32Ehdr &amp;ehdr = *(elf::EB32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::M68K&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::SPARC64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FileType::UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  ... 省略其他格式的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从数据开头的“\177ELF”确定为ELF文件，之后根据ELFHeader里面的内容读取更多的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FileType</span> &#123;</span></span><br><span class="line">  UNKNOWN,</span><br><span class="line">  EMPTY,</span><br><span class="line">  ELF_OBJ,</span><br><span class="line">  ELF_DSO,</span><br><span class="line">  MACH_OBJ,</span><br><span class="line">  MACH_EXE,</span><br><span class="line">  MACH_DYLIB,</span><br><span class="line">  MACH_BUNDLE,</span><br><span class="line">  MACH_UNIVERSAL,</span><br><span class="line">  AR,</span><br><span class="line">  THIN_AR,</span><br><span class="line">  TAPI,</span><br><span class="line">  TEXT,</span><br><span class="line">  GCC_LTO_OBJ,</span><br><span class="line">  LLVM_BITCODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mold当前所支持的FileType就是这些，但是注意，GitHub中mold项目下只存在elf文件的支持，mach的格式则是在sold这个项目中处理。除此之外的文件格式都在以下的switch中进行处理</p><p><a class="link"   href="https://github.com/bluewhalesystems/sold" >https://github.com/bluewhalesystems/sold<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, mf, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_DSO:</span><br><span class="line">  ctx.dsos.<span class="built_in">push_back</span>(<span class="built_in">new_shared_file</span>(ctx, mf));</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::AR:</span><br><span class="line"><span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">  <span class="keyword">for</span> (MappedFile&lt;Context&lt;E&gt;&gt; *child : <span class="built_in">read_archive_members</span>(ctx, mf)) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(child)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">      ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, child, mf-&gt;name));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line">    <span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">      <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, child, mf-&gt;name))</span><br><span class="line">        ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::TEXT:</span><br><span class="line">  <span class="built_in">parse_linker_script</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line"><span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">  <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, mf, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: unknown file type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化下来这里主要分为这么几类文件</p><ol><li>archive file</li><li>lto</li><li>linker_script</li><li>object_file</li><li>shared_file</li></ol><h2 id="archive-file"><a href="#archive-file" class="headerlink" title="archive file"></a>archive file</h2><p>archive file，也就是俗称的.a文件，其实就是许多个object文件塞到一起只需要解析其中所有member，之后将每个member进行读取即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">std::vector&lt;MappedFile&lt;C&gt; *&gt;</span><br><span class="line"><span class="built_in">read_archive_members</span>(C &amp;ctx, MappedFile&lt;C&gt; *mf) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(mf)) &#123;</span><br><span class="line">  <span class="keyword">case</span> FileType::AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_fat_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_thin_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ar和thin ar</p><p><a class="link"   href="https://sourceware.org/binutils/docs/binutils/ar.html" >ar (GNU Binary Utilities)<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>An archive can either be <em>thin</em> or it can be normal. It cannot be both at the same time. Once an archive is created its format cannot be changed without first deleting it and then creating a new archive in its place.</p></blockquote><p>这里的具体细节暂且略过，如感兴趣可自行查看源码</p><h2 id="lto"><a href="#lto" class="headerlink" title="lto"></a>lto</h2><p>lto是用于link time optimization的文件，而本质上还是一个object文件，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_lto_obj</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_lto_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.ignore_ir_file.<span class="built_in">count</span>(mf-&gt;<span class="built_in">get_identifier</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  ObjectFile&lt;E&gt; *file = <span class="built_in">read_lto_object</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  file-&gt;archive_name = archive_name;</span><br><span class="line">  file-&gt;is_in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  ctx.has_lto_object = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mold中解析lto的方式是通过指定plugin，加载对应的so来进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">ObjectFile&lt;E&gt; *<span class="title">read_lto_object</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// V0 API&#x27;s claim_file is not thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_gcc_linker_api_v1)</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.plugin.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: don&#x27;t know how to handle this LTO object file &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;because no -plugin option was given. Please make sure you &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;added -flto not only for creating object files but also for &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;creating the final executable.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dlopen the linker plugin file</span></span><br><span class="line">  <span class="keyword">static</span> std::once_flag flag;</span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;] &#123; <span class="built_in">load_plugin</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>学习解析文件的实现主要是要进一步了解ELF的格式，所以这里具体细节就不进行考据了。</p><h2 id="linker-script"><a href="#linker-script" class="headerlink" title="linker script"></a>linker script</h2><p>mold的linker script根据解析的过程来看比较简单，没有在ld的脚本中的指定SECTION地址之类的内容，主要是对format以及符号version的一些控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_linker_script</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  current_file&lt;E&gt; = mf;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string_view&gt; vec = <span class="built_in">tokenize</span>(ctx, mf-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">  std::span&lt;std::string_view&gt; tok = vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!tok.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;OUTPUT_FORMAT&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_output_format</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;INPUT&quot;</span> || tok[<span class="number">0</span>] == <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_group</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;VERSION&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">      <span class="built_in">read_version_script</span>(ctx, tok);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok.<span class="built_in">size</span>() &gt; <span class="number">3</span> &amp;&amp; tok[<span class="number">1</span>] == <span class="string">&quot;=&quot;</span> &amp;&amp; tok[<span class="number">3</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      ctx.arg.defsyms.<span class="built_in">emplace_back</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">0</span>])),</span><br><span class="line">                                   <span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">2</span>])));</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SyntaxError</span>(ctx, tok[<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;unknown linker script token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h2><p>object file是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_object_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  ObjectFile&lt;E&gt; *file = ObjectFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf, archive_name, in_lib);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mold以链接速度快出名，而其快的原因之一就是充分利用了多线程，实际进行多线程操作的地方是在这里，ctx.tg.run，tg则是一个tbb::task_group，简而言之就是在这里开启了多线程的解析input file。</p><p>做了一些简单的in_lib参数处理，因为archive的链接机制默认是按需链接，而不是像shared file一样全部链接，之后在这里创建了object file并且开始parse。关于创建和parse的细节在后面再说。</p><h2 id="shared-file"><a href="#shared-file" class="headerlink" title="shared file"></a>shared file</h2><p>shared file同样是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SharedFile&lt;E&gt; *</span></span><br><span class="line"><span class="function"><span class="title">new_shared_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  SharedFile&lt;E&gt; *file = SharedFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里做了和object file类似的事情。</p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>在详细讲解object file和shared file创建以及解析之前先介绍一下他们和InputFile类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled.png"                      alt="Untitled"                ></p><p>ObjectFile和SharedFile都是简单的从InputFile中继承下来的。而这里的InputFile更像是代表了一个输入的ELF文件，构造的过程中做了一些ELF的基础解析，同时还提供了一些通用的接口，交由ObjectFile和SharedFile各自实现。</p><p>我们来看一下InputFile的构造函数部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">InputFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : <span class="built_in">mf</span>(mf), <span class="built_in">filename</span>(mf-&gt;name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfEhdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: file too small&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(mf-&gt;data, <span class="string">&quot;\177ELF&quot;</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: not an ELF file&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfEhdr&lt;E&gt; &amp;ehdr = *(ElfEhdr&lt;E&gt; *)mf-&gt;data;</span><br><span class="line">  is_dso = (ehdr.e_type == ET_DYN);</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *sh_begin = (ElfShdr&lt;E&gt; *)(mf-&gt;data + ehdr.e_shoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shnum contains the total number of sections in an object file.</span></span><br><span class="line">  <span class="comment">// Since it is a 16-bit integer field, it&#x27;s not large enough to</span></span><br><span class="line">  <span class="comment">// represent &gt;65535 sections. If an object file contains more than 65535</span></span><br><span class="line">  <span class="comment">// sections, the actual number is stored to sh_size field.</span></span><br><span class="line">  i64 num_sections = (ehdr.e_shnum == <span class="number">0</span>) ? sh_begin-&gt;sh_size : ehdr.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; (u8 *)(sh_begin + num_sections))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: e_shoff or e_shnum corrupted: &quot;</span></span><br><span class="line">               &lt;&lt; mf-&gt;size &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_sections;</span><br><span class="line">  elf_sections = &#123;sh_begin, sh_begin + num_sections&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line">  <span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">  i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">    ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br><span class="line"></span><br><span class="line">  shstrtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shstrtab_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从文件大小和文件头部标识信息进行ELF的校验，其次是做一些简单的解析。根据代码中可知，整个文件最开始的部分即可作为一个ElfEhdr（Ehdr：Elf Header）</p><p>根据header的信息可以解析出是否为dso文件，ElfShdr（Shdr：Section Header）的起始地址和长度，以及shstrtab（Section Header String Table）的位置。</p><p>大多数的参数直接可以获取，但是对于e_shnum和e_shstrndx来说，由于长度只有16bit的限制，因此如果值过大，则会分别存到第一个Shdr的sh_size以及sh_link中。</p><p>那么根据这段代码我们可以看出ELF的文件信息是这样的</p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先是ObjectFile的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt; *</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                      std::string archive_name, <span class="keyword">bool</span> is_in_lib) &#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;(ctx, mf, archive_name, is_in_lib);</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">ObjectFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                          std::string archive_name, <span class="keyword">bool</span> is_in_lib)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf), <span class="built_in">archive_name</span>(archive_name), <span class="built_in">is_in_lib</span>(is_in_lib) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !is_in_lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数被放入了private中，因此必须通过静态的create方法来创建实例。在每次创建的时候会将对应的obj对象放入到全局的ctx.obj_pool中，mold中的内存与生命周期的管理方式则是全部交由ctx保有，到最后一起释放。而对应的obj_pool为了多线程的设计也都使用了并发的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbb::concurrent_vector&lt;std::unique_ptr&lt;ObjectFile&lt;E&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数只是传递了参数，大部分的解析还是在InputFile的构造函数中执行。</p><h2 id="parse过程开始"><a href="#parse过程开始" class="headerlink" title="parse过程开始"></a>parse过程开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  sections.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>());</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_SYMTAB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (symtab_sec) &#123;</span><br><span class="line">    <span class="comment">// In ELF, all local symbols precede global symbols in the symbol table.</span></span><br><span class="line">    <span class="comment">// sh_info has an index of the first global symbol.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;first_global = symtab_sec-&gt;sh_info;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialize_sections</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_symbols</span>(ctx);</span><br><span class="line">  <span class="built_in">sort_relocations</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_ehframe_sections</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symtab-sec"><a href="#symtab-sec" class="headerlink" title="symtab_sec"></a>symtab_sec</h2><p>首先是寻找symtab_sec的过程，寻找段的过程非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ElfShdr&lt;E&gt; *InputFile&lt;E&gt;::<span class="built_in">find_section</span>(i64 type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ElfShdr&lt;E&gt; &amp;sec : elf_sections)</span><br><span class="line">    <span class="keyword">if</span> (sec.sh_type == type)</span><br><span class="line">      <span class="keyword">return</span> &amp;sec;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>symtab_sec不存在的情况多半是strip了，直接在elf中搜索symtab是能搜到的，但是如果strip以后就无法找到这个段了，也就是为空的情况</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%201.png"                      alt="Untitled"                ></p><p>sh_link和sh_info对于不同的section有不同的含义，对于这里的symtab来说sh_info就是保存了第一个global symbol的index，而sh_link就是保存了symbol_strtab的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%202.png"                      alt="Untitled"                ></p><h2 id="initialize-sections"><a href="#initialize-sections" class="headerlink" title="initialize_sections"></a>initialize_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Read sections</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br></pre></td></tr></table></figure><p>针对所有的sections开始处理，以下内容都在个循环体之中</p><h3 id="特殊SHT的处理"><a href="#特殊SHT的处理" class="headerlink" title="特殊SHT的处理"></a>特殊SHT的处理</h3><p>SHT（Section Header Type）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((shdr.sh_flags &amp; SHF_EXCLUDE) &amp;&amp; !(shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">    shdr.sh_type != SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这几个段无法在ELF标准中查到，后来查到了这么一段介绍</p><p>SHF_EXCLUDE：This section is excluded from input to the link-edit of an executable or shared object. This flag is ignored if the SHF_ALLOC flag is also set, or if relocations exist against the section.</p><ol><li>如果alloc被set则失效，因此这里要SHF_EXCLUDE以及SHF_ALLOC都满足条件</li><li>同时sh_type为SHF_LLVM_ADDRSIG且不是relocatable</li></ol><p>关于SHF_LLVM_ADDRSIG</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#id20" >LLVM Extensions — LLVM 17.0.0git documentation<i class="fas fa-external-link-alt"></i></a></p><h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p>首先是关于Group的介绍</p><blockquote><p>This section defines a section group. A section group is a set of sections that are related and that must be treated specially by the linker (see <a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html#section_groups" >below<i class="fas fa-external-link-alt"></i></a> for further details). Sections of type <code>SHT_GROUP</code> may appear only in relocatable objects (objects with the ELF header <code>e_type</code> member set to <code>ET_REL</code>). The section header table entry for a group section must appear in the section header table before the entries for any of the sections that are members of the group.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>在实现中首先是寻找对应group的签名，签名是关联到了一个esym上，而这个符号的索引则是记录在sh_info中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the signature of this section group.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_info &gt;= <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid symbol index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[shdr.sh_info];</span><br><span class="line"></span><br><span class="line">std::string_view signature;</span><br><span class="line"><span class="keyword">if</span> (esym.st_type == STT_SECTION) &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() +</span><br><span class="line">              <span class="keyword">this</span>-&gt;elf_sections[esym.st_shndx].sh_name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些特殊情况的处理。</p><ol><li>跳过wm4</li><li>跳过entries[0]为0的情况</li><li>如果[0]不是GRP_COMDAT则是错误</li></ol><p>之后获取comdat group members，并使用signature来关联一个ComdatGroup</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ignore a broken comdat group GCC emits for .debug_macros.</span></span><br><span class="line"><span class="comment">// https://github.com/rui314/mold/issues/438</span></span><br><span class="line"><span class="keyword">if</span> (signature.<span class="built_in">starts_with</span>(<span class="string">&quot;wm4.&quot;</span>))</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get comdat group members.</span></span><br><span class="line">std::span&lt;U32&lt;E&gt;&gt; entries = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U32&lt;E&gt;&gt;(ctx, shdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: empty SHT_GROUP&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] != GRP_COMDAT)</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported SHT_GROUP format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.comdat_groups)</span>::const_accessor acc</span>;</span><br><span class="line">ctx.comdat_groups.<span class="built_in">insert</span>(acc, &#123;signature, <span class="built_in">ComdatGroup</span>()&#125;);</span><br><span class="line">ComdatGroup *group = <span class="keyword">const_cast</span>&lt;ComdatGroup *&gt;(&amp;acc-&gt;second);</span><br><span class="line">comdat_groups.<span class="built_in">push_back</span>(&#123;group, (u32)i, entries.<span class="built_in">subspan</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>关于上面处理过程中出现的成员的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in context</span></span><br><span class="line">tbb::concurrent_hash_map&lt;std::string_view, ComdatGroup, HashCmp&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ObjectFile</span></span><br><span class="line">std::vector&lt;ComdatGroupRef&lt;E&gt;&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComdatGroupRef</span> &#123;</span></span><br><span class="line">  ComdatGroup *group;</span><br><span class="line">  u32 sect_idx;</span><br><span class="line">  std::span&lt;U32&lt;E&gt;&gt; members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是根据签名关联一个group空，之后将对应group的引用传递给ObjectFile中的comdat_groups</p><p>里面的i就是section的index</p><p>来看一下这个group段的排布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| SectionSize | Group1SectionIndex | Group2SectionIndex | … |</span><br></pre></td></tr></table></figure><p>关于GRP_COMDAT文档中也有提到</p><blockquote><p>This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded.</p></blockquote><h3 id="常规SHT处理"><a href="#常规SHT处理" class="headerlink" title="常规SHT处理"></a>常规SHT处理</h3><p>此处还有很长的特殊段以及开启—gdb-index后需要处理的内容，并非重点，此处先跳过。</p><p>常规处理就是简单创建了一个InputSection</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;sections[i] = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br></pre></td></tr></table></figure><h3 id="Attach-relocation-sections-to-their-target-sections"><a href="#Attach-relocation-sections-to-their-target-sections" class="headerlink" title="Attach relocation sections to their target sections."></a>Attach relocation sections to their target sections.</h3><p>到这里，所有的section已经执行过了一遍，最后再进行关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach relocation sections to their target sections.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_info &gt;= sections.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid relocated section index: &quot;</span></span><br><span class="line">               &lt;&lt; (u32)shdr.sh_info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;target = sections[shdr.sh_info]) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(target-&gt;relsec_idx == <span class="number">-1</span>);</span><br><span class="line">    target-&gt;relsec_idx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对RELA和REL处理，设置上对应的relsec_idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_rela = <span class="built_in"><span class="keyword">requires</span></span>(ElfRel&lt;E&gt; r) &#123; r.r_addend; &#125;;</span><br></pre></td></tr></table></figure><h2 id="initialize-symbols"><a href="#initialize-symbols" class="headerlink" title="initialize_symbols"></a>initialize_symbols</h2><p>这部分的过程主要是将esym转换为Symbol。esym则是ElfSym的缩写，也就是Elf文件中的Symbol定义，而Symbol则是mold中自己定义的，相当于转换为自己想要的格式。</p><p>这里的symtab_sec是parse刚开始的时候寻找的section，对应的符号表不存在则不进行这个过程。首先初始化了local_syms以及第0个符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;all_syms&quot;</span>)</span></span>;</span><br><span class="line">  counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize local symbols</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;first_global);</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].file = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].sym_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="local-symbol"><a href="#local-symbol" class="headerlink" title="local symbol"></a>local symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: common local symbol?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type == STT_SECTION)</span><br><span class="line">      name = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() + <span class="keyword">this</span>-&gt;elf_sections[<span class="built_in">get_shndx</span>(esym)].sh_name;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;local_syms[i];</span><br><span class="line">    sym.<span class="built_in">set_name</span>(name);</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.value = esym.st_value;</span><br><span class="line">    sym.sym_idx = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>())</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(sections[<span class="built_in">get_shndx</span>(esym)].<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先是对于common符号的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_COMMON; &#125;</span><br></pre></td></tr></table></figure><p>关于这个SHN_COMMON</p><blockquote><p>SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.</p></blockquote><p>大意是common的话不能是local，比如这里说的unallocated C external variables，external和local就是冲突的。</p><p>除了报错的common符号之外，其他符号在后面获取对应的名字，如果是section name则去shstrtab中寻找，否则就是常规的符号名，去symbol_strtab中寻找。这里的名字本质上是一个距离对应字符串段的offset，因为字符串相关的数据都统一保存在这shstrtab和symbol_strtab中了。</p><p>之后就是获取local_syms的引用，开始设置对应的信息。</p><p>在最后，对非abs符号的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_ABS; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have <strong>absolute values and are not affected by relocation.</strong></p></blockquote><p>非abs符号，也就是说都是相对地址，会affected by relocation。</p><p>而实际set_input_section则是设置其mask位，用于区分什么性质的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_input_section</span>(InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> addr = (<span class="keyword">uintptr_t</span>)isec;</span><br><span class="line">  <span class="built_in">assert</span>((addr &amp; TAG_MASK) == <span class="number">0</span>);</span><br><span class="line">  origin = addr | TAG_ISEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用2bit区分不同情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol usually belongs to an input section, but it can belong</span></span><br><span class="line"><span class="comment">// to a section fragment, an output section or nothing</span></span><br><span class="line"><span class="comment">// (i.e. absolute symbol). `origin` holds one of them. We use the</span></span><br><span class="line"><span class="comment">// least significant two bits to distinguish type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">  TAG_ABS  = <span class="number">0b00</span>,</span><br><span class="line">  TAG_ISEC = <span class="number">0b01</span>,</span><br><span class="line">  TAG_OSEC = <span class="number">0b10</span>,</span><br><span class="line">  TAG_FRAG = <span class="number">0b11</span>,</span><br><span class="line">  TAG_MASK = <span class="number">0b11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-symbol"><a href="#global-symbol" class="headerlink" title="global symbol"></a>global symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbols.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">i64 num_globals = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="keyword">this</span>-&gt;first_global;</span><br><span class="line">symvers.<span class="built_in">resize</span>(num_globals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = &amp;<span class="keyword">this</span>-&gt;local_syms[i];</span><br></pre></td></tr></table></figure><p>在开始处理之前可以看到这里又有两个resize容器的位置，目前为止有三处，这里写明了对应的容器以及所处的类，用于区分这个信息是否为ObjectFile only的</p><ol><li>local symbols(InputFile)</li><li>symbols(InputFile)</li><li>symvers (ObjectFile)</li></ol><p>之后将local_sym绑定到symbols中</p><p>之后是详细的处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize global symbols</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a symbol name</span></span><br><span class="line">  std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">  std::string_view name = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse symbol version after atsign</span></span><br><span class="line">  <span class="keyword">if</span> (i64 pos = name.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != name.npos) &#123;</span><br><span class="line">    std::string_view ver = name.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    name = name.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ver.<span class="built_in">empty</span>() &amp;&amp; ver != <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">        key = name;</span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">        symvers[i - <span class="keyword">this</span>-&gt;first_global] = ver.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">    has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; symvers;</span><br></pre></td></tr></table></figure><p>这里不需要再区分是否为Section的符号，因为global符号不包含section符号。</p><p>这里最主要的是需要解析symbol version，因为有的符号会依赖于版本号。要注意的是这个东西并非ELF的官方定义，而是GNU的一个扩展，因此去看elf specification是找不到的。关于名称规范也很简单，常规符号名后接@加符号版本</p><p>解析符号版本完成后设置到symvers中，关于这个版本号，最常见的就是GLIBC，以下是本机helloworld代码的示范</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/tmp &gt; nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line"> w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"> U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line"> U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>之后是insert symbol，并且设置其common属性。要注意除了这些解析方式外，global symbol和local symbol相比还有一个比较隐藏的不同，global symbol没有设置对应的file，后面很多符号的处理会进行判断file。</p><p>接下来是insert symbol的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a symbol object for a given key. This function handles</span></span><br><span class="line"><span class="comment">// the -wrap option.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Symbol&lt;E&gt; *<span class="title">insert_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string_view key, std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; name.<span class="built_in">starts_with</span>(<span class="string">&quot;__real_&quot;</span>) &amp;&amp;</span><br><span class="line">      ctx.arg.wrap.<span class="built_in">contains</span>(name.<span class="built_in">substr</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">7</span>), name.<span class="built_in">substr</span>(<span class="number">7</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym-&gt;wrap) &#123;</span><br><span class="line">    key = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(key));</span><br><span class="line">    name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(name));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">save_string</span><span class="params">(C &amp;ctx, <span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">  u8 *buf = <span class="keyword">new</span> u8[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">  buf[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  ctx.string_pool.<span class="built_in">push_back</span>(std::unique_ptr&lt;u8[]&gt;(buf));</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)buf, str.<span class="built_in">size</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不只是不存在key就创建key并返回那么简单。</p><ol><li>关于save_string的问题，这里也是和之前一样，创建了string后由ctx来管理生命周期，返回一个string_view提供使用。</li><li>除此之外get_symbol的部分是实际执行了符号不存在则创建新符号并且返回的工作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we haven&#x27;t seen the same `key` before, create a new instance</span></span><br><span class="line"><span class="comment">// of Symbol and returns it. Otherwise, returns the previously-</span></span><br><span class="line"><span class="comment">// instantiated object. `key` is usually the same as `name`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">Symbol&lt;E&gt; *<span class="title">get_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.symbol_map)</span>::const_accessor acc</span>;</span><br><span class="line">  ctx.symbol_map.<span class="built_in">insert</span>(acc, &#123;key, Symbol&lt;E&gt;(name)&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Symbol&lt;E&gt; *&gt;(&amp;acc-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最后提一下-wrap option选项</li></ol><p>这个-wrap是在main中read_input_files之前的地方设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --wrap options if any.</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.wrap)</span><br><span class="line">  <span class="built_in">get_symbol</span>(ctx, name)-&gt;wrap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>关于这个选项我参考了这个回答里的内容，虽然是gcc的介绍，但是本质是相同的</p><p><a href="https://stackoverflow.com/questions/46444052/how-to-wrap-functions-with-the-wrap-option-correctly">How to wrap functions with the <code>--wrap</code> option correctly?</a></p><p>我摘选了一些关键的段落</p><blockquote><p>-wrap=symbol<br>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.<br>…<br>If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.</p></blockquote><blockquote><p>… Any <strong>undefined reference</strong> to symbol will be resolved to “__wrap_symbol”. Any <strong>undefined reference</strong>  to “__real_symbol” will be resolved to symbol.</p></blockquote><p>至此，initialize_symbols就结束了</p><h2 id="sort-relocations"><a href="#sort-relocations" class="headerlink" title="sort_relocations"></a>sort_relocations</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relocations are usually sorted by r_offset in relocation tables,</span></span><br><span class="line"><span class="comment">// but for some reason only RISC-V does not follow that convention.</span></span><br><span class="line"><span class="comment">// We expect them to be sorted, so sort them if necessary.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">sort_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> less = [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.r_offset &lt; b.r_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i];</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">is_sorted</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), less))</span><br><span class="line">        <span class="built_in">sort</span>(rels, less);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，这里的sort是为了将不遵守约定没按照r_offset排序的rv的relocations转换为遵循约定的格式</p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>关于这里的内容比较长，不仅要包含解析本身，还有ehframe本身的内容，因此留到下期再继续讲。</p><h1 id="图解总结"><a href="#图解总结" class="headerlink" title="图解总结"></a>图解总结</h1><p>画了一些比较粗糙的图示将今天的内容串联起来（未标记长度信息，部分大小不标准，没精力画了）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%203.png"                      alt="Untitled"                ></p><p>首先是读取InputFile时的流程，主要是ElfHeader指向ELF文件的哪一部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%204.png"                      alt="Untitled"                ></p><p>其次是读取Section的时候符号表相关的查找流程，这里还没来得及画具体取名字的部分</p><p>从Section Header Table中找到对应sh_type为SHT_SYMTAB的段，之后根据offset和size找到具体存放symbol的位置，同时通过sh_info确定第一个global symbol的index</p><h1 id="参考资料汇总"><a href="#参考资料汇总" class="headerlink" title="参考资料汇总"></a>参考资料汇总</h1><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >Sections<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://refspecs.linuxfoundation.org/elf/elf.pdf" >Elf Specification 1.2<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-1-read-in</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>美丽新世界</title>
    <link href="https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/"/>
    <id>https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/</id>
    <published>2023-02-19T13:25:02.000Z</published>
    <updated>2023-02-19T13:25:58.736Z</updated>
    
    <content type="html"><![CDATA[<p>起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。</p><blockquote><p>到最后，孩童的心灵就是这些暗示，暗示的总和就是孩童的心灵。而且不只是孩童的心灵，成人的心灵也是——一辈子都是。下判断、产生欲望、做决定的那个心灵——就由这些暗示构成。但这所有暗示都是我们的暗示！</p></blockquote><p>这哪里美丽了，这简直是地狱。</p><p>但是读到后面，我开始动摇了。在这里的人只需要舒适就可以了，无需遭受病痛的折磨，每个人之间都彼此相属也就因此不会因为孤单而痛苦，甚至不需要思考，顺从周围的人以及大脑中已经调整好的暗示去做就好了。即便遇到不如意的事情，还有索麻来将他们从痛苦的当下逃离。</p><blockquote><p>因为我们的世界跟奥瑟罗的世界不同了。你无法不用钢铁来制造福利佛——而没有不稳定的社会，你也不可能创造出悲剧。这个世界现在稳定了。人人都很快乐，他们得到他们想要的东西，而他们永远不会想要他们得不到的。他们很富裕，他们很安全，他们从不生病，他们不怕死，他们幸福地不知何谓激情与老迈，他们没有母亲或父亲的折磨，他们没有妻子、孩子或爱人可以激起强烈的感觉，他们被制约得这么厉害，以至于他们实际上忍不住要表现出他们应有的行为。而要是有任何事情出了错，还有索麻</p></blockquote><p>而上面提到的丧失自由，被歧视，阶级固化等内容，对于”劣等“的人种自身来说并不是什么问题，他们也从来没有觉得这是什么问题。这里的人们也并非丧失了所有的自由，他们有着局限于新世界法则的自由，对于他们来说这样就可以了。所有的消息渠道都不会让他们了解一切的真相，只要他们不了解，继续蒙在鼓里，那么就不会感到任何痛苦。</p><blockquote><p>对他们而言，他们不是牺牲品，他们是最没有抗拒能力的品系。他的制约已经铺好他该沿着哪条铁轨前进。他无法克制自己不这样做，他注定如此。</p></blockquote><p>遭受痛苦与折磨的我无法否认自己读到这里产生了对这种环境的向往，尽管有最初那么多令人反感的描述，尽管明知代价是失去自我、放弃真正的自由、放弃崇高的精神，但这里的人不需要承受痛苦，只需要舒适就可以了。这样撒手不管是很轻松，我想大多数人也都是更倾向于这样的选择，不去产生改变。</p><p>如果身为当局者的话很难对这些问题进行讨论与判断，想法会受到世界本身的限制，如果我是那个世界中的一员，那么我大概率也是会和大多数人一样认为所谓真正的自由、痛苦都很荒谬。接下来还是回到旁观者的上帝视角来看待这一切。以上提到的内容在新世界中是完全对立的：是选择要自我、自由与痛苦，还是舒适和快乐。</p><p>如管制官所说</p><blockquote><p>强调的重点从真理与美转移到舒适与快乐。<br>普遍的快乐，让轮子稳定地转动下去，真理与美却做不到。</p></blockquote><p>新的世界也是如此形成的。追求真理与美是不可能舒适与快乐的，真理与美来自于经历苦难，破坏性的变化。这让我想起加缪的《快乐的死》中提到的观点，高质量的幸福需要通过痛苦体现。同时在管制官和野人的对话中屡次出现莎士比亚的作品，其作品以悲剧美而闻名，也是一个很好的例子。沉溺在舒适与快乐之中无法寻求到真理，每种科学的发现都有潜在的破坏性，而要突破这种破坏性并不会使得舒适与破坏性。在舒适和快乐中也无法体现出人性的美，罗翔老师举过一个例子。</p><blockquote><p>如果现在有一个小黄书，郭德纲相声，一个莎士比亚，三者都会给你带来一些快乐。但是你即便真诚的认为小黄书给你带来了愉悦，郭德纲的相声给你带来了快乐，但只能留一本书，你留哪本书？莎士比亚。这个故事告诉我们，越能体现人性尊严的快乐，越是一种最大的快乐，因为它跟人的尊严有关。</p></blockquote><p>对于“新世界”来说，他们无法得知这一切，大部分人也没有选择的权利。对于现实社会来说，我们完全可以了解到这一切，并且两者都选择，只是或多或少罢了。还是如罗翔老师所说</p><blockquote><p>我读莎士比亚并不妨碍我听郭德纲的相声，但是如果你的眼目永远只关心地下，你永远不知道向上看有多么快乐。</p></blockquote><p>不过我们现在所处的“小小世界”，在许多方面已经有了这样的影子，逐渐开始失去了选择的权利。从想法来说，所谓人们的想法就是来自所处的环境、所处的社会、所接触到的地域文化，这让我想到了某些洗脑的宣传，以及不断试图阻挡人们看到真相的，某个大家都很熟知的地方。既然你无法得知真相与其他答案，面前只有一个选项，那么你很大概率不会去考虑这个选项的对与错。除此之外，我还想到了昨天和朋友聊天的时候他提到的“异化”一词</p><blockquote><p>所谓的「自由而来的不自由」。你有一定的自由分工、自由迁徙的能力，但是正是由于深度的投入到了某个社会分工内而被困在了这个环境下的「不自由」。</p></blockquote><p>这个“世界”的人们都是如此，渐渐开始失去了部分的自由，而这份不自由也正是由所处的这个“世界”所造成的。大部分人像阿尔法一样遵循着一直以来的”睡眠教学法“，有的人们像伯纳德一样略微窥探到了一些，有的人像管制官一样看到了全部，即便看到了一切，但我们仍然是被禁锢着，只是所在的“瓶子”或许没有那么小但是不知道哪一天这个瓶子可能会缩到非常小，我想这也正是作者所担忧的事情，担心人们连自己选择一切的权利都失去了，担心人们人生的一切都是被安排的。</p><p>这样的世界我无法断言好还是坏。如果选择经历苦难，那么你要具备面对苦难的能力，你要不断的经历痛苦以及发现真理与美。如果你选择舒适与快乐，那么你将放弃自我，放弃自由。管制官与“野人”的选择则是非常强烈的对比，两者在得知了一切并且有选择权的情况下，一个选择了前者，另一个选择了后者。不论选择哪一个，其实都要付出代价。在这样的世界，绝大部分人其实是没有选择的权利的，但是在现实世界中绝大部分人依然有选择的权利，如果只能在这两者之间选择，你是要成为野人，还是管制官呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;到最后</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="奥尔德斯·赫胥黎" scheme="https://fusionbolt.github.io/tags/%E5%A5%A5%E5%B0%94%E5%BE%B7%E6%96%AF%C2%B7%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>心理咨询是怎样的</title>
    <link href="https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/"/>
    <id>https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/</id>
    <published>2023-02-18T14:30:49.000Z</published>
    <updated>2023-02-18T14:56:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。</p><p>首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询师进行商定，间隔超过一周可能时间太久内容难以连贯，少于一周可能费用上更难接受一些，即便是最便宜的档次一周一次，一个月也要2000的费用，更何况这是一项长期的工作，<strong>如果你能接受这个价格再继续看下去</strong>。流程上也没有什么特别的，预约时间，当天到咨询师所在的地方进行一小时左右的沟通，基本上是一对一。（这里咱不探讨团体咨询以及多人咨询）</p><p>咨询的方式有着不同的流派，而不论是什么流派，咨询的过程都是沟通为主。咨询师会问你各种问题，又或者由你自己挑起某些话题，如果可以还是自己选择某些比较关心的话题开场比较好，而具体的话题会因流派不同而异。有的流派会倾向于长期咨询，有的会倾向于短期解决问题，在选择的时候还是需要注意，通常咨询之前也会问你是想要进行短期还是长期的咨询ty。我在此更建议长期的咨询，首先咨询师需要几次对话充分了解你，你也需要几次机会去熟悉跟咨询师去讲述一些事情，后面需要更长的周期去一点点深入自己的内心，一点点的去修复问题。在对话的过程中，通常会涉及到你的许多想法、感受、过去、秘密、家庭、人际关系等等，同时在这个交流沟通的过程中，会不断探寻自己的内心，有的时候就戳到痛处，如果要选择咨询，要做好暴露一切的心理准备。有的人并不在意和陌生人讲这些，但也有的人面对陌生人会比较难以说出这些，这些人群需要一定时间去适应，也不必觉得因为自己不想说就完全不适合去咨询。咨询时有什么不适的感受也都尽情的跟咨询师提出，不用担心提出意见会有什么攻击性的反应，我之前对咨询师的一些问法感到厌烦，及时和咨询师进行沟通，这种厌烦感也就慢慢结束了。</p><p>在我目前的理解与体验咨询主要以两种形式起作用。第一种是感性上的支持，对于心里积攒着很多想法的人来说，咨询师会耐心倾听你的诉说，在这个过程中你可以放心的讲你所不愿跟别人讲的秘密，或者你认为会被人厌烦的内容，不必担心被人拒绝，被人讨厌。而对于孤单的人来说，咨询师也是一个每周陪伴你的人，不会因为你做错了什么就会放弃你。他们会给予你情感上的支持，在你遇到问题会与你产生共情。第二种则是理性上的支持，对于需要咨询的人来讲，通常会有许多思维的误区，而找出这些误区也是咨询师们的工作之一。另外还会对你一些具体的问题会给出建设性的建议，最关键的是和你一起分析你的问题，你的思维方式，作为一个旁观者，而不是作为你自己来观察这一切，远比自己观察的要清楚。你需要明白这些，在这个过程中你可能会学会自己查找自己的问题，同时还会增强你对于自己问题的修正。</p><p>以下是《神经症与人的成长》这本书中的摘录</p><blockquote><p>所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。</p></blockquote><blockquote><p>此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互间的作用。</p></blockquote><blockquote><p>了解所有的这些因素，并非指懂得这些因素的死知识，而是意指要彻底地去认识它们。</p></blockquote><p>对于一些十分特别的流派或许会有其他更特别的解决方式，这里暂且不谈论。</p><p>不论如何起作用，心理咨询的过程是一个不断探寻自己内心的过程，看到现在的自己和过去的联系，而目的是为了让你重新找回对抗问题的力量，而不是帮助你解决所有问题。理解了一个又一个的问题，解决了一个又一个问题的过程，同时也是在不断增强自身力量的过程。</p><p>也许你会在纠结到底要不要进行咨询，你不如换个问题，你想要通过咨询获得什么？对于我来说，通常会对自己的想法进行基本的觉察与反思，也并没有什么一定要跟别人倾诉的苦水，我需要一个人从外部来看待我，帮助我更快的解决自己的问题，找到我自己难以看到的想法中的误区，毕竟“当局者迷”，同时想要有人跟我深入的探讨一些个人成长与性格中的一些问题。事实上我最近三次的咨询也确实达到了期望的效果。这些问题没法跟认识的绝大部分人去交流，有的人不关心这些，有的人不愿意聊这些，或者说没有那么要好的朋友，谈论这些内容或许是需要非常深入密切的关系才行，你需要袒露你内心中的秘密，你要愿意将这个秘密讲出来，而对方也要愿意接受你的秘密，愿意帮助你解决这些问题。</p><p>在这里要认清一些思维误区。首先并不是去咨询了就一定能解决任何问题，也不是依靠咨询师就能解决大部分问题，咨询师只是辅助你解决问题，最终还是需要你自己去真正改变想法。其次咨询并不是什么丢人的事情，或许在大众的认知中去接受心理咨询就是所谓的“神经病“，但我想你看了上面的内容后或许不会这样想，即便是这个领域大师级别的人物仍然需要他人帮助自己进行心理咨询。</p><p>如果想要了解更多关于心理咨询的过程或者其他内容，可以参考《也许你该找个人聊聊》。另外个人十分推荐《神经症与人的成长》，书中的一些分析讲的非常棒，非常有助于理解自己的一些问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。&lt;/p&gt;
&lt;p&gt;首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="心理咨询" scheme="https://fusionbolt.github.io/tags/%E5%BF%83%E7%90%86%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其零 main</title>
    <link href="https://fusionbolt.github.io/2023/02/12/mold/mold-0/"/>
    <id>https://fusionbolt.github.io/2023/02/12/mold/mold-0/</id>
    <published>2023-02-12T14:06:32.000Z</published>
    <updated>2023-02-19T05:33:14.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/FWlv3FsaMAAdSs2-20230212221048408.jpeg"                      alt="图像"                ></p><p>我们从main函数的开始，大致讲一下都做了哪些事情。之后再从每个流程中的具体实现开始阅读（如果我记得的话会回头在这里补上对应的链接），或者会以解决某些问题为线索写一篇，比如说某一些常见的参数具体在mold中怎么生效的，比如说whole_archive这种。为保证两部分文章内容的连贯性，内容不可避免会有一定重叠。</p><p>这个系列的一些约定</p><ol><li>只考虑elf的支持，其他平台相关的不再考虑</li><li>文件路径都是项目根目录的相对路径</li></ol><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>由于代码比较少，项目的结构非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── docs</span><br><span class="line">├── elf</span><br><span class="line">├── test</span><br><span class="line">│   └── elf</span><br><span class="line">└── third-party</span><br><span class="line">    ├── mimalloc</span><br><span class="line">    ├── rust-demangle</span><br><span class="line">    ├── tbb</span><br><span class="line">    ├── xxhash</span><br><span class="line">    ├── zlib</span><br><span class="line">    └── zstd</span><br></pre></td></tr></table></figure><p>根目录下有一些共用的文件以及一些项目的常规文件</p><p>启动的main函数也是在根目录下</p><p>在elf目录下是我们需要看的主要核心代码</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/Untitled.png"                      alt="Untitled"                ></p><p>在这之中有两个作为主线的文件: main.cc和passes.cc</p><p>实际执行链接的主要流程都存放在main.cc的elf_main中，而这个过程执行的代码大多会指向passes.cc中的函数。不同目标arch的文件都用相应的文件名区分开了，以及其他的文件看名字也相对比较易懂。</p><h1 id="链接前的准备流程"><a href="#链接前的准备流程" class="headerlink" title="链接前的准备流程"></a>链接前的准备流程</h1><p>main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  mold::mold_version = mold::<span class="built_in">get_mold_version</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MOLD_IS_SOLD</span></span><br><span class="line">  std::string cmd = mold::<span class="built_in">filepath</span>(argv[<span class="number">0</span>]).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">  <span class="keyword">if</span> (cmd == <span class="string">&quot;ld64&quot;</span> || cmd == <span class="string">&quot;ld64.mold&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mold::macho::<span class="built_in">main</span>(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mold::elf::<span class="built_in">main</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elf/main.cc</p><p>默认采用了X86_64</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elf_main&lt;X86_64&gt;(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的Machine Type是通过模板类型来区分的。在elf_main里面创建了全局的Context对象（并非是代码实现层面上的全局对象，只是所有的流程都需要传递ctx）并且解析命令行参数（命令行参数的具体实现就不再细看了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">elf_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  Context&lt;E&gt; ctx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process -run option first. process_run_subcommand() does not return.</span></span><br><span class="line">  <span class="keyword">if</span> (argc &gt;= <span class="number">2</span> &amp;&amp; (argv[<span class="number">1</span>] == <span class="string">&quot;-run&quot;</span>sv || argv[<span class="number">1</span>] == <span class="string">&quot;--run&quot;</span>sv)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(__APPLE__)</span></span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;-run is supported only on Unix&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">process_run_subcommand</span>(ctx, argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse non-positional command line options</span></span><br><span class="line">  ctx.cmdline_args = <span class="built_in">expand_response_files</span>(ctx, argv);</span><br><span class="line">  std::vector&lt;std::string&gt; file_args = <span class="built_in">parse_nonpositional_args</span>(ctx);</span><br></pre></td></tr></table></figure><p>获取具体的machine_type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If no -m option is given, deduce it from input files.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emulation == MachineType::NONE)</span><br><span class="line">  ctx.arg.emulation = <span class="built_in">deduce_machine_type</span>(ctx, file_args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redo if -m is not x86-64.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, X86_64&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(ctx.arg.emulation != MachineType::X86_64)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> redo_main&lt;E&gt;<span class="params">(argc, argv, ctx.arg.emulation)</span></span>;</span><br></pre></td></tr></table></figure><p>redo_main就是简单的根据命令行参数指定的target来选择对应的模板类型进行特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">redo_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, MachineType ty)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ty) &#123;</span><br><span class="line">  <span class="keyword">case</span> MachineType::I386:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;I386&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM32:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM32&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V1:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V1&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V2:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V2&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::S390X:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;S390X&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::SPARC64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;SPARC64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::M68K:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;M68K&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接大体流程"><a href="#链接大体流程" class="headerlink" title="链接大体流程"></a>链接大体流程</h1><p>根据注释和我个人的理解，分为如下这么几大部分</p><ol><li>解析所有的输入，包含命令行参数，输入的各种文件</li><li>对于输入做链接器最基本的处理，包含符号解析，段合并，符号检查之类的</li><li>创建一些synthetic的内容，包括一些段和符号</li><li>将所有段、符号进行扫描以及按照需求进行排序，添加到全局的ctxt中</li><li>计算与修正一些具体的信息，固定生成产物的memory layout</li><li>修正某些地址，确保固定file layout</li><li>将所有文件拷贝到输出文件中</li><li>结束的清理操作</li></ol><p>其中有些地方可以根据Timer来协助划分链接的流程。比如说拷贝到输出之前有这样一行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timer <span class="title">t_copy</span><span class="params">(ctx, <span class="string">&quot;copy&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>而到了后面的部分有这么一行对应，中间的部分很自然就是这一个步骤做的事情了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_copy.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure><p>而main函数中的内容比较简洁，几乎每个小功能都划分为了一个函数，而且附加了大量的注释，比如说这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><p>再加上代码比较长，这里就不放后续完整代码了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-0/FWlv3Fs</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>链接器起始篇</title>
    <link href="https://fusionbolt.github.io/2023/01/17/linker/linker-init/"/>
    <id>https://fusionbolt.github.io/2023/01/17/linker/linker-init/</id>
    <published>2023-01-17T12:31:34.000Z</published>
    <updated>2023-01-17T12:27:42.292Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/linker-init/Untitled.jpeg"                      alt="Untitled"                ></p><p>又开始不务正业乱开新坑了。接下来会通过阅读mold的源码来学习如何实现一个ELF链接器，有精力也会再跟着plct的这个课程学习实现一个简单的RV ELF链接器，可能会跟着将代码换一门语言翻译一遍，将这个学习过程中遇到的知识点记录到博客中。如果坑能开到后面的话我还会针对这门课程实现的链接器在功能上与mold的进行比较，一门教学用的链接器和真正实用的链接器在功能上有哪些差别。</p><p><a class="link"   href="https://github.com/rui314/mold" >https://github.com/rui314/mold<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ksco.cc/rvld/" >index<i class="fas fa-external-link-alt"></i></a></p><p>从未了解过链接器实现的我，在跟着mold源码和这门课程之前，先来写一下根据我现有的知识去设想一个链接器内部应该大致有哪些功能。（本期内容不是教程，只是我个人对知识的回忆，因此很多地方都会缺很多东西）同时回忆过后对比检查理解的问题，在差不多理解整体运作过程的情况下学习会更有效一些。</p><h1 id="链接器做了什么"><a href="#链接器做了什么" class="headerlink" title="链接器做了什么"></a>链接器做了什么</h1><ol><li>链接器做的事情是将多个编译器生成的目标文件的内容合到一起</li><li>处理符号。在编译期间要求编译生成的目标文件中每个符号小于等于一个定义，在链接的时候链接器负责找到未定义的符号的地址，重复符号的解决（如果是弱符号则根据规则选取其中一个定义，如果非弱符号则需要报错）</li></ol><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>要合并目标文件那么我们要知道目标文件的内容是什么样的（这里我们仅探讨ELF的格式）。先不查阅文档，想一下目标文件大概会有什么内容。</p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>首先是对于我们写代码的时候经常提到的一些段，比如说代码段、数据段、BSS段、堆、栈等等。这些段本身只是一串数据，那么我们需要一个位置存放起始位置和数据长度。而其中的各种段名以及各种符号名也需要一个位置保存，因此目标文件中还需要有一个符号段用于保存各种用于链接使用的符号。（strip是否就是去掉这里）我们知道debug模式生成的代码包含debug信息，而这些信息对于elf来说是写在内部的，因此里面还需要有保存调试信息的段。</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>类似于段段起始和长度这种</p><p>寻找保存具体信息的信息需要放到一个文件头中，除此之外文件头中还需要一些魔数来标识文件类型。</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>保存所有代码中符号的相关信息（而不是段名的符号），最容易想到的就是地址，其次上面提到了符号的强弱。</p><h1 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h1><p>而更精细控制这些行为的方式一个是命令行参数，另一个是链接脚本。由于系统中内置了默认的链接脚本，我们日常很少会接触到这些。读取链接脚本也是链接器很重要的一个功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下来，链接器主要的功能如下</p><ol><li>读取目标文件ELF文件头</li><li>读取链接脚本并且按照链接脚本控制链接行为</li><li>符号解析</li><li>合并段</li><li>生成对应的ELF文件</li></ol><p>而plct课程的大纲如下</p><p>第一课：搭建开发环境、初始化项目、开始读取 ELF 文件</p><p>第二课：继续读取 ELF 文件</p><p>第三课：解析链接器参数</p><p>第四课：解析静态链接库文件</p><p>第五课：解析未定义符号，移除未使用文件</p><p>第六课：处理 Mergeable Sections</p><p>第七课：开始写文件</p><p>第八课：处理 Output Sections</p><p>第九课：继续处理 Output Sections</p><p>第十课：Phdr 和 Merged Sections</p><p>第十一课：处理重定向，课程回顾</p><p>可以说做的功能大致类似，之后就会先从mold的源码开始开新系列了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/linker-init/Un</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
  </entry>
  
  <entry>
    <title>调试器之工作原理</title>
    <link href="https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/"/>
    <id>https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/</id>
    <published>2023-01-09T15:27:58.000Z</published>
    <updated>2023-01-09T15:30:36.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试器之工作原理"><a href="#调试器之工作原理" class="headerlink" title="调试器之工作原理"></a>调试器之工作原理</h1><p>之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么实现运行时断点的。今天来简单了解一下调试器部分功能的工作原理。</p><h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>对于调试来说第一步是要下断点。断点本质是到了指定位置后中断当前的进程，进入对应的中断处理程序。（信号的本质是软中断，这里、统一称发生了中断）</p><p>根据实现方式的不同分为如下三类。</p><h2 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h2><p>当cpu执行了特定调试指令后会发出一个中断，而软件断点要做的就是在对应的pc位置“插入”断点指令，说是插入，实际上是修改原指令，触发中断后再写回。</p><p>以x86的INT3指令为例，在一个位置设置断点后会保存该位置的原指令，之后在该位置写入INT3，当执行到这条指令的时候发生软中断，内核向子进程发送SIGTRAP信号，之后这个信号转发给父进程，此时再用保存的指令替换之前写入的INT3指令等待中断恢复。</p><h2 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h2><p>某些cpu包含调试用的寄存器，通过设置对应的值来控制对应产生中断的pc位置以及一些其他信息。</p><p><a class="link"   href="https://en.wikipedia.org/wiki/X86_debug_register" >x86 debug register - Wikipedia<i class="fas fa-external-link-alt"></i></a></p><p>cpu在执行代码之前会先确定要执行的地址是否保存在中断寄存器中，同时确认访问的地址是否处于设置了硬件断点的区域内，满足条件后会触发INT1中断。</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>通过设置对应内存位置所在页为guard page，对保护页访问则会触发异常，之后页面恢复访问前的状态。</p><h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p>Linux中我们可以直接通过ptrace来打断点、读取信息或者是单步执行等。</p><p>关于ptrace的文档：<a class="link"   href="https://man7.org/linux/man-pages/man2/ptrace.2.html" >https://man7.org/linux/man-pages/man2/ptrace.2.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h2><p>首先我们来看一下用法示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = <span class="built_in">ptrace</span>(PTRACE_PEEKUSER,child, <span class="number">4</span> * ORIG_EAX,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child made a &quot;</span><span class="string">&quot;system call %ld\n&quot;</span>, orig_eax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被调试的程序通过ptrace(PTRACE_TRACEME)来设定自身是被trace的对象，接着通过execl来执行对应的命令行程序，此时执行的程序作为调试器的子进程。</p><p>而调试器进程本身则是通过wait去等待子进程停下来，等wait返回后就可以查看子进程的信息或者对子进程进行操作。对于ptrace使用方面来说最重要的是选择合适的__ptrace_request，大多数调试器常见的功能都能通过设置这个参数来实现，比如说单步。</p><p>这个项目使用ptrace实现了许多debug的基础功能</p><p><a class="link"   href="https://github.com/Kakaluoto/ptraceDebugger" >https://github.com/Kakaluoto/ptraceDebugger<i class="fas fa-external-link-alt"></i></a></p><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>通过设置__ptrace_request为PTRACE_ATTACH或者PTRACE_SEIZE还可以调试一个当前已经启动的进程。</p><p>对于常规的调试和attach的本质区别自然是进程间的关系，直接调试中调试器进程和被调试进程互为父子进程，而attach时两者是独立的，也因此有的时候attch会需要管理员权限。</p><h1 id="其他系统"><a href="#其他系统" class="headerlink" title="其他系统"></a>其他系统</h1><p>以上ptrace的实现都是基于Linux的api来讲的，macOS的ptrace的request缺少非常多基本功能，比如说读取寄存器的值。如果想要在mac下实现可以参考如下链接，如果是arm的Mac则这里很多接口仍然过时。（我反正不想折腾了，有这时间多看下Linux的不香吗）</p><p><a class="link"   href="http://uninformed.org/index.cgi?v=4&a=3&p=14" >Uninformed - vol 4 article 3<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.spaceflint.com/?p=150" >Using ptrace on OS X<i class="fas fa-external-link-alt"></i></a></p><p>而对于windows来说则是提供了另一套完全不同的api，有兴趣的可以自行了解。</p><p><a class="link"   href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-engine-and-extension-apis" >Debugger Programming Extension APIs - Windows drivers<i class="fas fa-external-link-alt"></i></a></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>这一期的内容都是一些非常容易搜到的基础知识，如果不鸽的话调试器后面会继续深入学习，造一个自己的debugger之类的。大概也会作为一个系列更新，可能深入的方向有如下几个</p><ol><li>ptrace的具体实现细节代码</li><li>debug信息的格式以及源码级调试</li><li>lldb的学习</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试器之工作原理&quot;&gt;&lt;a href=&quot;#调试器之工作原理&quot; class=&quot;headerlink&quot; title=&quot;调试器之工作原理&quot;&gt;&lt;/a&gt;调试器之工作原理&lt;/h1&gt;&lt;p&gt;之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么</summary>
      
    
    
    
    <category term="Debugger" scheme="https://fusionbolt.github.io/categories/Debugger/"/>
    
    
    <category term="ptrace" scheme="https://fusionbolt.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/"/>
    <id>https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/</id>
    <published>2022-12-31T14:59:28.000Z</published>
    <updated>2022-12-31T15:08:11.573Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。</p><h1 id="去年的愿景"><a href="#去年的愿景" class="headerlink" title="去年的愿景"></a>去年的愿景</h1><p>去年的愿景许多方面我没有非常明确具体的目标，这对实现目标来说恰恰是致命的。以下这段来自我去年的年终总结</p><blockquote><p>不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的</p><p>想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升</p><p>想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西</p><p>自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈</p><p>想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等</p><p>明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战</p></blockquote><p>去年的年终总结：<a class="link"   href="https://homura.live/2021/12/26/Summary/summary-2021/" >https://homura.live/2021/12/26/Summary/summary-2021/<i class="fas fa-external-link-alt"></i></a></p><h2 id="身心健康"><a href="#身心健康" class="headerlink" title="身心健康"></a>身心健康</h2><p>按我现在的状态怎么都算不上身心健康。今年去体检查出一大堆的小问题，其中一项还影响到了脑血管，某种物质代谢不完全残留在血液中，导致容易形成了斑块，大概是基因加饮食习惯的问题，及时查出来也算是好事，补充了一些维生素B族后相关参数明显恢复正常值了，还没来得及再复诊。</p><p>精神状况今年一开始的时候状态还算可以，但是2月底有一次我超负荷运转了两三天，之后开始各种不太好。4月去医院大夫又加了新的药，后来6月底为了改善睡眠质量加上了安眠药，几个月后我发现这个大夫一直有问题就加药，同时每次和这个大夫沟通都感觉被当傻子一样对待，于是我又换了大夫，这个大夫让我停掉了安眠药。在这个不断换药的途中不论是睡眠还是精神状态都没有趋于稳定。</p><p>说到健康一定离不开锻炼。这方面确实做得不够，每次都是锻炼了一段时间就因为各种各样的理由暂停了。也不是多么讨厌锻炼，只是没有形成一种自然而然的习惯。</p><h2 id="做好编译器"><a href="#做好编译器" class="headerlink" title="做好编译器"></a>做好编译器</h2><p>一直到5月份还都在认真做自己的compiler，其中2月底开始用Scala换掉ruby，由于开发的效率不高，5月的时候前端的东西才差不多能跑了，此时需要开始做一些优化层面相关的事情，我从每天固定提交代码转变到了学习阶段。</p><p>在前期实现的过程中研究了一段时间rust的代码，开始学习优化的时候又去学了一点LLVM的东西，从PassManager开始到一些简单的Pass，对LLVM的整体结构以及一些组件有了一些了解。之后关于compiler随便读了点书，了解了一些概念，实现了一点简单的分析和优化，还实现了一点后端部分，结合gcc能够生成非常简单的native代码，这些部分我就没有放到我的博客里了。这个过程大概持续到九月多，中间也有很长一段时间都很少去学些什么。</p><p>LLVM相关的文章：<a class="link"   href="https://homura.live/tags/LLVM/" >https://homura.live/tags/LLVM/<i class="fas fa-external-link-alt"></i></a></p><p>自己的compiler开发周记：<a class="link"   href="https://homura.live/tags/Rc-lang/" >https://homura.live/tags/Rc-lang/<i class="fas fa-external-link-alt"></i></a></p><h2 id="拍到很多照片"><a href="#拍到很多照片" class="headerlink" title="拍到很多照片"></a>拍到很多照片</h2><p>今年也算是拍了一些照片，最初的安排是每周末出门拍照，只是从五月疫情严重居家办公开始，之后出门拍照的次数越来越少，而夏天也因为太热几乎没有出门拍照。不过到了合适的时节，（比如说中秋节）还是会去特定的地点拍一些照片。关于照片集，虽然有过想做的想法，也调研过一点点相关资料，但是后续似乎是因为当前照片素材不够，需要再拍一些再考虑成相册。关于设计和排版今年也学了一丁点相关软件的使用和一点点简单的知识，但是后面因为思路枯竭，没有应用场景，以及时间与生活节奏开始混乱，也没有再多学习了（总之就是给自己找各种各样的借口）。除了设计画册相关的之外也大概看了一点关于摄影的书籍，也多少有一些收获，但实践太少还是学的太肤浅。今年关于拍照相关的大概就是这些，最后选几张我还算喜欢的照片。（未进行调整，别问为什么，问就是懒）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/sakura.jpg"                      alt="sakura.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DSCF4435.jpg"                      alt="DSCF4435.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                      alt="40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                      alt="DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.jpeg"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.jpeg"                      alt="Untitled"                ></p><h2 id="和别人一起努力"><a href="#和别人一起努力" class="headerlink" title="和别人一起努力"></a>和别人一起努力</h2><p>这个目标是完完全全不沾边。我后来几乎没有考虑过这件事情了，也许我从最初就没有抱有过希望。有人一起努力，或者在某个圈子里一起努力，我觉得是非常有利于个人前进的事情，但是现在的我似乎并不能这样。我的行为习惯在让我避开他人，同时我慵懒的态度导致也无法跟上一直在努力学习的他人的步伐，也无法融入什么圈子。对于这个目标的态度我只有用“摆烂”这个词了，这个问题的依赖还没有被解决，这个问题本身也自然不可能去发生什么变化。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>不论是技术文还是水文，都算下来今年博客上提交了42篇文章。</p><p>我本来的计划是一周一篇，但是自从我停下了周记后（5.15）渐渐开始打乱了节奏。之后的LLVM Pass系列的相关博客又维持了一阵子时间，但完结后又未能维持更新的节奏，尤其是这两个月几乎停摆。技术博客相关和我学习的进展有关系，今年后半段我学习的进展也是停滞不前，博客也跟着一起没什么变化。</p><p>很多时候我都不知道该怎么写，即便今年过去了，我觉得自己对写博客这件事情依然没有那么熟练，对于让别人能看懂以及组织语言和结构这些事情都做不好，可能需要专门的练习，但我不太会专门花时间去做这件事情，至少先能保证稳定更新频率再说。</p><p>写的时候都是抱着反正也没人看的态度，本身确实不会有什么人对我写的内容感兴趣，另一方面希望越大失望越大。但后来有的人看到了我的技术文，还找到我的联系方式来联系我，这让我感到意外和开心。虽然并不是为了功利去写，但是这也确实给了我比较正向的反馈。</p><h1 id="今年还做了些什么"><a href="#今年还做了些什么" class="headerlink" title="今年还做了些什么"></a>今年还做了些什么</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年工作的内容比较杂，组内的项目在全部推倒重来，我基本上是每个环节都在跟着做，由于算是初期，各个方面都需要我们来做，以及都是优先移植好原有的功能，所以各方面涉及的都比较浅，但也可以说是熟悉每个模块，同时熟悉模块之间的关系，能够把握每个模块对于其他模块的影响，格局打开了！这个过程中也接触到了一些新东西，算是有所收获。工作的同时还开发了一些便于调试的工具，过去同事们的调试方法实在不适合我这种又笨又懒的人。</p><p>有几篇博客记录了工作相关的一些踩坑经历</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/03/29/Problem/solve-ci-and-link/" >https://homura.live/2022/03/29/Problem/solve-ci-and-link/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/some-work-problem/" >https://homura.live/2022/10/02/Problem/some-work-problem/<i class="fas fa-external-link-alt"></i></a></p><h2 id="工作外的学习"><a href="#工作外的学习" class="headerlink" title="工作外的学习"></a>工作外的学习</h2><p>作为程序员那不可避免的要留下小格子的记录，趁着前段时间GitHub变蓝就留了个截图。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.png"                      alt="Untitled"                ></p><p>这些提交基本上都是自己的东西，也有一部分是在其他分支没有统计到，总之今年什么时候在家的时间摸鱼一目了然。</p><p>除了上面提到的编译器相关的内容，又开了os的坑，开这个坑很大一部分原因是上面提到的这篇博客。</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p>基于裸机系统修复了内存分配问题，让我想起了过去想实现os的愿望，接着参考现有的项目（xv6-riscv为主）抄了一部分的rvv os的实现，rvv的启动代码比起Intel的各种历史包袱真的是太简单了，难免产生了如果我早来看这个该多好的想法。抄os代码这部分也开了博客，不过目前只写了第0期。</p><p><a class="link"   href="https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/" >https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/<i class="fas fa-external-link-alt"></i></a></p><p>生活上的技能以及代码之外知识的学习也是必不可少的，各种乱七八糟的东西三分钟热度买了杂七杂八的书籍，趁着上头看了那么一点点，或者三分钟热度去搜了一些东西记到了笔记中。曾经有那么一段时间我意识到自己目前的行为方式就是这样三分钟热度，觉得目前改不掉，那不如就随着这股热情去，只要选择一种能够积累下东西的方式就可以了，比如说每次三分钟热度的内容都留下笔记，之后不论什么时候想重新回来看都不必从头再来。今年也算是在笔记软件里多少积累了一点点东西，希望能在以后用上。</p><h2 id="还做了些什么"><a href="#还做了些什么" class="headerlink" title="还做了些什么"></a>还做了些什么</h2><p>首先是前面尚未提到但是在实施的一些习惯。</p><p>学习钢琴 从二月开始上钢琴课，也算是坚持了快一年，除了生病和偶尔几天实在专注不了外每天都有在坚持练习。这么久下来拜厄勉强通关了，虽然我练的非常慢，但和我一开始真的是天差地别了。</p><p>读书的目标是平均一个月一本，今年也是轻松的达到了。我的阅读量很小，目标也不敢设的太高，就这样慢慢的积累也挺好的。今年在一个朋友的影响下读了一些文学，也写了一些感想，希望明年都能保持。看到许多朋友写了读书总结，我读的也不多，也不值得再开一篇文章，不过后面的部分会提我觉得不错的书。关于读书和影视相关的记录，7月开始我也开始在豆瓣上进行标记，这是我今年豆瓣的格子记录，<del>虽然没什么用就是了</del>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.png"                      alt="Untitled"                ></p><p>同时在继续更新自己的读书channel（尽管最近两个月都摸了），对愿意订阅这个channel的读者我在此表示感谢，希望明年能在channel发更多的内容，而不是像最近一样总是摸鱼。tg channel链接：<a class="link"   href="https://t.me/homura_grand_archives" >https://t.me/homura_grand_archives<i class="fas fa-external-link-alt"></i></a></p><p>还养成了见到镜子中的自己就笑一笑的习惯。最初想到这个是5月份，看到几个喜欢的up主一直都充满着笑容，我知道自己平常的表情更倾向于一脸阴沉，让人看着就不想接触，同时试图通过这种身体的行为改变去改变自己的情绪，半年下来这个习惯也算是养成了，只是最近似乎有些忘，需要再重复巩固一下。</p><p>除了实施的一些习惯之外，今年还有幸接触到了许多以往未曾接触的东西，比如说开始学乐器，去听音乐会，去做瑜伽（做了半年就没继续了，实在太远了…），给朋友写信，尝试许多女装，去心理咨询等等。<del>不过…还是没有谈过女朋友（悲），有好心人愿意介绍女生认识吗。</del></p><h2 id="接触的作品"><a href="#接触的作品" class="headerlink" title="接触的作品"></a>接触的作品</h2><p>今年看的认为很不错的动画是《吹响！上低音号》，《利兹与青鸟》，《灵能百分百》第三季，都可以说是神作。</p><p><a class="link"   href="https://homura.live/2022/08/24/Animate/Sound-Enphonium/" >https://homura.live/2022/08/24/Animate/Sound-Enphonium/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/" >https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/12/31/Animate/MobPsycho100/" >https://homura.live/2022/12/31/Animate/MobPsycho100/<i class="fas fa-external-link-alt"></i></a></p><p>今年读过的印象深刻且非常喜欢的书有费尔南多·佩索阿的《不安之书》（未读完），莎士比亚的《哈姆雷特》，夏目漱石的《草枕》和《虞美人草》，村上春树的《世界尽头与冷酷仙境》和《海边的卡夫卡》。现在回想《不安之书》是最让我感到惊奇的，《海边的卡夫卡》是最有趣的，只可惜我并没有为它们写点什么。</p><p>虽然看到好多人在写年终阅读总结，我这里就不写了，读的太少不值得拿出来讲。今年内针对部分书籍写了一点想法，其他的书有的写了零碎一点就没好意思发出来，或者干脆没发。</p><p>虞美人草：<a class="link"   href="https://homura.live/2022/10/16/Reading/papaver-rhoeas/" >https://homura.live/2022/10/16/Reading/papaver-rhoeas/<i class="fas fa-external-link-alt"></i></a></p><p>世界尽头与冷酷仙境：<a class="link"   href="https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/" >https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/<i class="fas fa-external-link-alt"></i></a></p><p>加缪的《快乐的死》也还可以</p><p><a class="link"   href="https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/" >https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/<i class="fas fa-external-link-alt"></i></a></p><h2 id="计划与习惯"><a href="#计划与习惯" class="headerlink" title="计划与习惯"></a>计划与习惯</h2><p>我原本做了一个比较简单的计划用于规划晚上回家以后的时间，前半年执行的也都还可以。但是到了七月发生了一些事情，我的注意力全部被拉走了，完全破坏了执行习惯相关的要点。而这次一直持续了两个月，加上钢琴课作业我觉得需要更多时间，时间分配上也开始乱了套。而上个月底开始的居家办公，又因为我爆肝宝可梦导致又花了很多时间在打游戏上，最后每天只能保证基本的练琴了。尽管后期有些失败，但也算是切身体会到执行习惯的一些关键点的重要性。</p><p>关于习惯参考了《掌控习惯》这本书，十分感谢推荐给我这本书的朋友。</p><p>豆瓣链接：<a class="link"   href="https://book.douban.com/subject/34326931/" >https://book.douban.com/subject/34326931/<i class="fas fa-external-link-alt"></i></a></p><p>今年内也如往年一样，尝试做过各种规划，从改善各种坏习惯到想要做出什么改变，罗列了很多，当然也如往年一样绝大多数根本没成功。比如说想每月反思，定期选择新的习惯进行养成等。也许都是因为每次列了太多，而不是每次选择一个最重要的去培养，又或者是其他原因，现在的我还未能理解。</p><h1 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h1><p>写完后回头看去年的总结，没想到也是提到同样的主题，或许人的本性不会这么轻易改变吧。</p><p>高浓度负能量和没意义的大道理警告⚠️，不喜欢请直接跳至下一节。</p><p>对于我来说，重要的不仅是这一年我做了什么，还有到了今年年底我的心态变成了什么样子，我是个怎样的人。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>这一年来，我从来未停止过试图改变些什么，这种寻求改变的念头甚至到了魔怔的地步。我的一个朋友说我总是在试图改变，也有些着急改变，我的确是恨不得立刻就能把我身上的问题都改掉，因为在我的内心中如果我不去努力改变些什么那我不值得任何美好的事物，只值得另一个理想自我或者是他人的唾弃，夸张的说会觉得无法在社会生存。尽管有一些看起来像是真的因为追求些什么而去改变，但现在的我似乎又觉得这些所谓的追求也是同样为了“生存”。</p><p>现在的我和过往一样，犯错犯蠢多到令人发指的地步，待人冷漠，经常会因为自我攻击而开始在网上说疯话胡言乱语，性格越来越扭曲。但相比去年来说更好的方面是我的自我觉察能力能强了，能理解此时此刻的我处于什么情境，我到底为什么会这样做，同时即便在说疯话我也能明白我此时此刻在做些什么。难过的是我即便了解这些，产生异样想法的时候试图用理智去说服自己，即便不断的重复，大部分情况仍未能起到什么用处。这些想法本身就令人痛苦，清醒的看着它们而无法做到些什么则会令人更痛苦。不过我在这个过程中也算是真正感受到理性的不可靠性，作为人来说还是感受更加重要，感受完全是不受理性束缚的，我却总想要用理性去修正感性，这也是完全不合理的。</p><p>自己心怀自卑却依然会有自大的妄想，不过今年意识并且切身体会到在某些方面自己远远没有想象中的自己那样好。虽然说着要做这个做那个，但实际上每天都无所事事，经常沉浸于虚拟世界之中（特指各种动画片）。感受到理想与现实的割裂感，说的时候会依照想象中完美自我的说话方式，但行动上却依然是弱小的自己。这让我想到《哈姆雷特》里面国王的一句令我印象深刻的台词</p><blockquote><p>我的言语高高在上，我的思想滞留地下。没有思想的言语永远不会上升天界。</p></blockquote><p>尽管我没有剧情中国王那么坏，但这种不一致性和矛盾性是相通的。</p><p>即使我知道今年有一些做的好的地方，但我依然无法认同自己，相比起这些“看起来微不足道”的改变，自己剩下的问题更严重。这本质是一个视角问题，即便当下的问题已经解决，我大概率也总会找理由去攻击自己。痛苦和折磨绝大部分来自于自身，自己看待问题的态度，自己的行为方式。</p><p>和往年一样，感觉时间过的越来越快了，这让我很是害怕。也许是害怕死亡，也许是害怕一事无成，也许是害怕虚度光阴，我不敢断言害怕的东西到底是什么样的。今年工作日每日重复的时间地点行为，每周末也都是几乎类似的，重复这件事情本身我觉得并无大碍，我只是不舍得时间就这样过去了。上半年都在做着自己要做的事情，却还总是担心时间的流逝，也许是感觉自己的时间利用的很差劲，觉得最后什么都没做好，迷失在了时间的洪流之中又无力掌控方向。而实际似乎也因为并没有花费多少时间学习也就没有学到多少，大多数时间还在发呆，娱乐。</p><p>前半年顺从着习惯，而后半年习惯渐渐瓦解，我的状态也各种有问题，做的事情渐渐开始变少了，不想做任何事情的状态再度袭来。后来我才真正体会到对于现在的我或许不需要去追寻什么非常喜欢的东西，至少当前不想做任何事情的时候是这样。我需要的是在我状态还算可以的时候选择几件事情，然后每日去做，不去想什么想不想做，只是每天一定要做的任务。</p><p>在写总结的时候偶然想到似乎最近没有那么强烈的一定要成为什么大佬的想法，开始思考起所谓成为大佬这种事意味着什么呢，而这件事对我来说又意味着什么呢？仔细想想我也许只是为了那么一个名号，喊的只有成为这个结果，却没有去追求学会什么知识，只是想通过这样的结果和标签获取关注和认同罢了。我之前发表过想成为编译器专家这种暴论，但渐渐我发现了，现在的我不是能成为什么领域专家的人。在我看了各种乱七八糟东西以后，意识到这和一个人的行为习惯有很大的关系，人一天绝大部分都是依靠无意识的习惯。同时我的目标应该是学好某个方面的知识，到达什么名号或者名誉都不是我应该去考虑的。</p><p>今年最后一个月的一半时间除了工作就是专心打游戏，这段时间非常平静，没有抱有对这种事情的执念。但当我从游戏世界中走出来，看着现实世界，思考起现实世界的问题，又难以恢复平静的心态，尤其是在最后几天大家纷纷放出了自己的年终总结，不由得对别人丰富多彩的一年感到羡慕，又三分钟热度想要成为多么好的人。想必明年也会如此，时而平静，时而扭曲，时而上推发疯。这些想法强烈的时候会非常痛苦，过去也不知该如何去缓解，也许需要等到真的接纳自己，真的觉得这样的自己也能很好的生存的时候，到时我的目标或许就会真正变为学好些什么，而不是成为什么带有名头的人。</p><p>人为什么一定要向着顶端爬呢，有的人是因为想要征服山顶，有的人是因为不安。我一定是后者吧，没有能够安稳生存的自信，想要通过这一种极端的方式来掩盖所有生活中的其他问题，真是懦弱。</p><h2 id="年初的我"><a href="#年初的我" class="headerlink" title="年初的我"></a>年初的我</h2><blockquote><p>我想过，我把时间分成这么多份最后的结果一定是每样都做不好。<br>我不是说所有人都是这样，只是我比较笨，多方面全能的天才太多了，不论是看过的传记，还是推特上实际见到过的大佬，他们都是切实做到全才<br>尽管我每样都不会做好，但是总比浪费时间要强的多。我在选择一些东西的时候就在想，如果不做这个，我的时间可以拿来做什么？答案显而易见，和我过去的周末一样，浪费时间。<br>我也在想，这些东西是否真的有必要，但是我感兴趣就够了，什么东西能够起到什么作用这种事情充满了太多的未知。<br>年初写下这些话，不知道年末的我怎么想</p></blockquote><p>一年下来，发现对我来说如果在做了就很好了，因为很多的时间依然被我随意浪费与挥霍。想要尽量减少浪费时间就去多做一些能够积累下来的东西，比如说学的东西用笔记的形式记录下来。而在这个时间洪流中前进的方法只有养成各种方面的习惯，习惯到了很多事情也就能做到了，但这个过程比做到什么事情本身还要难上许多。</p><h2 id="迷失方向"><a href="#迷失方向" class="headerlink" title="迷失方向"></a>迷失方向</h2><p>找不到自己应去之处，找不到人生的方向，这是一个困扰着绝大多数人的问题，而我也是绝大多数人的其中一员。对于未来的发展方向今年有过许多乱七八糟的想法，年初有，但到年中逐渐开始变化，到年末变化太大导致年初的想法又全军覆没。其中也做过一些奇奇怪怪的努力，但是都有些无功而返。自己尚未具备选择些什么的决心，也缺少将其实现的能力与自信。有过许多想法，但几乎每次都在变。这样的我现在能做的或许只能像最上面所说，先选中一些什么东西，坚持做下去吧。</p><p>除了之外，我对于自身的存在也感到迷茫。对于自己的人格，对于道德，对于对与错，对于各种各样的问题都在疑惑。疑惑也算是好事，起码我开始思考起这些问题了，开始想要跳出这个圈子看待问题，而不是继续陷入圈内。越发觉得不了解自己，不知道自己的兴趣爱好，不知道自己想要的是什么。因此什么都要，放弃做出选择，还会为得不到某些不需要的东西而产生负面情绪。也因此所追寻的大多数是别人的东西，外界所灌输的“我这样的人”所应该追求的，而不真正属于我自己想要的。我到底想要到哪里去，想要成为怎么样的人呢？</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>今年无疑是被疫情影响最大的一年。五月开始常态化核酸。后来核酸的频率降低，一直持续到了12月彻底放开。疫情影响导致多次居家远程办公，远程办公有好有坏，硬要说坏的方面比较多，但是家里的硬件设备远比公司舒服，同时又可以一直一个人窝着，因此还是更喜欢远程办公。彻底放开导致许多人都感染了新冠，而我选择蜗居在家，也因此暂时避免了感染。</p><h2 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h2><p>今年作息越来越阴间了，年初还是在12点睡，后来渐渐的12点半，10月底的时候差不多1点睡了。自从上个月底开始居家办公，仗着可以更晚起床，居然过分的到了一点半甚至到了两点才睡。</p><h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>今年涨了工资，经济状况相对来说宽裕了一些。今年依然在记账，虽然可能一如既往的记的不够精细，但是分析开销还是够用了。看了今年的账单，有点想打消整租的念头了，如果整租每个月起码要多支出2k多，以及冬天供暖还需要自己一个人承担费用。</p><p>随便讲一下情况，最大头的分类自然还是必须支出，吃穿住用的日常用品。住就不提了，一年吃了2w8，也花了不少。今年舍得打车了，没想到打车就花了快2k…淘汰了很多旧衣服，这方面也花了不少钱，电费什么的也花了不少，还有各种买药，杂七杂八的日用品。第二大头就是消费了，电子产品居多。其中很大一部分都是去年分期买的（比如说去年24期分息入手了M1Max…），加装了显示器以及入了相机镜头什么的。最后一大部分就是钢琴课，心理咨询以及前半年瑜伽的费用。书也花了不少钱，尤其是双十一的时候囤了20多本，一年下来杂七杂八的书花了快2000…虽然可能没看多少吧，很多都是有需要买来翻一翻。</p><h2 id="人际"><a href="#人际" class="headerlink" title="人际"></a>人际</h2><p>我这个人独来独往习惯了，便不想和人去打交道。有不擅长的成分，有害怕的成分，有觉得浪费时间的成分，总之有很多乱七八糟的原因形成了我现在这个样子。不过大多数不会因为讨厌别人，也因此我几乎不会为了维持关系去私聊他人。用一句话来形容，大概就是“我为来来往往的人流感到烦躁，但并没有因为你而烦躁“（已不记得原话）。这也是一个非常复杂的问题，和咨询师提到过这个问题一两次，但后来因为生病加各种问题，未再深入讨论这个话题了，明年一定要再深入讨论下去。不过不论怎么讨论，最终都是需要我来做出些什么改变。</p><p>今年发现了一个非常非常喜欢的网友，和他交流的过程中发现他简直就是我理想中的样子，追随着他的身影，也多少受到了他的一些正面影响。充满了想要成为他那样的想法，尽管那是不可能的。而在和他相处的过程中我受到了他的帮助，也改变并且成长了许多。人的成长还是要和什么人发生什么事情才行，只身一人游离于一切之外是不可能发生多少变化的，这是我今年的经历中切身体会到并且意识到的事情。</p><p>自己现在认识人的途径几乎只有Twitter了，今年新认识了许多Twitter上的朋友，也面基了几位，也有一些朋友没来得及面基，今年也要感谢朋友们对我的帮助以及对这样的我的容忍。</p><h1 id="明年的愿景"><a href="#明年的愿景" class="headerlink" title="明年的愿景"></a>明年的愿景</h1><p>我是非常贪心并且做不出选择的人，因此想添加上非常多的愿景。写这么多其实是不利于实现的，或许应该找几个核心目标再围绕展开，但这里还是想到什么写什么。</p><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><p>学习和生活想要恢复到今年刚开始的状态，并且希望能维持下去。身体健康方面还是要尽量下功夫，起码要保持每天运动的习惯，即便锻炼量很少，也要坚持动下去。关于情绪方面，尽管我有很多负面或者扭曲的想法，但是我大多能够及时觉察，认为自己能够一定程度的应对，只是很多时候由于各种大脑成分的原因我无法停止一些负面的想法，这些就不属于我改变想法就能做到的了。</p><p>找画师约一个皮套，直接出道。目前打算每天直播回家以后的学习生活，但似乎实现起来会有很多不方便，所以暂且将目标定在约好皮套这一步。</p><p>想遇到属于自己的madoka，这个是最想实现但是最不抱希望的了，做梦都没有这种好事的。</p><p>疫情好一些的话可能会挑个假期去南方转转。</p><p>希望今年能形成一些新的好习惯。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>compiler和os的坑会继续填，compiler的话继续开发我的玩具，以及再花些时间学习一下LLVM相关的内容，os起码要到把xv6里提到的功能抄一遍的地步，如果可以自制cpu这方面我也想开个坑，这个就尽力而为了。我觉得光是这些超大的坑就已经够占据我的精力了，暂时不去多想其他内容。</p><p>博客希望起码能保证两周一篇，如果可以还是想一周一篇，可以实施以写博客为目的的学习，既能保证博客更新又能保证持续学到东西。</p><p>除了专业技术之外我希望能多学一些专业之外的知识和技能，可能会向视觉类（设计/摄影）之类的靠近，也可能向一些科学方面的。</p><p>读书还是维持每个月一本好了。双十一阶段一口气囤了二十多本书，也不奢求能读完，毕竟比起要求读完还是持续阅读并且享受书中的内容更加重要。</p><h2 id="自我-1"><a href="#自我-1" class="headerlink" title="自我"></a>自我</h2><p>希望能对自己的生活有更多的掌控力，而这件事情的实现需要依赖于每一件小事的积累，并不需要我特地完成什么，只要做好其他任务自然能够做到。希望通过这样的方式逐渐增长一点自信。</p><p>最重要的是希望能够更加清楚的认识自己，找到自己的方向，不再因为没有自己想要的东西就去想要所有的东西，羡慕所有的人。</p><p>还想要多探究一些自己的感受，而不是自己的想法，多接触一些带有情感的事物或者作品，而不是只有冷冰冰的机器和科学知识。</p><h2 id="不重要的想法"><a href="#不重要的想法" class="headerlink" title="不重要的想法"></a>不重要的想法</h2><p>这部分的内容都是随缘了，不会太过于关注。</p><ol><li>小概率可能会继续写日记。去年写了几天但是后来就没再写了。</li><li>会试着强迫自己去再接触一些人，尤其是线下，也会试着开展新的交友渠道。</li><li>希望夏天有机会拍到英仙座流星雨。</li><li>想女装出门拍照，再修个图出来康康。</li><li>尝试一些其他新事物什么的。</li></ol><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>今年也多多少少做了一些事情，并且我能够确信有了不小的进步，这份进步也必然来自于我自身的行动。不过即便如此，这些内容放到一年的维度上来说真的是感觉非常渺小，每天都觉得在混日子一样的活着。因此说不上好，也说不上坏，只是又度过了一年平淡时光。</p><p>不过，平平淡淡也没什么不好。</p><blockquote><p>你的人生你做主，平淡无奇又何妨。总有一天，定能发现，各自的答案。</p></blockquote><p>来自《灵能百分百》第一季op</p><p>最后放一下今年最后一餐的烤鱼照片，不知为何今天突然想吃了，晚上火速下单！</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/IMG_5946.jpeg"                      alt="DSCF4435.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。&lt;/p&gt;
&lt;h1 id=&quot;去年的愿景&quot;&gt;&lt;a href=&quot;#去年的愿景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>灵能百分百 mob的改变与成长</title>
    <link href="https://fusionbolt.github.io/2022/12/31/Animate/MobPsycho100/"/>
    <id>https://fusionbolt.github.io/2022/12/31/Animate/MobPsycho100/</id>
    <published>2022-12-31T10:26:01.000Z</published>
    <updated>2022-12-31T12:59:04.202Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/MobPsycho100/image-20221231205833503.png"                      alt="image-20221231205833503"                ></p><p>灵能百分百，一个讲述了mob改变与成长过程中的故事。</p><h1 id="改变与成长"><a href="#改变与成长" class="headerlink" title="改变与成长"></a>改变与成长</h1><p>改变与成长，对于每个人来说都是不可避免的问题，对于mob也是一样。人的成长与改变离不开人，与他人相遇，然后发生些什么事情。mob受到了他人的影响，开始产生改变，而在这个过程中，其他人也受到mob的影响发生改变。</p><p>最上篇中mob所说的</p><blockquote><p><strong>人是可以改变的</strong>，这是最上与浅桐小姐教我的。我也被大家改变了，我也明白了<strong>自己或许可以改变某个人。</strong></p></blockquote><p>灵幻，小酒窝，花泽，芹泽，铃木等等许多人都是如此，受到了mob的影响所改变，而其中的许多人同时还是推动mob改变的一方，在人与人之间的交流中是互相影响和改变的。</p><p>mob和铃木的对决中有这样的台词</p><blockquote><p><strong>不管是谁，人都会在与他人的交往中成长，人需要别人，总有一天会需要他人</strong></p></blockquote><p>而铃木从中学开始“认为自己凌驾于他人之上”，认为不需要他人，而mob则对铃木说“止步于中学时期的是你”。不需要他人的铃木也正因如此这么多年来在许多方面仍未成长。</p><h1 id="接纳自我"><a href="#接纳自我" class="headerlink" title="接纳自我"></a>接纳自我</h1><p>而接纳自我，也是成长中非常重要的一部分。这部分主要都在最终的告白篇进行讲述与刻画。在这部分内容中，mob再次暴走了，而此刻是剧中唯一一次mob和暴走的自我进行持续对话，或者说他不得不在面对另一个自我。他畏惧情感化的另一个自己，但两者其实都是他自己。律一开始畏惧他，不断的跟自己说那不是哥哥，但到最后律明白了，那个也是mob的一部分，律选择去接受。</p><blockquote><p>他是一直被压抑的另一个哥哥，他们从根本上连在一起，无法剥离，哥哥今后也必须和这样的自己共存下去。</p></blockquote><p>正如律所说，暴走的是mob的一部分，而每个人则是由无数个这样的一部分组成的，我们要去尝试接纳自己的每一部分。现在回想看，似乎并非只有最终话才有接纳自我这件事情。mob最初对自己所拥有的力量感到烦恼，是灵幻教会他接受自己力量的方式以及使用力量的方式，这亦是一种接纳。</p><p>大家一直在否认另一个mob，而???也讨厌被人否认，整个对话的过程他都在不断的强调自己的存在。</p><blockquote><p>mob:你的想法太不正常了</p></blockquote><blockquote><p>???:什么叫正常，你又要否认我本身吗</p></blockquote><p>而”蕾只把我和龙套当成要好的朋友“很明显的是他将自己和mob区分开了。???想要认同，但他不被认同，同时他却未能认同另一个自己。自称不会被驯化的另一个mob，他只是不想被人当作一个会被否认的“特殊的存在”罢了。</p><blockquote><p>你并不特殊，每个人都有两面性。我也有，所以你不必烦恼。不对，烦恼一下倒也行，会烦恼其实也是理所当然的。我其实非常讨厌我隐藏起来的本性。但就是因为有这“虚假的一面”我才认识了你，你也是拥有这份力量…才有了今天的你吧。总之我想说，你其实，现在这样就可以了，现在的你就算没有我也不要紧了，别担心。是时候接纳了，接纳你自己。你能行…龙套一定能做到，我知道的。</p></blockquote><p>灵幻的这一番话表达了自己不认为另一个mob是特殊的，并且不是应当被否认的，从自己开始自我接纳，同时表达了对他接纳的意愿，mob的主人格也因此能够接纳他，他因此能够接纳师父和mob，一切也就回归了原样。<strong>不论哪一个自我，都是自己的一部分，都不是什么特殊的存在，都不是什么值得否定的存在。</strong></p><blockquote><p>你是说你要接纳我吗？</p></blockquote><blockquote><p>不…我希望你也能接纳我。就像大家接纳了我一样。</p></blockquote><p>即便是自认为最黑暗的部分，也只是自己的一部分，都不是什么特殊的、值得自己否定的存在，试着去接受它们吧。</p><h1 id="mob"><a href="#mob" class="headerlink" title="mob"></a>mob</h1><p>灵能百分百的剧情都是围绕着mob的成长展开的。最初的mob不善言辞，没有自己的想法，习惯性的压抑情感，无法接纳另一个情绪化的自己。在他第一次失控之后就开始抑制自己的情感，他对自己，或者说另一个自己感到畏惧。随着他与灵幻相遇开始发生了一些改变，而当他与更多的人相遇后，他逐渐开始找到自己所迷失的东西，开始有自己的想法和意见。但即便如此，他仍未能接纳另一个自我，他仍在压抑自己的情感，对于mob来说压抑情感和接纳另一个自我是相连在一起的事情。</p><p>而在最终的结局， 灵幻的一番话让他接纳了自己，将他从失控的状态中拉回。此时的mob是影山茂夫100%，正因为他接纳了另一个自己，他不再抑制自己的情感，他才得以完整。也正是从这里开始他恢复了自己的情感流露，在表白失败以后直接哭了出来，在ed为灵幻的生日喝彩时他甚至放声大笑了起来，而在前面的剧情中mob几乎都未有这样的情感表现。</p><h1 id="灵幻"><a href="#灵幻" class="headerlink" title="灵幻"></a>灵幻</h1><p>提到灵幻，我想一开始给观众留下的印象就是利用mob的欺诈师，但灵幻对于mob的整个成长旅途来说是最重要的角色。整个剧情部分我觉得可以说是以灵幻接受了mob的烦恼咨询开始，而最后又以灵幻引导mob接受另一个自己结束。one老师并没有这么用俗套的按时间顺序开场，而是mob即将爆发时将灵幻接受mob的咨询插入到回忆之中，这样的安排使得角色的行为更加合理，同时这个时候插入回忆会给我们观众留下更深刻的印象。他除了灵能力和超能力外几乎什么都能做到，而mob则是超能力最强但除了超能力外什么都做不到，这样的两个人完全是一对。正是这样的灵幻，在mob的成长中给出了方向，大多数情况能够敏感的察觉到mob的情绪。他开导了迷茫的mob，他告诉mob不需要看空气配合别人，遇到不愿意的事情可以逃避，教给mob接受自己。</p><p>在三季的boss战中每次灵幻的台词都让人十分感动。在第一季进攻爪支部的时候，其他人都在逼迫mob使用超能力，但只有灵幻察觉到了他不愿在这个时候使用。“住手，龙套，这么做你只会更加痛苦。不愿意的时候，逃跑也没关系”，用着这样的话语成功让mob从杀意转换为了逃避。第二季mob独自和爪的boss对峙时，灵幻独自赶了过去，对mob说出”还是觉得不应该让你独自来“这样的话。第三季面对另一个mob的时候，“你其实…现在这样的你就好，现在的你就算没有我也不要紧了，别担心。是时候接纳了，接纳你自己。你能行…mob一定能做到，我知道的“，这样引导mob接纳情绪化的自己。</p><p>除了灵幻对mob引导的情节外，还有二人产生矛盾的情节，他未能及时发现mob的快速成长所带来的变化，而mob选择了暂时不去灵幻那里。这段时间随着剧情推动，我们一点点看到了灵幻不为人知的过去，同时看到了这个除了除灵不论遇到什么都能临机应变的人的另一面。平凡的毕业开始工作，后来自己开始独自靠“除灵”赚钱。他其实是非常孤单的，mob和朋友们去卡拉OK，开始有人陪伴，有自己的生活，mob的身边热闹起来，不再是只有师父了。对于灵幻来说只有mob能真的陪伴着他，即便是他被套路之前人们也只是图求利益接近他，当他想诉说些什么却也无人能够倾听，被套路之后则是更不会有人愿意接近他了。这些都充分体现出了mob对于灵幻的重要性，mob对他来说不仅仅是一个利用来除灵的人，而是一个真诚的朋友，一个陪伴自己的人。</p><p>而在灵幻被套路后在记者发布会上记者提及到他作文中写的毕业期望的主题是“想成为什么”，他开始回忆起自己为什么要成为灵能力者，紧接着又从另一个角度讲述了他和mob相遇的故事。</p><blockquote><p>当时，我对那个少年产生了憧憬，我也想抓住些什么，想成为特别的人</p></blockquote><p>他做到了所想的事情，他抓住了他和mob之间的连接，成为了对于mob来说最为特别且不可或缺的人。灵幻虽然作为mob改变的推动者，但我想他也是被这场相遇改变的人。灵幻是一个圆滑处事的人，是会欺骗、利用mob的人，但他在面对另一个mob的暴走时却放弃了一切，没有选择圆滑的放弃，即便冒着生命危险，即便讲出自己欺骗的真相后mob可能会彻底离开，他也要将自己的想法传达给mob，就想要阻止他，我想这也是一种改变，他不再是那个只会圆滑处事的人了，而是重视朋友的人。</p><h1 id="小酒窝"><a href="#小酒窝" class="headerlink" title="小酒窝"></a>小酒窝</h1><p>除了灵幻，最重要的角色非小酒窝莫属。灵幻对于mob来可以说是最重要的，而小酒窝几乎是陪伴他最久的。小酒窝初登场是作为教主的身份，他一直怀有想要通过宗教成为神的愿望。从最初的想要利用mob，但逐渐开始帮助mob，不知不觉中小酒窝和mob已经成为了能够互相信任的朋友。小酒窝其实只是世间众多迷茫者中的一员，即便成为灵那么久，依然不知道自己想要的什么，在到神树篇之前他未曾察觉到自己只是想要朋友罢了。小酒窝或许也算是受到mob的影响所改变，也许正因为mob开始信任他，mob把他当作一个普通的人对待，他开始信任mob，真正发自内心而不是以利用为目地的去帮助mob。</p><p>小酒窝的出场，除了日常穿梭于各种剧情之中，以及被几大战力担当除灵，就是神树篇了。在神树篇之外几乎很少刻画小酒窝的想法和明显的变化，只有他的行动，而在神树篇中通过各种细节来刻画出他的想法，他的变化，将这个角色完整的表现了出来。</p><p>在mob进入神树的前一晚，他还在邀请mob一起，即便他已经有了足够的力量，但他本质上只是想和mob，和这个非常要好的朋友在一起做这件事情。这里他的台词我觉得非常巧妙。</p><p>不论是发出邀请时特意用的是“咱们”</p><blockquote><p>咱们是时候站上顶点了，一起去吧</p></blockquote><p>还是在mob拒绝以后，说出了这样的话</p><blockquote><p>你小子，想把本大爷排除在外吗</p></blockquote><p>这一切其实全都在表现他想要和mob一起的愿望，但他本人未曾察觉，而此时的mob由于忘乎所以也未注意到这一切。</p><p>但即便闹了矛盾，但不论是开场先吐槽，还是一直不忍心用全力攻击mob，又或者发出神之光线后的担心，他还是我们熟悉的那个小酒窝。即便说着要一决胜负，看到mob的衣服后还是吐槽了起来，开始为mob担心。他自己也没有意识到，自己在和mob相处的过程中渐渐的将mob看做了朋友，一个需要担心的人。</p><p>脱离了忘乎所以的mob，看到小酒窝对衣服的吐槽，发现他还是熟悉的小酒窝，决定100%信任小酒窝。并诚恳的道歉。而此时的小酒窝，才真正意识到自己想要的事情。</p><p>mob：</p><blockquote><p>对不起，小酒窝…这是你一直想做的事…一直不懈追寻的东西，你却在愿望眼看就要实现的时候，向我发出了邀请。你有能力这样独自实现愿望，却还特意来邀请我，这才是…最重要的事情。你不是在打坏主意，你只是想实现自己的愿望，和我一起。是你信赖来了我，谢谢你</p></blockquote><blockquote><p>你想做什么，我都会认真听的，作为你的朋友。</p></blockquote><p>小酒窝：</p><blockquote><p>之前一直没发现，本大爷其实…只是想要朋友。</p></blockquote><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>或许这部作品不温不火，但是我觉得它是我心目中的神作。</p><h3 id="原作"><a href="#原作" class="headerlink" title="原作"></a>原作</h3><p>我对原作的评价是one老师的剧情有趣、富有深度同时又浅显易懂，他想表达的事物已经切实传达到了我们这里。同时one老师笔下的角色都很有特点，某个积累了两年全勤记录的不良，我想大家都会在得知全勤记录的时候感受到这个角色的反差，花泽的各种奇特造型（包括两次被剃头以及多次出现的超高头发），篇幅所限这些角色就不再每个都聊一遍了。</p><p>有的人吐槽one老师的画风，这个因人而异，对我而言不论是原作十分简单的画风还是tv动画中对原作的模仿都觉得挺有趣的。但我觉得这是一部不应被画风所限制的作品，one老师是真的想要传达给读者些什么，将更多的精力放在讲故事中。现在的时代大多是一些惊险刺激的作品，又或者迎合宅宅们口味的作品，像这种专注于通过故事传达给读者些什么的作品已经很少了。</p><h3 id="TV表现"><a href="#TV表现" class="headerlink" title="TV表现"></a>TV表现</h3><p>tv动画通过漫画做不到的方式增强了表现力，声优的精彩演绎，bgm的完美结合，通过与剧情密切相关的歌词，op的独特动画。众多因素结合调动了观众更多的感官，对观众的情绪施加了更强烈的影响。在最后灵幻冲到mob面前时，配上第一季op的歌词，每一个画面几乎都与歌词契合，我甚至有理由怀疑这是制作组早就计划好的事情。</p><p>最终的结尾与最初的op相呼应，更加显现出第一季作为基础的地位。第一季虽然相对平淡。但是如果没有一开始的铺垫，我们不会感受到后面的精彩。<br>随着三季动画的播出，我们也跟着一起见证了mob的成长，而在剧情中一直见证着这一切的人则一定是灵幻。在第三季op中最后那一段灵幻站起来拍着逐渐长大的mob的肩膀，已经看过前两季的我从这里的画面联想到他们之间强烈的联系，情感也随之迸发。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>告白篇最终灵幻与mob的那段真的非常棒，让我忍不住想为这部作品写点什么，也便有了本文。但我想绝不仅是因为这一个结尾部分非常精彩，这一部分情绪感受很大程度由前面所有内容的铺垫而来。自己未想过能为这部作品写这么多东西，也许是真的有所感触。还有很多值得写的和深挖的内容，情感，mob与朋友们的联系，其他的角色等等，但作者水平受限便写到这里停下了。我一直在寻求改变，一直在寻求灵幻一样的存在，我能够感受到mob改变路上的迷茫，同时我也真心为one老师笔下的mob所经历的成长而感到高兴，我想这些都是让我感受到剧情中强烈情感的原因。</p><p>同样描述角色成长的京吹却未能像灵能百分百一样这么强烈的打动我，也许京吹更多的是校园的青春，也许是如我在京吹的感想中所说：“整部番一切都距离我的现实过于遥远，无法引起什么共鸣”，虽然京吹更加接近现实，但对我来说那种多人一起努力的青春场景远比灵能中的幻想世界更加遥远。我最喜欢的另外两部作品是魔法少女小圆，另一部是利兹与青鸟。这两部作品靠的是极致的情感吸引了我，而灵能则是整个mob成长经历的一点一滴，在最后将这些积累的东西全部爆发出来。</p><p>希望读者和我都能像mob一样不断的改变与成长，试着接纳不同的自己，最终做到</p><p><strong>自我100%</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/MobPsycho100/i</summary>
      
    
    
    
    <category term="Animate" scheme="https://fusionbolt.github.io/categories/Animate/"/>
    
    
    <category term="MobPsycho100" scheme="https://fusionbolt.github.io/tags/MobPsycho100/"/>
    
  </entry>
  
  <entry>
    <title>基于xv6 riscv实现学习os 其零：helloworld</title>
    <link href="https://fusionbolt.github.io/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/"/>
    <id>https://fusionbolt.github.io/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/</id>
    <published>2022-11-13T13:32:18.000Z</published>
    <updated>2022-11-13T13:51:45.329Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/xv6-riscv-os-0/30933181.jpg"                      alt="30933181"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">学习os的时间开始了! pixiv:30933181</center> <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的目的还是以讲解xv6-riscv的代码以及记录我在做的事情为主，也会掺杂许多mini-riscv-os的代码介绍（关于xv6-riscv和mini-riscv-os的链接请看参考），并非教程倾向（但也会尽可能讲解一些基础知识），<strong>很多细节不会讲到</strong>。如果想要更详细的教程我建议你查看参考资料中引用的内容，在这一期我会列出一部参考的项目。</p><p>compiler的坑还没走多远，我又要开新的坑了，这是我很久之前想做但不敢做的事情。以前也做过一些尝试，比如说《30天自制os》以及6.828，前者讲的相对比较容易理解一些，但是当时的我缺少实践，后者难度较高，看不懂课后习题只能去查看别人的实现，东抄西抄总算抄完了前四章的内容，最后只留下了一些概念的印象。对我来说学会什么东西只有通过具体去实现，自己很难从什么概念去理解某个东西，也因此之前学的很多知识其实都是非常肤浅无用的。</p><p>实现os这件事情看起来是挺吓人的，本身复杂的概念和各种实现，同时需要许多前置知识。同时大多数os的开始都是离谱的x86bootloader，我想这个应该劝退了非常多的人。但最近发现做一个最简易的os或许并没有那么可怕，搜了一些项目，最简单的功能很少的系统只有一两千行代码，相对比较容易学习，同时riscv的bootloader部分没有乱七八糟的历史遗留，十分简洁，不会再因为这个劝退别人。也在这里感谢他们的付出。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>mini-riscv-os是针对riscv32，而xv6针对的是riscv64，导致一些汇编上、编译选项以及一些其他的内容会有所不同</li><li>代码引用会直接使用项目名/路径的格式</li></ol><p>此后不再赘述</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h2><p>参考链接</p><p><a class="link"   href="https://pdos.csail.mit.edu/6.828/2019/tools.html" >https://pdos.csail.mit.edu/6.828/2019/tools.html<i class="fas fa-external-link-alt"></i></a></p><p>我是在mac（M1）下开发的，homebrew在安装riscv-tools的时候会提示需要安装一些依赖。在我配置的时候遇到了flock这个依赖搞不定的问题，发现直接brew install flock安装的flock是其他东西，因此需要卸载flock并且使用brew tap的命令，安装好依赖再去按riscv-tools</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall flock</span><br><span class="line">brew tap discoteq/discoteq</span><br><span class="line">brew install flock</span><br><span class="line">brew install riscv-tools</span><br></pre></td></tr></table></figure><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p>这个没什么好说的，直接用包管理安装就是</p><h1 id="启动所需代码"><a href="#启动所需代码" class="headerlink" title="启动所需代码"></a>启动所需代码</h1><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><ol><li>设置栈的起始地址</li><li>跳转到c代码中</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>mini-riscv-os/01-HelloOs/start.s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.equ STACK_SIZE, 8192</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # setup stacks per hart</span><br><span class="line">    csrr t0, mhartid                # read current hart id</span><br><span class="line">    slli t0, t0, 10                 # shift left the hart id by 1024</span><br><span class="line">    la   sp, stacks + STACK_SIZE    # set the initial stack pointer </span><br><span class="line">                                    # to the end of the stack space</span><br><span class="line">    add  sp, sp, t0                 # move the current hart stack pointer</span><br><span class="line">                                    # to its place in the stack space</span><br><span class="line"></span><br><span class="line">    # park harts with id != 0</span><br><span class="line">    csrr a0, mhartid                # read current hart id</span><br><span class="line">    bnez a0, park                   # if we&#x27;re not on the hart 0</span><br><span class="line">                                    # we park the hart</span><br><span class="line"></span><br><span class="line">    j    os_main                    # hart 0 jump to c</span><br><span class="line"></span><br><span class="line">park:</span><br><span class="line">    wfi</span><br><span class="line">    j park</span><br><span class="line"></span><br><span class="line">stacks:</span><br><span class="line">    .skip STACK_SIZE * 4            # allocate space for the harts stacks</span><br></pre></td></tr></table></figure><p>csrr是从csr（Control and Status Register）寄存器中read值，而其中的csrr reg, mhartid则是将hart id读到对应的reg中。hart是riscv中硬件线程的最小单位，在riscv的spec中是这样描述的</p><blockquote><p>A RISC-V compatible core might support multiple RISC-V-compatible hardware threads, or harts, through<br>multithreading.</p></blockquote><p>这里的代码判断如果hart id不是0就跳到park这个循环中。实质上是只开启了一个hart</p><p>xv6-riscv/kernel/entry.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure><p>xv6的启动代码中考虑了多个hart启动的情况，给每一个hard都设置stack的起始地址。而stack的起始地址是写在其他的c代码中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="keyword">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure><h2 id="c代码"><a href="#c代码" class="headerlink" title="c代码"></a>c代码</h2><p>在c代码中打印出一个血统纯正的helloworld。这里其实隐含了很多的内容，但是暂且知道这样做就可以打印出helloworld即可。</p><p>对于xv6来说在进入os的main之前有许多设置状态的内容，这里暂且不讨论。</p><p>mini-riscv-os/01-HelloOs/os.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART        0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_THR    (uint8_t*)(UART+0x00) <span class="comment">// THR:transmitter holding register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_LSR    (uint8_t*)(UART+0x05) <span class="comment">// LSR:line status register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_LSR_EMPTY_MASK 0x40          <span class="comment">// LSR Bit 6: Transmitter empty; both the THR and LSR are empty</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lib_putc</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> ((*UART_LSR &amp; UART_LSR_EMPTY_MASK) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> *UART_THR = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lib_puts</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) <span class="built_in">lib_putc</span>(*s++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">os_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">lib_puts</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ldscript"><a href="#ldscript" class="headerlink" title="ldscript"></a>ldscript</h2><p>这里主要是需要指定这么几项内容</p><ol><li>对于qemu来说，启动之后会读位于0x80000000这个地址的内容，因此我们需要将我们的内容放到这个地址开始。</li><li>指定OUTPUT_ARCH( “riscv” )</li><li>指定汇编入口地址，比如ENTRY( _entry )</li></ol><p>xv6-riscv/kernel/entry.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line">ENTRY( _entry )</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">   * ensure that entry.S / _entry is at 0x80000000,</span><br><span class="line">   * where qemu&#x27;s -kernel jumps.</span><br><span class="line">   */</span><br><span class="line">  . = 0x80000000;</span><br><span class="line"></span><br><span class="line">  .text : &#123;</span><br><span class="line">    *(.text .text.*)</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line">    _trampoline = .;</span><br><span class="line">    *(trampsec)</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line">    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;);</span><br><span class="line">    PROVIDE(etext = .);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .rodata : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.rodata .rodata.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .data : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sdata .sdata.*) /* do not need to distinguish this from .data */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.data .data.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .bss : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sbss .sbss.*) /* do not need to distinguish this from .bss */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.bss .bss.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PROVIDE(end = .);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>mini-riscv-os/01-HelloOs/Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-unknown-elf-gcc</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany -march=rv32ima -mabi=ilp32</span><br><span class="line"></span><br><span class="line">QEMU = qemu-system-riscv32</span><br><span class="line">QFLAGS = -nographic -smp 4 -machine virt -bios none</span><br><span class="line"></span><br><span class="line">OBJDUMP = riscv64-unknown-elf-objdump</span><br><span class="line"></span><br><span class="line"><span class="section">all: os.elf</span></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: start.s os.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -T os.ld -o os.elf <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu: <span class="variable">$(TARGET)</span></span></span><br><span class="line">@qemu-system-riscv32 -M ? | grep virt &gt;/dev/null || exit</span><br><span class="line">@echo <span class="string">&quot;Press Ctrl-A and then X to exit QEMU&quot;</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QFLAGS)</span> -kernel os.elf</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.elf</span><br></pre></td></tr></table></figure><p>这里没什么好讲的，绝大多数选项都用不到，唯一要注意的是-march的值</p><p>riscv是一种模块化的指令集，不同的名字代表支持的扩展指令集不同，关于详情参考</p><p><a class="link"   href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions" >RISC-V#ISA_base_and_extensions<i class="fas fa-external-link-alt"></i></a></p><p>之后直接通过make命令编译出elf之后通过qemu启动就好</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://github.com/cccriscv/mini-riscv-os" >https://github.com/cccriscv/mini-riscv-os<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/mit-pdos/xv6-riscv" >https://github.com/mit-pdos/xv6-riscv<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://riscv.org/technical/specifications/" >Specifications - RISC-V International<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/xv6-riscv-os-0</summary>
      
    
    
    
    <category term="os" scheme="https://fusionbolt.github.io/categories/os/"/>
    
    
    <category term="xv6-riscv" scheme="https://fusionbolt.github.io/tags/xv6-riscv/"/>
    
    <category term="mini-riscv-os" scheme="https://fusionbolt.github.io/tags/mini-riscv-os/"/>
    
    <category term="bootloader" scheme="https://fusionbolt.github.io/tags/bootloader/"/>
    
    <category term="riscv" scheme="https://fusionbolt.github.io/tags/riscv/"/>
    
  </entry>
  
  <entry>
    <title>虞美人草</title>
    <link href="https://fusionbolt.github.io/2022/10/16/Reading/papaver-rhoeas/"/>
    <id>https://fusionbolt.github.io/2022/10/16/Reading/papaver-rhoeas/</id>
    <published>2022-10-16T14:12:51.000Z</published>
    <updated>2022-10-16T14:15:33.016Z</updated>
    
    <content type="html"><![CDATA[<p>从小野身上的阴影中看到了自己。从差劲的过去与环境中脱离，只想要斩断过去，但是斩的断吗，不可能的，每个人都不可能断绝和过去的联系；小野与井上家相处的态度，小野认为自己的生活和井上家父女二人相差甚远，尽管还怀有恩情，但是对他们产生了鄙视；小野为了利益，不惜逐渐失去真诚，破坏承诺，选择去追求藤尾。这些内容相关的描述大多让我感同身受，不断的触动着我我内心黑暗的部分。我一直在迷茫，不知如此不真诚的自我有多少是该修正的，又要如何修正这些部分。小野最后受宗近所助解开了心结，那身为读者的我们如果也是这样该怎么做呢？写这些内容的时候偶然刷到诺贝尔奖获得者被爆出性侵少女，我对于小野这个角色所蕴含的意义多了一点想法。身为银表持有者，几乎代表了高学识的人们，但即便是这样的人们，也未必都是追寻道义的。许多人像小野一样，为了利益和欲望去做一些违反道义的事情，甚至是违反合理的法律，而大多数人不会像小野一样有人劝阻，我想作者一定是有对这样的人的批判在的。</p><p>而甲野与其完全相反，即便继承许多财产却依旧不为所动，坚持道义，有一种看透一切超脱于一切的感觉，但过于上帝视角，让人难以有代入感，或许也是因此作者给他设定为哲学专业，以及通过甲野相关的许多内容道出真理。宗近看似性格和甲野相差甚远，但从他对待不同人的态度可以看出对于道义他也是有着自己的坚持方式与追求。宗近和他家人对话的描述和小野与井上家相处的对比真的是非常强烈，宗近和他父亲以及他妹妹的谈话中充满了真诚，他是真的在关注他的家人，关注朋友。宗近与小野相交的剧情描写的不多，但每次相交小野都不会占上风，不论是买东西回家时小野感到被宗近的贬低，还是最后宗近的劝说，小野在这个真诚的人的眼前感到无力，只能感到他的耀眼，只能羡慕他的真诚。</p><p>藤尾母亲的虚荣、狡猾，为了面子无聊的伪装，无论哪一个行为决策都将她的这些特点描绘的淋漓尽致。描绘出了一个非常现实的形象，尤其是为了面子在意周围邻居看法这一面，特别像我们家长那一辈人，他们和亲戚以及邻里的关系更密切，他们也更重视这些所谓的外人看法，总是为了无聊的面子和外人看法做出一些毫无意义的事情；又或者为了利益层层计算这一点，现实中有太多这样的例子了，争夺家产，或者只是单纯的设下计谋以谋取利益。最后讲到藤尾自身，所有的主要角色都和她有着很强的关联，她更像是串联起这一切角色的线索。而到了故事的最后，通过藤尾的死来结束这一故事。藤尾更像是她母亲扭曲下的牺牲品，性格的塑造离不开她母亲，正如最后宗近所说：”您平素的想法确实有问题“，也正是因为这些产生了藤尾这样扭曲的性格，产生了这样的结局。</p><p>结局甲野的日记诉说着人们只看着不遵循道义的眼前利益，却忘了抛弃道德的代价，只看着美好的生却忘却了可怕的死，或许这和这和《快乐的死》中提到的非快乐的事情才能体现出快乐的事情略微相似，无论是好的还是坏的我们都不能忽视。在故事中小野即便打算找浅井回绝和小夜子的婚事，但他依然内心不安，甚至想要不遵守与藤尾的约定，也正如宗近所说，如果他这样选择下去了他一辈子都会置于痛苦中，而这就是他的代价。藤尾的母亲日常狡猾的话术，对于物质以及虚荣的执着，最终得到的就是甲野的抛弃与藤尾的死亡。宗近最后回复甲野的那句“此地只流行喜剧”真的是太嘲讽了，此时此地规定都已变成了这样，而社会上大多数人们的想法也是这样。大家在乎的是眼下的利益、是喜剧、是生，而不是更远的道义、悲剧、死亡。人们内心的黑暗普遍存在，《海边的卡夫卡》中有这样一段话</p><blockquote><p>外部世界的黑暗固然彻底消失，而心的黑暗却几乎原封不动地剩留了下来。我们称为自我或意识的东西如冰山一样，其大部分仍沉在黑暗领域，这种乖离有时会在我们身上制造出深刻的矛盾和混乱。</p></blockquote><p>只有真的去追求道义的人才会点亮这些黑暗，而这样的人又是很少的。另外社会上只有“喜剧”才被允许接纳和存在，只有“喜剧”才被允许传播，尤其是在这里。幸福的人千篇一律，不幸的人各不相同，而不同的悲剧带给我们各不相同的生的意义以及不同的教导，我们看不到这些悲剧那么我们迟早有一天会重复踏入这些悲剧之中。</p><p>道义这件事情，总觉得是一个难以谈论的话题。追求道义的人是极少的，做少数选择的人在生存上更加困难，同时有的人追求的又或者持有的是虚假的道义。在我眼里人类这一抽象存在是恶的，人的内心也确实普遍存在着许多黑暗，追求道义的过程我想也是点亮内心的过程。在这里似乎隐含了我对于不追求道义的人一些不接受，或许这个行为本身就是不够道义的。而追寻道义本身也是困难的，许多时候需要付出些什么，放弃眼前的利益这件事情又是违背人性的，而道义的边界似乎也模糊不定，这部分边界几乎是由环境的文化所决定。我为追求道义这件事感到苦恼，要做到怎样的地步，我又要如何战胜自己黑暗的人性，不断怀疑自己是否在虚假的寻求它。为此痛苦，为此迷茫，独自行走在茫茫人海中，不想追随人流，却也不知自己要去向哪里。希望有一天我能找到自己的答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从小野身上的阴影中看到了自己。从差劲的过去与环境中脱离，只想要斩断过去，但是斩的断吗，不可能的，每个人都不可能断绝和过去的联系；小野与井上家相处的态度，小野认为自己的生活和井上家父女二人相差甚远，尽管还怀有恩情，但是对他们产生了鄙视；小野为了利益，不惜逐渐失去真诚，破坏承诺</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="夏目漱石" scheme="https://fusionbolt.github.io/tags/%E5%A4%8F%E7%9B%AE%E6%BC%B1%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>快乐的死</title>
    <link href="https://fusionbolt.github.io/2022/10/15/Reading/a-happy-death-albert-camus/"/>
    <id>https://fusionbolt.github.io/2022/10/15/Reading/a-happy-death-albert-camus/</id>
    <published>2022-10-15T10:26:03.000Z</published>
    <updated>2022-10-15T10:26:47.239Z</updated>
    
    <content type="html"><![CDATA[<p>这本书的后续发展和我预想的偏差比较大。还没开始读的时候，看到杀死富豪携带一大笔财产这件事情，想到的第一件事情就是有钱了依然不会快乐，我想主人公会拿这笔钱去娱乐，娱乐很久最后开始觉得无聊与没有意义，后来通过什么事件发现了快乐的真相，之后过上了快乐的日子。不过现在来想如果真的是这样的展开那可能就没意思了。</p><p>对主人公梅尔索来说他觉得痛苦，母亲已经去世，没有人陪伴，即便有玛尔特但他并不爱她，他也不爱其他情人；他觉得自己没有钱，每天还要这样工作八小时；无所事事的过着每一天，每周都是在消磨时间，正如文中他所说的“又熬完了一个星期天”。这样的他看到他的租户卡多纳的惨状，推动了他现在就想要获取快乐的想法，因此他动手了。他认为拿到那笔钱自己就能脱离这种现状，有了钱不必再去每天花费时间工作，有钱就自由了。</p><p>除了不用工作以及最后买了房子之外，似乎并没有什么地方体现出这笔钱的价值，哪怕描写钱对于快乐的帮助没有那么大这件事情都不存在，也许是因为我被自己的想法所束缚住了。关于钱的观念借扎格尔斯也提到过一些，比如他说的“大多数有钱人完全不知快乐为何物。但这不是问题所在。有钱，就是有时间。”以及“我想说清楚一点，不要觉得我在说金钱能带来快乐。我的意思是，对某个阶层的人来说，在有时间的前提下，快乐是可能的，而有钱，就能摆脱金钱的困扰”。但写到这我想作者后续的内容很少提及拿到的那笔钱也许正是对于这些观点的体现。有了钱，他不需要浪费时间去工作，而钱又无法带来快乐，因此没有什么体现出钱的重要性的地方。</p><p>作者没有采取表现出钱带不来快乐这一方面，而是着重在了其他方面。最重要的就是孤独。从他踏上行程后第一部分就在描写他独自一人在外的孤单，试图摆脱也未成功。即便在后面远离熟识的人们选择独自居住的时候依然会保持和新村子中居民的联系，和以往熟识的人们见面。</p><p>这本书借由扎格尔斯表达的内容除了对金钱的态度外似乎一直在强调要有追寻快乐的心，也许是想要表达不论环境如何关键是自己的心态与看法。后面作者还说到“要懂得让自己的心顺应每天的节奏，而不是非要每天的节奏顺应每天的心意”，追寻快乐，去做些什么固然重要，但是不是说一定要去达到了什么目的、做到了或者改变了什么才是快乐的，而是自己的心意如何去看待与解释周围一切，通过这种角度尽可能让自己的快乐程度多一分。</p><p>翻开书的第一页就是“要不计代价地追求快乐，抵抗这个用愚蠢和暴力将我们包围的世界。”（不知道其他译本是否是这样）但是他为什么最后一个人去住了呢，和卡特琳娜的对话仿佛是在说如果没有和快乐相反的经历无法体现快乐的经历一样。也许这是非常重要的一个观点，他说“我在意的，是有一定质量的快乐。只有当快乐和它相反的事物呈现出持久而激烈的对峙时，我才能够品尝到快乐的滋味”。只有他自身孤独的瞬间才会让他觉得和别人在一起是多么美好，快乐本身是由相反的事物衬托出来的。</p><p>说了那么多废话，最关键的结论大概是我们不应去追求什么理想的没有痛苦的世界，而是基于此时此刻，基于自己现在的人生，改变自己的看法，接纳与快乐相反的那一部分。真实的世界就存在于那里，但我们眼中的世界是由我们自己塑造的。</p><p>我被这本书的书名以及内容概要吸引而来，大概为了看到想要看到的东西以及为了明白些东西。那么我得到了什么呢，好像没有什么，这也无妨。那么读着这本书的我，感到快乐吗？遇到好事自然会快乐，但无法说整体的基调是快乐的。不算快乐。那痛苦吗？除了会对身体的不适感到痛苦之外，其他情绪上的好像也无所谓，或者做不到想做的事情就会难过，但那更像是踢到了石头一样的痛苦，也因此无法说整体基调是痛苦的。我对此似乎也不会在意，只是像个机器，按照命令做一切事情。</p><p>自己精神上对于快乐的追求好像没有那么强烈，我很喜欢jojo里吉良吉影的态度，“不需要疯狂的喜悦，相反也就没有深沉的绝望”，这句话也算是印证了上面提到的快乐是由相反的事物衬托的，对我个人来说这样的平静是最好的。</p><p>解读出来这些也都只是大道理，无法引起什么感受。只有道理本身或许也不会产生什么影响，尽情去生活、阅读与思考，也许有一天一切都会连接起来，震撼到心灵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书的后续发展和我预想的偏差比较大。还没开始读的时候，看到杀死富豪携带一大笔财产这件事情，想到的第一件事情就是有钱了依然不会快乐，我想主人公会拿这笔钱去娱乐，娱乐很久最后开始觉得无聊与没有意义，后来通过什么事件发现了快乐的真相，之后过上了快乐的日子。不过现在来想如果真的是</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="加缪" scheme="https://fusionbolt.github.io/tags/%E5%8A%A0%E7%BC%AA/"/>
    
  </entry>
  
  <entry>
    <title>工作踩坑小结</title>
    <link href="https://fusionbolt.github.io/2022/10/02/Problem/some-work-problem/"/>
    <id>https://fusionbolt.github.io/2022/10/02/Problem/some-work-problem/</id>
    <published>2022-10-02T09:26:12.000Z</published>
    <updated>2022-10-02T09:27:44.010Z</updated>
    
    <content type="html"><![CDATA[<p>前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>一开始闹了一个小乌龙，工具链支持到c++17的标准，但是同事之前指定了14的标准，差点就要把filesystem相关的代码全改掉了。但是后来依然编译不过，在需要系统调用的标准库处报了错误，这才想到裸机并没有这种东西，最后还是加条件判断宏全部处理掉了…</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h2><p>裸机的启动代码中有一些汇编，其中JAL跳转指令在链接的时候报了错</p><p>startup.S:120:(.text+0xbe): relocation truncated to fit: R_RISCV_JAL against symbol `SystemInit’ defined in .text.SystemInit section in</p><p><a class="link"   href="https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean" >https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean<i class="fas fa-external-link-alt"></i></a></p><p>先说结论，JAL指令的立即数字段的长度是固定的，而所要跳转的地址超出了JAL这个字段所能代表的长度。</p><p>最初猜想是否和我的lib大小有关系，尝试删掉了部分代码缩小了接近一半的体积后果然可行。但是依靠这种方法解决是不可行的，代码体积无法再简化了，而且以后lib体积只会增大。参考链接中设置mcmodel，然而依然报错。</p><p>接着尝试修改链接顺序，因为符号的顺序是和链接的顺序相关的，想要将对应的符号放到链接的最前面，但是需要跳转到我的lib中的符号，又不方便再去调整lib中的顺序。</p><p>最后在同事的提醒下修改了链接脚本，将这些报错的text section放到了最前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">  . = ALIGN(0x8) ;</span><br><span class="line">  __stext = . ;</span><br><span class="line">  KEEP(*startup.o(*.text*))</span><br><span class="line">  KEEP(*startup.o(*.vectors*))</span><br><span class="line">  /* avoid link failed when lib too large */</span><br><span class="line">  *(.text.SystemInit)</span><br><span class="line">  *(.text.trap_c)</span><br><span class="line">  *(.text.vTaskSwitchContext)</span><br><span class="line">  *(.text.startup.main)</span><br><span class="line">*(.text)</span><br><span class="line">  *(.text*)</span><br><span class="line">  *(.text.*)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conda的环境问题"><a href="#conda的环境问题" class="headerlink" title="conda的环境问题"></a>conda的环境问题</h1><p>在使用某个python库的时候提示了Could not find a suitable hostfxr library，一直以为hostfxr相关的库版本错了，直到我点进这个源码看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_hostfxr</span>(<span class="params">dotnet_root: <span class="built_in">str</span></span>):</span></span><br><span class="line">    hostfxr_name = _get_dll_name(<span class="string">&quot;hostfxr&quot;</span>)</span><br><span class="line">    hostfxr_path = os.path.join(dotnet_root, <span class="string">&quot;host&quot;</span>, <span class="string">&quot;fxr&quot;</span>, <span class="string">&quot;?.*&quot;</span>, hostfxr_name)</span><br><span class="line">    <span class="keyword">for</span> hostfxr_path <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">sorted</span>(glob.glob(hostfxr_path))):</span><br><span class="line">        <span class="built_in">print</span>(hostfxr_path)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> ffi.dlopen(hostfxr_path)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;Could not find a suitable hostfxr library in <span class="subst">&#123;dotnet_root&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>一看血压直接拉满，抛了异常一律视为没找到。手动改成打印错误信息才发现是dlopen的时候所加载的glibcxx版本不对，由于是在conda环境下因此去修改conda的链接。不是第一次被conda坑了…</p><h1 id="优化与调试"><a href="#优化与调试" class="headerlink" title="优化与调试"></a>优化与调试</h1><p>这算是我第一次实际遇到因为优化产生的问题。由于最近在调试内存分配相关模块的问题，我想要手动malloc/new一块内存复现问题。此处为代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_malloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;na\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nb\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nc\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="keyword">int</span> *d = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nd\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用的是裸机专用的工具链，因此内存的分配和释放都会调用工具链中的代码，我在其中打了log，但是发现new的时候并没有打印log。</p><p>没有调试器，想了半天怎么也想不明白，最后查看反汇编发现画风是这样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/some-work-problem/Untitled.png"                      alt="Untitled"                ></p><p>指定编译选项的部分都是其他同事编写的，我一开始也没往这里想。看了半天最后发现原来malloc被优化掉了。b和d很直接，是unused的代码，但是a和c都被free了却依然被优化掉。</p><p>关于这个问题好奇搜了一下，搜到这个回答</p><p><a class="link"   href="https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2" >https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2<i class="fas fa-external-link-alt"></i></a></p><p>the optimizer knows malloc and considers it is a function with no side-effects，多半是编译器内部针对特定符号编写的优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。&lt;/p&gt;
&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;p&gt;一开始闹了一个小乌龙，工具链支持到c++1</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CrossCompiling" scheme="https://fusionbolt.github.io/tags/CrossCompiling/"/>
    
    <category term="Conda" scheme="https://fusionbolt.github.io/tags/Conda/"/>
    
  </entry>
  
</feed>
