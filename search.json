[{"title":"Hello World","url":"/2021/04/19/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"运气","url":"/2021/06/12/luck/","content":"攒了很多文想写，但由于总觉得自己了解的还不够加上生活比较忙碌迟迟没有写，不过哪怕写的再差，月底之前一定会再憋一篇技术文出来。\n最近比较想写运气这个话题的内容。因为各种意义上，我实在是”倒霉”，尤其是最近几个月。比如说前些时间让我很头疼的毕业相关事宜，刚从学校那边上回北京高铁，导员就通知我一个放进档案的表格字写的不合格要我重写，填一些论文以及实习材料的时候都全填完了论文指导老师才说哪里哪里应该怎么写，好多又白费了。\n先别急着关闭博客，我不是来讲我多”倒霉”的。\n倒霉不是倒霉我觉得这其中一部分并不是真正随机的事情，它们可以通过人为因素来一定程度的避免，这也是为什么我在前面的倒霉加了双引号表示。比如说要我重写的表格，明知道要放进档案但我还是没花太多精力去一笔一画的写导致字迹略草（虽说比平常的字好很多了），如果我当时再认真点写或许就可以避免这所谓的“倒霉了”。\n为什么要这样区分？这些事情中自己总有做的不够好的地方，如果能改正那可以减少下次发生类似事件的概率（@@@：重复同一件事情是无用的，木大木大），进而还能间接减少坏心情\n改变自己的视角，将出现的问题、差错视为一个发现自己问题并且纠正的机会（这是一场「试炼」，我认为这是一场让我战胜过去「试炼」，我接受了，只有在战胜那不成熟的过去后，人才能有所成长…你不也是一样吗？）\n把一切都推脱出去的行为一点也不可爱（划重点）\n误区尽管这类事情中很多是个人因素，但不要因此苛责自己，出错这件事情是不可避免的。并不是说因为自己应该做到些什么就把责任全部归咎于自己身上，比如说你在人行道没看路有摩托撞上来了，自己没看路是一方面，但是对方也没有遵守道路行驶规则。\n再重复一次，改变这些看法的本质只是为了改正自己做的不合适的地方，不要因为这个而苛责自己。实际上确实存在容易将责任归于自己身上的人，如果你是这样那希望本文能够让你意识到问题并且开始萌生改变的想法。\n人为防范的例子很多人可能都会有到学校/公司之后发现今天晚上会有雨，但是没有带雨伞的经历。其中也有不少认为今天真倒霉，偏偏要下雨了没带伞。但如果你考虑到这种情况还会发生，于是下次又买了一把伞放在学校/公司那就不一样了，不会因为同样的理由被雨淋，减少了觉得“倒霉”的次数，进而心情还会好一些。\n无可奈何的情况除了人为可控的情况，当然也有一些不可抗力，比如说抽卡，抽卡，还有抽卡，但你钱砸的够多还是能抽到。这种情况那我只能说平日多扶老奶奶过马路，多关心孤寡推友 比如作者\n最后，希望读者能够早日脱离“运气”的陷阱，减少运气对自己的情绪影响以及能够从中学到些什么。\n","categories":["Thinking"]},{"title":"Rc-lang开发周记0 基本块与if重排","url":"/2021/12/19/rc-lang-dev-0/","content":"目前的工作重心在于将ast转换为tac指令。\n由于ast的if转成的中间表示的条件跳转是带有两个分支的，因此需要对if后面所跳转到的位置进行重排。\n基本块与重排相关的代码目前在ir/cfg.rb中，ast到tac的代码目前在ir/tac/tac.rb中\n而跳转指令实质上是从一个基本块（BasicBlock）跳转到另一个基本块，因此我们需要先将tac（三地址码）转换成由基本块构成的形式\n基本块核心性质\n每个基本块是从一个label开始（单一入口点）\n每个基本块是由一个跳转结束（单一结束点）\n\n每一个基本块是独立的，因为由跳转结束，所以不管怎么更换基本块的位置最后都不会影执行顺序的正确性\n案例def f(cond, a, b)  n = a + b  if cond    n * 2  else    n + 2  endend\n\n比如这段代码，就会存在三个基本块\n\nmain开始到if的条件跳转\ntrue的部分是一个基本块\nfalse的部分是一个基本块\n\n2和3：在生成if代码的时候会给true和false的分支各自添加一个label作为跳转目标，而每个分支结束都会跳转到最后结束的分支\n用途能够表示程序的控制流。\n目前用于重排if指令，后续代码的优化分析会经常用到。最经典的就是ssa(Static Single Assign)相关操作，需要对控制流进行分析，而转换为cfg的形式本质上只需要对cfg分析就可以了\n构造算法构造算法很简单。从头到尾进行一遍搜索，找到一个label就开始一个基本块，而到了一个跳转就结束一个基本块。\n但是存在两种特殊情况\n\n当前是label的情况下前一条指令不是jump的话需要手动添加一个jump跳转到当前的label\n当前是jump的情况下如果下一个不是label则需要将下一个指令设置为label\n\n上核心代码（这里省掉了检查第一个label的代码\ntac_list.each_with_index do |cur_tac, index|  if cur_tac.is_a? TAC::Label    # prev is not a jump, maybe need push a jump to this label    # but when first, not need process    valid_do(tac_list, index - 1) do |prev_tac|      unless prev_tac.is_a? TAC::Jump        blocks.last.push TAC::DirectJump.new(cur_tac)      end    end    blocks.push BasicBlock.new(cur_tac)  elsif cur_tac.is_a? TAC::Jump    # next is not a label, need create a block and push a label to next block    blocks.last.push cur_tac    valid_do(tac_list, index + 1) do |next_tac|      unless next_tac.is_a? TAC::Label        blocks.push BasicBlock.new(&quot;TmpLabel#&#123;tmp_label_count&#125;&quot;)        # push a label      end    end  else    blocks.last.push cur_tac  endend\n\n目前这里的tac采用的是数组而不是链式结构，所以查看前一个以及插入结点略微麻烦（第一次写，所以一开始写的时候没有想到那么多，后续可以考虑换成链式结构方便插入与查找前驱后继）\n重排if重排的过程分为三步\n\n找到所有的路线\n路线排序\n\n找到所有路线这里也是采用相对比较简单粗暴的算法\n类似于dfs的形式，将所有的基本块放入一个队列中，从第一个未标记的开始深度优先遍历，和dfs一样需要标记中途遍历过的结点，但是并不恢复标记。一条路走完后会从队列取出下一个未走过的点作为新的路线的起点。\n从当前的块选择下一个到达块的时候优先选择false分支， ****为了后续转到vm指令的时候不需要考虑CondJump false的情况，false直接顺着走就可以了，方便后面的排序\n上代码\ndef search_all_branches(cfg)  blocks = cfg.blocks  tag = Tag.new  q = blocks  roads = []  # dfs that traverse all nodes  until q.empty?    roads.push search_single_road(q, tag)  end  roads.reduce([]) do |sum, road|    sum + road.blocks  endenddef search_single_road(q, tag)    t = Road.new    b = q.shift    until tag.has_marked(b)      tag.mark(b)      t.append(b)      # find last(false branch)      first_next_b = b.all_next.reverse.find &#123; |next_b| not tag.has_marked(next_b) &#125;      if first_next_b.nil?        break      else        b = first_next_b      end    end    tend\n\n排序这里有三种情况\n\nCondJump后面接着的是false的块，则不需要做任何事情\n后面接的是true块，则需要调换顺序，而条件需要设置为相反的\n后面的块和这个CondJump没有关联，那么需要将这个CondJump(cond, label_true, label_false)转换为一个CondJump(cond, label_true, label_false‘)，之后在后面添加一个label_false’以及直接到label_false的跳转指令\n\nCondJump(cond, label_true, label_false) →\nCondJump(cond, label_true, label_false‘) + label_false’ + Jump(label_false)\n我这里是通过判断块的第一个label来判断是不是对应的块。代码写的比较粗糙\ndef reorder_branches_impl(tac_list)  tac_list.each_with_index do |tac, index|    if tac.is_a? TAC::CondJump      next_tac = tac_list[index + 1]      if next_tac == tac.false_addr        # is ok      elsif next_tac == tac.true_addr\t\t\t\tset_not_cond(tac_list, index)        next_false_tac = tac_list[index + 2]        tac_list[index + 1], tac_list[index + 2] = next_false_tac, next_tac      else        old_false_branch = tac.false_addr        new_false_branch = TAC::Label.new(&quot;#&#123;tac.false_addr.name&#125;f&#x27;&quot;)        tac.false_addr = new_false_branch        tac_list.insert(index + 1, new_false_branch)        tac_list.insert(index + 2, TAC::DirectJump.new(old_false_branch))      end    end  endend\n\n可以看到这里也是由于使用数组来保存导致插入新指令比较麻烦（下次一定修改为链式，咕咕咕）\n关于更详细的案例可以看对应的测试代码。重排if的测试代码在spec/ir/tac_spec.rb中\n参考资料现代编译原理C语言描述 第七章、第八章\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记1 中间代码表示","url":"/2021/12/26/rc-lang-dev-1/","content":"本周前面的时间主要选择了重新整理项目结构以及修正了自己滥用require_relative的问题，后面的话则是开始对ast to tac进行测试，尝试通过TDD的方式在开发效率和质量确保找到一个平衡点。\n比起测试，更主要的目的是重新回顾自己tac的设计决策，前面写的时候更多是一时兴起，完全不顾结构与正确性就往下写，比起急急忙忙往后赶进度还是应该将当前的内容做好才行。\n当前的项目结构.github # CI 尽管代码不多，但是依然要依靠单元测试和CI保证每次修改的正确性analysis # 代码分析的内容，目前并没有做过多的内容interface # 编译器、解释器和REPL的入口compiler # compiler的实现interpreter # 解释执行的实现ir # 多级ir的实现，ast, tac, vm指令lib # 编译器相关的一些简单的库，比如env, log或者错误处理之类parserspec # 专门用于测试\n\n解释执行实现的部分由于其他内容快速修改，暂无法顾及，因此暂时无法正常工作\nRc-lang的多层IR结构\n高层IR：AST\n中层IR：四元式\n底层IR：VM指令\n\n本周内容主要以中层IR为主\n中间代码表示IR主要分为两类\n\n线性IR\n图IR\n\n要注意的是树IR也是一种DAG图，因此也属于图IR，而高层的AST也是属于图IR\n选择IR的时候最主要的一点是我们要用它来做什么、需要什么信息，我想也没有什么绝对的设计正确，只要提供了所需信息，方便后续测试就足够了。在这里对比一下常见的IR实现（以线性IR为主）\n线性IR的概念三地址码是指 指令右侧只能有一个运算，不允许出现组合的形式\na2 = (b + c) * 4需要被翻译为a1 = b + ca2 = a1 * 4\n\n龙书中选择了线性IR的方式，使用了传统的三地址码。而虎书采用了树形IR（最后会简单提及）\n四元式具有四个字段，类似于 op arg1 arg2 result的形式，但是存在一些特例\n\nop仅需要一个参数\nparam的运算不使用args2和result（这里的param是龙书中用于传递函数参数的指令，龙书针对每一个参数产生一个param，仅传递参数也不需要返回值）\n转移指令将跳转地址放入result\n\n这些特例是针对虎书中的指令，实际可以根据需求进行一些变动\n定义这是我的四元式定义 在文件ir/tac/quad.rb中\nclass Quad  attr_accessor :op, :result, :lhs, :rhs  def initialize(op, result, lhs, rhs)    @op, @result, @lhs, @rhs = op, result, lhs, rhs  end  def to_s    &quot;#&#123;@result&#125; = #&#123;@lhs&#125; #&#123;@op&#125; #&#123;@rhs&#125;&quot;  end  def ==(other)    @op == other.op &amp;&amp; @result == other.result &amp;&amp; @lhs == other.lhs &amp;&amp; @rhs == other.rhs  endend\n\n以及我个人觉得没必要全都严格按照这种方式来，还是以自己的需求为准。按照常规的四元式op可以是各种类型的\n比如说我实现的Assign和Call（其他的op目前还没有修改以及做更多测试，本周先介绍这两个最基本的）\n通过类型来获取更多的信息，而不是仅仅通过字符串判别。还可以做到像call一样设置一个别名，能够显得更加直观\nclass Assign &lt; Quad  def initialize(result, lhs)    @op = &#x27;assign&#x27;    @result = result    @lhs = lhs    @rhs = EmptyValue.new  endend\n\nclass Call &lt; Quad  def initialize(result, target, args)    @op = &#x27;call&#x27;    @result = result    @lhs = target    @rhs = args  end  def target    @lhs  end  def args    @rhs  endend\n\nAssign没什么可说的。但是Call比较特殊\nargs并不是只有一个地址，所以Call并不算严格意义上的四元式。上面也提及过龙书中的Call的参数是通过一个param指令传递的，然后单独调用一个call。但就我目前来说这样做比较方便，等到后续做其他功能发现这么做的坏处的时候再修改也不晚\n转换实现\n转换代码在ir/tac/translator.rb中\nclass Assign # Rc::AST::Assign  attr_reader :var_obj, :expr  def initialize(var_obj, expr)    @var_obj, @expr = var_obj, expr  endenddef on_assign(node)  name = visit(node.var_obj)  expr = visit(node.expr)  Assign.new(name, expr).tap &#123; |assign| @tac_list.push assign &#125;end\n\n转换ast::assign的时候会将原来的名字作为tac::assign一个目标地址（尽管设计上留有了这个空间，但是目前先不考虑成员变量这种复杂的情况），然后再将表达式返回的内容设置为assign的operand。因此我们需要看一下expr的转换\nclass Expr # Rc::AST::Expr\tattr_reader :exprend# Rc::AST::Expr -&gt; Operanddef on_expr(node)  expr = visit(node.expr)  if expr.is_a? Operand    expr  elsif expr.is_a? Quad    expr.result  else    raise &#x27;unknown expr type&#x27;  endend\n\n存在两种情况\n\n转换为一个operand（比如说常量的情况）\n\n转换为了一个quad\n比如说c = a * b，a * b 会先存到一个临时变量再赋值。关于这个，龙书6.1.1中提到了这样的内容\n\n为什么我们需要复制指令？通常，每个子表达式都会有一个它自己的新临时变量来存放运算结果。只有处理赋值运算符=时，我们才知道将把整个表达式的结果赋到哪里，一个代码优化过程将会发现可以发生替换\n\n我没完全理解，也许只有做优化的时候才会明白，就先沿用这样的设计了\n\n\nquad的时候需要返回对应的临时变量，因为返回值会直接用于assign的operand\n测试\n然后我们再来看一下测试代码 spec/ir/tac_spec.rb\ncontext &#x27;assign&#x27; do  it &#x27;succeed&#x27; do    s = &lt;&lt;SRCdef f1\ta = 1\tb = 2\tc = a * bendSRC    tac = get_tac(s)    list = tac.first_fun_tac_list    expect(list[1]).to eq Assign.new(Name.new(&#x27;a&#x27;), Number.new(1))    expect(list[2]).to eq Assign.new(Name.new(&#x27;b&#x27;), Number.new(2))    expect(list[3]).to eq Quad.new(&#x27;*&#x27;, TempName.new(&#x27;0&#x27;), Name.new(&#x27;a&#x27;), Name.new(&#x27;b&#x27;))    expect(list[4]).to eq Assign.new(Name.new(&#x27;c&#x27;), TempName.new(&#x27;0&#x27;))  endend\n\n可以看到有简单的assign, 还有一个表达式的运算。\n表达式的运算转换为了一个quad，并且保存在了临时变量中，最后再将这个临时变量assign给c\n线性IR的存储方式对于线性IR来说，保存的方式也是一个比较重要的实现决策，很大程度会影响到后续各种操作。\n而实际实现无外乎数组和链表两种保存方式，在上周做重排if的时候也能看到数组的方式插入删除比较麻烦，而且效率会比较低。数组插入删除的方式也有对应的优化实现，但是对于其他优点目前没什么了解，后续做到优化的时候可能会需要考虑到这些实现方式的差别。\n我当前所有指令都保存在了一个数组，所以上面的四元式并没有指向前后的指令。之所以这么选择是因为当时没考虑太多，很自然的会想到一组指令会存到一个数组中。不过需要时在ast全部转为tac以后再做一下转换即可，需要做其他优化时再添加。当前目的是直接生成下一步的指令，所以现在这样就够了。\n名称与地址对于线性ir来说名称和地址是非常重要的事情。名称与地址是对应了三地址码的操作数，可以是常数，可以是一个地址，也可以是一个名字（间接索引到地址）\n所以有了一个operand的定义，在文件ir/tac/operand.rb中\nclass Operandend\n\n1.名字通过名字确定一个地址，实际实现可以通过符号表来索引到对应地址。\nclass Name &lt; Operand  attr_accessor :name  def initialize(name)    @name = name  end  def to_s    @name.gsub(/:/, &#x27;&#x27;)  end  def ==(other)    @name == other.name  endendclass TempName &lt; Nameend\n\n2.常量如果是数字类型的常量可以直接放入，这也符合CPU指令的行为。（bool本质也是数字）\n如果是字符串常量则需要记录到全局的一个表中，本质上我们还是使用字符串的地址。这个表里的东西在后续转vm指令和运行时会放入常量段，由于不会牵扯到改变，因此目前这里采用了一个普通的列表，通过索引来获取地址的方式。这里或许会牵扯到优化的问题，我觉得关于字符串常量这种优化可以放到转入这一步之前，如果遇到其他场合再做修改。\n两种常量的定义\nclass Number &lt; Operand      attr_accessor :num      def initialize(num)            @num = num      end      def to_s            @num.to_s      end      def ==(other)            @num == other.num     endend\n\nclass Memory &lt; Operand  attr_reader :addr  def initialize(addr)    @addr = addr  end  def ==(other)    @addr == other.addr  endend\n\n常量的转换\ndef on_bool_constant(node)  Number.new(node.val.to_i)enddef on_number_constant(node)  Number.new(node.val.to_i)enddef on_string_constant(node)  Memory.new(@const_table.add(node.val))end\n\n在这里涉及到一个const_table的问题。字符串会放在常量区，因此我选择在这里转换为一个地址。关于Memory或许需要选择段的问题，但是目前还没有遇到需要区分的情况，后续添加其他类型的常量再考虑吧，因此也是先这样。\nclass Memory &lt; Operand  attr_reader :addr  def initialize(addr)    @addr = addr  end  def ==(other)    @addr == other.addr  endend\n\n常量表\nclass ConstTable  attr_reader :list  def initialize    @list = []  end  def add(constant)    i = @list.index(constant)\t\ti.or_else do      @list.push constant      @list.size - 1    end  end  private def method_missing(symbol, *args)    @list.method(symbol).try &#123; |x| x.call(*args) &#125;  end  def ==(other)\tlist == @other.list  endend\n\n目前选择了这样简单的形式。没有用Set的原因是难以添加一个成员以后再返回对应的索引，可以作为后续优化的一个点。\nor_else是一个hack, nil的情况会返回block中的代码\n3.临时变量临时变量会出现在各种表达式中，前面转换的实现中也能看到相关内容。这里不多赘述\n其他IR形式这里对于SSA(Static Single Assign)就暂不提及了，SSA更多的是用于优化方面，目前的目标是生成VM指令并且能在VM上运行，做到SSA的时候会讲的\n其他的形式在这里大概一提，不讲过多细节（写不完了）\n三元式具有三个字段，类似于op arg1 arg2的形式。和四元式不同，不会显式保存返回结果，而是将每个结果存入列表中，因此三元式对结果的引用也是依靠于位置。很明显，这样就会导致如果添加或者减少指令则会变得很麻烦，因此引入间接三元式（在这里不赘述了，有兴趣自行搜索）\n由于实现比较麻烦，所以我还是选择使用常规四元式\n图IR虎书采用了树形IR\n由于我目前选择了线性的方式，暂无这方面的代码，姑且还是提一下虎书中的实现并且贴一下图\n其实也比较接近于tac，只是结构变成了树状，同样会有各种常数，内存操作，调用等等，因为中层IR本质上都是要将AST转换为接近于机器表示，所以不管什么样子最终都是要接近于机器指令。不同的存储方式区别只是做优化的时候不同\n\n\n最后tac指令以及对应的operand过于繁琐，测试代码也有待改进，对于Ruby来说这些都可以利用元编程来精简代码，而且可以疯狂造dsl。只是每天的开发时间实在不多，还是以能做出来为最高优先级。\n写了足足快俩小时，有点写的不耐烦了（有点时间焦虑，先以能写完为目标吧…）。写的过程中我会强迫自己反思和改进，上周写的时候最后还发现了一个bug，也算是不亏，下周也会更（在新建文件了，咕咕咕\n参考https://www.zhihu.com/question/33518780/answer/56731699\n编译原理 第六章\n现代编译原理 第七章\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记2 VM相关","url":"/2022/01/02/rc-lang-dev-2/","content":"本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧\n本周vm的代码都在ir/vm中，translator用于转换，inst是指令定义，vm.rb是入口\nFunction转换这是我目前的Function的ast定义\nclass Function    attr_reader :name, :args, :stmtsend\n\n在修改function生成代码的时候发现了一个问题，因为我有默认最后一个值直接返回的设计，所以或许应该在高层添加一个将stmt显式抽出\nreturn的操作。这个步骤现在看来大概分为简单两步\n\n消除不可达代码，比如说一个return后面还有好几个值\n消除后就可以放心将最后一个语句的结果转换为一个返回值了\n\n但是第二步实际实现的时候可能没有这么简单，这里就暂提个思路，以后再回头看这个设计是否有需要\n无意义的tac to vm inst之后做了一些将tac转到vm指令。在做这个的过程我才意识到其实不需要转成tac，对于tac和vm指令的表达力应该是同等级的，都比较偏向于中层IR。查看了一下其他语言的做法，Ruby和Java都是从AST转到了字节码\n深入理解Java虚拟机310页：\n\n字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作\n\nRuby原理剖析36页：\n\n在解析完 词条生成AST之后，Ruby1.9和Ruby2.0继续把代码编译成一系列的底层指令，叫做YARV指令\n\n这里的YARV是Ruby的字节码解释器，而YARV指令自然就是对应的字节码。而Ruby1.9之前是直接解释执行ast的，甚至不会考虑到tac这样的东西\n为什么不需要先转成tac优化后再到vm指令关于这一点，我询问了朋友，最后的结论大概有以下两点。如果读者对这方面很了解希望能科普一下\n\n转成tac做优化以后，尤其是部分针对全局的优化会以及其他的变换会剔除掉一些JIT时所需要的信息。\n关于这点我问了很久，我觉得还要尽可能地多做优化再到jit，应该要通过控制不做哪些优化来避免剔除所需信息。因为我对这几个层面所能做的优化了解不深，不知道所能做的优化有哪些差异，也没法举出例子或者说明收益\n后续我又了解了一些信息，发现jit中还有一个名叫的deoptimize技术，这个出现在multi tiered jit中。关于这个的内容在我另一篇博客中\n\n如果直接显式执行的是源码而不是字节码，先转成tac做处理再到vm指令会影响到了启动时间\nRuby是在内部对源码解析之后再由vm来执行。Java可能给大多数人的印象是必须要先编译到字节码，然后再单独加载执行字节码，但调查发现Java9开始可以通过jshell来直接执行。将这个过程封装到一起实际上也不麻烦，只是不需要你显式操作罢了\n\n\n所以经过了这些结论，前面做的tac到vm指令的就白费了，只能重新写一套从ast生成vm指令代码。生成tac这个过程并没有白费，编写的过程中让我有对这个东西有了更深的理解，以及后续可能会用tac实现优化算法。\nVM简介至于VM的实现，很自然的就会选择栈式VM。以学习为目的肯定要做寄存器分配，但是因为后续想做jit，所以寄存器分配就留到那个时候再做，或者说可以再从tac做成aot，反正目前还是以实现学习为目的。\n搞一个VM本质是什么？我觉得本质是对运行时的环境进行处理。那么我们首先要来谈及这个环境都有哪些部分\n我觉得简单可以分为以下两种\n\n数据（代码与计算的数据）\n当前状态（寄存器与栈帧）\n\n数据数据牵扯到的问题有很多，比如说数据排布、对象布局、地址分配等等。这也是我第一次动手做这些，这里就先从最简单的只有int32做起。如果后面做完善了可以再单独出一期把这些东西串起来（咕咕咕咕咕咕\n当前状态寄存器寄存器就从目前来说，我们需要一个pc寄存器来表明当前执行到哪条语句了。至于vm那边的实现目前使用一个数组保存，pc保存下数组索引就好\n栈帧栈帧根据不同的需求内容也各不相同\n我们来看一下龙书中提到的常见栈帧成员（不论什么书其实大都差不多\n\n局部变量\n临时变量的位置（牵扯到临时变量？\n机器状态（保存的特殊寄存器值，这个和调用约定也有一定关联。调用约定决定了哪些寄存器是需要保存的，哪些是不需要保存的，关于调用约定更多详情还请自行查询\nrbp指针（用于管理访问链\n指向调用者的地址\n返回值（我选择统一放到一个寄存器中）\n实参\n\n要注意的是书中提到的基本上是针对非VM的栈帧，VM的栈帧可以根据需求做出不一样的设计，比如说Ruby中采用了双栈的设计，一个调用栈用于管理调用链，一个计算栈用于存放各种变量与计算，而对于非VM栈帧絕大多说都是一个栈（我没听说过有使用双栈的，但是说不定也存在呢）通过栈中保存的rbp寄存器中的值来处理访问链\n就目前从头开始实现而言，我们需要什么再加什么就好了，后续每个东西怎么加，为什么加我都会有一定说明。\nVM指令转换计算赋值先从普通的运算赋值做起。这里其实有点问题，我还没有处理好单独的语句，所以都放到了一个函数里（写完这篇就去改），以及对于函数定义该如何处理我也没想好。\ndef foo  a = 3 * 2end\n\n在Ruby的虚拟机中扫描到类似的函数定义则是会产生一行调用 definemethod :foo, foo\n而foo本身的内容则是\n== disasm: #&lt;ISeq:f@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])[ 1] a@00000 putobject                              3                         (   2)[LiCa]0002 putobject                              20004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;0006 dup0007 setlocal_WC_0                          a@00009 leave                                                            (   3)[Re]\n\n这里出现了一个点，由于函数体中是一个assign，值会pop走，但是这个assign又是作为一个返回值，因此ruby中对结果调用了dup，创建一个重复的值用于返回。在写博客的时候看到Ruby指令的结果刚意识到这个问题，不过这个是属于关于函数体与函数调用相关的内容，这里目前暂不修改。\n作为参考，进行编写测试。\ncontext &#x27;assign&#x27; do  it &#x27;normal expr&#x27; do    s = &lt;&lt;SRCdef fooa = 1 * 2endSRC    inst = get_vm_inst(s)    expect(inst).to eq [Rc::VM::Push.new(1), Push.new(2), Mul.new, SetLocal.new(0), Return.new]  endend\n\n对于一个普通的a = 1 * 2，我们期望的行为是将两个参数push到栈上，之后进行mul操作，最后设置本地变量的值\n乘法操作class Binary # Rc::AST::Binary  attr_reader :op, :lhs, :rhsenddef on_binary(node)  [    push(visit(node.lhs)),    push(visit(node.rhs)),    translate_op(node.op),  ]end\n\n操作数的处理指令操作数目前分了两种，一种是直接可以保存值的，一种是引用某个名字\nmodule VMInstOperand  class Value &lt; Struct.new(:value)  end  # Ref a exist var  class Ref &lt; Struct.new(:ref)  end  def push(node)    if node.is_a? Value      Push.new(node.value)    elsif node.is_a? Ref      GetLocal.new(node.ref)    else      raise &quot;Unsupported node type #&#123;node.class&#125;&quot;    end  endend# 下面两个都是visit结点的函数def on_number_constant(node)  Value.new node.val.to_iend# Get or Set, so need return a iddef on_identifier(node)  Ref.new cur_fun_env[node.name].idend\n\n这么设计的原因是\n\n针对一个简单的数值我们可以直接将值push到栈上\n针对一个名字我们需要去符号表中找到这个名字所在的位置，再将对应的值push到栈上\n\n同时也有不同的“push操作”\n\n针对简单的值直接push\n针对名字我们通过GetLocal来获取（对于vm那边的实现，需要根据局部变量的基址和偏移量以及类型找到对应的值再放上去，但是类型目前不考虑，统一int32）\n\n这里暂时不考虑访问外部作用域的问题，这会涉及到符号表的访问以及栈的修改两部分内容。\n针对这样的设计，我们需要开始增加栈的功能了\n\n简单数值的运算，我们需要能将值放上去，再进行运算取出或者留在栈里（这些临时变量）\n\n因此就有了如下最最最简单的栈\n----------  临时变量----------\n\n\n我们需要留有局部变量的位置，能够在里面存取数据。临时变量是会随着当前函数结束而销毁，因此我们需要添加临时变量的位置在栈上，栈回退的时候也会直接销毁掉\n由于1需要反复修改栈指针的操作需要所以放在当前栈帧的最顶端比较合适\n\n\n因此就有了如下最最简单的栈\n----------  临时变量----------  局部变量----------\n\nop处理这个没什么好说的，简单从op字符串转换到不同类型的运算指令\ndef translate_op(op)    case op.op    in &#x27;+&#x27;      Add.new# ...以下省略\n\n符号表就之前的代码而言，符号表信息之类的记录的并不够。在实际考虑栈帧以及执行之前我对符号表的认识仅仅停留在作为解释器的env以及他的功能的“概念”上。由于是之前写过的，就直接拿来用了，没有 再来认真反思设计以及其他的问题，回头再重新设计吧，先能用就行\n考虑局部变量如何保存这个问题，引出了我对符号表更多的实际理解，所以还是要自己动手做才能更有助于理解，只是看一些理论讲还是不够，至少对我而言是这样的\n关于扫描分析的代码在analysis/global_env中\n符号表相关的定义在lib/env中\n全局表class GlobalEnv &lt; Struct.new(:define_env, :const_table, :fun_env)end\n\n全局表目前保存三个东西\n\n各种定义（类定义、函数定义等），这个设计是比较早的时候写的，可能并不合适，后续再好好想一下该怎么做\n常量表\n函数的符号表，根据函数名找到对应函数的符号表\n\n条目针对生成VM指令的阶段，需要知道一个临时变量的位置，因此有了这样的一个东西作为符号表的条目。\nclass EnvItemInfo &lt; Struct.new(:id, :type)end\n\nid的话在一个函数中是自增的，用于GetLocal和SetLocal中计算具体的offset（这个设计对于后续可能不够用，先这样）。类型肯定也是需要的，但是目前并没有考虑类型的问题，就留了这么一个坑在这里\n函数def on_function(node)  @define_env.define_symbol(node.name, node)  @cur_fun_sym = Env.new  @cur_fun_var_id = 0  @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)  visit(node.stmts)  @fun_env[node.name] = @cur_fun_symend\n\n\n将函数名字关联到结点\n从每个函数开始分析时初始化各参数的状态\n将参数merge进当前函数的符号表中\n访问函数体\n将函数名关联到对应的符号表\n\n最后今天写的太久有点写不下去了，所以到后面内容比较潦草，还请见谅。（目前以保证更新频率为主）有疑惑的地方可以联系我\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记3 生成C++代码","url":"/2022/01/09/rc-lang-dev-3/","content":"由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。\n指令定义每个指令有一个InstType的枚举字段来标明类型\n所有指令继承自一个VMInst类\nstruct VMInst &#123;    InstType type;protected:    VMInst(InstType t) : type(t) &#123;&#125;;&#125;;struct Addr : VMInst &#123;public:    Addr(int offset, string seg) : VMInst(InstType::Addr), _offset(offset), _seg(seg) &#123;&#125;private:    int _offset;    string _seg;&#125;;\n\nC++解析最主要的问题是要如何让C++解析这边生成的东西。我目前就选用了最简单粗暴的方法，直接生成字符串，用空格分离参数，用换行分离指令\n获取所有指令信息获取有哪些指令我将所有的指令都放到了Rc::VM::Inst中，通过获取这个module的所有constant，判断哪些是Class\ndef get_classes(mod)\tmod.constants.map&#123;|c| mod.const_get(c)&#125;.select&#123;|c| c.is_a? Class&#125;.sort_by&#123; |klass| klass.to_s &#125;endclasses = get_classes(Rc::VM::Inst)\n\n通过这个代码能够获取到Inst这个模块中的所有指令\n\n获取每个指令里面是怎么样的\n\n由于ruby并没有定义成员类型的东西，因此我选择自己造一个指定成员类型的东西\n有两种实现\n实现方式TypeStruct第一种是将Struct给包装一层，我给其命名为TypeStruct\n使用方式\nclass CondJump &lt; TypeStruct.new(:cond, :addr =&gt; :int)  def to_s    &quot;CondJump #&#123;cond&#125; #&#123;addr&#125;&quot;  endend\n\n类似于常规的Struct的使用方式，但是输入变成了可以是一个hash\n实现\n\n实现的一个要点在于new返回的东西需要是一个class。那么我们需要知道Ruby中new是怎么运作的\n常规的对象来说，new中会做三件事。class MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = “\\n”, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map { |td| td.name }  endend通过allocate分配空间，send initialize方法进行构造对象，最后将obj返回。而在这里只要修改返回的内容即可\n\n另一个要点在于需要给返回的class添加一些实例方法\n这里我们需要先理解常规的Struct.new做了什么，在我的理解本质上是返回了一个通过动态添加定义的匿名class，那么我们需要的是给这个匿名class添加一些方法来定义\n那么我们很自然的就会想到将所有传给new的参数转换为每一个成员以及与之相应的类型定义，之后再对其中每一对“成员名⇒类型”定义对应的获取类型的方法\n\n保存一个type_map，用于后面获取信息使用\n\n\n来看一下代码\ndef args_to_hash(*args)  args.reduce(&#123;&#125;) do |sum, arg|    sum.merge(      if arg.is_a? Hash        arg      else        &#123; arg =&gt; :str &#125;      end)  endendclass TypeStruct  include TypeCheck  def self.new(*args, &amp;block)    # if don&#x27;t have allocate, will be nil class    obj = allocate    # initialize is a private method    # initialize must be send instead of direct call    obj.send(:initialize, *args, &amp;block)  end  def initialize(*args)    args = args_to_hash(*args)    Struct.new(*args.keys).tap do |klass|      args.each do |attr, type|        check(type)        # per class Struct is different        klass.define_method &quot;#&#123;attr&#125;_t&quot; do          type        end      end\t  klass.define_method &quot;type_map&quot; do        args      end    end  endend\n\n还有一个点是需要在这里检查type的合法性，这里想过生成类的，但是最后想或许现在没必要，还是先用符号吧。检查相关的代码如下\nmodule TypeCheck  VALID_TYPE = &#123;:int =&gt; :int, :str =&gt; :string&#125;  def invalid?(type)    VALID_TYPE.keys.include? type  end  def check(type)    unless invalid? type      raise &quot;invalid type #&#123;type&#125;, only supported #&#123;VALID_TYPE.map(&amp;:to_s).join(&#x27;,&#x27;)&#125;&quot;    end  end  module_function :check, :invalid?end\n\nattr_type第二种是增加了一个像attr_reader一样叫做attr_type的东西，但是这个要依赖于常规的Struct，我还是想要常规Struct内部的东西来避免重复代码。虽然有办法不依赖Struct，但是那样需要在这个attr_type里面引入更多不属于这个函数的功能，于是还是放弃吧\n使用示例\nclass Push &lt; Struct.new(:value)  attr_type :value =&gt; :int  def to_s    &quot;Push #&#123;value&#125;&quot;  endend\n\n实现\n实现的核心原理还是参数转到hash再对每一对值define_method，只是这次我们要直接hack Module。attr_reader等函数也是采用的类似的做法\ntype_map的处置有一些不同，type_map需要将成员初始化，所有成员默认str类型，接着需要不断的merge新的参数，这个时候会将type_map中在args出现过的key所关联的值更新，这么解释可能比较复杂，看代码更直接一些\n&#123;:a =&gt; 1&#125;.merge(&#123;:a =&gt; 2&#125;)=&gt; &#123;:a=&gt;2&#125;\n\nclass Module  def attr_type(*args)    args = args_to_hash(*args)    args.map do |attr, type|      TypeCheck::check(type)      define_method &quot;#&#123;attr&#125;_t&quot; do        type      end    end\t@type_map ||= self.members.reduce(&#123;&#125;) &#123;|mem| &#123;mem =&gt; :str&#125;&#125;    @type_map.merge!(args)  endend\n\n二者的选择最后的结果嘛…ide分析不出来，不想看到各种报错的红线。遇到需要手动new的时候只能改成第二种了\n\n在获取成员的时候也用了很脏的做法，没找到什么在不new的情况下获取成员的好方法，因此也只有先new再从里面找。\n生成以前没做的坑这里其实做一个dsl来描述然后生成是最好的。在好久之前了解rv的时候我甚至一度想开一个坑，用一个dsl来描述一个isa，之后生成对应的C++的读写代码。最后也是咕咕咕了，后续有时间可以做一下，还是挺有意思的。\n这是一个描述load store的例子。当时做的时候没想到，现在一想其实也可以直接用Struct来描述，采用和我上面一致的方案\nISA.define :LOAD do  field :rd, 5  field :funct3, 3  field :rs1, 5  field :imm, 12endISA::define :STORE do  field :offset_4_0, 5  field :width, 3  field :base, 5  field :src, 5  field :offset, 5end\n\n这是一个只做了外观没有做内部实现的例子，属实有点问题，正经人谁会搞出这玩意\nnamespace :Suica do  namespace :T do    struct :F do      auto :a1      auto :a2, 1      void :f2, [&#x27;a&#x27;, &#x27;b&#x27;] do      end    end  endend\n\n生成的实现有点扯远了，我们来看一下实际生成C++代码的部分。\n我们需要生成如下几步\n\n获取所有指令信息\ninclude头文件，名称空间等内容\nInstType的enum定义\n所有指令类的定义\n解析输入的部分\n\n每个部分生成一个源码字符串，最后将这些拼接为一个长的字符串就好了\n捋清这个流程以后就简单贴一下部分代码好了，源码中&lt;&lt;SRC的部分是一个字符串块的开始，SRC是结束，中间的任何字符都会保留，除了#{expr}，这个是将expr to_s以后再嵌入进去\n帮助方法这是我自己加给Array的辅助函数，因为经常会有需要遍历array的所有对象做一套统一的操作最后再join连接的情况\nclass Array  def generate(c = &quot;\\n&quot;, &amp;f)    map &#123;|a| f[a] &#125;.join(c)  end  def pure_generate(&amp;f)    map &#123; |a| a.demodulize_class &#125;.generate(&amp;f)  endend\n\ndemodulize_class的话就是简单的将类名去除了module前缀\n获取所有指令信息虽然上面提过，这里再放一下代码\ndef get_classes(mod)      mod.constants.map&#123;|c| mod.const_get(c)&#125;.select&#123;|c| c.is_a? Class&#125;.sort_by&#123; |klass| klass.to_s &#125;end\n\n头文件def gen_header_namespace  &lt;&lt;SRC#include &lt;string&gt;#include &lt;vector&gt;#include &lt;memory&gt;#pragma onceusing std::string;SRCend\n\nInstType的enum定义def gen_enum_inst_type(classes)  &lt;&lt;SRCenum class InstType &#123;#&#123;classes.pure_generate &#123;|c| &quot;#&#123;c&#125;,&quot;&#125;&#125;&#125;;SRCend\n\n生成的样子\nenum class InstType &#123;Add,Label,SetLocal,&#125;;\n\n指令类定义def gen_class_define(klass)  class_name = klass.demodulize_class  member_map = klass.get_member_map  params = member_map.generate(&#x27;, &#x27;) &#123;|td| gen_class_member(td)&#125;  init_member = &quot;#&#123;member_map.keys.generate(&#x27;, &#x27;) &#123;|name| &quot;_#&#123;name&#125;(#&#123;name&#125;)&quot;&#125;&#125;&quot;  init_member = &quot;, #&#123;init_member&#125;&quot; unless init_member.empty?  init_inst = &quot;VMInst(InstType::#&#123;class_name&#125;)&quot;  &lt;&lt;SRCstruct #&#123;class_name&#125; : VMInst&#123;public:  #&#123;class_name&#125;(#&#123;params&#125;):#&#123;init_inst&#125;#&#123;init_member&#125; &#123;&#125;private:#&#123;member_map.generate &#123;|mem_ty| &quot;#&#123;gen_class_member(mem_ty, &#x27;_&#x27;)&#125;;&quot;&#125;&#125;&#125;;SRCend\n\n这里可能有一些需要提一下的东西，比如说有一个get_member_map\nclass Class  def get_member_map    instance = self.new    # need keep same order    MemberMap.new(instance.try(:type_map).or_else&#123;[]&#125;.map do |name, type|      TypeDefine.new(name, type)    end)  endend\n\n为了保持顺序，我选择了用数组来存放。指令最多无外乎一两百条，对于这个数据量不需要太去关心什么高效算法。\n为了有更多的类型信息来帮助写易读和更可用的代码，一个名称类型对也转转换为了一个类型\nclass TypeDefine &lt; Struct.new(:name, :type)end\n\n而MemberMap是一层包装，内部用typedefine的array存储，但也是可以像hash一样取出所有的key\nclass MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = &quot;\\n&quot;, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map &#123; |td| td.name &#125;  endend\n\n生成的样子\nstruct Label : VMInst&#123;public:  Label(string name):VMInst(InstType::Label), _name(name) &#123;&#125;private:string _name;&#125;;\n\n解析代码def gen_all_parser(classes)  &lt;&lt;SRCstd::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list)&#123;#&#123;classes.generate &#123;|x| gen_parser(x)&#125;&#125;throw std::runtime_error(&quot;Unknown inst type&quot; + list[0]);&#125;SRCend\n\n生成的样子（这里只放一个示例\nstd::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list) &#123;\t    if (list[0] == &quot;Addr&quot;)\t\t        return std::make_unique&lt;Addr&gt;(std::stoi(list[1]), list[2]);&#125;\n\nC++代码格式这里应该提一下，这种生成方式代码格式一定会乱七八糟，所以还应该调用一下clang-format处理一下。但是VM那边的clang-format之类的许多东西还没有加好，之后再做一下吧\n最后感谢你能看到这里，我再闲谈几句没什么关联的\n这个系列我已经到了四篇，也就是一个月。持续做了这么几次已经可以确定只要不出意外自己就能连载下去，于是之后都会在推特推送我的更新（本周的就先算了，ruby本身所占比例有点大）RealAkemiHomura’ Twitter\n如果对我的日常有兴趣可以点个关注，如果并不在意这个只想看后续的文章，那么可以通过rss订阅，或者每周一查看我的文章，更新一定是在周末\n前面也提到元旦状态差，这些天甚至几次觉得这个系列过于玩具没有意义，想要断更、项目不想做下去了。但我最后还是决定继续更新，不为别的，只因为我还想接着做这个项目，哪怕内容如此简陋，只是一个过于简单的玩具，但我确实从中收获了知识和乐趣\n","categories":["Ruby"],"tags":["Rc-lang","元编程"]},{"title":"Rc-lang开发周记4 函数其一","url":"/2022/01/16/rc-lang-dev-4/","content":"本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。\n函数解析方式这里我一开始没想好怎么做的，所以会做的很诡异，最大的原因是静态类型语言和动态类型语言是不同的。由于我只对动态语言有一些了解，这里暂时只提动态语言的一些点\n动态语言手头动态类型语言的资料是相对较多的，而实际看编译出的产物也是相对熟悉一些。\n对于Ruby和Python来说，函数都是动态定义的。因此解析到一个函数的时候会产生一个定义函数的指令\nRuby\n0000 definemethod     :foo, foo      (   1)[Li]\n\n（后面的1是行号）\nPython\ndef f():0 LOAD_CONST    0 (code object f)3 MAKE_FUNCTION 06 STORE_NAME    0 (f)\n\n而函数本体内容则是创建了一个函数对象并放到了其他的位置，以及地址是重新从0开始的。这个地址应该是相对地址，因为会动态装载\n这两个的源代码不一样的，只是想展示地址都是从0开始。dump出来的内容差异也比较大\nRuby\ndef foo a = 3 * 2end\n\n== disasm: #&lt;ISeq:foo@&lt;compiled&gt;:9 (9,0)-(11,3)&gt; (catch: FALSE)local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])[ 1] a@00000 putobject                              3                         (  10)[LiCa]0002 putobject                              20004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;[CcCr]0006 dup0007 setlocal_WC_0                          a@00009 leave\n\nPython（函数体被编译成的内容\ndef f():\tprint(&quot;Function&quot;)\n\n0 LOAD_CONST 1 (“Function”)3 PRINT_ITEM4 PRINT_NEWLINE5 LOAD_CONST 0 (None)8 RETURN_VALUE\n\n实现一开始是想仿照做一个动态的实现，但是后来觉得还是静态的好，导致产生了如下的代码。\n对于一个函数，我生成了一个DefineFun。FunLabel是因为我不知道它们是如何判断函数结尾到哪里的，这属于我当时的一个理解错误，编译的时候函数体的内容会被编译好放到其他位置，而不是说运行时再看到一个函数的标签，再将之后的一段代码跳过。\n# 只展示关键部分# 错误版本def on_function(node)  [DefineFun.new(node.name), super(node), Return.new, FunEnd.new]end\n\n正确的做法应当是在编译的时候就将这些代码单独放到其他位置，运行时再进行装载。\n调用无参函数函数调用我们先从简单的无参函数说起\ndef f1    a = 1    1end\n\ntarget那么首先，我们需要考虑到call的target如何来做处理。很自然的会想到target可以使用字符串。\n尽管使用字符串的话会导致指令长度膨胀，解析复杂等。但目前不考虑那些，解析的也是字符串指令，所以先这样\n去哪里找目标函数的信息这个自然来说是需要符号表中保存了\n符号表中的函数信息对于符号表来说，表中条目需要保存的信息有以下几条\n\n参数个数（目前全部为无类型，因此返回类型也无需考虑）\nlocal变量的信息\n函数体的指令地址\n\n这些目前来说都是编译期间可知的，所以也会以字符串的方式dump出来供vm去解析。至于函数体地址的问题牵扯到链接，而目前我们先不需要考虑链接的情况，只需要将生成的符号表中的地址加载进来就好了。\n生成符号表由于以上需求，我们在编译的时候需要生成符号表信息\n我们之前设计的全局符号表是这样的\nclass GlobalEnv &lt; Struct.new(:define_env,:const_table, :fun_env)end\n\n暂时不考虑常量表，我们需要的是剩下两个表的信息。\n生成vm指令这个阶段会将一个全局定义表（define_env，目前仅存其定义），将其定义更改为args以及offset\noffset都是未知的所以先设置为一个未定义值，因为我是通过返回数组并且把数组连接起来的形式，所以这个时候并不知道偏移量。这里用一个数组存放值的做法实在很差劲，但是实在没精力改进了…先能跑吧\ndef on_function(node)    ...      @global_env.define_env[node.name] = [node.args, &#x27;undefined&#x27;]    ...end\n\n重新设置偏移量\ninst.each_with_index do |ins, index|      if ins.is_a? DefineFun            @global_env.define_env[ins.name][1] = index      endend\n\n而fun_env表，则是保存了每个表的参数以及局部变量的信息。拥有fun_env表和define_env表（这两个表其实应该合并，下次一定…）的信息，我们就能够生成出上面所需的信息了\ndef gen_sym_table(global_env)      global_env.define_env.map do |name, (args, offset)|        &quot;#&#123;name&#125; #&#123;args.size&#125; #&#123;global_env.fun_env[name].size&#125; #&#123;offset&#125;&quot;      end.join(&quot;\\n&quot;)end\n\n生成示例 格式为 函数名，参数个数，local var个数，起始地址\nmulti 2 2 0main 0 1 6\n\n函数符号表中的条目\nstruct FunInfo&#123;        FunInfo(): FunInfo(0, 0, 0) &#123;&#125;        FunInfo(size_t _argc, size_t _locals, size_t _begin): argc(_argc), locals(_locals), begin(_begin) &#123;&#125;        FunInfo(constFunInfo&amp; other) =default;        FunInfo(FunInfo&amp;&amp; other) =default;        FunInfo&amp;operator=(constFunInfo&amp; other) =default;        FunInfo&amp;operator=(FunInfo&amp;&amp; other) =default;        size_t argc;        size_t locals;        size_t begin;&#125;;\n\n调用栈既然要调用函数，那么就需要调用栈这个东西了\n就目前的需求来说，调用栈中的栈帧需要有以下几种成员\n\n前一个栈帧（跟踪整个调用链）\n返回的pc地址（函数调用结束后需要返回到调用者）\n当前栈帧在栈中的起始地址（起始地址开始分配局部变量的空间）\n\n关于多个栈帧之间的存储方式，由于需要频繁添加删除尾部结点，因此选择了链表的方式。如果使用数组的话会牵扯到长度不够再重新分配数组空间的情况\n而实际栈内数据的布局是\n----------------    tmp var----------------        f1    local var----------------  ----------------    tmp var----------------        main    local var----------------\n\n注意这里和实际的栈不同，对于实际的栈来说类似于返回的pc地址，以及前一个栈帧的地址都是保存在栈内的\n返回值目前的设计是返回值最后放到栈顶，这样返回的时候直接从栈顶取值，之后再恢复栈就可以了\n调用带参数的函数def f1(a, b)\t    c = a + b\t    cend\n\n参数传递目前采用的是push的方式直接push参数，这个体现在函数调用的时候编译出的指令上\ndef on_fun_call(fun_call)    fun_call.args.map &#123; |arg| push(visit(arg)) &#125; + [Call.new(fun_call.name)]  end\n\n栈内数据排布\n----------------    tmp var----------------    local var           f1----------------       args----------------  ----------------     tmp var----------------    local var           main----------------       args----------------\n\n关于参数传递的话题其实还有很多，比如说顺序，变长参数，谁来释放，在之后的内容再一点点补足\n正文无关闲谈首先是最重要的一点：本周的内容就充满了各种应付式的内容，这在往期我都是会直接当场修改掉的，但实属有些无力…我在想这样的内容发出来会不会很不负责任，但是如果停更那我所做出的每周更新的承诺这么快就要被打破了，而且以后更容易不遵守了。\n本周的内容相对少的多，最加对于压力的感知更加明显了，尽管我反复将注意力转移到当前做的事情上（每天也会有对应冥想练习），但很多事情依然力不从心。时间安排的太满，我不会的太多，但每一项我都无法舍弃，最后分配到做这个的时间真的不多了，还要一边查看各种实现学习一边写，好多东西都是周日写的时候才学习修改的。学习实现基本上也是靠看书，看前人总结过的内容，对于大型项目实在没有精力去扒。这周还在看Ruby的YJIT的论文，本就不多的时间更没多少了，最后论文也没看多少（就看了几段介绍…），这篇论文读明白后也会再出一篇博客，尽管只看了一点但也让我增加了许多JIT方面的常识\nYJIT: a basic block versioning JIT compiler for CRuby\n如何能摆脱这种状态，如果读者有经验还请赐教\n如果我是学生的时候就能开始做这件事情就好了..可是没有那么多如果\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记5 函数其二&OOP其一","url":"/2022/01/23/rc-lang-dev-5/","content":"本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽\n那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。\n函数在VM的实现回顾之前没有提及函数相关的内容在vm是怎么实现的，所以这里首先提及这个话题\n函数的实现无外乎就是调用与返回的情况，这里再多加一个关于getlocal和setlocal以及计算的实现部分。\n先来简单回顾一下我们的栈上的信息\n--------------------       tmp var--------------------      local var           f1--------------------         args--------------------  ----------------       tmp var--------------------      local var           main--------------------         args--------------------\n\n除了这些再来看一下我们的栈帧\nclass StackFrame&#123;    std::shared_ptr&lt;StackFrame&gt; _prev;    char *_base;    size_t _ret_addr;&#125;;\n\n关于这些成员都是因为什么需要增加的，请回顾上期内容\nRc-lang开发周记4 函数其一 | Homura’s Blog\n具体实现call\n去符号表找符号\n这一步在vm中处理，找到符号的话将信息传递给栈来做第二步\n\n栈处理\n\n更新pc\n\n\n着重讲一下栈的处理\n\n设置当前栈帧基址\n由于目前参数是在call之前push的（这个push一定紧接着call），因此需要先将stack_top指针移动到第0个参数的位置，得出基址\n\n分配局部变量空间\n根据局部变量的数量再将栈基址向上移动\n\n创建新的栈帧\n\n\n实现代码，都在eval_stack.h中\nvoid begin_call(size_t argc, size_t locals, size_t ret_addr)&#123;    // 1.set stack base    auto *base = get_args_begin(argc);    // 2.alloc local var space    _stack_top = stack_move(base, static_cast&lt;int&gt;(locals));    // 3.create new stack frame    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr);&#125;char *get_args_begin(size_t argc)&#123;    return _stack_top - argc * WordLength;&#125;char *stack_move(char *stack_pos, int offset)&#123;    return stack_pos + offset * WordLength;&#125;\n\n关于WordLength\nconstexpr static size_t WordLength = sizeof(int);\n\nreturn\n获取返回值\n由于在函数体内计算的时候最后会将返回值push到栈顶，那么这里需要先pop将值取出来\n\n栈帧回退\n\n重置pc\n\n返回值放到栈顶\n\n\n这个返回值有点折腾…目前就先这个样子\n这里也是着重讲一下栈帧回退\nsize_t end_call()&#123;    auto ret_addr = _frame-&gt;ret_addr();    _stack_top = stack_move(_frame-&gt;base(), -1);    _frame = _frame-&gt;prev();    return ret_addr;&#125;\n\ngetlocal/setlocal就是简单的从当前栈基址添加偏移量\nint get_local(size_t offset)&#123;    return *get_base_offset(static_cast&lt;int&gt;(offset));&#125;void set_local(size_t offset, int value)&#123;    *get_base_offset(static_cast&lt;int&gt;(offset)) = value;&#125;int *get_base_offset(int offset)&#123;    return get_offset_pos(_frame-&gt;base(), offset);&#125;\n\n运算template&lt;typename Callable&gt;void exec(Callable &amp;&amp;f)&#123;    auto new_v = f(pop(), pop());    push(new_v);&#125;\n\n函数最基本的功能完成了，那我们该做创建对象相关的部分了。\n从常见的类开始我们从一个常见的类的例子开始引入我们的问题\nclass Foo\tattr_reader :a\tdef initialize(a)    @a = a\tend\tdef add(b)\t\t@a + b\tendend\n\n这个类很简单，一个成员变量、一个构造函数和一个实例方法。\n在我们想要使用这个类之前，我们需要在编译期间先解析这个类的信息\n解析成员创建一个类表。保存了所有定义的类的定义，以及可以作为一个类型查询表。\n这个解析的过程一度想要直接从Ruby抄一套类似的，但是工作量会非常大，因为需要到基类查找方法，牵扯到继承等各种问题\n目前类的ast结构\nclass ClassDefine\tattr_reader :name, :define, :parent, :fun_list, :var_listend\n\n这个定义中define是之前做的对于现在来说是不必要的内容，但是我目前时间有限不太敢动，怕前面的东西都乱套了，留个todo再说。parent是因为之前ast解释器的部分做了继承，但是目前vm这边还没有开始做，也就先不管它\n对于成员函数全部翻译一遍，重命名一下符号，而对于成员变量，直接将信息添加到对应的表中即可。所以目前ClassTable是这样的\nclass ClassTable  attr_accessor :instance_methods, :instance_vars  def initialize    @instance_methods = &#123;&#125;    @instance_vars = &#123;&#125;  end  def add_instance_method(name, define)    @instance_methods[name] = define  end  def add_instance_var(name, define)    @instance_vars[name] = define  endend\n\n除了解析信息，还需要在运行的时候创建这个类的对象。创建对象则分为两步\n\n分配内存\n初始化\n\n分配内存关于分配内存我们需要知道\n\n为了知道所分配空间的大小，首先需要获取类型信息。那么该如何获取类型信息以及类型信息怎么存放，存在哪里\n\n目前不考虑元编程的地方，所以这些信息都是编译期间可知的。假设要做更多元编程的内容，那么需要将一部分的内容放到运行时处理。按照我的理解来说，到时候将类型信息传递给vm，以及添加一些指令专门用于做元编程（这样指令种类会增加很多）。但这仅限于我粗浅的理解，更详细的还是要等到我做的时候再考虑。\n\n如何计算空间大小\n\n这个时候可能会出现一个最简单不过的想法，直接将所有成员大小都加起来不就好了。但是如果这样做，地址无法对齐，在vm那边取是很麻烦的事情。关于对齐暂时也不考虑，目前只考虑数据全为一个字长的整型数字，因此产生的对象也只会有带有这样成员的数字。还有会遇到空对象的情况，没有任何成员函数该怎么办（关于空对象，下文会单独提一下）\n除了基本的空间大小，还需要考虑留有GC信息的头部。这个就牵扯到下一个问题\n\n数据保存的格式\n\nGC需要保存哪些对象信息，这些信息又是如何保存的。关于这一点在后面的Ruby的Object实现中会略微提及\nGC相关的更多内容要等到之后实现的时候再更详细的提及了\n关于这里实际上还有更多复杂的话题，比如说递归数据类型，Union等，这些也都以后做的时候再来讨论\n初始化生成方法这里涉及到了一个问题，一个最简单的Foo对象并没有构造函数，那么我们需要先在ast的阶段生成对应的“无参”构造函数。\n调用调用这里本质上是一个方法查找机制，目前想先做最简单的，后面按需添加。直接去对应的this指针，找到对应类的信息，然后再从类表中进行查找，还没做实现，大概会到下周的内容中\n同时这个方法也是作为一个成员函数被调用（尽管是外部不可见的），这里就顺便讲调用成员函数的做法\n首先考虑调用成员函数的时候就需要引入this指针了，这个属于固定在栈内的内容，所以我把它放到了栈帧的结构中，而不是栈的实际数据中。\n一些语言this相关说到this指针，我想到了两个语言\n第一个是Python，因为Python是需要显式传递self的\n另一个是C#，C#的extension机制大概是这个样子，通过这种方式来给某个类添加类函数，我没有深究过后面的实现机制，但我想大概是解析到这里就给符号表中的这个类添加一个成员函数吧\npublic static class SomeClassExtension&#123;    public static void method(this SomeClass instance, args)&#125;\n\nRuby本身也有一些相似的对象，定义类函数的时候会需要self。不过这里的self的含义变成了这个类，而不是某个实例成员\nclass Foo\tdef self.f\tendend\n\n特殊情况无成员变量类class Helper  def add(a, b)    a + b  endend\n\n这种情况最大的问题在于对象空间大小的问题。目前我已知的做法有如下几种\nC++中对于类似的类在实例化的时候会有一个一字节的空间占用，为的是区分地址\n而Rust则有一个叫ZeroSizedTypes的东东，在谷歌搜索的时候搜索到了这样一段代码\nuse std::mem::size_of;fn  main() &#123;   println!(&quot;&#123;&#125;&quot;, size_of::&lt;()&gt;());   println!(&quot;&#123;&#125;&quot;, size_of::&lt;[(); 100]&gt;());   let boxed_unit = Box::new(());   println!(&quot;&#123;:p&#125;&quot;, boxed_unit); &#125;作者：zqliang链接：https://ld246.com/article/1539826769170来源：链滴协议：CC BY-SA 4.0 https://creativecommons.org/licenses/by-sa/4.0/\n\n运行结果\n000x1\n\n可以看到Rust不像C++一样会有一字节的空间占用\n带有GC的语言通常是会有一个header的开销（header用于存储类型以及GC信息），成员域部分会因实际实现不同而不同\n对于Ruby来说Object是这个样子的。因此对象即便为空也会有下面这个union的开销\nstruct RObject&#123;    struct RBasic basic;    union     &#123;        struct &#123;...&#125; heap; //省略        Value ary[ROBJECT_EMBED_LEN_MAX];    &#125;&#125;\n\nRuby的类与函数def f1\t9endclass S  def initialize    9  end  def f1    9  endendm = 1a = S.new()\n\n成员函数和“普通函数”定义对比== disasm: #&lt;ISeq:f1@&lt;compiled&gt;:1 (1,0)-(3,3)&gt; (catch: FALSE)0000 putobject                              9                         (   2)[LiCa]0002 leave                                                            (   3)[Re]\n\n== disasm: #&lt;ISeq:initialize@&lt;compiled&gt;:5 (5,2)-(7,5)&gt; (catch: FALSE)0000 putobject                              9                         (   6)[LiCa]0002 leave                                                            (   7)[Re]\n\n可以看到编译出的函数没什么不同。我想这是因为Ruby的一切皆对象的缘故。哪怕只是一个单独的函数，也是定义在Kernel中，本质上还是一个成员函数。\n而这个initialize也是和普通的成员函数是一致的，特别之处只是会在Object的new中被调用，甚至和普通成员函数一样可以被外部调用\n== disasm: #&lt;ISeq:f1@&lt;compiled&gt;:9 (9,2)-(11,5)&gt; (catch: FALSE)0000 putobject                              9                         (  10)[LiCa]0002 leave                                                            (  11)[Re]\n\n调用方式0011 putself                                                          (   9)[Li]0012 opt_send_without_block                 &lt;calldata!mid:f1, argc:0, FCALL|VCALL|ARGS_SIMPLE&gt;\n\n定义类0003 putspecialobject                       3                         (   3)[Li]0005 putnil0006 defineclass                            :S, &lt;class:S&gt;, 00010 pop\n\n这里可以看到，Ruby中类也是和method一样是通过特殊的vm指令进行动态定义的\n编译出的类定义的内容\n== disasm: #&lt;ISeq:&lt;class:S&gt;@&lt;compiled&gt;:4 (4,0)-(12,3)&gt; (catch: FALSE)0000 definemethod                           :initialize, initialize   (   5)[LiCl]0003 definemethod                           :f1, f1                   (   9)[Li]0006 putobject                              :f10008 leave\n\n调用构造函数的全部流程流程0016 opt_getinlinecache                     25, &lt;is:0&gt;                (   9)[Li]0019 putobject                              true0021 getconstant                            :S0023 opt_setinlinecache                     &lt;is:0&gt;0025 opt_send_without_block                 &lt;calldata!mid:new, argc:0, ARGS_SIMPLE&gt;0027 dup0028 setlocal_WC_0                          a@1\n\n除去前面的优化和后面的赋值操作，可以发现new对象的时候实际调用还是在new上而不是所谓的构造函数。可以从这里一定程度的看到Ruby创建对象的实现：Ruby在创建对象的时候是会先调用隐含的new函数（继承自Object），而这个new函数的默认实现会调用allocate，之后调用对应的initialize方法，最后再将new出来的对象返回。关于这个知识点在之前做TypeStruct的时候也提及过，有兴趣的可以去看一下\nRc-lang开发周记3 生成C++代码 | Homura’s Blog\n参考资料Ruby原理剖析\n垃圾回收的算法与实现\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记6 OOP其二","url":"/2022/01/30/rc-lang-dev-6/","content":"在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看\n在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。\n本周修改的主要方向：所有的函数操作都是基于一个类的（因此函数信息也都会放到类中）\n在功能上要修改的有以下三个方面（测试这里暂且不谈）\n\n符号表分析\n生成vm指令\nVM运行时解析执行方式\n\n与此同时还更改了”链接”的方式，所有函数全部在第一次使用时动态加载\n符号表定义以前的\nclass GlobalEnv &lt; Struct.new(:define_env, :const_table, :fun_env)end\n\n现在的\nclass GlobalEnv &lt; Struct.new(:const_table, :class_table)end\n\n可以看到将所有信息都集成到一个class_table符号表目前全部依靠一个class_table进行运作，目前的内容也很简单，只是保存instance methods和vars的信息\nclass ClassTable  attr_accessor :instance_methods, :instance_vars  def initialize    @instance_methods = &#123;&#125;    @instance_vars = &#123;&#125;  end  def add_instance_method(name, define)    @instance_methods[name] = define  end  def add_instance_var(name, define)    @instance_vars[name] = define  endend\n\n这种时候需要单独解释类型信息，这就是动态类型的头疼之处，想试试Scala，但是没时间学了\nclass InstanceMethodInfo &lt; Struct.new(:define, :env, :args)end\n\ndefine在符号分析的时候是ast的结点，而在后面翻译到vm指令的时候\n相比之前取消了offset，因为全要等到运行时加载，这里的offset没有意义了\n而env就是在global_env中被干掉的fun_env，参数信息没什么好说的，目前仅保存名字以及只用于统计数量\n实际分析class_table的初始化def initialize  @define_env = Env.new  init_class_table  @const_table = Set[]  @cur_class_name = Rc::Define::GlobalObjectenddef init_class_table  @class_table = Env.new  @class_table.define_symbol(Rc::Define::GlobalObject, ClassTable.new)endmodule Rc  module Define    GlobalObject = &#x27;Kernel&#x27;    UndefinedMethod = &#x27;Undefined&#x27;    ConstructorMethod = &#x27;initialize&#x27;  endend\n\n塞进去一个默认的全局类，在vm执行的时候也会提到这里\n类def on_class_define(node)  # save old  old_class_name = @cur_class_name  # make new and update  @cur_class_name = node.name  class_table = ClassTable.new  # define before visit fun, because of this is a context used for visit fun  @class_table.define_symbol(node.name, class_table)  # visit and add value to class_table  node.fun_list.each &#123;|f| visit(f)&#125;  node.var_list.each &#123;|v| class_table.add_instance_var(v.name, v.val)&#125;  # restore name  @cur_class_name = old_class_nameend\n\n访问到类的时候创建一个类表，之后遍历visit成员的var和method，将这些信息添加到类表中\nmethod是在visit的内部添加的，这里目前这样做是因为如果是Kernel的method，则不会经过on_class_define，这里应当在前面ast层面就做处理。先记下来以后来修改，目前比较想赶快赶工到能做GC的地方\n函数之前\ndef on_function(node)    @define_env.define_symbol(node.name, node)    @cur_fun_sym = Env.new    @cur_fun_var_id = 0    @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)    visit(node.stmts)    @fun_env[node.name] = @cur_fun_sym  end\n\n现在\ndef on_function(node)  @cur_fun_sym = Env.new  @cur_fun_var_id = 0  @cur_fun_sym.merge(node.args.map&#123; |arg| [arg, EnvItemInfo.new(cur_fun_var_id, &#x27;&#x27;)]&#125;.to_h)  visit(node.stmts)  @fun_env[node.name] = @cur_fun_sym  cur_class.add_instance_method(node.name, InstanceMethodInfo.new(node, @cur_fun_sym, node.args))end\n\n也没什么可说的，主要还是符号表存储方式的差别导致了这里信息存储的位置不同了\nvm代码生成translate之前的实现\ndef translate(ast, global_env)  @global_env = global_env  inst = visit(ast).flatten.compact  inst.each_with_index do |ins, index|    if ins.is_a? FunLabel      @global_env.define_env[ins.name].offset = index    end  end  @global_env.define_env.reject! do |name, table|    name.include? &#x27;@&#x27; or table.is_a? Rc::AST::Function  end  instend\n\n现在的实现\ndef translate(global_env)  global_env.class_table.update_values do |class_name, table|    @cur_class_name = class_name    table.instance_methods.update_values do |f_name, method_info|      @cur_method_info = method_info      method_info.define = visit(method_info.define).flatten.compact      method_info    end    table  end  global_envendclass Hash  def update_values(&amp;block)    each do |key, value|      self[key] = block.call(key, value)    end  endend\n\n尽管都是以一个函数为单位进行visit，但是对于现在的实现来说更大的遍历单位是一个class\n可以看到这里已经不再设置offset了，等到vm执行的时候再生成offset\non function之前\ndef on_function(node)  @cur_fun = node.name  @global_env.define_env[node.name] = Rc::FunTable.new(cur_fun_env, node.args, &#x27;undefined&#x27;)  [FunLabel.new(node.name), super(node), Return.new]end\n\n现在\ndef on_function(node)  @cur_fun = node.name  [FunLabel.new(node.name), super(node), Return.new]end\n\non_function只会在translate调用，只需要获取编译出的所有指令就可以了，关于表的更新都在translate中做\n此外，获取当前函数的env要修改一下\n之前\ndef cur_fun_env  @global_env.fun_env[@cur_fun]end\n\n现在\ndef cur_fun_env  @cur_method_info.envend\n\ncur_method_info可以在前面的translate中看到不断的更新值\ndump信息目前全部dump到了一个文件中\n源码class Foo  def initialize()  end  def add(x, y)    x + y  end  var a = 1enddef main    var f = Foo.new()end\n\n编译出的文件Kernelmain 0 1FunLabel mainAlloc FooCall Foo initializeSetLocal 0ReturnFoo # 类名a # 成员变量initialize 0 0 # 成员函数名 args数量 local_var数量FunLabel initialize # 函数定义Returnadd 2 2FunLabel addGetLocal 0GetLocal 1AddReturn\n\nFunLabel或许也可以删掉了，目前先这样留着吧，说不定debug会用得上\n写到一半才意识到完全可以使用一些现有的格式来做到这件事情，但这也只是临时用的东西，最后一定会转成真正的字节码而不是这种dump，先这样吧，大家千万不要跟我学坏\n实现这个也没什么好讲的，并非重点，相比之前不同也是以类为一个单位。目前是都编译到了一个文件，目前这样就够用\ndef gen_class_table(global_env)  global_env.class_table.map do |class_name, table|    &lt;&lt;SRC#&#123;class_name&#125;#&#123;table.instance_vars.keys.map(&amp;:to_s).join(&#x27; &#x27;)&#125;#&#123;table.instance_methods.map &#123; |name, info| gen_method(name, info) &#125;.join(&quot;\\n&quot;) &#125;SRC  end.join(&quot;\\n&quot;)enddef gen_method(name, method_info)  &lt;&lt;SRC#&#123;name&#125; #&#123;method_info.args.size&#125; #&#123;method_info.env.size&#125; #&#123;method_info.offset&#125;#&#123;method_info.define.map(&amp;:to_s).join(&quot;\\n&quot;)&#125;SRCend\n\nVM符号表这里要和ruby的符号表一致。用两种语言做这种时候就很麻烦，要再做一份\nstruct ClassInfo&#123;    std::vector&lt;std::string&gt; _vars;    SymbolTable&lt;FunInfo&gt; _methods;&#125;;struct FunInfo&#123;  \tsize_t argc;    size_t locals;    size_t begin;    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; inst_list;&#125;;\n\n不过要注意FunInfo中这里要保存起始地址，因为装载以后就会有地址了，默认为0（不可能存在的地址，视为未链接）\n加载文件先这样凑合用好了\nSymbolTable&lt;ClassInfo&gt; parse() &#123;    std::ifstream f(_path);    std::string str;    SymbolTable&lt;ClassInfo&gt; class_table;    while (std::getline(f, str)) &#123;        // 1. class name        auto class_name = str;        // 2. member vars        std::getline(f, str);        auto member_vars = split(str);        // 3. functions        std::getline(f, str);        SymbolTable&lt;FunInfo&gt; fun_table;        while(!str.empty())        &#123;            // 3.1 info            auto fun_info = split(str);            auto name = fun_info[0];            auto args = std::stoi(fun_info[1]);            auto local_vars = std::stoi(fun_info[2]);            // 3.2 add to class_table            fun_table.define(name, FunInfo(args, local_vars));            // 3.3 define            std::getline(f, str);            auto &amp;inst_list = fun_table[name].inst_list;            while(std::getline(f, str) &amp;&amp; !str.empty())            &#123;                auto list = split(str);                inst_list.push_back(get_inst(list));            &#125;            std::getline(f, str);        &#125;        ClassInfo class_info(member_vars, fun_table);        class_table.define(class_name, class_info);    &#125;    return class_table;&#125;\n\n函数调用由于增加了类相关的内容以及“动态链接”，这里的变化会大得多\n之前\nvoid begin_call(const std::string&amp; f)&#123;    if(!_sym_table.contains(f))    &#123;        // todo: find definition        throw std::runtime_error(&quot;Target Function&quot; + f + &quot;Not Found&quot;);    &#125;    auto &amp;fun = _sym_table[f];    // 1. stack process    _eval_stack.begin_call(fun.argc, fun.locals, _pc);    // 2. set pc    _pc = fun.begin;    LOG_DEBUG(&quot;Call &quot; + f + &quot; PC:&quot; + std::to_string(_pc))&#125;\n\n之后\nvoid begin_call(const std::string&amp; klass, const std::string&amp; f)&#123;    if(!_sym_table.contains(klass) || !_sym_table[klass]._methods.contains(f))    &#123;        throw std::runtime_error(&quot;Target Function&quot; + f + &quot;Not Found&quot;);    &#125;    auto &amp;fun = _sym_table[klass]._methods[f];    if(fun.begin == UndefinedAddr)    &#123;        fun.begin = load_method(fun);    &#125;    // 1. stack process    _eval_stack.begin_call(fun.argc, fun.locals, _pc);    // 2. set pc    _pc = fun.begin;    LOG_DEBUG(&quot;Call &quot; + f + &quot; PC:&quot; + std::to_string(_pc))&#125;\n\n变化主要有两个\n\n查找被调用函数的方式，需要先查找类表再从中查找到对应函数信息\n加载\n\n关于加载的实现\nsize_t load_method(const FunInfo&amp; f)&#123;    // 1. get start    auto start = std::max&lt;int&gt;(0, static_cast&lt;int&gt;(_inst_list.size() - 1));    // 2. load inst to inst_list    for(auto &amp;&amp;inst : f.inst_list)    &#123;        _inst_list.push_back(inst);    &#125;    return start;&#125;\n\n目前的需求来说这些就足够了，因为目前没有牵扯到一些相对寻址的指令。之后加到那些指令的时候再来更新\n初始化里面目前就这么一行代码，其实也没有太大变化，只是入口需要指定类了\nbegin_call(VMGlobalClass, VMEntryFun);\n\n最后正式开始构造对象以及调用构造函数要等到GC弄出来再写了（尽管编译器这边已经做了，但是VM不做出对应功能毫无意义）。下个周不出意外的话应该要开GC的坑了，尽管放假了，但依然有一堆事情要处理，就像写博客回顾、重构代码一样，我的生活也需要做一些打扫与清理，还有一些需要学习的新知识，所以大概率还是会维持平常的进度。不寻求太大的变化，能维持这样的进度我觉得也不错。\n我觉得这种对比修改前后代码的方式还挺不错的，以后如果再涉及到修改已有设计的地方都会再加一些。\n最近有些疏于测试了..尤其是VM代码一点都没有，下次一定\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记 序","url":"/2021/12/19/rc-lang-dev-preface/","content":"之前毕业设计想尝试设计一门语言并且实现编译器，奈何时间加个人状态不佳只做到了十分简陋的ast解释器，最近又想着转成编译器并且打算认认真真做下去。既然要做那索性把这个过程中重要的部分记录下来，记录的过程能够反思做的内容，回顾有没有隐藏bug，并且能够督促我继续做下去。不过受限于时间精力，恕我不能一口气把以前写的部分的讲解补上，下次一定（咕咕咕）\nRclang长远的想法是作为一门教学相联系的语言（并不是给刚学编程的人教学的意思），但是那还太遥远，甚至都不知道能不能坚持到那个时候，现阶段的目标是能够编译正确的代码到VM上正确执行，并且在这个过程中加强自己编程语言、编译器以及VM的基础知识。所以会有许多为了能跑或者了解相关知识而实现的决策，并且会反复修改很多设计\n本人水平不足，代码赶工情况很明显，因为时间真的不多，每天都要上班，同时每天以及周末还需要去学习其他的东西，也因此博客会粗糙一些（记录下来花费的时间比我预想的要多很多）。一定会有许多地方理解不够或者存在问题，如发现问题或者不合适的地方十分欢迎联系我（低血压人群可放心食用，高血压人群慎追）\n该系列如无特殊情况每周日更新，你可以在这里找到这个系列所有的文章\n标签: rc-lang | Homura’s Blog\n项目地址：https://github.com/FusionBolt/Rc-lang\n我想一定会有人好奇为什么选择Ruby，对我来说Ruby写的很爽很开心，这就够了。能够开心的持续做下去这才是最重要的（不过VM还是要C++受苦就是了…）\n","categories":["Compiler"],"tags":["Rc-lang"]},{"title":"所坚信的事情","url":"/2021/08/23/trust_self/","content":"唯有这一点，在我接下来的人生中一定会坚信不疑\n我一定能够做到无限接近理想的自己想了很久不知道该用什么词放在最后，聚聚，大佬，诸如此类的词想了很多，但好像并不符合我的心愿。虽然这种说法十分空洞，显得没有目标，但确确实实是我现在的想法，并不想成为别人眼中的谁，而是想要成为自己眼中的谁。理想自我是不可能抵达的，故只有无限接近\n现在理想的自己是什么样子的？我想起码是有坚固的自信，无论何时都能鼓起勇气，能够让自己的朋友会为认识我感到开心，能够专精某些领域。\n为什么要发一篇这样的博客呢？\n乔布斯说过这样一段话\n\nYou have to trust in something, your gut, destiny, life, karma, whatever.\nBecause believing that dots will connect down the road will give you the confidence to follow your heart even when it leads you off the well-worn path. \nAnd that will make all the difference.\n\n我选择它作为我一生的信念，同时这也是值得花费一生去做的事情。\n从今天、现在开始，又是新的起点\n希望这能够带给我信心与勇气\n带上一份歪歪扭扭的签名\n\n","categories":["Thinking"]},{"title":"2021年终总结","url":"/2021/12/26/summary-2021/","content":"下周末就是明年了，今年的事情不能拖到明年做，于是趁早把总结赶了出来。2021年对我来说算是各方面变化比较大的一年，还是有不少值得回顾的内容\n专业、工作与学习最大的变化莫过于大学毕业成为社畜了，找工作的过程算是十分坎坷，不过好在最终找到了一份合适的工作。工作中也学到了不少东西，自己也有了许多进步。看着自己的改变，看着自己的GitHub，今年总算可以说自己入门编程了。最大的遗憾是这一时间点来得太晚，每天下班回家留给写代码的时间只有一个多小时，如果还是学生的话时间能多太多。今年的习惯养成比较晚，所以只有最后的时间格子是填满的，明年的话会坚持每天下班后写代码，填满小格子\n\n今年的Github \n\n年初做了一个ast解释器作为毕业设计，随后随着找工作以及各种事情渐渐停止了维护。而年底又开始基于之前的内容添加编译的部分，希望明年能达到自己对于这个项目的初步目标，并且在这个过程中学习到更多编译器相关的知识。同时我开始每周写一篇博客记录本周开发的内容，序言链接在这里\nRc-lang开发周记 序 | Homura’s Blog\n今年开始读一些书，做到了平均一个月读一本专业之外的书，遗憾是读书笔记大都咕咕咕了，不过还有一些自己的思维片段，有时间会整理成文。明年的话会继续维持这个进度，会试着写一些读书笔记（在新建文件了）\n尝试入门GTD，但遗憾的是并没有用好，明年还要在这方面继续努力。\n尽管GTD运用不佳，但是年底的时候开始养成了一些习惯，这些习惯能够很大程度的帮助我抵抗自身的“懒惰”。其中一些习惯的养成受到《微习惯》和《原子习惯》这两本书的影响，后者比较推荐，能够涵盖了很多前者的内容。书中提到了一个让我印象深刻的概念：习惯叠加，意思是养成一个习惯之后可以在这个习惯之后接另一个习惯，而且很容易养成，像我现在每天晚上回家的时间都是数个习惯叠加在一起，养成的过程也没有太痛苦。\n生活由于成为了社畜，最显著的变化就是要自己租房住了。和宿舍生活相比，入睡时间再也不需要受到别人的影响了，同时住的地方肯定是比宿舍要大的，体验好的多\n另一个变化则是有了收入，因此能做的事情变得更多了\n比如说年底入手了种草许久的相机，开始尝试摄影，拍到了一些满意的照片，尽管其中也有许多瑕疵品。希望明年年底的时候能够自己设计出一个相册来展示自己笨拙的作品。\n除了能做的事情变多，同时还需要关心自己的开支情况。今年第一年工作，总之就是疯狂支出，月月实现负收入。买了各种以前就想买的东西，这个状态感觉还会维持一两年。明年开始大概会花很多钱在自己身上，通过氪金变强，存钱感觉比较困难，只能说尽力存一些吧\n年底渐渐开始接触各种各样的新事物，而这些事物又会激发我的各种想法（我逐渐理解一切了）。除了新事物，年底开始叠加了一些习惯使得我越来越忙碌。越来越多的事情我进入了我的生活中，可以说是有些充实，但是充实的不只有要做的事情，焦虑也是一样，对于事情做不完做不好的焦虑又逐步放大了起来，这也是我需要克服的点。\n除此之外，今年也有幸在推特上认识了一些新朋友，对于他们不嫌弃我这件事情深表感激\n自我好转一个很重点的问题就是自己的身心感受。比起去年或许有了一些好转，在一些事情上情绪波动也没有那么大了，我想这一定和感受到内心的不合理有关。至于治愈之法，上面提到的《神经症与人性的成长》书中也有提到\n\n所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。此地我们同样地要问，病人必须要知道什么才能铲除他的自负系统，以及除去由此所衍生的一切附带影响？我们可以简单地说，他必须晓得我在本书中所提到的每一件事：他对荣誉的探求，他的“要求”，他的冲突，他个人的特别解决法，以及所有这些因素在他的人际关系方面与创造力方面所具有的影响此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互的作用\n\n我的理解是当你彻底理解各个组建之间的联系的时就会慢慢破除。可惜的是这本书我只是年初读过一遍，许多地方理解并不到位。对我现在来说读过一遍的书还是挺难再花时间去读第二遍的，更偏向于去读新的书，但是鉴于这本书的重要性明年一定要再读一遍。\n还有一个想到的好转是破除了一些所谓的“完美主义”的误区。我自己并没有什么完美主义，只是之前会以这个作为幌子，找借口逃避问题罢了。现在一些东西哪怕做的很烂，也会开始行动了，就像这篇总结以及目前正在维护的开发周记一样\n也许是冥想所带来的习惯，我渐渐开始体会自己的不同感受，发现了自己内心空无一物。能够发现这一问题就是一个很大的进步，希望明年能够通过更多的行动给自己的内部逐渐填充些什么\n顽固除了好转，自己依然有一些顽固成分无法脱离。比如说仍有许多无法避免也无法与之相处的执念，这对我造成了很严重的负面影响，经常会因此沉溺于痛苦之中\n以及今年还是比较“自闭”，这个好像没什么好办法。所谓的“不适合和别人相处”只是一个逃避问题的幌子罢了，更深的原因是内心里还残留的一些性格扭曲，这个问题比起无力处理更准确地说是我不想处理，也先这样吧\n上面说的内容很大一部分要归咎与身体与睡眠。睡眠这个对我来说是一直无法解决的问题，长期的睡眠质量差导致我很多时候状态并不好，这和我的焦虑、以及焦虑的应对措施都有着联系。\n目前的应对措施是每日冥想加周日的跑步锻炼，这样的运动量是不太够的，但是时间确实不够用以及日常是步行上下班因此削减了运动时间，明年的话准备采取一些新的方案来对抗这些严重的问题。\n这一年这么写下来，今年好像做了一些事情却又好像并没有做多少事情。做了一些事情是因为确实有一点成果，比如说读了书，思维发生了转变，专业方面有了进步，养成了一些习惯等；而没有做多少事情是因为这些事情对于一年这个周期来讲并不多，而且大半年里自己的周末时间很明显并没有怎么用好，基本上都是在无意义的消耗时间。\n另外许多事情是年底才开始做，起步比较晚，但是对于明年来说可以开一个好头\n明年愿景不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的\n想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升\n想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西\n自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈\n想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等\n明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战\n最后自己的年终总结也没什么特别的感受与想法，只是简单地以流水帐的风格写了一下今年的事情，不过这就够了\n比较期待明年的到来（MBP，我的MBP）虽说回首过去与展望未来都会扰乱内心的平静，但我还是按耐不住自己的期待。\n明年一定是更加忙碌的一年，也是自己会有更多成长的一年\n","categories":["Thinking"]},{"title":"iPhone Ultra Max(iPad mini)体验","url":"/2022/01/30/iPadminiReview/","content":"曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。但iPad mini在我看来就是一个大号手机，某种意义上还是没错\niPad mini也已经入手有半个月了，半个月内重度使用，过了那阵新鲜劲以及各种问题踩坑也踩的差不多了，这个时候写下的体验我觉得应该是相对比较全面的了\n我的痛点我觉得iPad mini解决了我目前使用手机的各种痛点。我的iPhone8plus目前有存储不够，电池容量太小，只能单卡而我自己的卡流量又不够。如果只是这些问题可能有人说换新机不就完美解决了？但是换新机也不能解决屏幕太小的问题，想看点文章或者需要跨app处理一些内容iPhone这么小的一个屏幕实在不方便\n周末需要频繁挤地铁，地铁上的时间非常久，没有座位的时候拿iPad Pro非常不方便，即便有座位从包里拿出来也是很麻烦的事情，手机屏幕又太小，iPad mini的大小可以说是完美。\n所以我实质上是将iPad mini当作我的新手机，我的iPhone8plus还能再战好多年。以下体验更多是从手机的视角来看待\n\n实际体验首先：不玩手游，所以并不会提到相关的内容，想看手游相关的建议你去看各种评测视频\n重量感觉拿着没有任何压力，只比带着保护套的手机重了几十克。这个大小能够装到兜里，出门的时候看地图也非常方便。受益于大屏幕，看文章非常方便，不知道比iPhone高到哪里去了。\n电量够我出门用一天，再也不用挂着移动电源到处走了。这是我某一周的使用情况，如果开了省电模式一天非常稳妥，更何况我出门的时候电只有80左右\n\n出门在外，iPhone直接扔包里，有什么电话或者短信可以直接转接到iPad mini上\n网上所说的什么果冻屏至少我没什么感知，尽管有这也是显示技术不可避免的问题，120刷新率对于iPad mini来说不太可能用上（而且绝大部分情况不需要刷那么快）这一点争议非常大，建议你去实体店体验一下\n曾经我以为iPad正确的解释姿势就是Face ID，但直到出现了疫情…iPhone已经支持戴口罩解锁了，iPad pro什么时候才能用上？指纹解锁在现在这个到处需要戴口罩的情况下还是很棒的（但是我手指各种掉皮就还是白给\n谈一点没什么关联的，直到我用上了iPad mini才发现iPad Pro是多么大，以及各方面是多么好……不论是扬声器还是屏幕刷新率，这些我之前都毫无感觉，真的是没有对比就没有伤害\n不可避免的问题极其多余且愚蠢的设计这是我一定要着重说的一个问题。\n所谓的智能音量键调整位置，我的感受就是多此一举，用了一周并没有觉得多么方便，反而每次调整音量不仅要想按哪里，在屏幕没锁定旋转的情况下大概率会按反。我听的不同来源的音频声音响度是不同的，如果忘了提前调整音量则需要快速反应按下减音量，而这种设计又会导致你大概率要先思考或者先按错一次才能按到正确的地方，对于耳朵损伤还是非常大的\n因为有Touch ID，开屏的时候会提示按键位置在哪里，这个本身是好事，但是如果屏幕方向是竖直摆放这个提示则会导致无法看到电量，只是想打开屏幕看一下电量的时候非常难受\n上面这两条，我开始怀疑苹果的人机交互工程师有没有真的自己用一下，一家曾经以设计闻名的公司（个人看法）额外添加的这些设计却反而添加了负面体验，这么大的公司应该有合理的流程避免一些问题，尤其是对于apple来说。但是这种不良设计依然出现了，不知道该怎么评价了\n大屏幕大屏幕随之而来的就是你在看的东西更容易被其他人看到，对于非常重视隐私的人来说是灾难。另一个就是便携性不可避免的要下降一些，很多场景不能单手握持，但是只是读文章，单手下滑是没问题的，这是必须做出的取舍。还有就是我衣服兜比较浅，总觉得要掉（后来有一天不知道为什么过于大意，在同一个地方摔了两次….），装到裤子兜又麻烦，到了夏天衣物可能更难携带iPad mini\n字体略小，将字体调到了最大还算可以接受（除了一些app字体并没有适配好）\n到户外这个屏幕亮度不够用。这是我个人觉得最难受的\n双手握持打字略微有些头重脚轻的感觉（竖屏），而且有一种要滑出去的趋势。以及键盘还不是完全一样的，需要一点时间适应。但对我来说键盘录入大量内容可能还是偏少数，更多的是用它去阅读\nOS与应用iOS应用仍有一些不适配的情况，万幸的是可以手动放大到一个勉强能用的状态。但是更离谱的是支付宝只能登录一个设备，这产品经理是不是张小龙带出来的。当然这种环节不可避免要把微信拉出来挨打，目前iPad版和mac版是冲突的，干脆不用mac上的了，反正我的微信只用来联系家人。除此之外还有qq不能多个iPad上登陆，也有点小烦，等等还有很多类似的问题\n还有一些并非适配问题而是不能用的，比如说健康和Apple Watch的管理，这些还是要依赖于iPhone。以及就是iPad OS诟病已久的没有天气和计算器。以及某些离谱的应用，比如说企业微信第一次登陆还要手机确认……\n代替手机由于不能打电话的硬伤，你并不能真的完全离开你的手机。尽管现在的人电话场景是“十个里面九个骚扰电话，还有一个是快递”\n周末坐地铁的时候意识到不能刷nfc，突然想到还可以刷Apple Watch，但我戴在左手刷起来略显别扭。什么，你说扫码？\n\n购买相关如果去官网购买，很可能需要等待两个月才能到货，这个着实比较离谱了，因此我选择了京东购入，也就错失了刻上iPhone Ultra Max的机会\n本来想要购入一个紫色，但是去实体店查看跟示意图完全是两个样子…如果想要购入我建议你还是去实体店亲自看一下\n我会用它完全代替iPhone吗除了初拿到的欣喜，用了一段时间以后发现很多时候还是用手机方便，但是我依然没有后悔买了这个iPad mini，尽管在上面吐槽了它这么多问题，但我对它实在是非常满意（售价除外）。某种意义上可以说是因为没有竞争对手，我们只能忍受它的所有缺点。如果你有类似的需求，那非常推荐你。如果没有，那我还是推荐买大屏\n最后加一个小技巧：如果你的iPhone像我一样只是需要维持最低限度功能，你可以在快捷指令里面设置自动化，当断开电源的时候自动开启低电量模式，平常充电超过80%IPhone会自动关闭低电量模式\n本文绝大部分在地铁上一口气用iPad mini写完，再也不想用iPad mini打这么多字了\n","categories":["Life"],"tags":["iPadmini","Apple"]},{"title":"论柳比歇夫","url":"/2022/02/04/Lyubishchev/","content":"也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解\n大部分人看到标题，一定只有一个问题：柳比歇夫是谁？\n他是一个大半生都在支配时间的人。我想你一定会对支配时间这个词摸不着头脑，还会有人在想时间面前人人平等，时间怎么可能被他支配？\n那么我们先从他的成就谈起吧\n他的成就\n前苏联的昆虫学家、哲学家、数学家。毕业于圣彼得堡国立大学，一生发布了70余部学术著作，从分散分析、生物分类学到昆虫学等。业余时间研究地蚤的分类，还写过不少科学回忆录。 各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。\n\n除了这些，数学、历史与诗歌他都十分擅长。毫无疑问，他是一个全才，并且在一生中做出了超乎想象的成就。他是怎么达到这样的成就的呢？\n开始早在他28岁的时候他就已经找到了他一生的奋斗的目标：创造生物自然分类法。尽管遭受怀疑他依然开始着手他的任务，并且将一生投身到其中。\n\n他当然相信他能做到，但总是要从另外什么地方再去挖掘一些力量，再去挖掘一些时间。\n\n而为了完成这一切，他选择了“支配时间”\n时间完成事情需要时间，这是一个不可避免的内容。而对于时间的使用，很自然会想到利用好各种时间，他自然是做到了，将各种碎片时间利用到了极致。但只是利用碎片时间自然是不足以使他获得如此成就\n\n应当不断挖掘一切时间潜力。明摆着，人不能者是每天工作十四五个小时。应当正确利用工作时间。从时间中去找时间。\n\n接着他就开始了记录时间的生涯。他将自己做得几乎每件事情所需要的时间记录下来，进而达到能够十分清楚地了解自己做每件事情的时间，在了解自己的时间后进行十分周密的安排（注意，这是在他能够保证利用各种碎片时间的前提下）。\n这些内容我觉得比起我来讲不如来看摘录的原文\n\n计划就是挑选时间、规定节律，使一切都各得其所。头脑清醒的时候应当钻研数学，累了便看书。\n\n\n这个方法之所以能够存在，是依靠经常的计算和检查。没有计算的计划是盲目的计划，就象某些研究所那样，光会做计划，却不去操心这计划能不能完成。\n\n他对于时间的理解是非常深刻的。而最重要的则是他使用了一生来实践这样的方法。\n了解时间记录法后我偶然想到在一本书中看到的话：不是要达到什么目标，而是要形成一个自己想要的系统，目标会自然而然达到。再看柳比歇夫的经历，亦是如此\n而书中也有很多时间相关值得回味的内容，在这里摘录两段\n\n为了节约时间，实干家下了马车坐上火车，下了火车坐上飞机。发明了电报和电话来代替书信，电视代替了剧院，拉链代替了扣子，圆珠笔代替了鹅翎。电梯、计算机、百货公司、电传打字机、电动制刀——这一切发明，都是为了替人节省时间。然而，不知道为什么，人越来越感到时间不够用\n\n\n时间的分配几乎同两千年以前赛纳卡时代一摸一样：“我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事\n\n代价与幸福可能很多人会觉得，这样机械式的生活真的快乐幸福吗？这里可以肯定的回答，至少对他来说是这样的。这里我有一个比较奇特的视角来讲，他清晰的明白自己的能力边界，因此他不需要担心时间不足或者担心自己做不到，他不需要焦虑在这种事情上，减少了焦虑并且能够更好的发挥自己的才能。\n而在作者看来他亦是幸福的。在书的一开始，作者就提到\n\n我从中得到的一切，对于我来说，是一个新发现，使我参透了一个人一生的秘密。\n这个秘密是——怎么生活得更好。\n\n但是这一切是有一个前提：他不断的给自己设定更高的要求，并且他有着源源不断的好奇心和求知欲，而这样做正是满足了他的欲望，因此这一切对他来说是十分幸福的。\n在写下前面的部分，回顾文中的内容，在最后也看到了作者持有着同样的态度\n\n只有一个人向自己提出崇高目标时，这个时间统计法才能成立\n\n能力边界与高要求他持续对自己高要求，并且在明确自己能力边界的情况下不断在边界中前进\n\n 他不让自己负担过重，力不胜任；他总是循着他能力的边缘前进，他对自己能力的掂量愈来愈精确。这是一条永不停顿的自我认识的道路”“如果每个人都能知道自己能干些什么，那生活会变得多么美好！因为每个人的能力都比他自己感觉到的大得多。他会变得比自己想象的更为勇敢；他会变得更坚韧、更有力，更能适应环境”\n\n还有一段我觉得是非常棒的描述\n\n对于柳比歇夫，任何时候都不能说他已“成为”怎样一个人。他永远正在“逐步成为”怎样一个人。他一直在探索，一直在变化，他总是重新考虑，不断提高对自己和对自己理想的要求\n\n对知识的热爱以及偏离目标他学习知识，数学、历史、文学、音乐等等各种方面。\n他不善于克制自己，经常迷上同他完全无关的东西中。他无法抗拒周围环境的诱惑，他无法抗拒那些知识。但是关于这些，作者给出了很明确的观点\n\n“天哪，对于嗜癖和精力分散我们又能知道些什么呢！谁能说清楚“人应当是怎么样的”。我们从何知道人应当是怎么样的呢”\n\n不过有一点要注意，不论怎么样他最后都能够确保任务的完成，这也和他对自己能力有着清晰的认识有关。\n而“偏离目标”，也就是学习各种看似不相关的知识实际上也会产生一些意想不到的效果。达芬奇就是一个非常擅长将不同领域的知识融合在一起的人，他的许多创作都是如此。\n关于这本书作者在本书的开头就在提到如何吸引读者这一件事情，而毋庸置疑的作者达到了他的目的，不像我后来看的达芬奇传（作者沃尔特 艾萨克森）真的是无聊至极。\n正如作者所期望的那样，每读一点我就更加迫不及待的想要看到后面的内容，作者巧妙的描述出了一个饱满的柳比歇夫的形象。读完这本书后让我产生了更强烈的阅读其他传记的欲望，之后也就顺势读完了乔布斯传。\n读这本书的过程中自己被柳比歇夫所吸引，也许这就是我所理想的样子。他对自我的要求、他的自由、他的幸福、他对自己的严格要求、他不断增长的边界，无一例外充满了魅力。在写到这一段的时候越写下去越发不可收拾，我着了迷、入了魔，那段时间读到相关的部分都会感到非常兴奋。\n我希望这本书给别人的印象不仅仅是只有柳比歇夫的时间统计法，尽管是在读者的角度，我依然想要让其他阅读这本书的人更多的去体会、感受柳比歇夫的各种特质，而并非只是局限于时间统计法，时间统计法本质上是他的特质的衍生产物，是他为了完成自己的目的所选择的一条道路。\n而完美的是作者也将这些特质巧妙的讲了出来，也没有花费太大篇幅去描述时间统计法。我最初也并不知道柳比歇夫是怎么样的人，但至少读完本书之后对他的形象有了一个饱满的认识，尽管这些只是局限于作者所描述的部分。\n最后整理这篇文章花费的时间比预想的还要多很多，整理的过程中几度想要放弃了，但是整理的时候多少又找回了一些热情，又回想起了很多，最后还是坚持了下来。请原谅我个人能力有限，文中内容简陋，而且内容有所遗忘，无法在这么短的篇幅中将他的魅力讲述到极致，只能提及部分性格特点，而书中所讲述的他更为有趣。如果你是对自己有要求的人，那么我非常推荐你去读这本书，去感受他的人生，感受他的精神，也许你会和我一样着迷。\n虽然我做不到柳比歇夫的时间记录法，但是我可以学习他的高要求、不断在自己的边界进步、他对知识的热情，这些也足够我获得很大的成长了。我应该认真思考如何像他一样对自己不断的提出要求并且达到这些要求，而不只是空谈，写完这篇文章的今天我该拿出时间好好反思。\n最开始写这些文字的内容是几个月前我刚读完这本书的时候，现在将其整理成文。开头一段现在回头看多少有点怪异，但我最后还是决定保留。不过不论如何，我现在依然很为能看到这本书并且了解这个人而感到幸运。\n","categories":["Reading"],"tags":["柳比歇夫"]},{"title":"AI Compiler是什么？","url":"/2022/02/05/what-is-ai-compiler/","content":"为了让更多人对AI compiler有个了解，在此对这两者的区别和联系做一个科普，也因此本文以科普区别为主，不会深入。这篇文章一直想写，也算是对我去年工作中所学到的一部分东西的总结，但是硬是咕咕咕到了现在，最后选择了假期结束前把这一篇赶出来以提前适应上班状态，避免假期太强的假期综合症。个人水平有限，如有偏颇之处欢迎联系我指正\n本文将从两方面讲述内容，首先是AI compiler是什么，都在做什么，其次是和传统compiler的异同。为了让读者能更好的理解内容，所需的背景知识我会尽可能的在文中做注解\nAI compiler是做什么的将各种框架训练产生的模型文件进行编译，生成目标平台的代码。从这个角度来看是和传统compiler是非常类似的，但是模型文件更像一个DSL（ldomain-specific language）\n编译流程先从解析输入开始，按照编译的流程来讲解各个阶段的异同。而这些异同大都是由于ai compiler输入的特殊性质导致的\n编译对象首先要编译的对象就有很大的不同。传统compiler则是编译的语言源代码，而AI compiler编译的是各种各样的模型，编译对象的不同导致了后面的各种处理大相径庭。\n先来科普一下模型的组成：模型中包含了一个计算图以及各种数据，而计算图又是由许多算子构成的。每一个算子代表了一种计算\n我个人觉得模型也可以算是一种DSL，从模型的输出向上看相当于一个expr，而每个op结点相当于一些特定函数。\n解析输入方式不同而传统语言源代码需要经过各种的parse，手写parser更是非常费力不讨好的一件事情，尽管现在的parser generator技术比较成熟，parser写起来依然是非常麻烦的。\n对于AI compiler来说需要支持各种各样的模型的解析。这里不需要写什么复杂的parser了，像onnx会提供一个文件，可以通过protobuf解析这个文件生成对应的解析模型的源代码，直接调用生成的解析模型的源码中的函数即可。由于这个原因，你也不用担心不使用特定的语言进行编写还要自己做解析的工作，极端的讲，哪怕有一天要换语言做你也不需要担心解析的过程。在这个过程中更多的是将模型的数据取出来，放入设计好的IR中。\n但是对于ai compiler来说你需要支持各种模型，如果只是支持某一种格式的模型是远远不会有用户的，这里不像传统compiler只需要支持自己语言的parser就可以了。目前主流的框架大致有三类，pytorch、onnx以及tensorflow，这三类有着各自的模型格式，而三者都有一定的用户群体，框架的支持程度对于用户来讲是一个非常关键的点。\n高层IR设计上面提到了ai compiler需要支持多种格式的模型，而不同格式模型的算子定义又是有许多差异。想要做到兼容各种格式的模型又是一个非常麻烦的问题，假设你设计了一套对应了算子的高层IR，可能需要对输入的模型中的算子前后添加一些操作，使其达到等效于你所选择的这个算子的实现。用常规编程语言的例子就是C语言中要做到类似于成员函数调用通常会在这个函数的第一个成员传入结构体的指针。但是实际上麻烦的事情更多，很多算子甚至不能在不同框架转换，有的能转换也非常复杂，而关于这个问题本文就不深入探索了。\n而传统编程语言的高层IR（通常为ast）相对简化很多，高层不需要考虑兼容与转换的问题。\n优化将输入读取进来后要做的事情当然是优化，编译器不仅要能够正确的生成对应平台的可执行代码，还要尽可能保证性能。\n这个方面可讲的实在太多，不同层面的IR的优化方式又是各不相，而我所知的也比较有限（很多地方没有参与，但是有一些了解，我想做一个简单的科普还是不成问题），就挑ai编译器讲一下通常都有哪些方面的优化（简单提及概念），都是做什么用的，为什么要有这样的优化。\n图优化\n图节点合并：这个想法非常自然，只要减少了节点数量那么计算所需要的时间自然也会减少许多\n更换顺序：有的时候更换节点顺序后一些节点就可以自然的合并\n还有很多优化是基于算子自身定义的，这些在此就不提及了，本质上都是为了减少计算\n\nfuse将多个节点融合到一个子图中，直接影响到后面的tiling、调度、buffer分配，这是比较常见的一个步骤，因为本质上是为优化服务因此放到了这里。\ntiling ：数据切分与重排tiling这边我没有实际参与过，所以我只能大概讲一下在编译到ai加速器上的情况下我的理解。\n对于ai加速器来说，通常只会适应某一些满足条件的数据大小的计算，而实际给加速器的数据大小则是各种各样的，因此需要将数据切分到适应加速器的结构。而大部分情况图上的每个节点所需要数据的大小则是已知的，因此可以提前切分好数据进行计算。（也有节点的数据大小不固定的情况，这里暂且不谈）\n对于ai来说计算很多数据都是多维数组，而实际计算很多又是多层循环，常规的数据计算方式相对低效，而许多数据又是编译期间固定的，所以需要重新以一个高效的方式重排数据。\ntiling这个过程可以说是对性能影响最大的部分之一，相信大部分人都看过那个经典的按行遍历与按列遍历二维数组的例子，不仅如此，还会牵扯到计算单元的利用率以及数据传输的带宽利用。\n调度将计算图序列化，计算出一个合适的算子执行顺序\n如果要涉及多设备还要尽可能做到多设备之间减少依赖，同时要考虑到数据在不同设备之间传输的带宽\nbuffer分配数据是通常以一个tensor为单位（最简单的说法tensor就是一个多维数组，但是这样并不确切，但是理解这里足以），而一个tensor通常存在一个buffer之中，运算的时候从buffer中取数据\n通过合理的分配方式减少运算中内存的使用，其中牵扯到计算buffer的生命周期，什么时候可以及时释放掉这块buffer，什么时候可以重用已有的buffer等等\n生成代码与运行在这方面其实都是差不多的，ai compiler还经常会生成一些ai加速器用的代码。对于ai加速器来说更多是几条配置指令加一条计算指令来执行特定的算子（上面提到的数据切分重排也和这个问题有非常大的联系）\n关于生成产物的运行，和传统compiler相同也是有两类选择\n\n生成一个直接可以执行的程序\n生成类似于字节码的东西供另一个运行时的程序读取并且执行\n\n编译时间敏感度传统compiler还是对编译时间比较敏感的，因此导致了一些算法必须选择一个较好解，而最优解是需要很长时间的。\n对于ai compiler编译时间的敏感程度相对较小，而且如果开启量化需要跑量化矫正集那根本无法控制时间（也因此需要高性能的evaluator）。而且对目标执行速度要求高，因此有更多的时间去搜索更好的解，相对于炼丹来说这点时间洒洒水啦。\nAI compiler特有的部分量化这里的量化并不是指量化交易，而是指一种将浮点数转换为定点数的计算。在ai中通常使用float进行计算，为了缩小数据大小通常会将float量化到int8，而最后还会转换回float输出（这个则是反量化过程）。如果只是做常规的数据类型转换那一定会有很大的精度损失，因此需要各种量化的算法来尽可能减少这一影响。\n而量化通常需要统计数值范围，并且使用这个范围来算出一个适当的量化参数，而这个范围我们需要通过在编译期间实际执行整个模型来得到，这个时候我们就需要一个evaluator来执行。\nevaluator与kernel我觉得这里可以视为以模型和参数作为输入的解释器，对于模型来说最小单位是一个算子，那么我们就需要添加每一个算子所对应的实现，又称为kernel。\n而kernels的实现不仅要正确，还要尽可能的高效。原因有如下两条\n\n这直接影响到开启量化后的编译时间。\n对于ai加速器来说只能够加速特定的算子，而其他算子依然会使用cpu来执行。cpu上的算子执行如果要利用这些kernels的话那它们的性能也是非常重要。\n\n关于第二条，这只是做法之一，实际上加速器加速不到的算子也有很多的实现方式，在这里只是提及有这种实现方式不进行评价好与坏，所以仅供参考。\n利用传统编译器的技术来做ai compiler常量折叠、寄存器分配等技术都是可以从传统编译器来借鉴的。\n一个非常典型的利用传统编译器技术的莫过于TVM（最有名的开源ai compiler）。其中的高层IR（Relay）直接利用了lambda calculus\n\n既然我们知道如何做control flow（lambda calculus），为啥不直接用lambda calculus当IR呢？这就是relay了。(当然，传统DL compiler能做的还是一样，但是没啥好讲的（maybe sized tensor？but sized tensor is boring））。选取了lambda calculus为ir以后，由于这上面的研究很多，我们实现需求复杂的任务比其他框架简单得多 - 因为我们只需要照抄经典compiler算法。\n\n原文链接：https://www.zhihu.com/question/331611341/answer/875630325\n不过只是这些当然还不够，需要探索更多专为ai相关的技术才能做好ai compiler。\n最后当了解了一些知识以后，就很难从一个完全不知道的视角去讲述了，所以写完本文我也难以把握哪里是相关知识较少的人看不明白的地方。读者如果能够通过本文了解ai compiler大致是什么样子的话那是再好不过了，如果读完本文对ai compiler产生了兴趣也欢迎进入这个行业和我一起摸爬滚打\n","categories":["Compiler"],"tags":["AI"]},{"title":"Rc-lang开发周记7 GC也没有那么可怕 其一","url":"/2022/02/06/rc-lang-dev-7/","content":"本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。\n由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说，可以等到下周养肥再一起看\n本周从质和量来说都无法令人满意，状态比较差要写不下去了，但是起码比咕了强\nGC的对象表示对象被保存在内存中，而对象则分为头和域两部分。\n其中头被用于标识对象信息，比如说类型，以及gc的tag信息，利用tag信息来判断当前对象的状态\n域则是能够被编程语言访问到的部分。域很显然可能是一个值，也可能是一个指向对象的指针\nRuby让我们看一下Ruby的RObject的定义\nstruct RObject &#123;    /** Basic part, including flags and class. */    struct RBasic basic;    /** Object&#x27;s specific fields. */    union &#123;        struct &#123;            uint32_t numiv;            VALUE *ivptr;            struct st_table *iv_index_tbl;        &#125; heap;        VALUE ary[ROBJECT_EMBED_LEN_MAX];    &#125; as;&#125;;\n\n不需要关心过多的细节，可以看到很明显是分为了头和域两部分。\n让我们再来看一下头部 RBasic\nstructRUBY_ALIGNAS(SIZEOF_VALUE)RBasic &#123;    VALUE flags;    const VALUE klass;&#125;\n\n很显然，一个标记和一个类信息。Ruby采用的也是标记算法，这里有flags保存标记信息\nPython再来看一下Python的实现。这次我们从头部开始看起\ntypedef struct _object &#123;    _PyObject_HEAD_EXTRA    Py_ssize_t ob_refcnt;    PyTypeObject *ob_type;&#125; PyObject;\n\nObject本质上是对象的头部信息。python是通过引用计数实现的GC，可以看到有一个ob_refcnt，同时还有一个保存Type的对象，\n第一行的_PyObject_HEAD_EXTRA\n#ifdef Py_TRACE_REFS/* Define pointers to support a doubly-linked list of all live heap objects. */#define _PyObject_HEAD_EXTRA            \\    struct _object *_ob_next;           \\    struct _object *_ob_prev;#define _PyObject_EXTRA_INIT 0, 0,#else#  define _PyObject_HEAD_EXTRA#  define _PyObject_EXTRA_INIT#endif\n\n可以看到这是为了方便测试以及跟踪执行情况而添加的内容\n看一下Python的对象\ntypedef struct &#123;    PyObject ob_base;    Py_ssize_t ob_size; /* Number of items in variable part */&#125; PyVarObject;\n\n其中的ob_size是用于可变长对象使用的，例如List\n对比Python是每个对象的头部有一个PyObject的指针，不同的类型是基于这个扩展的\n而Ruby是每个对象是一个RObject，对象内部也有一个相同的头部RBasic，而不同的类型都是RObject本身\n虽然实现的方式略有不同，但是本质上还是一样的。而对于GC的实现也是一样，所以我们之后只是大概提一下实现方式的本质\n实现算法在这里只简单谈及标记清除、引用计数以及复制，这三者是最基本的算法，改进版本暂且也不会提及，本周的内容的目的只是希望读者能够对GC有一些了解。其他算法都是从它们衍生出来的本质并没有发生变化（其实主要是因为我只看了这三个）\n标记清除标记清除，我个人觉得用追溯更形象一些，因为需要从一些节点开始遍历访问所有的对象，对这些对象设置上tag，之后再对没有打上tag的对象进行回收\n引用计数在对象的头部设置一个字段用于标记有几个对象正在应用当前对象，在被创建的时候会设置标记为1，而被一个新的对象引用的时候计数就加1\n当然这个做法存在一个很明显的问题，就是如果两个对象互相保存了对方的引用，那么就会造成循环引用的情况。C++的智能指针也是使用循环计数，因此依然会遇到这样的问题，而在C++中的解决方案是需要使用一个不获取对象所有权的weak_ptr来解决这个问题。\n复制对于复制算法来讲，实际上将堆等分为两部分。一部分是正在使用的空间，另一部分是作为复制的临时空间。\n复制算法将所有的活动对象从当前正在使用的空间复制到临时空间，之后直接将两块空间交换，也就是说没被复制的对象直接被销毁了\n参考书籍垃圾回收的算法与实现\nPython源码剖析\n","categories":["GC"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记8 OOP之成员函数调用","url":"/2022/02/12/rc-lang-dev-8/","content":"本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。\n成员函数调用的过程我们先来想一下这个过程大致是怎样的\n\n被调用对象非静态方法的时候首先成员函数要依赖于一个具体的对象，那么我们则需要在调用之前先将被调用对象的指针push到栈上\n方法查找根据对象的信息找到对应的类表，然后在类表中找到对应方法的地址（牵扯到继承的话也是在这里找父类的方法）\n\n编译器的实现AST成员函数调用的AST是这样的\nclass ClassMemberAccess    attr_reader :instance_name, :member_name, :argsend\n\n其实这里当初设计想的是能够同时支持函数和成员变量的调用（也会加上无括号调用），但是我们现在认为它就是一个成员函数调用\nTranslatedef on_class_member_access(access)  argc = access.args.size  push_this = if access.instance_name == &quot;self&quot;    PushThis.new  else    push Ref.new cur_fun_env[access.instance_name].id  end  call = Call.new(access.member_name, argc)  [push_this] + access.args.map&#123; |arg| push(visit(arg))&#125; + [call]enddef on_fun_call(fun_call)  [PushThis.new] + fun_call.args.map &#123; |arg| push(visit(arg)) &#125; + [Call.new(fun_call.name, fun_call.args.size)]end\n\n再对比看一下旧的fun_call\ndef on_fun_call(fun_call)  fun_call.args.map &#123; |arg| push(visit(arg)) &#125; + [Call.new(@cur_class_name, fun_call.name)]end\n\n没什么可讲的，非常直观\nVM的实现call的实现思路之前的call的参数是一个类和一个函数名，完全可以说是用于静态函数调用的做法。（关于静态函数调用的实现我们之后再考虑）\n上面提到非静态方法需要依赖于具体对象，因此我们需要先将被调用对象的指针push到栈上。而类信息可以从对象上获取，因此不需要call参数中的类型名。而获取指针则需要知道有多少个参数，因此我们需要传递进去参数的数量。这个做法也可以处理变长参数的情况\n传递参数数量在ruby中也是类似的\n0004 opt_mult &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;[CcCr]\n\n写到这里的时候我突然想到了一个问题，为什么要先push被调用对象指针？顾思考了一下，如果在push完所有参数之后再push被调用对象指针则前面的参数无法直接作用于被调用函数中。\n代码实现FunInfo &amp;method_search(const RcObject * const obj, const std::string &amp;f)&#123;    auto klass = obj-&gt;klass();    if(!global_class_table.contains(klass) || !global_class_table[klass]._methods.contains(f))    &#123;        throw std::runtime_error(&quot;Target Function:&quot; + f + &quot; Not Found&quot;);    &#125;    return global_class_table[klass]._methods[f];&#125;void begin_call(const std::string&amp; f, size_t argc)&#123;    auto *obj = _eval_stack.get_object(argc);    auto &amp;fun = method_search(obj, f);    if(fun.begin == UndefinedAddr)    &#123;        fun.begin = load_method(obj-&gt;klass(), f, fun);    &#125;    // 1. stack process    _eval_stack.begin_call(fun.argc, fun.locals, _pc + 1, obj);    // 2. set pc    set_pc(fun.begin);    EXEC_LOG(&quot;Call &quot; + f + &quot; new PC:&quot; + std::to_string(_pc) + &quot; ret pc:&quot;        + std::to_string(_eval_stack.current_frame()-&gt;ret_addr()));&#125;\n\n也很直观，先获取被调用对象，之后找到函数，开始处理调用栈，除了获取调用对象的部分和之前差不多。而栈帧会多保存一个当前的obj。在这里我新记录了调用栈的深度，便于调试\nvoid begin_call(size_t argc, size_t locals, size_t ret_addr, RcObject *this_ptr)&#123;    // 1.set stack base    auto *base = get_args_begin(argc);    // 2.alloc local var space    _stack_top = stack_move(base, static_cast&lt;int&gt;(locals));    // 3.create new stack frame    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr, this_ptr);    // 4.increase depth    ++_depth;&#125;\n\n关于set_pc\nvoid set_pc(size_t new_pc)&#123;    _pc = new_pc;    _pc_need_incr = false;&#125;\n\n新增了一个控制pc是否递增的成员，pc跳转的时候不应当继续递增pc，所以在各种跳转指令中都会直接使用set_pc\n而递增的逻辑也相应的发生了变化\nvoid pc_increase()&#123;    if(_pc_need_incr)    &#123;        ++_pc;    &#125;    else    &#123;        _pc_need_incr = true;    &#125;&#125;\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记9 OOP之继承","url":"/2022/02/20/rc-lang-dev-9/","content":"本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分\n类的符号信息对于之前的类表实现是只有方法和成员变量的，而现在在获取符号表信息遍历到class的时候需要再添加一个parent的信息。\nclass ClassTable\tattr_accessor :instance_methods, :instance_vars, :parentend\n\nVM方法查找FunInfo &amp;method_search(const RcObject *obj, const string &amp;f, bool super) &#123;    auto klass = super ? get_parent_class(obj) : obj-&gt;klass();    return method_search(klass, f);&#125;FunInfo &amp;method_search(const string &amp;klass, const string &amp;f) &#123;    auto &amp;class_table = global_class_table[klass];    if (class_table._methods.contains(f)) &#123;        return class_table._methods[f];    &#125;    if(class_table._parent.empty()) &#123;        throw MethodNotFoundException(f);    &#125;    else &#123;        return method_search(class_table._parent, f);    &#125;&#125;\n\n再来看一下之前的实现做一个对比\nFunInfo &amp;method_search(const RcObject * const obj, const std::string &amp;f)&#123;    auto klass = obj-&gt;klass();    if(!global_class_table.contains(klass) || !global_class_table[klass]._methods.contains(f))    &#123;        throw std::runtime_error(&quot;Target Function:&quot; + f + &quot; Not Found&quot;);    &#125;    return global_class_table[klass]._methods[f];&#125;\n\n很显然多了去父类查找的部分。\n调用父类同名函数既然要继承了，那么也一定要涉及到调用父类的同名函数的问题。在上面的method_search的实现中，可以看到从obj查找method的时候有一个叫super的参数。因此如果要调用super的话一定是从父类开始查找，而不是从当前类\n而这个在源代码中是通过一个super方法来实现的，大概是这个样子\ndef value  super()end\n\nAST定义class InvokeSuper  attr_reader :args  def initialize(args)    @args = args  end  def to_s    &quot;InvokeSuper#&#123;args_to_s(@args)&#125;&quot;  end\n\nVM指令定义class InvokeSuper &lt; Struct.new(:argc)  attr_type :argc =&gt; :int  def to_s    &quot;InvokeSuper #&#123;argc&#125;&quot;  endend\n\n注意AST中保存的是实参，而指令中已经提前push好了参数，这里只需要传递一个argc用于寻找参数之前push的this指针就可以了\nast翻译到vm指令的实现def on_invoke_super(node)  [PushThis.new] + push_args(node.args.map) + [InvokeSuper.new(node.args.size)]end\n\nvm指令的执行void visit(const InvokeSuper &amp;inst)&#123;    _vm.begin_call(_eval_stack.current_method(), inst.argc, true);&#125;void VM::begin_call(const string &amp;f, size_t argc, bool super) &#123;    auto *obj = _eval_stack.get_object(argc);    auto &amp;fun = method_search(obj, f, super);\t\t...&#125;\n\n这个也非常简单，比起之前的实现，现在begin_call里添加了一个super传递给method_search\n成员变量储存既然要继承，那么就要保存父类成员的变量。目前的做法是像ruby一样直接覆盖父类同名变量，因此在创建对象的时候获取整个类继承链中所有变量的集合，然后获取其长度，在创建变量的时候使用这个长度来分配对应的空间。\n这个长度应该是编译期间就算出来的，这里这样写有一种应付的感觉…虽然说这样能够处理动态修改父类定义的方法，但是现在并没有做的那么动态，很多设计还没有敲定\nstd::set&lt;std::string&gt; find_all_var(const string &amp;klass) &#123;    auto parents = global_class_table[klass]._parent;    auto &amp;vars = global_class_table[klass]._vars;    auto result = std::set(vars.begin(), vars.end());    if(parents.empty())    &#123;        return result;    &#125;    else    &#123;        result.merge(find_all_var(parents));        return result;    &#125;&#125;size_t class_vars_size(const string &amp;klass) &#123;    return find_all_var(klass).size();&#125;\n\n读写成员变量AST定义class GetClassMemberVar  attr_reader :name  def initialize(name)    @name = name  endend\n\nVM指令定义对应了读和写两条指令\nclass GetClassMemberVar &lt; Struct.new(:id)  attr_type :id =&gt; :int  def to_s    &quot;GetClassMemberVar #&#123;id&#125;&quot;  endendclass SetClassMemberVar &lt; Struct.new(:id)  attr_type :id =&gt; :int  def to_s    &quot;SetClassMemberVar #&#123;id&#125;&quot;  endend\n\nid是用于标识是这个对象field域中的对象编号\n我目前是通过固定一个变量在field中的位置来读写变量，这样其实没有任何灵活性可言，无法支持动态定义新的变量。想要更灵活那就得存一个hash用名字索引才行，ruby中是这样做的。我这里也没有太想好要怎么样做，只能先做着，可能做下去以后再看就会有来新的看法。\n写博客的时候意识到了存在一个很大的bug，就是我没有处理继承成员时的id…所以说关于id的方面就不要作为参考实现了，写下来只是作为一个出错记录。\n翻译过程常规的读会直接翻译成对应的vm指令，从class表中获取要读的这个对象的编号\ndef on_get_class_member_var(node)  GetClassMemberVar.new(get_class_var(node))enddef get_class_var(var_obj)  cur_class_table.instance_vars[var_obj.name]end\n\n对于成员变量的赋值，则是在assign中，如果被赋值的对象是一个AST::GetClassMemberVar的话，则会转换成一个SetClassMember指令\ndef on_assign(node)  value = visit(node.expr)  if value.is_a? Value or value.is_a? Ref    value = push(value)  end  if node.var_obj.is_a? Rc::AST::GetClassMemberVar    [value, SetClassMemberVar.new(get_class_var(node.var_obj))]  else    res = visit(node.var_obj)    [value, SetLocal.new(res.ref)]  endenddef push(node)  if node.is_a? Value    Push.new(node.value)  elsif node.is_a? Ref    GetLocal.new(node.ref)  elsif node.is_a? GetClassMemberVar    node  else    raise &quot;Unsupported node type #&#123;node.class&#125;&quot;  endend\n\n而push也略有不同，函数的参数都是遍历然后对每一个进行push。在成员变量作为参数传入函数的时候，visit的结果则是一个GetClassMemberVar指令，因此需要添加对应的支持。\nVM实现void visit(const SetClassMemberVar &amp;inst)&#123;    auto *obj = _eval_stack.this_ptr();    obj-&gt;set_value(inst.id, _eval_stack.pop());&#125;void visit(const GetClassMemberVar &amp;inst)&#123;    auto *obj = _eval_stack.this_ptr();    _eval_stack.push(obj-&gt;get_number_field(inst.id));&#125;\n\n关于set与get的实现\nvoid set_pointer(int index, RcObject *value) &#123;    fields[index] = value;&#125;void set_value(int index, int64_t value) &#123;    fields[index] = reinterpret_cast&lt;RcObject*&gt;(value);&#125;RcObject *get_ptr_field(int index) const &#123;    return fields[index];&#125;int64_t get_number_field(int index) const &#123;    return reinterpret_cast&lt;int64_t&gt;(fields[index]);&#125;\n\nfields是std::vector&lt;RcObject*&gt; fields 用于保存所有的成员\n由于stack中取出来的是值，那么我们直接将值转换为指针赋值给成员，如果成员确实是值，那么我们将成员转换为指针存储（这里是一个非常不安全的操作，也许应该添加检查）。取的时候再根据需要取出不同的值\n类型多态以及接口这些，现阶段是不需要做的。因为目前偏向于鸭子类型，只要你有同名方法就OK，不需要走什么接口。等到后面加上了各种类型相关的操作再考虑引入这些东西\n关于鸭子类型，wiki是这样写的\n\n鸭子类型（英语：duck typing）在程序设计中是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定\n\n实现oop的时候许多地方已经开始和类型系统强相关了。现在许多语言中也可以兼顾动态类型，kotlin和C#都有类似于dynamic class的概念。现在先按照动态类型的实现来做，即便之后要全面切入到静态类型，这些依然可以作为动态类型的类的实现\n其他很多地方都不知道该如何设计，同时也有应付了事的成分…目前的开发流程算是一次试水吧，后面的时候我会尽量克制应付了事的冲动，不仅是在代码上，做其他的事情我也是容易有相同的问题。昨天钢琴课老师也说，一定要先着重练好手型再去弹，速度多慢都不要紧，这另一种方面也是一种需要克制住“对手型应付了事”的冲动，克制住去做后面更有意思的事情的冲动。克制这件事不仅牵扯到能否做好，如果不克制可能还会浪费更多的时间，这对于时间本就不充足的我是一个很大的影响，在克制这方面我还是要多下功夫。\n过一段时间可能会迁移到另一门语言上，那个时候可以从头梳理一遍目前所做过的决策，同时对好的进行保留，坏的进行剔除。前面的parser我觉得写的一塌糊涂，而且这几周的内容也能看出来很多地方开始乱搞了，都是没有决定好一个语言的方向，导致一个地方偏向这个样子，另一个地方又会偏向完全相反的样子。\n要着重注意的是，重构是好的，但不要过于依赖重构来保证代码的好设计。\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记10 分支与循环","url":"/2022/03/05/rc-lang-dev-10/","content":"开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来\n本周更新的内容主要是修复之前的问题以及处理了分支循环\n继承与成员变量首先是上周遗留的继承的情况下成员变量id会有问题，我们先来看一下成员变量相关的实现\n\n使用id标明\n运行时存一个hash，按照名字来取\n\n我选择在添加parent的时候将parent的成员变量添加到当前的instance_vars中。这样需要布局在编译器确定，无法应对动态添加成员变量的情况，不过先不管那些\ndef instance_var_keys  @instance_vars.sort_by(&amp;:last).map &#123;|k, _|k&#125;enddef add_parents(parent_name, parent_table)  @parent = parent_name  unless parent_table.is_a? ClassTable    raise &quot;parent_table should be a ClassTable&quot;  end  parent_table.instance_vars.each do |var_name, _|    unless @instance_vars.include? var_name      add_instance_var(var_name)    end  endend\n\n分支最近才发现我还没有做分支以及循环的内容\nASTclass If\t# stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]\tattr_reader :stmt_list, :else_stmtsend\n\ntranslatordef on_if(node)  list = node.stmt_list.map do |cond, stmt|    c = visit(cond)    s = [visit(stmt), JumpAfterIf.new].flatten    cmp_and_jmp = push_eq_jmp(s.size)    [c, cmp_and_jmp, s].flatten  end.flatten  els = visit(node.else_stmts)  list = list + els  list.each_with_index do |inst, index|    if inst.is_a? JumpAfterIf      list[index] = RelativeJump.new(list.size - index + 1)    end  end  listenddef push_eq_jmp(true_branch_size)  [Push.new(1), EQ.new, JumpFalse.new(true_branch_size + 1)]end\n\n思路对于每一组（if或者elsif）if条件和stmt进行遍历\n\n生成判断条件的指令\n\n生成比较指令\n将判断执行的结果与true进行eq操作，失败则跳转到下一组elsif，也就是true分支之后的第一条指令\n\n生成当前组if中对应的true的分支\n最后要添加一个跳转到整个if结束的指令\n\n\n新指令可以看到这里引入了几个新的指令\nJumpAfterIf：用于跳转到if结束语句，提前占好指令位置，最后由RelativeJump代替\nRelativeJump：跳转到一个相对地址\n对于分支来说，判断指令也是需要的，因此还引入了GT，LT，EQ三个指令\ndef translate_op(op)  case op.op\t...  in &#x27;&lt;&#x27;    LT.new  in &#x27;&gt;&#x27;    GT.new  else    raise &#x27;unsupported op&#x27;  endend\n\n循环astclass While &lt; Struct.new(:cond, :body)end\n\ntranslatordef on_while(node)  cond = visit(node.cond)  body = visit(node.body).flatten  cmp_and_jmp = push_eq_jmp(body.size + 1)  while_inst = [cond, cmp_and_jmp, body].flatten  while_inst + [RelativeJump.new(-while_inst.size)]end\n\n这里的内容更简单，相比if来说只需要处理一个分支判断和true的语句，最后加一个回到while开头的跳转即可\n指令的VM实现新的pc寻址方式void VM::set_pc(size_t new_pc) &#123;    _pc = new_pc;    _pc_need_incr = false;&#125;voidVM::relative_pc(int offset) &#123;    DEBUG_CHECK(static_cast&lt;int&gt;(_pc) + offset &lt; 0,                &quot;invalid pc, pc:&quot; + std::to_string(_pc) + &quot;offset:&quot; + std::to_string(offset))    set_pc(_pc + offset);&#125;\n\n比较void visit([[maybe_unused]]  const EQ &amp;inst)&#123;    _eval_stack.exec(BinaryOp::EQ);&#125;void visit([[maybe_unused]]  const GT &amp;inst)&#123;    _eval_stack.exec(BinaryOp::GT);&#125;void visit([[maybe_unused]]  const LT &amp;inst)&#123;    _eval_stack.exec(BinaryOp::LT);&#125;\n\n关于这里，我把一些binary的op做了一下处理\nvoid exec(BinaryOp op) &#123;#define PUSH(_opname, _op) \\   case BinaryOp::_opname: \\      push(v1 _op v2);     \\      break;    // LT GT, FILO    auto v2 = pop();    auto v1 = pop();    switch (op) &#123;        PUSH(Add, +)        PUSH(Sub, -)        PUSH(Mul, *)        PUSH(Div, /)        PUSH(Mod, %)        PUSH(EQ, ==)        PUSH(LT, &lt;)        PUSH(GT, &gt;)    &#125;#undef PUSH&#125;\n\n有一个需要注意的点是第一个pop出来的是表达式右侧的变量，因为栈是先进后出的。不仅比较操作需要注意，减法和除法也是如此\nRelativeJumpvoid visit(constRelativeJump &amp;inst)&#123;    _vm.relative_pc(inst.offset);&#125;\n\nJumpFalsevoid visit([[maybe_unused]] const JumpFalse &amp;inst)&#123;    auto cond = _eval_stack.pop();    if(cond == 0)    &#123;        _vm.relative_pc(inst.offset);    &#125;&#125;\n\n其他过于急切的去摸了一点oop的边，甚至连基本的分支跳转之类的都没有做，这么匆匆忙忙是否表示我已经不想做了呢…不管怎么说，这个坑决定开了，不想做也要做下去，做的烂总比什么都没做要强的多（最近几周的内容不论是数量还是质量都开始大幅下降了…\n开始不想接着写当前的了，vm那边我觉得虽然没写多少但已经开始有屎山的倾向了，应该花点时间重新考虑下代码结构以及测试。\n优化以及类型分析之类的我觉得还是换一门静态类型的语言来做。最近也在开始进行编译器重写的工作，好在实际上东西不是很多。重写过后就会从优化以及类型开始做一些工作，而下周开始可能会花更大比例的时间在重写上。尽管东西不多，但由于我对新语言对不熟悉，而且尽可能的改用好的设计，还是要花上一定的时间\n","categories":["Compiler","VM"],"tags":["Rc-lang"]},{"title":"Rc-lang开发周记11 重构与Lexer","url":"/2022/03/13/rc-lang-dev-11/","content":"本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。\n重构vm目前代码很少，做的重构主要是将一些东西抽象拆分出来\n这是之前vm的成员变量\nstd::shared_ptr&lt;VMInstVisitor&gt; _visitor;std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;size_t _pc = 0;EvalStack _eval_stack;std::string _cur_fun;bool _can_stop = false;bool _pc_need_incr = true;\n\n成员函数\nvoid run();void pc_increase();void set_pc(size_t new_pc);void relative_pc(int offset);[[nodiscard]] size_t pc() const &#123; return _pc; &#125;EvalStack&amp; eval_stack()&#123;    return _eval_stack;&#125;void begin_call(const std::string&amp; f, size_t argc, bool super = false);void end_call();size_t load_method(const std::string&amp; klass, const std::string&amp; name, const FunInfo&amp; f);[[nodiscard]] bool can_stop() const &#123; return _can_stop; &#125;void set_can_stop() &#123; _can_stop = true; &#125;[[nodiscard]] bool pc_need_incr() const &#123; return _pc_need_incr; &#125;\n\npc首先就是关于pc的部分，零碎的放在了vm的实现中，我们单独将这些实现挑出来作为一个类来实现，因此就有了\nnamespace RCVM &#123;class PC &#123;public:    PC() = default;    void absolute_jump(size_t new_pc);    void relative_jump(int offset);    void increase();    size_t current() const;    operator size_t() const    &#123;        return current();    &#125;    void force_need_incr();private:    size_t _inst_addr = 0;    bool _need_increase = true;&#125;;&#125;\n\n代码段其次是代码段的内容。和代码段相关的虽然只有一个指令的vector和一个load method方法，但是为了组件之间减少耦合、方便测试还是要拆出来（虽然我还没有写更多的测试…）。最后结果是多了一个这样的类\nnamespace RCVM&#123;class CodeSegment&#123;public:    size_t load_method(const std::string &amp;klass, const std::string &amp;name,                       const FunInfo &amp;f);    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; inst_list() const;    size_t size() const;    std::shared_ptr&lt;VMInst&gt; get_inst(size_t i) const;    std::shared_ptr&lt;VMInst&gt; operator[] (int i) const;private:    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;&#125;;&#125;\n\n重构后的成员class VM&#123;\t\t...    void run();    [[nodiscard]] PC pc() const &#123; return _pc; &#125;    EvalStack &amp;eval_stack() &#123; return _eval_stack; &#125;    void begin_call(const std::string &amp;f, size_t argc, bool super = false);    void end_call();    [[nodiscard]] bool can_stop() const &#123; return _can_stop; &#125;    void set_can_stop() &#123; _can_stop = true; &#125;    [[nodiscard]] bool out_of_code_segment() const;private:    void init();    friend class VMInstVisitor;    std::shared_ptr&lt;VMInstVisitor&gt; _visitor;    CodeSegment _code_segment;    EvalStack _eval_stack;    std::string _cur_fun;    bool _can_stop = false;    PC _pc;&#125;;\n\n看上去清爽了许多。目前先改到这里了\n相关前置知识之后的内容开始设计lexer和parser。假设读者没有相关知识，我先来大概讲一下编译器从源码生成到ast的流程。\n\n对输入的源码进行分词，生成一系列Token，我们称之为词法分析\n分词是什么呢？说的直白一些就是把字符串划分开，哪一部分是名字，哪一部分又是空格，哪一部分是数字，诸如此类。Token就是表明了这个东西到底是哪种词，如果不明白可以看后面的代码部分。\n\n将Token根据特定的规则进行解析，生成抽象语法树，我们称之为语法分析\n\n\n这些过程的实现方式不外乎两类\n\n使用生成器进行生成：常见的是Lex（生成词法分析器） + YACC（生成语法分析器）。这些需要自己编写一下规则，喂给生成器进行生成\n自行手写实现：手写的灵活性灵活度是会比生成器要高的，但是相对比较复杂\n\n关于手写方式有一种叫parser combaintor的技术，能够通过组合不同的函数来实现解析，实现起来自然是比传统的手写方式方便，而我这里选择的也正是这种方案\nLexer虽说是parser，但是肯定还是要先做分词的。之前的实现中是没有做分词的，很多地方都搞的比较难受。一开始我还疑惑了一会使用parser combaintor是否还要做分词，但是写了一会意识到还是需要，虽然可以直接隐含了分词的部分，但是这样会把两类逻辑全部糊在一起，对于调试、测试都是非常难受的问题，而且对于空格、换行之类的也会非常麻烦。\nToken先来看一下Token的定义\nenum Token extends Positional:  case IDENTIFIER(str: String)  case NUMBER(int: Int)  case OPERATOR(op: String)  case STRING(str: String)    case EOL  case COMMA  case EQL  case SPACE  case TRUE  case FALSE  case VAR  case VAL  case DEF  case RETURN  case END  case IF  case THEN  case ELSIF  case ELSE  case WHILE  case CLASS  case SUPER  case LEFT_PARENT_THESES  case RIGHT_PARENT_THESES  case LEFT_SQUARE  case RIGHT_SQUARE\n\n通过extends Positional进而让Token都携带了位置信息（行号列号）\n这是一份不是很好的定义。写这个的时候来不及改了，下周会改正，但是在这里将这个不太好的范例拿出来讲。我一开始也觉得这样很奇怪，但是也没深入思考有没有什么更好的方式（再一次见到了自己的惰性），对于Token来说这样平着展开也不能说不对，但是可以做得更好\n后来看到Rust中Token的一些地方我才反应过来，还是应该将keyword和一些间隔符单独揪出来，而不是这么完全扁平化。写这篇的时候来不及改了，只能拖到下周再说了\n一些简单的实现def NoValueToken(str: String, token: Token): Parser[Token] = positioned &#123;    str ^^^ token  &#125;def eol = NoValueToken(&quot;\\n&quot;, EOL)def eql = NoValueToken(&quot;=&quot;, EQL)def comma = NoValueToken(&quot;,&quot;, COMMA)def trueLiteral = NoValueToken(&quot;true&quot;, TRUE)def falseLiteral = NoValueToken(&quot;false&quot;, FALSE)def varStr = NoValueToken(&quot;var&quot;, VAR)def valStr = NoValueToken(&quot;val&quot;, VAL)\n\n这个也非常简单，读取到对应的字符串直接返回对应的token。外面包了positioned以后内部的内容就能够携带行号和列号的信息\ndef ops = &quot;[+\\\\-*/%^~!&gt;&lt;]&quot;.rdef operator: Parser[Token] = positioned &#123;  ops ^^ OPERATOR&#125;\n\n这是一个通过正则表达式匹配的例子，这里的^数量由三个变成了两个，三个的情况下是左边的条件匹配成功则返回右边的值，而两个的情况下是条件匹配成功后执行右边的函数并且返回其值。\noperator这里是通过正则表达式来进行匹配，ops则是一个正则表达式\n这里可能有一些引起困惑的地方。为什么下面需要返回函数的时候填的是返回的类型？我没有正经学过Scala，用我在其他语言学过的东西来说这大概是因为虽然OPERATOR本身是类型，但在这里是一个值构造器，用另一种表达方式的话就是一个传入OPERATOR所需参数返回一个OPERATOR实例的函数\n这里我可能解释的不是很正确，如有哪里用词/描述不当还请联系我指出\n间隔符与非间隔符核心代码\ndef allTokens: Parser[List[Token]] = &#123;\t((rep1sepNoDis(repN(1,notSpacer),spacer.+) ~spacer.*) |\t\t// BAA is imposible\t\t(rep1sepNoDis(spacer.+, repN(1,notSpacer)) ~notSpacer.?)) ^^ &#123;    case list ~ t =&gt;      list        .fold(List())(_:::_)        .concat(t match &#123;          case Some(v) =&gt; List(v)          case None =&gt; List()          case _ =&gt; t        &#125;)        .filter(_ != SPACE)  &#125;&#125;\n\n^^前都是解析的部分，解析部分的～是连接的意思，也就是说前面的解析完会接着解析后面的内容。后面处理的部分只是将每个解析部分生成的输出都连接起来，成为一个List[Token]。由于觉得用不到因此我在这里干掉了SPACE\n其中出现过的一些函数的定义\ndef space: Parser[Token] = positioned &#123;  whiteSpace.+ ^^^ SPACE&#125;def notSpacer: Parser[Token] = keyword | value | eoldef spacer: Parser[Token] = symbol | operator | eql | spacedef keyword: Parser[Token] = stringLiteral | trueLiteral | falseLiteral |    defStr | endStr | ifStr | thenStr | elsifStr | elseStr | whileStr |    classStr | superStr | varStr | valStrdef symbol: Parser[Token] = comma | eol | leftParentTheses | rightParentTheses | leftSquare | rightSquaredef value: Parser[Token] = number | identifier\n\n这里对我来说是一个比较难写的点，上周在写的时候头痛了好一阵子，想明白逻辑以后再回来看会好很多\n整体逻辑这里的逻辑是这样的：我们先定义不能作为间隔符的为A（notSpacer），可以作为间隔符的为B（spacer），那么我们需要的是A(B+A)*B*，或者是B+(AB+)*A?\n注：这里的*+?都是正则表达式的语义\n拆分逻辑关于为什么要这么设定，我们先从B开始。\n\n可以看到B包含了一些运算符，空格，一些标点符号，这些本身是和任何字符相连都是无歧义的（目前来说B中的内容是无歧义的），那么它们连续存在依然不会产生歧义。B本身是要存在的，因此这里可以推导出B+\n\n而A中的内容，比如说两个keyword之间一定要有空格，不然会被识别成一个identifier了，比如说传递参数的时候需要逗号分开（symbol），那么A是不可能连续存在的，因此这里可以推导出A\n\n由于我们需要A和B间隔放置，我首先想到的是rep1sep(A, B+)，而由于A和B都可能在第一个，因此有了rep1sep(A, B+) | rep1sep(B+, A)。（repsep举个例子，repsep(str, ‘,’)，对应的就是str, str, str这种以，分割的）但是repsep会扔掉B，因此我从rep1sep抄了一份修改了一下，变成了不扔掉B的版本\n以下rep1sepNoDis都用rep1sep代替\n\n\ndef rep1sepNoDis[T](p : =&gt; Parser[T], q : =&gt; Parser[Any]): Parser[List[T]] =    p ~ rep(q ~ p) ^^ &#123;case x~y =&gt; x::y.map(x =&gt; List(x._1.asInstanceOf[T], x._2)).fold(List())(_:::_)&#125;\n\n原版\ndef rep1sep[T](p : =&gt; Parser[T], q : =&gt; Parser[Any]): Parser[List[T]] =    p ~ rep(q ~&gt; p) ^^ &#123;case x~y =&gt; x::y&#125;\n\n\n但是只是repsep的做法无法处理AB（会残留一个B未解析），那么很自然的就会想到再后面接一个可选的B，因此就有了rep1sep(A, B+) ~ B?，同理无法处理BA，也就有了 rep1sep(B+, A) ~ A? 组合起来就有了 rep1sep(A, B+) ~ B? | rep1sep(B+, A) ~ A? \n\n事后回顾思路还算是捋的比较清晰，一直这样写或许也会有利于我之后写代码的时候逻辑梳理的能力。不过当时写的时候真的是整个人都不好了…这块写代码的时候想了半天，写博客尽管逻辑很流畅了但是还是写了很久\n逻辑与实现的一些出入拆分完逻辑后将\nrep1sep = rep1sepNoDis\nA = notSpacer\nB = spacer\n代入后，会发现有一些不一样的地方。我在rep1sep的A中做了repN(1, A)的操作。至于为什么这么写，是为了保证A和B哪一个在前哪一个在后都可以使用。一个值和一个List交换顺序还能连接的实现不知道有什么可用的，自己尝试写了一个\ndef link[T](l: List[T], v: T): List[T] = l:::v::Nildef link[T](v: T, l: List[T]): List[T] = v::ldef link[T](l1: List[T], l2: List[T]): List[T] = l1:::l2\n\n但是和前面的函数组合起来，在处理的时候一些看起来很自然的东西并没有通过类型检查，对于Scala的类型理解不到位也难以解决问题，因此就只好先这个样子。虽然用起了Scala，但是并没有学太多，凭着其他语言的经验直接就来写\n具体实例这么说过于抽象，我们通过看测试来实际理解以下例子。\n之所以要搞得这么复杂，是因为最后一个测试用例的那种情况。对于我之前lexer和parser混在一起写的做法处理这样的情况是非常难的。不过我不敢说已经想全面了，有问题再改吧\ndescribe(&quot;spacer&quot;) &#123;  // a is notSpacer, b is spacer\tit(&quot;AB&quot;) &#123;    expectSuccess(&quot;id&quot;, List(IDENTIFIER(&quot;id&quot;)))  &#125;\t  it(&quot;ABA&quot;) &#123;    expectSuccess(&quot;id id&quot;, List(IDENTIFIER(&quot;id&quot;), IDENTIFIER(&quot;id&quot;)))  &#125;  it(&quot;BAB&quot;) &#123;    expectSuccess(&quot; id &quot;, List(IDENTIFIER(&quot;id&quot;)))  &#125;  it(&quot;ABABB space and eol&quot;) &#123;    expectSuccess(&quot;def f \\n&quot;, List(DEF, IDENTIFIER(&quot;f&quot;), EOL))  &#125;  it(&quot;BABA&quot;) &#123;    expectSuccess(&quot; def f&quot;, List(DEF, IDENTIFIER(&quot;f&quot;)))  &#125;  it(&quot;only space&quot;) &#123;    expectSuccess(&quot; &quot;, List())  &#125;  it(&quot;local&quot;) &#123;    val v = List(IDENTIFIER(&quot;a&quot;), EQL, NUMBER(1))    expectSuccess(&quot;a = 1&quot;, v)    expectSuccess(&quot;a = 1 &quot;, v)    expectSuccess(&quot;a =1&quot;, v)    expectSuccess(&quot;a=1&quot;, v)  &#125;&#125;\n\n最后本来是想写一些parser的内容的，但是没想到这个token间隔符相关的逻辑就花了我这么久的时间。这块我觉得写的还是相对比较清晰，也算是比较满意，所以本周就先这么结束了。关于token一般来说不会有什么特别的内容了，所以关于解析输入，之后基本上就是parser的内容了。\n这个周我觉得进度比较慢，不会调加上前几天整个人都过于不稳定，回家会花一些时间在刷刷刷上，进而减少了编码的时间，不知道什么时候能做完重写啊…\n","categories":["Compiler"],"tags":["Rc-lang","Lexer","ParserCombaintor"]},{"title":"Rc-lang开发周记12 部分Parser","url":"/2022/03/20/rc-lang-dev-12/","content":"\npixiv:95518122 \n\n本周内容主要就是parser，而ast的内容会穿插其中\nParser的一些问题换行由于是由换行来分句，我觉得一个头疼的点在于要想清楚哪里要换行，想清楚这个parser都是由什么组成，然后拼接在一起。但是写到这里的时候我才想到如果表达式有多行（这个也是非常常见的情况）就支持不了了…以后再做支持吧，这个或许可以对于表达式单独添加换行的支持。\n我目前的换行策略是统一由stmt以及item吃掉eol，其中的子parser是不会处理eol的。stmt是很自然的，一行是一个stmt，item的话目前则是由函数或者class组成，而函数和class也不需要管理换行统一由item管理\n左递归这个问题留到下次再讲（因为我还没写）\n关于设计在重写的时候发现很多原来的设计并不好，但是又一时不知该如何设计。后面觉得还是先实现一种，先功能完备再来考虑美化语法\n关于具体的设计还是要看parser和ast的实现\nexprastenum Expr extends Positional:  case Number(v: Int)  case Identifier(id: Id)  case Bool(b: Boolean)  case Binary(op: String, lhs: Expr, rhs: Expr)  case Str(str: String)  // false -&gt; elsif | else  case If(cond: Expr, true_branch: Block, false_branch: Option[Expr])  case Lambda(args: List[Expr], stmts: List[Expr])  case Call(target: Id, args: List[Expr])  case MethodCall(obj: Expr, target: Id, args: List[Expr])  case Block(stmts: List[Stmt])  case Return(expr: ast.Expr)  case Field(expr: Expr, id: Id)\n\n关于Expr, Stmt, Block之间不知道以什么样的形式比较好，就暂且学习了Rust的做法。自己不知道怎么做那去学习一些比较好的语言，这样的想法我觉得应该是没问题的。之前做的时候也是经常会参考Ruby的实现\n关于Expr我就不一个个放parser了，大部分比较简单没有什么可讲的内容。着重讲几个关键的点。代码中出现log的部分可以忽略\nifast的变化首先ast的定义相比于之前发生了变化\n这是之前if的ast定义\nclass If\t# stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]\tattr_reader :stmt_list, :else_stmtsend\n\n参考了rust中的if而现在转换成了这个样子\nIf(cond: Expr, true_branch: Block, false_branch: Option[Expr])\n\nfalse_branch可以是一个普通的else，也可以是接的另一个if，也就是将elsif这一语法糖还原为原始的if了，而elsif的if里又是同样的定义\n同时之前的if是一个stmt，而现在的if是expr。返回的是对应分支block的返回值。block是由多个stmt组成，其返回值则是最后一条stmt\nparserdef block: Parser[Block] = positioned &#123;  rep(statement) ^^ (stmts =&gt; Block(stmts))&#125;def multiLineIf: Parser[If] = positioned &#123;  oneline(IF ~&gt; expr) ~ block ~ elsif.* ~ (oneline(ELSE) ~&gt; block).? &lt;~ END ^^ &#123;    case cond ~ if_branch ~ elsif ~ else_branch    =&gt; If(cond, if_branch, elsif.foldRight(else_branch.asInstanceOf[Option[Expr]])(      (next, acc) =&gt; Some(If(next.cond, next.true_branch, acc))))  &#125;&#125;def elsif: Parser[If] = positioned &#123;  oneline(ELSIF ~&gt; termExpr) ~ block ^^ &#123;    case cond ~ branch =&gt; If(cond, branch, None)  &#125;&#125;\n\n可以看到elsif在这里被编译为了if，多个elsif则是被编译为了一个List[If]，在这里通过FoldRight的方式折叠为一个if。以else为初始值，不断的将List最右边的元素设置为下一个if的else\n逻辑展开是这样的\nA B C, ELSE: Option[Expr]A B Some(IF(C.cond, C.true_branch, ELSE))A Some(IF(B.cond, B.true_branch, Some(IF(C.cond, C.true_branch, ELSE)))Some(IF(A.cond, A.true_branch, Some(IF(B.cond, B.true_branch, Some(IF(C.cond, C.true_branch, ELSE))))\n\n代码中出现的asInstanceOf是因为我不知道这里的类型是怎样处理的，索性通过这种方式来回避编译错误。\ntermExprtermExpr只是为了parser的时候区分各种expr的一种方式，所以ast表示上是和常规的expr是一样的。可以看到term是一些可以用于各种操作符的东西，比如说1 + 1，1是一个term，整个是一个termExpr。后面我们需要将这一系列的term和operator组合成一个expr，因此需要有后面的termToBinary\ndef termExpr: Parser[Expr] = positioned &#123;  term ~ (operator ~ term).* ^^ &#123;    case term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; List(a._1, a._2)))  &#125;&#125;def expr: Parser[Expr] = positioned &#123;  multiLineIf | termExpr | ret&#125;def term: Parser[Expr] = positioned &#123;  bool | num | string | call | memField | memCall | idExpr&#125;\n\n关于termsToBinary的实现\ntrait BinaryTranslator &#123;  val opDefaultInfix = HashMap(&quot;+&quot;-&gt;10, &quot;-&quot;-&gt;10, &quot;*&quot;-&gt;10, &quot;/&quot;-&gt;10, &quot;&gt;&quot;-&gt;5, &quot;&lt;&quot;-&gt;5)  def findMaxInfixIndex(terms: List[Positional]): Int =    terms      .zipWithIndex      .filter((x, _) =&gt; x.isInstanceOf[OPERATOR])      .map((x, index) =&gt; (x.asInstanceOf[OPERATOR], index))      .minBy((op, index) =&gt; opDefaultInfix(op.op))._2  def replaceBinaryOp(terms: List[Positional], index: Int): List[Positional] = &#123;    var t = terms(index)    val left = terms.slice(0, index - 1)    val bn = Expr.Binary(      terms(index).asInstanceOf[OPERATOR].op,      terms(index - 1).asInstanceOf[Expr],      terms(index + 1).asInstanceOf[Expr])    val rights = terms.slice(index + 2, terms.size)    left.appended(bn):::(rights)  &#125;  def termsToBinary(term: Expr, terms: List[List[Positional]]): Expr = &#123;    if terms.isEmpty then return term    termsToBinary(term :: terms.flatten)  &#125;  def termsToBinary(terms: List[Positional]): Expr = &#123;    var newTerms = terms    while (newTerms.size &gt; 1) &#123;      val max_index = findMaxInfixIndex(newTerms)      newTerms = replaceBinaryOp(newTerms, max_index)    &#125;    newTerms.head.asInstanceOf[Expr.Binary]  &#125;&#125;\n\n实现逻辑：\n\n如果只有开头的一个term则返回该term\n否则将开头的和后面的terms组合起来进行处理\n\n找到最高优先级的op的位置\n\n将该位置以及左右的term组合为一个expr并且替换\n\n重复这个过程直至剩下一个term\n\n\n这里我觉得实现的有点脏…基本上是把我用ruby写的那一套抄过来了，我一时也没想到什么好的方案\n由于要对替换以后的expr再进行组合，这个过程中index会发生变动；如果要将组合后的拿出来，那还要处理哪些是拿出来的哪些是没有拿出来的，这样获取前后的term也会很不方便\nStmtastenum Stmt extends Positional:  case Local(name: Id, ty: Type, value: ast.Expr)  case Expr(expr: ast.Expr)  case While(cond: ast.Expr, stmts: Block)  case Assign(name: Id, value: ast.Expr)  case None\n\n这里的while和rust的不太一样，rust的while也是一个expr，尽管能够从理性上认识到这样做是为了返回最后一个block的结果，但我仍然觉得这个做法好奇怪。目前还是先将其作为stmt，以后发现了哪里不合适再进行修正\nparser这边也比较简单。内容不多就直接贴出来了\ndef local: Parser[Stmt] = positioned &#123;  (VAR ~&gt; id) ~ (EQL ~&gt; termExpr) ^^ &#123;    case id ~ expr =&gt; Stmt.Local(id, Type.Nil, expr)  &#125;&#125;def ret: Parser[Return] = positioned &#123;  RETURN ~&gt; termExpr ^^ Return&#125;def assign: Parser[Stmt.Assign] = positioned &#123;  (id &lt;~ EQL) ~ termExpr ^^ &#123;    case id ~ expr =&gt; Stmt.Assign(id, expr)  &#125;&#125;def whileStmt: Parser[Stmt.While] = positioned &#123;  oneline(WHILE ~&gt; parSround(termExpr)) ~ block &lt;~ END ^^ &#123;    case cond ~ body =&gt; Stmt.While(cond, body)  &#125;&#125;\n\n最后如果读者能够读到这里（虽然并不会有几个人，其中大概也不会有追更的），那很大概率不嫌弃我的内容，在这里可能要提前和各位说一声对不起，下周很有可能将是我第二次断更。（其实本周也有好几天都没写了…）\n下周工作之外的事情除了最低限度的练琴，我会尽可能的不去做什么事情。眼睛疼（写的现在也在疼），精神极其不稳定（经常不受控制的胡思乱想），这些都是原因。\n我也不想停，重写的进程还是比较慢，我的开发效率又偏低同时又要各种测试确保正确性。我好想赶快把这些基础的迁移完，然后去学习做优化，学习加上类型系统，等等，还想要多学习一些Scala，除此之外有很多创意想要实现还想去学swiftUI\n但是或许此刻再不停就真的要断线了，我需要花时间好好冷静一下，平复情绪，进行休整。我无法努力获得温暖，那就只有努力去平复情绪。面对至今为止最重要也最大的挑战（当前的不良状态），我也应该拿出应有的态度\n","categories":["Compiler"],"tags":["Rc-lang","ParserCombaintor","Parser"]},{"title":"我原本计划停下一周，然而...","url":"/2022/03/28/rest-for-a-week/","content":"最近的精神状态愈发差劲，无止境的压力涌入身体，我也没有什么好的排解途径（本文不是讲我状态多差的，但是这些属于所需要了解的上下文，希望不要看到这个就直接关掉了文章）。我觉得不能再这个样子了，因此我想要尝试为期一周的“在家只休息”计划（过于直接的命名）\n这周是如何度过的计划很美好，现实嘛…大家都懂\n第一天清理了卧室的垃圾，做了一些轻微的收拾。之后的时间都是习惯性的就要去抓手机，想要放音乐。看到这里，你可以一会尝试一下一段时间什么也不做是怎样的感受。\n停下来什么都不做还是很难，不知所措的时候突然想到一些东西就开始记了下来，最后花了一个小时的时间手写了满满一页纸的想法（这也不算是在休息）。最后也是不知不觉就十二点了，早睡也没能成功\n后面几天本周的精神状态极差，回家只想获取简单快速的反馈，因此结果和我预料的也差不多，第二天开始回家只有各种刷视频，以及玩一些游戏。后面几天愈发过分，甚至到了快一点\n周末由于事情比较多导致只有晚上在家，然而周末晚上也没有多少改善\n总结发现自己现在的情况，所谓的休息在情绪高压下根本就是找理由刷推特和视频，这种休息还不如不休，但是不休息又会持续积累压力和疲劳，那…\n\n仔细想想还是应该注重维持我的日常规划的同时在不同任务之间进行轻微的休息，而减少大片的休息时间。这是非常必要的事情，不能一直紧绷着精神。否则就会像我现在这个样子，在状态差到只想刷刷刷以及处理任务之间反复游走，从来没有真正的休息过\n第一天我都写了些啥？尽管写满了一页A4纸，在这里只挑出一些提及一下。\n很久没有这样决定不逼着自己做些什么了（但是另一种角度说我还是在逼着自己不做事情，尽管也没能成功。\n回想起以前的各种略悠闲的生活：回想起三年前在家的时候自己买菜做饭自己去海边溜达的日子，回想起在学校和舍友满学校找猫喂猫的日子。我也有那样的时光啊。\n而现在的我显得忙碌与疲劳，不断给自己添加非常多的压力，这给我的第一反应是与之前的生活有着极大的反差。\n但是后来想起现在的我会去买花，会去公园拍照，会去看星星拍星星，会关心云彩是什么样的，这样想下去现在也没有那么枯燥无谓。相比之前能做以及实际去做的事情都多了非常多，感兴趣的事情也多了许多，自己渐渐开始主动接触各种各样的事物，自己不再是只知道上学学习与打游戏的一个人了。\n一些想法休息也不能白休，偶尔也会感受一下，会想一下自己的状态，进而记录了一些想法。\n外界push不论因为什么，我目前都是处于一个身体不想做事情的状态（实际表现就是想做什么但并不会去做）。这个现象我一直隐约有所察觉，但是并没有做过多想法，或许是想了也没有用，再怎么想还是会这样。对于现在的话，更多的是将这个东西有意识的提醒自己，这是很重要的问题自然不能忽略\n我有那么多想做的事情，都是觉得有意思想要尝试的东西，最后没有利用时间去做大多是如此。由于总处于疲惫状态，不管学的东西再有意思也不可能在累的时候还想要用力\n关于这个问题，想起了我第一次接触精神药物的时候，当时因为睡眠不好大夫给我开了黛力新，之后的半个月内真的是精神十足，没有觉得累，也不像以往一样什么都不愿做，讨厌的英语材料也能一直在啃（绝不是给我现在回避啃英语找借口），随后一些原因效果都没了，一共也就吃了两个月。那段时间我在看各种书的lab，然而药效小了以后的效率最多只有原来一半，只能硬逼着自己做，逼着自己做也会很快就产生厌烦，完全找不回那半个月的精神劲。如果能持续保持那样的状态那我大概几个月就会产生更为巨大的变化吧，可惜已经一去不复返了\n想要身体去做事情只有通过各种方式进行push，至少对我来说在被轻度push的时候状态基本上都是相对良好（重度可能会增加焦虑），之前也看到类似这样的话\n\n自己一个人努力是难的，需要有人拉你一把\n\n习惯然而不是总能有人来帮你，大多数情况需要靠自己。而对自己push对于我这样的情况来说是相对比较困难的，但我之前依然每天都能够坚持做些什么，这完全归功于习惯。\n只要逐渐养成习惯，那么做这些事情所需的阻力逐渐会减小，那么即便是相对疲惫的状态也能够一直做下去。\n关于如何逐渐养成习惯这些，我推荐去阅读《掌控习惯》这本书。这本书最初是由推友在推特推荐给我的，阅读之后觉得收益非常多。虽然只能将书中的少部分内容运用到实际中，但依然促进了我许多改变。\n关于习惯，周六心情不错的时候我一度认为这就是我破局最重要的东西之一。我写下了这样的一段话：我也不需要再担心自己会一直魔怔了，不过那要到何时我就不知道了。魔怔能不能解决我不知道，但是一定会帮助我解决非常多的问题。在这里我想起了上面提到的《掌控习惯》中提及了这样的内容\n\n不是应当达到某个目的，而是要达到某个系统\n\n一旦所需的习惯系统形成了，目的自然而然也就能够达到了\n“应该做的”停摆了一个周，很多事情没有去做也没有那么大的影响。（当然不是说我现在所做的事情都是不该做的意思）\n想到了自己时常会被自己心中所谓的“应该做的”事情所限制所约束所浪费时间。之前总是会把很多这样的事情塞给自己，然后就开始拖。拖到最后太多了就狠心全部清空，实际最后也没有太大的影响。\n你有多少事情也是这样？不过想明白自己真正应该做什么绝非易事，生活中的噪音太多了，而且即便没有这些噪音这也是一个非常难的问题。\n这一周我究竟得到了什么这一周的时间，我对所处的情况进行了一些思考，得出了一些结论。在写下成文的过程中再一次强化对这些想法的感知，希望能够帮助我强化一些正确的想法在脑中的印象并且更好的去实施提到的应当做的事情。\n意识到了习惯究竟有多么的重要，看到离开了习惯的我是如何打回原形的；意识到了应该什么时候休息，缺乏休息的后果。这些虽然潜意识的有意识到，但是这种事情还是需要从潜意识中提取出来才能真正开始产生一些影响。\n赶往目的地很重要，但是偶尔还是应该停下脚步，看看周边的风景\n","categories":["Thinking","Life"],"tags":["Habits","Rest"]},{"title":"Rc-lang开发周记13 另一些Parser","url":"/2022/04/04/rc-lang-dev-13/","content":"\npixiv:40165995 \n\n本周的内容主要就是添加剩下的一些parser，主要是和类相关的，同时还添加了数组的下标索引。内容稍微少一些，我觉得也没有太多值得讲的，基本上就是确定语法 + 直接写实现。代码写的也不多，花了不少时间在另一篇博客上，同时还要添加测试。到此为止原先的parser支持的差不多了。还增加了类型以及下标索引的内容，同时还有了更合理的测试。今天收下尾差不多可以开始写其他的内容了\n本周出现的所有语法首先我们要确定要写出什么样的语法。语法大致先这样，不知道怎么样的语法才是优雅的，先都做出来再说\nclass F &lt; Parent // 继承，类型名必须首字母大写  v1: Fun // 成员变量  v2: Int = 1 // 成员变量默认值  def update() // 成员函数\t\t@v2 = @v2 + 1 // @获取成员变量  endenddef f()\tvar v = F.new() // Class.new()的形式构建变量。new本质是object基类的方法\tv.update() // 调用成员函数  var arr = Array.new(2)\tarr[0] = 1 // 常规的取数组下标end\n\n类定义其实我有点中意下面这种写法，将vars和methods都限制在一起，但是后面如果类中可以添加新的东西那会麻烦一些，所以这个想法暂时保留\nclass Fvars:  v1: Fun  v2: Int = 1methods:  def f1()  endend\n\n实现def classDefine: Parser[Item.Class] = positioned &#123;  oneline(CLASS ~&gt; sym ~ (OPERATOR(&quot;&lt;&quot;) ~&gt; sym).?) ~ log(item | field | noneItem)(&quot;class member&quot;).* &lt;~ log(END)(&quot;class end&quot;) ^^ &#123;    case klass ~ parent ~ defines =&gt;      Item.Class(klass, parent,        defines.filter(_.isInstanceOf[Field]).map(_.asInstanceOf[Field]),        defines.filter(_.isInstanceOf[Item.Method]).map(_.asInstanceOf[Item.Method]))  &#125;&#125;def noneItem: Parser[Item] = positioned &#123;  EOL ^^^ Item.None&#125;def field: Parser[Field] = positioned &#123;  oneline(VAR ~&gt; (id &lt;~ COLON) ~ sym ~ (EQL ~&gt; expr).?) ^^ &#123;    case id ~ ty ~ value =&gt; Field(id, Type.Spec(ty), value)  &#125;&#125;def item: Parser[Item] = positioned &#123;  oneline(method | classDefine)&#125;\n\nExpr新增加的ast成员。其中Constant是大写字母开头的名字\ncase MethodCall(obj: Expr, target: Id, args: List[Expr])case Field(expr: Expr, id: Id)case Selfcase Constant(id: Id)case Index(expr: Expr, i: Expr)\n\nMethodCall调用成员函数\ndef memCall: Parser[Expr.MethodCall] = positioned &#123;  (termExpr &lt;~ DOT) ~ id ~ parSround(repsep(termExpr, COMMA)) ^^ &#123;    case obj ~ id ~ args =&gt; Expr.MethodCall(obj, id, args)  &#125;&#125;\n\nFielddef memField: Parser[Expr.Field] = positioned &#123;  (termExpr &lt;~ DOT) ~ id ^^ &#123;    case obj ~ name =&gt; Expr.Field(obj, name)  &#125;&#125;def selfField: Parser[Expr.Field] = positioned &#123;  (AT ~&gt; id) ^^ (id =&gt; Expr.Field(Expr.Self, id))&#125;\n\nIndexdef arrayIndex: Parser[Expr.Index] = positioned &#123;  termExpr ~ squareSround(termExpr) ^^ &#123;    case expr ~ index =&gt; Expr.Index(expr, index)  &#125;&#125;protected def squareSround[T](p: Parser[T]) = LEFT_SQUARE ~&gt; p &lt;~ RIGHT_SQUARE\n\n左递归lazy val beginWithTerm: PackratParser[Expr] = positioned &#123;  memCall | memField | arrayIndex&#125;def term: Parser[Expr] = positioned &#123;  bool | num | string | selfField | call | beginWithTerm | sym ^^ Expr.Constant | idExpr&#125;def termExpr: Parser[Expr] = positioned &#123;  term ~ (operator ~ term).* ^^ &#123;    case term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; List(a._1, a._2)))  &#125;&#125;\n\n添加了如上几个语法后，语法已经变成了左递归的形式。遇到这种问题一般来说是转成非左递归的语法，因为左递归的情况很容易堆栈溢出，而Scala的parser combaintor提供了记忆化的能力，简单来说就是能够缓存遍历过的情况，第二次递归到某个情况，如果这个情况已经被遍历过那么直接从缓存中取出即可，而不需要再次递归搜索\n想要使用这个功能需要两个步骤\n\nparser继承自PackratParsers。之前我的parser都是继承自Parsers，而更换成PackratParsers是兼容的，直接修改继承类名即可\n显式指定需要这个功能的parser返回PackratParser\n函数必须改成lazy val\n\n可以看到上面的beginWithTerm已经修改为了这种形式\n","categories":["Compiler"],"tags":["Rc-lang","ParserCombaintor","Parser"]},{"title":"关于glibc与GLIBC_XX","url":"/2022/03/29/glibc-version/","content":"\n是GLIBC的版本多还是miku的版本多? pixiv:67650124 \n\nglibc位置这个不同系统不一致，linux中比较多的存在于/lib/libc.so.6\n想要查找libc的位置可以通过ldd(linux)/otool(mac)查看依赖于libc.so的库（有的库会静态塞进去，这种的是看不了）\n有的时候ldd看到的错误信息也会包含glibc的路径，这些还是根据不同的情况来查找\n确认当前环境glibc版本信息ldd --version\n\n#include &lt;gnu/libc-version.h&gt;#include &lt;stdio.h&gt;int main()&#123;  printf(&quot;%s&quot;, gnu_get_libc_version());&#125;\n\n两者都可以\nGLIBC Version兼容性本质上这是一个so的不同版本兼容性问题。通常我们看到的so的版本号是 主版本号.次版本号，比如说2.6。链接的时候只会进行主版本号的判断，不同主版本号可能是不兼容的（不管实际如何，我们都应该视为不兼容，链接器也会报错的）。而次版本号保证新版本会兼容旧版本，比如说2.6兼容2.4\n关于自己编译的库查看GLIBC的依赖简单的命令查看\nstrings libxxx.so | grep &quot;^GLIBC&quot;\n\n你会看到多个版本号，由于新版本兼容旧版本，因此其中最新的一个GLIBC版本号是我们所需要的。这时你可能有很多小问号，让我们一个一个的来解决\n自己的库的GLIBC Version怎么来的？上面也提及了次版本号会高版本兼容低版本，但是如果依赖高版本的却运行于低版本时可能会出现找不到符号的情况，因此引入了基于符号的版本机制。即对应符号可以依赖于某个特定的次版本号\n我们从一个例子来将这些串联起来。以下以上面提到过的确认当前环境GLIBC信息的示例代码为例，实际GLIBC版本大概率不会相同，与你的系统环境有关\n首先使用strings查看，可以看到搜到了两个版本\nGLIBC_2.2.5GLIBC_2.34\n\n当然我想你可能已经尝试过前面确认当前版本GLIBC Version的命令，发现这里的符号和当前版本的符号并不相同。我们先讲解这些版本的来源，之后就会明白原因了\n那么为什么会有两个版本呢？两个版本又是怎么来的呢？让我们用nm查看一下其中的符号\n000000000000039c r __abi_tag0000000000004038 B __bss_start0000000000004038 b completed.0                 w __cxa_finalize@GLIBC_2.2.50000000000004028 D __data_start0000000000004028 W data_start0000000000001080 t deregister_tm_clones00000000000010f0 t __do_global_dtors_aux0000000000003df0 d __do_global_dtors_aux_fini_array_entry0000000000004030 D __dso_handle0000000000003df8 d _DYNAMIC0000000000004038 D _edata0000000000004040 B _end0000000000001170 T _fini0000000000001140 t frame_dummy0000000000003de8 d __frame_dummy_init_array_entry00000000000020a8 r __FRAME_END__0000000000004000 d _GLOBAL_OFFSET_TABLE_                 w __gmon_start__0000000000002008 r __GNU_EH_FRAME_HDR                 U gnu_get_libc_version@GLIBC_2.2.50000000000001000 T _init0000000000002000 R _IO_stdin_used                 w _ITM_deregisterTMCloneTable                 w _ITM_registerTMCloneTable                 U __libc_start_main@GLIBC_2.340000000000001149 T main                 U printf@GLIBC_2.2.500000000000010b0 t register_tm_clones0000000000001050 T _start0000000000004038 D __TMC_END__\n\n可以看到 __cxa_finalize, gnu_get_libc_version, printf是基于2.2.5，而__libc_start_main是基于2.34，这正好与我们前面看到的符号相关联。\n看到这里你应该已经明白了，自己的库中GLIBC版本是来源于所使用的符号所标明的版本，因此我们在当前环境编出来的库的依赖版本实际上是当前环境的库中对应符号所依赖的版本号\nlibc.so与libc.so.6libc.so虽然长得像so，但它并不是，甚至不是一个软链接。内容大致是这样的\n/* GNU ld script   Use the shared library, but some functions are only in   the static library, so try that secondarily.  */OUTPUT_FORMAT(elf64-x86-64)GROUP ( /usr/lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /usr/lib/ld-linux-x86-64.so.2 ) )\n\n参考资料程序员的自我修养：链接、装载与库\n","categories":["C"],"tags":["Link"]},{"title":"与CI和链接大战三百回合","url":"/2022/03/29/solve-ci-and-link/","content":"\n攻撃隊、出撃！Vorwärts！ pixiv:54707001 \n\n噩梦开始的地方在C#的CI测试中（目前仅开启了ubuntu）DllImport报错DllNotFoundException。而报错的位置是我对自己搞的一个capi做的C#包装\n本地尝试遇到这种问题，我的第一反应还是先在本地的环境确认一下，这样的做法相对来说成本低很多，能够初步确认一些问题（但是由于自己配的环境的影响会导致很多问题无法排查）\n自然本地是失败了，切到了Windows的机器上依然失败，又切到了公司内部的ubuntu服务器（我没有做过什么环境配置，可以认为相对干净一些）依然是失败了\n查看类似的情况项目中也有其他使用我们自己做的C#包装的测试，因此我想到了确认一下它的正确性。我使用了自己的分支，而主分支是没有问题的。自己这里确认的过程中还是不够严谨，应该直接查看对应测试成功与失败的用例的执行情况，只是用这样想当然的想法来考虑。\nCI调试神器各种尝试无果（忘了做了哪些，总之都没有效果），之后尝试在Windows和mac下进行测试，这两者居然是能通过的。\n一时之间也没能想到有什么决定性的因素，后来想到以前看过本地模拟ci环境的东西，因此去搜索关于ci调试的信息，并且发现了这个神器\n- name: Setup tmate session  uses: mxschmitt/action-tmate@v3\n\n只要将这一段加到GitHub action的yaml文件中，即可在执行到这里的时候停住。此时会不断刷新ssh连接的命令。\n进入CI后我做的第一时间是检查so本身是否存在问题\n像以往一样写了一个最简单的main.c，之后 gcc main.c -L . llibname 查看报错。\n我一直使用这样的方式来检查实际链接的时候因为哪些符号是undefined导致链接挂掉，简单易实施，久而久之也开始潜意识的认为这样能过链接就没有问题了，还是对链接了解不够。\n这里出现了一个我忽略了的问题，也正是这个问题导致我浪费了大半天时间。因为这个库是我自己写的自己编的，不会依赖于系统库之外的so，我潜意识认为这里不会出问题，所以我没有使用ldd进行确认链接状态。\n启动一个裸docker测试前面那一步做好也就不会有后面的那么多操作了..总之后面的操作也回顾一下\n为了和跑测试的ci版本一致，启动了一个ubuntu18.04的docker（后面可以看到，幸好我这里选择了一致的版本，不然可能解决问题的时间需要更久…）\n由于是非常干净的镜像，什么都没有，折腾了半天安装所需要的基本组建，开始编译并且执行测试，依然是存在问题。之后也没什么好思路，后来跑了一下上面提及的类似性质的相关测试的正确性，发现docker中也是错的。（这里如果我之前更严谨的确认了可能也会减少一些重复过程）\n之后我就喊实现这块的同事和我一起看问题，切到了主分支测试也不能通过。后来不记得为什么了我随手敲了个ldd看了一下他的so，他看到了错误信息，一提醒我才看到。自己思考问题经常会钻牛角尖，以及经常会忽略掉一些信息，有的时候换个人从旁观者角度来看会好很多，自己想切换到旁观者角度还是有些难。\nGLIBC_x.xx not found看到的错误信息是这样的\n./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBCXX_3.xx&#x27; not found (required by ./libxxx.so)\n\n由于这是一个非常干净的ubuntu，所以甚至没有这个东西。这个时候我意识到了自己的库在CI中会不会也是类似的原因，我之前是否ldd检查过，检查过的话是否是忽略了这么重要的调试信息？（这个时候由于没有清晰的思路和严谨的做法，开始怀疑之前是否做过这个测试）\n随后意识到在ci中会不会也是类似的问题。于是进入了ci调试器，看到了\n./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#x27; not found (required by ./libxxx.so)\n\n测试能通过的so中是没有类似的错误信息。使用strings /usr/lib/x86_64-linux-gnu/libc.so.6 查看其中的glibc版本信息，发现其中并没有我们所需的版本（注意不要去看libc.so，它虽然叫so但不是动态链接库，用file可以看到实际上是一个文本文件）\n这时可以确认问题就在这里了。\n“失误”这个时候我觉得离谱的是这个库我是通过github ci编译的，最后ci不能通过，也许还有什么因素应该控制但是我没有做好的。\n本来还想吐槽这个，最后想办法处理GLIBC版本不一致的时候发现自己编的时候用的是ubuntu-latest的ci…而测试的地方是18.04。这一部分是我不知道从哪里直接就拷贝过来的，没有确认是否有问题就进行拷贝（之前也没有遇到过这样的情况，确认可能也不会想到这一点。但是我也确实没有进行过核对）\n同时这次的经历意识到了自己编的库还是应该尽量依赖低版本的glibc\n关于glibc和GLIBC_XX这个我整理起来发现东西不少，以及要控制一下文章长度，因此整理到了另一篇博客上\nhttps://homura.live/2022/03/29/glibc-version/\n问题总结\nGLIBC的version版本对应不上（错误的根本原因）\n在写编译的ci的时候没有认真写，而是随便找了一个抄上就完事（错误的产生原因）\n没有一套严谨的确认问题的思路（花费了我大半天的原因）\n\n太多意想不到的地方出了问题，不论是ldd还是最后发现是系统版本错，也许是自己在这些地方都没有太注意，最后各种小问题堆积太多导致出现了这种坑。\n事后诸葛亮在此写一下理想的解决思路应该是怎么样的\n\n发现CI出现问题，查看错误是DllNotFoundException\n本地相同系统测试能通过，那么要确认查找的过程没有问题。多半是要排除掉环境变量的影响因素\n确认路径查找是没有问题的以后进入CI环境查看dll的状态\nldd查看依赖是否满足（本次错误看到a即可）\n如果依赖满足的则再手动链接查看是否有undefined的符号之类\n\n\n发现是glibc的问题，确认是否真的找不到版本（这里我真的遇到过（虽然是GLIBCXX）…安了conda以后因为会先找到conda的glibc，而这个版本可能又是不合要求的，然后就会报错了..解决方案是直接修改链接，如果你遇到类似的问题一搜就能搜到解决方案）\nglibc通常和环境有关，真的是没有匹配版本那么要查看环境的不同\n由于是ci环境，那么肯定首先要看ci的yaml文件，对比配置的差异（问题解决）\n\n先确认第三步其实也可以，最好的情况下我们先去做了第三步是会省了第二步的问题。但我觉得这种dll链接相关的路径查找的问题可能更多一些，总之这些都是需要确认的步骤。\n这个思路是在本地能够通过测试的前提条件下。需要调的这种情况一般是要合并了之类，这种情况肯定是要先在本地做好测试的。没有做好的情况肯定是要先测试的\n一些想法自己经常会遇到这种离谱的问题，然而每个问题看起来再离谱最终都是会找到原因的，而且这个原因往往出现在意想不到的地方。想要减少这种现象的出现，只有明确自己行为的后果，以及不断踩坑的过程中形成一套自己的应对策略。（如果是别人的库那首先要注意的肯定是查看相关位置的源码）\n这些问题的解决方式大多貌似都是口口相传，因此我打算再遇到这样类似的问题就进行一个记录。记录下我的思路，最终是如何解决问题的以及在这个途中有什么错误的想法，尽量避免第二次犯同样的错误，不断反思形成一套自己的解决问题方案，同时又会重新回顾在这之中有什么细节或者知识点是遗漏的。以后会增加更多这样的博客\n遇到这种问题很重要的一点是如果不能调试，那解决问题可能要付出成倍的时间代价。像这个例子如果我不进去ci环境查看，也比较难确定是否真的是版本问题，不断更新ci打log也可以，但是非常非常麻烦且低效。\n后面应该再写一个链接问题定位的博客（写的话大概会说一些自己踩过的坑）。我的思路未必全面，但是一定有着参考价值（下次一定，在新建文件了，难不成我还能咕咕咕吗）\n","categories":["Debug"],"tags":["Link","CI"]},{"title":"Rc-lang开发周记14 重构与AST Visitor","url":"/2022/04/10/rc-lang-dev-14/","content":"\n非pixiv作品 \n\n本周先是解决了上周遗留下来的一个非常头疼的问题，之后重构了Token和AST的定义以及考虑了一下Visitor。之后也编写了建立符号表的代码以及一半转换到vm指令的代码，但是总觉得哪里不太对劲就先停了下来，后续确认无误了再一起拿出来讲。还学习了一些rust的实现方式，关于IR方面有更多了解以后有意向再单独出一篇文章讲解自己的一些了解\nPackratReader上周为了解决左递归的语法使用了PackratParser，但是这会引入一个问题，PackratParser会使用PackratReader管理输入，而PackratReader并没有重载toString，因此在log的时候都是类似于\ntrying class member at scala.util.parsing.combinator.PackratParsers$$anon$1@4d3167f4\n\n我的解决思路如下\n首先尝试继承并且实现一个自己的PackratReader，因为之前TokenReader就是继承并实现了Reader。但是发现经过了PackratParser的处理后又会变成系统自带的reader\n查看源码发现有这么一段内容\ndef rest: Reader[T] = new PackratReader(underlying.rest) &#123;  override private[PackratParsers] val cache = outer.cache  override private[PackratParsers] val recursionHeads = outer.recursionHeads  lrStack = outer.lrStack&#125;\n\n可以看到每次获取rest的时候都会重新构造一个PackratReader，因此继承这条路行不通。之后我的思路一直在想着如何hack这个类的toString（用ruby的话我一定会这么做的，对于ruby来说这种做法是理所应当的），但是对于Scala来说并没有那么过分的元编程能力（至少我没有搜寻到相关解决方案）。\n反复尝试无果后，只好继续硬调代码了。调试的过程中偶然想到我可以重载log这个函数，前面的思路都是我需要它的字符串，但是我实际的需求是能够log输出正确的信息\n这是我重载以后的行为\nprivate def take[T](p: Reader[T], n: Int): List[T] = &#123;  if (n &gt; 0 &amp;&amp; !p.atEnd) then p.first::take(p.rest, n - 1) else Nil&#125;override def log[T](p: =&gt; Parser[T])(name: String): Parser[T] = Parser&#123; in =&gt;  in match &#123;    case reader: PackratReader[Token] =&gt;      println(s&quot;trying $&#123;name&#125; at ($&#123;take(reader, 3).mkString(&quot;, &quot;)&#125;)&quot;)    case _ =&gt;      println(&quot;trying &quot; + name + &quot; at &quot; + in)  &#125;  val r = p(in)  println(name +&quot; --&gt; &quot;+ r)  r&#125;\n\n这是原本的实现\ndef log[T](p: =&gt; Parser[T])(name: String): Parser[T] = Parser&#123; in =&gt;  println(&quot;trying &quot;+ name +&quot; at &quot;+ in)  val r = p(in)  println(name +&quot; --&gt; &quot;+ r)  r&#125;\n\n重构Token之前的博客也提到过Token的定义不太好，之前思路过于死板，只想着用enum来解决，但是这里可以更灵活的将trait和enum组合起来，可以通过类型更好的区分不同的Token，AST也是如此。以下这是新的定义的部分代码\ntrait Token extends Positionalenum Literal extends Token:  case NUMBER(int: Int)  case STRING(str: String)  case TRUE  case FALSEenum Delimiter extends Token:  case LEFT_PARENT_THESES  case RIGHT_PARENT_THESES  case LEFT_SQUARE  case RIGHT_SQUAREenum Ident extends Token:  case IDENTIFIER(str: String)  case UPPER_IDENTIFIER(str: String)enum Keyword extends Token:  // local  case VAR  case VAL  // method  case DEF  case RETURN  case END\n\n据我所了解rust的trait是不能携带变量的，在这方面上Scala好用的多，不需要再在每个Token里面保存一个position信息\n举一个这样写法实际比较有帮助的例子，比如说我现在Lexer结束获得了一个List[Token]，想要将其中Keyword的部分全部提取出来并且将这些信息传给编辑器插件高亮处理，那么我不需要再费力的去写一个麻烦的逻辑判断是否是Keyword的方法，而是直接匹配类型。再写其他逻辑不仅是麻烦的问题，实际也容易出错，比如说漏掉什么或者多写了什么，而这些东西直接写到类型定义中大大减少了问题的产生\n我没有写过插件，不知道实际是否是需要这样，但是这种想法和思路都是一样的\n实际处理代码\ntokens.filter &#123;  case k: Keyword =&gt; true  case _ =&gt; false&#125;\n\nAST大体思路都在Token部分讲的差不多了，这里贴一下部分关键的AST定义就好了\ntrait ASTNode extends Positionalenum Expr extends ASTNode:  case Number(v: Int)  case Identifier(ident: Ident)  case Bool(b: Boolean)  case Binary(op: BinaryOp, lhs: Expr, rhs: Expr)  case Str(str: String)  // false -&gt; elsif | else  case If(cond: Expr, true_branch: Block, false_branch: Option[Expr])  case Lambda(args: List[Expr], stmts: List[Expr])  case Call(target: Ident, args: List[Expr])  case MethodCall(obj: Expr, target: Ident, args: List[Expr])  case Block(stmts: List[Stmt])  case Return(expr: ast.Expr)  case Field(expr: Expr, ident: Ident)  case Self  case Constant(ident: Ident)  case Index(expr: Expr, i: Expr)enum Stmt extends ASTNode:  case Local(name: Ident, ty: Type, value: ast.Expr)  case Expr(expr: ast.Expr)  case While(cond: ast.Expr, stmts: Block)  case Assign(name: Ident, value: ast.Expr)\n\n之前写的str与Id的隐式转换函数放到了一个object中，需要的时候直接import这个object中的一个函数或者全部函数，将隐式转换函数都放在一个位置进行管理\nobject ImplicitConversions &#123;  implicit def strToId(str: String): Ident = Ident(str)  implicit def IdToStr(id: Ident): String = id.str  implicit def boolToAST(b: Boolean): Expr.Bool = Expr.Bool(b)  implicit def intToAST(i: Int): Expr.Number = Expr.Number(i)&#125;\n\n需要用到的时候\nimport ast.ImplicitConversions.*\n\nAST Visitor思路虽然在公司做的ai compiler的项目里也有visitor，但那终究只是对特殊形式对expr处理的，也可以说是针对一种DSL的，并不能直接套用。之前用ruby写的版本存在很多问题，同时也使用了动态语言才能写出来的方式。\n编写遍历的时候关键在于遍历函数的签名。除了结点本身之外应当传递什么参数？返回值又是怎样的？\n我的思路是先想一下之后的使用场景是怎么样的。能想到的场景大致有这么几种\n\nast check\ntype infer\nlower\n其他pass\n\nast check这个显然是要遍历所有结点\ntype infer没有做过，对于实际要怎么做我还没有一个思路\nlower在很多编译器也是作为一种pass存在，而我目前暂时想先作为一个单独的流程存在。\n其他pass只是参与过公司项目，但是传统compiler还没有做过。关于这个我还存有许多问题，比如说都会用到什么样的访问方式？我目前想到的方面是针对表达式或者说某个特定类型的结点进行处理，那么应用的时候是需要做\n最后结论还是去学习一下前人的做法，尝试查看Scala和rust的实现，Scala实现方式过于复杂，因此最终参考的是rust的实现（但Scala但是实现我还是挺感兴趣但，可能会再花一些时间研究一下）\nrustrust中写了一个visitor的trait，其中包含了各种ast中出现的内容：crate，stmt，ident等都有。其中每一个visit_xxx的默认实现都是调用了walk_xxx，而walk是访问当前这个节点的所有成员，因此默认实现的整个逻辑是：先进入visit，visit调用到了walk，walk对每一个节点进行visit，而每个节点的visit又是调用了walk\n从上面提及的函数签名的角度来看，传递了一个所需的ast结点，无返回值\npub trait Visitor&lt;&#x27;ast&gt;: Sized &#123;...\tfn visit_crate(&amp;mut self, krate: &amp;&#x27;ast Crate) &#123;\t    walk_crate(self, krate)\t&#125;&#125;pub fn walk_crate&lt;&#x27;a, V: Visitor&lt;&#x27;a&gt;&gt;(visitor: &amp;mut V, krate: &amp;&#x27;a Crate) &#123;    walk_list!(visitor, visit_item, &amp;krate.items);    walk_list!(visitor, visit_attribute, &amp;krate.attrs);&#125;\n\n这里有一个小问题我即便在写到这里的时候我还是没能理解，为什么要传一个visitor进来，直接作为trait的成员不就好了吗？rust的高层IR有好几层，起初我以为是为了给其他的ir使用（思考完这个问题我才意识到这是一个不良设计，每一层的东西应当隔离开来），但经过查看每一层但IR都是完全单独的visitor和walk，偶尔使用walk也是在impl ast visitor的时候\n实现选取片段\ntrait ASTVisitor &#123;  type R = Unit  def visit(modules: Modules): R = visitRecursive(modules)  def visit(module: RcModule): R = visitRecursive(module)  def visit(item: Item): R = visitRecursive(item)  def visit(expr: Expr): R = visitRecursive(expr)\t...\tfinal def visitRecursive(item: Item): R = &#123;\t    item match &#123;\t      case method: Item.Method =&gt; visit(method)\t      case klass: Item.Class =&gt; visit(klass)\t      case _ =&gt; throw new RuntimeException(&quot;NoneItem&quot;)\t    &#125;\t  &#125;\t...&#125;\n\n关于返回值的地方我也纠结了一下，虽然留有了一个R的类型，但是没想好之后怎么用。因此就先这样实现吧，之后根据需求再改。在不了解的情况下不应当想着一口气写出合适的实现，而是先从能用开始，再不断修改\n","categories":["Compiler"],"tags":["Rc-lang","Rust","AST"]},{"title":"Rc-lang开发周记15 Rust源码学习之desugar","url":"/2022/04/17/rc-lang-dev-15/","content":"\npixiv:68232005 \n\n这周可以说几乎没写什么代码，都在学习别人的实现。在参考别人的做法之前自己写一版比较合适，这样会对整体有个了解（这样有利于阅读代码），知道哪些地方会有问题，看别人的代码后会发现哪里不一样并且去思考差异。不过我之前已经写过简易的实现了，因此直接来参考Rust的实现了\n本周看的内容一半是desugar，另一半是关于MIR的。讲解的话目前先讲一下desugar的内容，内容相对较少能够一篇讲完。MIR的东西非常多，笔记也没有整理好，之后会单独开启一个源码阅读系列的坑\n在讲之前首先要提的是为什么要学习他人的实现。尽管写出来能跑是没有问题的，但是参考这样的项目的过程中能学到他人写代码的方式，学到更多不一样的实现方式\ndesugar是什么我们现在在使用的编程语言中有一些语法糖，这些语法糖本质上是对一些功能的包装，让我们用的更方便，但是没有做到一些什么没有这个语法糖所做不到的东西。\n这里举一个很直观的例子，ruby中有一个关键字是unless，它的功能是如果false则执行第一个分支，否则执行第二个分支，相当于if !cond\n为什么需要上面也提到了只是包装，那么可能多种不同形式的语法糖都是针对同一种功能，像C语言中的while和for本质都是一个loop（Rust的for并不是，后面会提到这种for的desugar过程）\ndesugar的过程是将这些都转换为了更本质的东西，我觉得这属于一种“去重”的过程。还是上面的例子，假设需要对loop做优化，没有desugar的情况下我们需要对while和for两者都进行处理，两者又有轻微的差别，导致实现起来更不方便，每个优化都需要对这些细节做处理，那不如直接全部转换成一种形式来处理处理\n关于Rust的文档中的介绍是这样\n\nThis means many structures are removed if they are irrelevant for type analysis or similar syntax agnostic analyses.\n\nRust的实现官方的文档介绍\nhttps://rustc-dev-guide.rust-lang.org/lowering.html\n在这里我要给Rust一个好评，开发文档比较详细，而且一些注释也相对容易懂一些。后面的很多东西都会以注释为参考讲了大概做了什么，注意这里我们的目的并不是搞清楚细节，而是搞清楚都做了什么操作，所以细节部分点到为止，细节深究下去是无底洞，有兴趣可以去源码处深入看一下\ndesugar相关代码不特别说明根目录都是rustc_ast_lowering\n读代码之前需要了解的了解了这些能够更容易看明白代码\n\n各种参数更多是使用ir来标识以及获取的\nspan用于记录源码相关信息\narean.alloc是用于分配构建ir的，看实现的时候不需要在意这里的细节，只需要看传进去的IR\n\nDesugaringKind这个类型在rustc_span/src/hygine.rs中\n实际使用的时候主要用于创建span的时候填入相关信息，因此并没有放到ast_lowering的位置\npub enum DesugaringKind &#123;    /// We desugar `if c &#123; i &#125; else &#123; e &#125;` to `match $ExprKind::Use(c) &#123; true =&gt; i, _ =&gt; e &#125;`.    /// However, we do not want to blame `c` for unreachability but rather say that `i`    /// is unreachable. This desugaring kind allows us to avoid blaming `c`.    /// This also applies to `while` loops.    CondTemporary,    QuestionMark,    TryBlock,    /// Desugaring of an `impl Trait` in return type position    /// to an `type Foo = impl Trait;` and replacing the    /// `impl Trait` with `Foo`.    OpaqueTy,    Async,    Await,    ForLoop,    LetElse,    WhileLoop,&#125;\n\n先不考虑Async和Await，我们来一个个说其他的\nCondTemporary这部分都在src/expr.rs中\n我们先来看一下它的调用位置，发现是在manage_let_cond这个函数中\n// If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`// in a temporary block.fn manage_let_cond(&amp;mut self, cond: &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt;) -&gt; &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt; &#123;    fn has_let_expr&lt;&#x27;hir&gt;(expr: &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt;) -&gt; bool &#123;        match expr.kind &#123;            hir::ExprKind::Binary(_, lhs, rhs) =&gt; has_let_expr(lhs) || has_let_expr(rhs),            hir::ExprKind::Let(..) =&gt; true,            _ =&gt; false,        &#125;    &#125;    if has_let_expr(cond) &#123;        cond    &#125; else &#123;        let reason = DesugaringKind::CondTemporary;        let span_block = self.mark_span_with_reason(reason, cond.span, None);        self.expr_drop_temps(span_block, cond, AttrVec::new())    &#125;&#125;\n\n转换条件根据函数名和参数我们可以得知这个是处理cond不为let的情况下，既然是cond那么应当会出现在while和if中\n实现实际查看manage_let_cond的usage也正是如此。这两处的处理都是类似的，因此我选取一段来介绍\nlet lowered_cond = self.lower_expr(cond);let new_cond = self.manage_let_cond(lowered_cond);\n\n可以看到十分简单，就是先对cond本身lower，然后再对整个cond lower\n然后我们再回到manage_let_cond的实现中\n根据实现可以看到对expr递归判断，如果包含let则直接返回原始cond，否则进行转换\nspan_block是用于记录信息的，关键在expr_drop_temps中\n本质行为进入实现可以看到\n/// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.////// In terms of drop order, it has the same effect as wrapping `expr` in/// `&#123; let _t = $expr; _t &#125;` but should provide better compile-time performance.////// The drop order can be important in e.g. `if expr &#123; .. &#125;`.pub(super) fn expr_drop_temps(    &amp;mut self,    span: Span,    expr: &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt;,    attrs: AttrVec,) -&gt; &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt; &#123;    self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))&#125;pub(super) fn expr_drop_temps_mut(    &amp;mut self,    span: Span,    expr: &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt;,    attrs: AttrVec,) -&gt; hir::Expr&lt;&#x27;hir&gt; &#123;    self.expr(span, hir::ExprKind::DropTemps(expr), attrs)&#125;\n\n实际做的事情就是转换为了DropTemps这种类型的Expr\nQuestionMark是什么QuestionMark是Result为Err或者Option为None的时候直接抛出错误的一种语法糖，摘选一段官方的例子\n#![allow(unused_variables)]fn main() &#123;use std::num::ParseIntError;fn try_to_parse() -&gt; Result&lt;i32, ParseIntError&gt; &#123;    let x: i32 = &quot;123&quot;.parse()?; // x = 123    let y: i32 = &quot;24a&quot;.parse()?; // returns an Err() immediately    Ok(x + y)                    // Doesn&#x27;t run.&#125;let res = try_to_parse();println!(&quot;&#123;:?&#125;&quot;, res);assert!(res.is_err())&#125;\n\n查看QuestionMark的usage，找到了lower_expr_try这个函数\n做了什么先来看注释，这里的注释可以说是非常清楚了，将一个QuestionMark转换为了一个模式匹配\n/// Desugar `ExprKind::Try` from: `&lt;expr&gt;?` into:/// ```rust/// match Try::branch(&lt;expr&gt;) &#123;///     ControlFlow::Continue(val) =&gt; #[allow(unreachable_code)] val,,///     ControlFlow::Break(residual) =&gt;///         #[allow(unreachable_code)]///         // If there is an enclosing `try &#123;...&#125;`:///         break &#x27;catch_target Try::from_residual(residual),///         // Otherwise:///         return Try::from_residual(residual),/// &#125;/// ```\n\n实现函数签名\nfn lower_expr_try(&amp;mut self, span: Span, sub_expr: &amp;Expr) -&gt; hir::ExprKind&lt;&#x27;hir&gt;\n\n既然是返回了一个match，那么我们先看一下Expr::Match的结构\n/// A `match` block, with a source that indicates whether or not it is/// the result of a desugaring, and if so, which kind.Match(&amp;&#x27;hir Expr&lt;&#x27;hir&gt;, &amp;&#x27;hir [Arm&lt;&#x27;hir&gt;], MatchSource)\n\n根据注释的内容看上去分为三个部分\n\nTry::branch()\n\n非常直接的操作，直接lower传进来的sub_expr\n// `Try::branch(&lt;expr&gt;)`let scrutinee = &#123;    // expand &lt;expr&gt;    let sub_expr = self.lower_expr_mut(sub_expr);    self.expr_call_lang_item_fn(        unstable_span,        hir::LangItem::TryTraitBranch,        arena_vec![self; sub_expr],        None,    )&#125;;\n\n\nControlFlow::Continue(val)\n\n// `ControlFlow::Break(residual) =&gt;//     #[allow(unreachable_code)]//     return Try::from_residual(residual),`let break_arm = &#123;\t\t... // 省略    let break_pat = self.pat_cf_break(try_span, residual_local);    self.arm(break_pat, ret_expr)&#125;;\n\n这里的arm是构建了hir的Match的Arm参数\n\nControlFlow::Break(residual)\n\n// `ControlFlow::Break(residual) =&gt;//     #[allow(unreachable_code)]//     return Try::from_residual(residual),`let break_arm = &#123;\t\t... // 省略    let break_pat = self.pat_cf_break(try_span, residual_local);    self.arm(break_pat, ret_expr)&#125;;\n\n和上面差不多，细节都在省略的部分\n在实际的处理中在最前面的有一部分像上面的CondTemporary一样，先创建一个span用于记录源码相关的信息，源码不再赘述\n还会创建一个*#[allow(unreachable_code)]* 供后面的match使用\nlet attr = &#123;    // `allow(unreachable_code)`    let allow = &#123;        let allow_ident = Ident::new(sym::allow, self.lower_span(span));        let uc_ident = Ident::new(sym::unreachable_code, self.lower_span(span));        let uc_nested = attr::mk_nested_word_item(uc_ident);        attr::mk_list_item(allow_ident, vec![uc_nested])    &#125;;    attr::mk_attr_outer(allow)&#125;;let attrs = vec![attr];\n\nTryBlock在lower_expr_try_block中被用到\n做了什么这里的注释解释的比较清楚了，我就不再赘述\n/// Desugar `try &#123; &lt;stmts&gt;; &lt;expr&gt; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(&lt;expr&gt;) &#125;`,/// `try &#123; &lt;stmts&gt;; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(()) &#125;`/// and save the block id to use it as a break target for desugaring of the `?` operator.\n\n最终都是转换为一个包含stmts和::std::ops::Try::from_output的block\n实现我们从返回值往上看，可以看到返回了一个Block，Block的第二个参数是Label，这里并不需要因此设置为了None\n那么我们顺着第一个参数block往上看来源，又回到了函数的开始\n和注释所讲的一样，根据是否有一个expr来做两种不同的处理方式，也是比较直观的实现\nfn lower_expr_try_block(&amp;mut self, body: &amp;Block) -&gt; hir::ExprKind&lt;&#x27;hir&gt; &#123;    self.with_catch_scope(body.id, |this| &#123;        let mut block = this.lower_block_noalloc(body, true);        // Final expression of the block (if present) or `()` with span at the end of block        let (try_span, tail_expr) = if let Some(expr) = block.expr.take() &#123;            (                this.mark_span_with_reason(                    DesugaringKind::TryBlock,                    expr.span,                    this.allow_try_trait.clone(),                ),                expr,            )        &#125; else &#123;            let try_span = this.mark_span_with_reason(                DesugaringKind::TryBlock,                this.sess.source_map().end_point(body.span),                this.allow_try_trait.clone(),            );            (try_span, this.expr_unit(try_span))        &#125;;        let ok_wrapped_span =            this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, None);        // `::std::ops::Try::from_output($tail_expr)`        block.expr = Some(this.wrap_in_try_constructor(            hir::LangItem::TryTraitFromOutput,            try_span,            tail_expr,            ok_wrapped_span,        ));        hir::ExprKind::Block(this.arena.alloc(block), None)    &#125;)&#125;\n\nOpaqueTyOpaqueTy是什么OpaqueTy是impl Trait的一种别名，看一下这个例子\ntype Foo = impl Bar;\n\n实际参数使用Foo的时候只能使用Bar中的接口，不论实现了Bar的类型是否实现了其他类型\nlower做了什么关于这个lower的操作，在DesugaringKind::OpaqueTy的位置写的非常清楚了，只是做了简单的类型替换\n/// Desugaring of an `impl Trait` in return type position/// to an `type Foo = impl Trait;` and replacing the/// `impl Trait` with `Foo`.\n\nlower操作lower操作在lower_opaque_impl_trait这个函数中(src/lib.rs)\nfn lower_opaque_impl_trait(        &amp;mut self,        span: Span,        fn_def_id: Option&lt;LocalDefId&gt;,        origin: hir::OpaqueTyOrigin,        opaque_ty_node_id: NodeId,        capturable_lifetimes: Option&lt;&amp;FxHashSet&lt;hir::LifetimeName&gt;&gt;,        lower_bounds: impl FnOnce(&amp;mut Self) -&gt; hir::GenericBounds&lt;&#x27;hir&gt;,    ) -&gt; hir::TyKind&lt;&#x27;hir&gt; \n\n来看一下返回值的部分，可以看到主要处理分为两部分，一部分是处理ID相关的，另一部分是处理lifetime\n// `impl Trait` now just becomes `Foo&lt;&#x27;a, &#x27;b, ..&gt;`.    hir::TyKind::OpaqueDef(hir::ItemId &#123; def_id: opaque_ty_def_id &#125;, lifetimes)&#125;\n\n这里也就不展开了，上面的细节很多是关于type相关的，这部分我不了解，内容也比较长。\nlower_opaque_impl_trait这个函数则是被在上面的lower_ty_direct()调用\n...TyKind::ImplTrait(def_node_id, ref bounds) =&gt; &#123;  let span = t.span;  match itctx &#123;      ImplTraitContext::ReturnPositionOpaqueTy &#123; fn_def_id, origin &#125; =&gt; self          .lower_opaque_impl_trait(              span,              Some(fn_def_id),              origin,              def_node_id,              None,              |this| this.lower_param_bounds(bounds, itctx),          ),      ImplTraitContext::TypeAliasesOpaqueTy &#123; ref capturable_lifetimes &#125; =&gt; &#123;          // Reset capturable lifetimes, any nested impl trait          // types will inherit lifetimes from this opaque type,          // so don&#x27;t need to capture them again.          let nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy &#123;              capturable_lifetimes: &amp;mut FxHashSet::default(),          &#125;;          self.lower_opaque_impl_trait(              span,              None,              hir::OpaqueTyOrigin::TyAlias,              def_node_id,              Some(capturable_lifetimes),              |this| this.lower_param_bounds(bounds, nested_itctx),          )      &#125;...\n\n可以看到这里的TypeKind为ImplTrait且ImplTraitContext为TypeAliasesOpaqueTy或者ReturnPositionOpaqueTy的时候才会做这个desugar操作\n\n 这里我其实不是很明白。。\n\nImpltraitContext来看一下ImpltraitContext，根据Disallowed注释大意和成员可以得知这个类主要关联了一个位置是否可以使用impl trait\n/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,/// and if so, what meaning it has.#[derive(Debug)]enum ImplTraitContext&lt;&#x27;b, &#x27;a&gt; &#123;    /// Treat `impl Trait` as shorthand for a new universal generic parameter.    /// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually    /// equivalent to a fresh universal parameter like `fn foo&lt;T: Debug&gt;(x: T)`.    ///    /// Newly generated parameters should be inserted into the given `Vec`.    Universal(&amp;&#x27;b mut Vec&lt;hir::GenericParam&lt;&#x27;a&gt;&gt;, LocalDefId),    /// Treat `impl Trait` as shorthand for a new opaque type.    /// Example: `fn foo() -&gt; impl Debug`, where `impl Debug` is conceptually    /// equivalent to a new opaque type like `type T = impl Debug; fn foo() -&gt; T`.    ///    ReturnPositionOpaqueTy &#123;        /// `DefId` for the parent function, used to look up necessary        /// information later.        fn_def_id: LocalDefId,        /// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,        origin: hir::OpaqueTyOrigin,    &#125;,    /// Impl trait in type aliases.    TypeAliasesOpaqueTy &#123;        /// Set of lifetimes that this opaque type can capture, if it uses        /// them. This includes lifetimes bound since we entered this context.        /// For example:        ///        /// ```        /// type A&lt;&#x27;b&gt; = impl for&lt;&#x27;a&gt; Trait&lt;&#x27;a, Out = impl Sized + &#x27;a&gt;;        /// ```        ///        /// Here the inner opaque type captures `&#x27;a` because it uses it. It doesn&#x27;t        /// need to capture `&#x27;b` because it already inherits the lifetime        /// parameter from `A`.        // FIXME(impl_trait): but `required_region_bounds` will ICE later        // anyway.        capturable_lifetimes: &amp;&#x27;b mut FxHashSet&lt;hir::LifetimeName&gt;,    &#125;,    /// `impl Trait` is not accepted in this position.    Disallowed(ImplTraitPosition),&#125;\n\n而在上面只有ReturnPositionOpaqueTy和TypeAliasesOpaqueTy的情况下可以使用，当然从名字就可以看出来这两种情况就是为了OpaqueTy而设计的\nForLoop调用处的函数签名\nfn lower_expr_for(        &amp;mut self,        e: &amp;Expr,        pat: &amp;Pat,        head: &amp;Expr,        body: &amp;Block,        opt_label: Option&lt;Label&gt;,    ) -&gt; hir::Expr&lt;&#x27;hir&gt; &#123;\n\n注释写的非常详细了，将一个ForLoop转换为一个iterator操作\n/// Desugar `ExprForLoop` from: `[opt_ident]: for &lt;pat&gt; in &lt;head&gt; &lt;body&gt;` into:/// ```rust/// &#123;///     let result = match IntoIterator::into_iter(&lt;head&gt;) &#123;///         mut iter =&gt; &#123;///             [opt_ident]: loop &#123;///                 match Iterator::next(&amp;mut iter) &#123;///                     None =&gt; break,///                     Some(&lt;pat&gt;) =&gt; &lt;body&gt;,///                 &#125;;///             &#125;///         &#125;///     &#125;;///     result/// &#125;/// ```\n\n实现比较长就不贴了，想要了解更详细的可以去源码处查看\nLetElse什么情况会转换在lower_let_else中被调用，而这个lower_let_else则是在lower_stmts中\n这是lower_stmts中的处理代码，可以看到是InitElse的情况下会进行处理\nlet mut expr = None;        while let [s, tail @ ..] = ast_stmts &#123;            match s.kind &#123;                StmtKind::Local(ref local) =&gt; &#123;                    let hir_id = self.lower_node_id(s.id);                    match &amp;local.kind &#123;                        LocalKind::InitElse(init, els) =&gt; &#123;                            let e = self.lower_let_else(hir_id, local, init, els, tail);                            expr = Some(e);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// remaining statements are in let-else expression                            break;\n\n注意这里的break\n来看一下InitElse\npub enum LocalKind &#123;\t...\t/// Local declaration with an initializer and an `else` clause.\t/// Example: `let Some(x) = y else &#123; return &#125;;`\tInitElse(P&lt;Expr&gt;, P&lt;Block&gt;),&#125;\n\n实现函数签名\nfn lower_let_else(        &amp;mut self,        stmt_hir_id: hir::HirId,        local: &amp;Local,        init: &amp;Expr,        els: &amp;Block,        tail: &amp;[Stmt],    ) -&gt; &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt; &#123;\n\n一开始看到函数签名中的tail产生了一些疑惑，不知道用途是什么。一开始想到的是会往里添加东西，但是一看类型是immutable的（传进来的是一个array的slice），后面看到调用处的break才明白过来，具体用途后面会讲到\nfn lower_let_else(        &amp;mut self,        stmt_hir_id: hir::HirId,        local: &amp;Local,        init: &amp;Expr,        els: &amp;Block,        tail: &amp;[Stmt],    ) -&gt; &amp;&#x27;hir hir::Expr&lt;&#x27;hir&gt; &#123;\tlet ty = local\t      .ty\t      .as_ref()\t      .map(|t| self.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));  let span = self.lower_span(local.span);  let span = self.mark_span_with_reason(DesugaringKind::LetElse, span, None);  let init = self.lower_expr(init);  let local_hir_id = self.lower_node_id(local.id);  self.lower_attrs(local_hir_id, &amp;local.attrs);  let let_expr = &#123;      let lex = self.arena.alloc(hir::Let &#123;          hir_id: local_hir_id,          pat: self.lower_pat(&amp;local.pat),          ty,          init,          span,      &#125;);      self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))  &#125;;  let then_expr = &#123;      let (stmts, expr) = self.lower_stmts(tail);      let block = self.block_all(span, stmts, expr);      self.arena.alloc(self.expr_block(block, AttrVec::new()))  &#125;;  let else_expr = &#123;      let block = self.lower_block(els, false);      self.arena.alloc(self.expr_block(block, AttrVec::new()))  &#125;;  self.alias_attrs(let_expr.hir_id, local_hir_id);  self.alias_attrs(else_expr.hir_id, local_hir_id);  let if_expr = self.arena.alloc(hir::Expr &#123;      hir_id: stmt_hir_id,      span,      kind: hir::ExprKind::If(let_expr, then_expr, Some(else_expr)),  &#125;);  if !self.sess.features_untracked().let_else &#123;      feature_err(          &amp;self.sess.parse_sess,          sym::let_else,          local.span,          &quot;`let...else` statements are unstable&quot;,      )      .emit();  &#125;  if_expr&#125;\n\n我们从返回值向上看，可以看到if_expr的参数是let_expr, then_expr, else_expr\n\nlet_expr的部分转成了HIR的let\n\nlet let_expr = &#123;    let lex = self.arena.alloc(hir::Let &#123;        hir_id: local_hir_id,        pat: self.lower_pat(&amp;local.pat),        ty,        init,        span,    &#125;);    self.arena.alloc(self.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))&#125;;\n\n我们来看一下定义和注释\n/// Represents a `let &lt;pat&gt;[: &lt;ty&gt;] = &lt;expr&gt;` expression (not a Local), occurring in an `if-let` or/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.////// In an if-let, imagine it as `if (let &lt;pat&gt; = &lt;expr&gt;) &#123; ... &#125;`; in a let-else, it is part of the/// desugaring to if-let. Only let-else supports the type annotation at present.#[derive(Debug, HashStable_Generic)]pub struct Let&lt;&#x27;hir&gt; &#123;    pub hir_id: HirId,    pub span: Span,    pub pat: &amp;&#x27;hir Pat&lt;&#x27;hir&gt;,    pub ty: Option&lt;&amp;&#x27;hir Ty&lt;&#x27;hir&gt;&gt;,    pub init: &amp;&#x27;hir Expr&lt;&#x27;hir&gt;,&#125;pub enum ExprKind&lt;&#x27;hir&gt; &#123;\t...\t/// A `let $pat = $expr` expression.  ///  /// These are not `Local` and only occur as expressions.  /// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.  Let(&amp;&#x27;hir Let&lt;&#x27;hir&gt;),\t...&#125;\n\n\nthen_expr\n\nlet then_expr = &#123;    let (stmts, expr) = self.lower_stmts(tail);    let block = self.block_all(span, stmts, expr);    self.arena.alloc(self.expr_block(block, AttrVec::new()))&#125;;\n\n这里解答了我对传进来的tail的疑惑。这里的意思是then的话那么会继续lower tail的部分，将这部分插入到then的block中\n\nelse_expr\n\nlet else_expr = &#123;    let block = self.lower_block(els, false);    self.arena.alloc(self.expr_block(block, AttrVec::new()))&#125;;\n\n这里将传进来的els（InitElse的else block）lower到了一个block\n实际做了什么转换单个看起来可能不够直观，将三个部分组合起来的话这个逻辑就是\ncond中创建了一个expr bind\ntrue：将后面的stmts lower到一个新的block中（因此外面需要break）\nfalse：将els的部分lower到block\nfalse为什么不lower tail像我一样不了解这里语法的情况会觉得false的行为很奇怪，false就不走tail了吗\n于是我就写了这样的一个用例\n#![feature(let_else)]fn main() &#123;    let y:Option&lt;i32&gt; = None;    let Some(x) = y else &#123;         println!(&quot;fail&quot;) &#125;;    println!(&quot;test&quot;);&#125;\n\n直接报了编译错误，else中的内容是要强制从当前函数返回才行\nerror[E0308]: `else` clause of `let...else` does not diverge --&gt; src/main.rs:4:26  |4 |       let Some(x) = y else &#123;   |  __________________________^5 | |         println!(&quot;fail&quot;) &#125;;  | |__________________________^ expected `!`, found `()`  |  = note: expected type `!`             found type `()`  = help: try adding a diverging expression, such as `return` or `panic!(..)`  = help: ...or use `match` instead of `let...else`For more information about this error, try `rustc --explain E0308`.error: could not compile `playground` due to previous error\n\nWhileLoop在lower_expr_mut中被调用，在外部创建span信息然后在lower_expr_while_in_loop_scope中实际进行lower\n...ExprKind::While(ref cond, ref body, opt_label) =&gt; &#123;      self.with_loop_scope(e.id, |this| &#123;          let span =              this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, None);          this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)      &#125;)  &#125;...\n\n做了什么注释也非常易懂，将一个while转换为一个loop加一个，cond作为一个if，cond为false则break\n// We desugar: `&#x27;label: while $cond $body` into://// ```// &#x27;label: loop &#123;//   if &#123; let _t = $cond; _t &#125; &#123;//     $body//   &#125;//   else &#123;//     break;//   &#125;// &#125;// ```//// Wrap in a construct equivalent to `&#123; let _t = $cond; _t &#125;`// to preserve drop semantics since `while $cond &#123; ... &#125;` does not// let temporaries live outside of `cond`.\n\n实现实际的实现代码也是非常直接，没什么可讲的\nfn lower_expr_while_in_loop_scope(    &amp;mut self,    span: Span,    cond: &amp;Expr,    body: &amp;Block,    opt_label: Option&lt;Label&gt;,) -&gt; hir::ExprKind&lt;&#x27;hir&gt; &#123;    let lowered_cond = self.with_loop_condition_scope(|t| t.lower_expr(cond));    let new_cond = self.manage_let_cond(lowered_cond);    let then = self.lower_block_expr(body);    let expr_break = self.expr_break(span, ThinVec::new());    let stmt_break = self.stmt_expr(span, expr_break);    let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);    let else_expr = self.arena.alloc(self.expr_block(else_blk, ThinVec::new()));    let if_kind = hir::ExprKind::If(new_cond, self.arena.alloc(then), Some(else_expr));    let if_expr = self.expr(span, if_kind, ThinVec::new());    let block = self.block_expr(self.arena.alloc(if_expr));    let span = self.lower_span(span.with_hi(cond.span.hi()));    let opt_label = self.lower_label(opt_label);    hir::ExprKind::Loop(block, opt_label, hir::LoopSource::While, span)&#125;\n\n最后本来以为desugar的东西比较少就想都写完，但是越写发现越多，这还忽略了很多细节上的东西，导致了文章比较长\n在读代码的时候一开始我是没看到DesugaringKind这个类型的，想着既然要lower，那么首先将ast和hir的定义进行比较。由于内容比较多，只选了熟悉的Expr和Stmt进行对比。查看实际有哪些成员发生了变化，之后再去找到实现的位置。查看实现的过程中偶然看到DesugaringKind，之后看的过程就顺畅了许多\n","categories":["Compiler","源码阅读"],"tags":["Rc-lang","Rust","Desugar"]},{"title":"Rc-lang开发周记16 Rust源码学习之初识类型","url":"/2022/04/26/rc-lang-dev-16/","content":"\n类型和猫咪先生有多少相似之处呢 pixiv:74795024 \n\n本周先了解了一些Rust Type相关的代码，之后开始写一些类型无关的语法检查。\n虽然上周看了Rust中desugar的代码，但我这里就先不做desugar了，现在东西比较少，没什么价值。由于语法检查还没写多少，xs因此留到下周讲解。本周还是讲一下我看Rust Type相关的信息的一些了解，其中大部分信息是文档中介绍的，在这里算是一个简单概括。\nhttps://rustc-dev-guide.rust-lang.org/ty.html\n不同的类型表示在Rust中，目前我看到的部分有这么“几种”类型\n\nast::Ty\nhir::Ty(rustc_hir::Ty)\nty::Ty\n\n关于ast::Ty到hir::Ty本质上是进行了desugar，所代表的Ty本质是没有变化的。至于为什么这么说，这就要谈及hir::Ty和ty::Ty的区别\nhir::Ty vs ty::Ty先来讲我认为最根本的区别。\nhir::Ty所表示的是在源码中出现的一个应当出现在需要类型位置的类型，换句话说它是关联到源码的Ty\n而ty::Ty则是编译器中对中间表示（这里是hir）分析过后产生的一种类型，包含了更切实的语义，换句话说是关联到编译器内部类型表示的Ty\n我来引用一下官方文档中出现的例子\nfn foo(x: u32) → u32 &#123; x &#125;\n\n在这段代码中出现了两个u32，很显然这段代码的上下文中这两个u32都是同一个类型（注意不同lifetime的type是不同类型的）\n每个u32本质上是关联到源码中某个位置的u32，比如说第一个关联的是源码第一行第10个字符开始的u32，而第二个则是关联到源码后面那个位置的u32。在没有type infer和type check之前我们并不知道是否关联相同的语义\n而对于最终的type infer以及type check之后在这个语义环境下这两个u32会被视为同一个类型，最终这两个u32会被转换为相同的ty::Ty\n文档中有这样一句\n\nthey have two different [Spans](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html) (locations).\n\n之后我们来看一下官方文档中的总结表格，一切描述都是围绕着同一个核心区别\n\n\n\nrustc_hir::Ty\nty::Ty\n\n\n\nDescribe the syntax of a type: what the user wrote (with some desugaring).\nDescribe the semantics of a type: the meaning of what the user wrote.\n\n\nEach rustc_hir::Ty has its own spans corresponding to the appropriate place in the program.\nDoesn’t correspond to a single place in the user’s program.\n\n\nrustc_hir::Ty has generics and lifetimes; however, some of those lifetimes are special markers like LifetimeName::Implicit.\nty::Ty has the full type, including generics and lifetimes, even if the user left them out\n\n\nfn foo(x: u32) → u32 { } - Two rustc_hir::Ty representing each usage of u32. Each has its own Spans, etc.- rustc_hir::Ty doesn’t tell us that both are the same type\nfn foo(x: u32) → u32 { } - One ty::Ty for all instances of u32throughout the program.- ty::Ty tells us that both usages of u32 mean the same type.\n\n\nfn foo(x: &amp;u32) -&gt; &amp;u32)- Two rustc_hir::Ty again.- Lifetimes for the references show up in the rustc_hir::Tys using a special marker, LifetimeName::Implicit.\nfn foo(x: &amp;u32) -&gt; &amp;u32)- A single ty::Ty.- The ty::Ty has the hidden lifetime param\n\n\n要注意一个我刚才没有详细提及的点，那就是lifetime。由于经常会省略编写lifetime因此对于hir来说很可能不会包含其信息，这样的信息都是会转成hir之后再隐式插入的\n类型之间转换流程根据文档所说，在ast转换为HIR的时候会做一些基本的type infer以及type check。在type infer的过程中会产生ty::Ty并实际进行检查\n发生转换的入口则是在ast_ty_to_ty这里，而这个函数则是在AstConv这个trait中\n先来简单看一下十分直观的函数签名，传入一个hir::Ty返回一个ty::Ty\n/// Parses the programmer&#x27;s textual representation of a type into our/// internal notion of a type.pub fn ast_ty_to_ty(&amp;self, ast_ty: &amp;hir::Ty&lt;&#x27;_&gt;) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.ast_ty_to_ty_inner(ast_ty, false, false)&#125;\n\nast_ty_to_ty_inner做了什么这个函数依然属于AstConv\nfn ast_ty_to_ty_inner(&amp;self, ast_ty: &amp;hir::Ty&lt;&#x27;_&gt;, borrowed: bool, in_path: bool) -&gt; Ty&lt;&#x27;tcx&gt; &#123;  let tcx = self.tcx();  let result_ty = match ast_ty.kind &#123; ... &#125;\tdebug!(?result_ty);  self.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);  result_ty&#125;\n\n先忽略转换的细节，看一下整体做了什么\n\n获取TyCtxt\n实际转换\n记录类型\n\ntcx和recordself.tcx和self.record都是AstConv本身未实现的方法\n再来看一下一个实现了AstConv的部分实现（以下涉及AstConv未实现的部分都会以FnCtxt的实现作为参考）\nimpl&lt;&#x27;a, &#x27;tcx&gt; AstConv&lt;&#x27;tcx&gt; for FnCtxt&lt;&#x27;a, &#x27;tcx&gt; &#123;  fn tcx&lt;&#x27;b&gt;(&amp;&#x27;b self) -&gt; TyCtxt&lt;&#x27;tcx&gt; &#123;    self.tcx  &#125;\tfn record_ty(&amp;self, hir_id: hir::HirId, ty: Ty&lt;&#x27;tcx&gt;, _span: Span) &#123;    self.write_ty(hir_id, ty)  &#125;&#125;impl FnCtxt &#123;\t#[inline]\tpub fn write_ty(&amp;self, id: hir::HirId, ty: Ty&lt;&#x27;tcx&gt;) &#123;    debug!(&quot;write_ty(&#123;:?&#125;, &#123;:?&#125;) in fcx &#123;&#125;&quot;, id, self.resolve_vars_if_possible(ty), self.tag());    self.typeck_results.borrow_mut().node_types_mut().insert(id, ty);    if ty.references_error() &#123;        self.has_errors.set(true);        self.set_tainted_by_errors();    &#125;  &#125;&#125;\n\ntcx没什么可说的，大多数都是这样简单的返回\nrecord_ty中将一个hir的id与它的Ty进行关联，而这个hir的id则是hir::Ty的id。如果只看FnCtxt的record_ty的本身很容易以为一定是其他有类型的东西（比如expr或者Fn）的id关联到一个类型，但是往上看调用处没想到还会将一个hir::Ty指向ty::Ty\nast_ty to ty内容比较多，这里选择几个讲一下\n先来看一下里面是什么样子的\nlet result_ty = match ast_ty.kind &#123;    hir::TyKind::Slice(ref ty) =&gt; tcx.mk_slice(self.ast_ty_to_ty(ty)),    hir::TyKind::Ptr(ref mt) =&gt; ...&#125;\n\n根据ast_ty的不同kind做不同处理（下面只选取某一个kind的处理方式讲解）\ninfer先来看一下infer\nhir::TyKind::Infer =&gt; &#123;    // Infer also appears as the type of arguments or return    // values in an ExprKind::Closure, or as    // the type of local variables. Both of these cases are    // handled specially and will not descend into this routine.    self.ty_infer(None, ast_ty.span)&#125;// impl AstConv for FnCtxtfn ty_infer(&amp;self, param: Option&lt;&amp;ty::GenericParamDef&gt;, span: Span) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    if let Some(param) = param &#123;        if let GenericArgKind::Type(ty) = self.var_for_def(span, param).unpack() &#123;            return ty;        &#125;        unreachable!()    &#125; else &#123;        self.next_ty_var(TypeVariableOrigin &#123;            kind: TypeVariableOriginKind::TypeInference,            span,        &#125;)    &#125;&#125;// Impl inferCtxtpub fn next_ty_var(&amp;self, origin: TypeVariableOrigin) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.tcx.mk_ty_var(self.next_ty_var_id(origin))&#125;#[inline]pub fn mk_ty_var(self, v: TyVid) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.mk_ty_infer(TyVar(v))&#125;#[inline]pub fn mk_ty_infer(self, it: InferTy) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.mk_ty(Infer(it))&#125;pub fn mk_ty(self, st: TyKind&lt;&#x27;tcx&gt;) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.interners.intern_ty(st, self.sess, &amp;self.gcx.untracked_resolutions)&#125;\n\n套娃比较多，不过内容也比较直观。关于intern_ty下一部分再仔细讲一下，先来看一下其他的例子\n注意一点，这里infer产生的代码是unchecked的，上面也提到过\n\n在type infer的过程中会产生ty::Ty并实际进行检查\n\n一些其他的hir::TyKind::Tup(fields) =&gt; tcx.mk_tup(fields.iter().map(|t| self.ast_ty_to_ty(t))),hir::TyKind::Slice(ref ty) =&gt; tcx.mk_slice(self.ast_ty_to_ty(ty)),hir::TyKind::Ptr(ref mt) =&gt; &#123;    tcx.mk_ptr(ty::TypeAndMut &#123; ty: self.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl &#125;)&#125;pub fn mk_tup&lt;I: InternAs&lt;[Ty&lt;&#x27;tcx&gt;], Ty&lt;&#x27;tcx&gt;&gt;&gt;(self, iter: I) -&gt; I::Output &#123;    iter.intern_with(|ts| self.mk_ty(Tuple(self.intern_type_list(&amp;ts))))&#125;pub fn mk_slice(self, ty: Ty&lt;&#x27;tcx&gt;) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.mk_ty(Slice(ty))&#125;pub fn mk_ptr(self, tm: TypeAndMut&lt;&#x27;tcx&gt;) -&gt; Ty&lt;&#x27;tcx&gt; &#123;    self.mk_ty(RawPtr(tm))&#125;\n\n看起来都比较直观，而每一个mk_xxx本质上都是直接或者间接调用了mk_ty，再进入intern_ty做处理\nInternTy实现代码\n/// Interns a type.#[allow(rustc::usage_of_ty_tykind)]#[inline(never)]fn intern_ty(    &amp;self,    kind: TyKind&lt;&#x27;tcx&gt;,    sess: &amp;Session,    resolutions: &amp;ty::ResolverOutputs,) -&gt; Ty&lt;&#x27;tcx&gt; &#123;  Ty(Interned::new_unchecked(    self.type_      .intern(kind, |kind| &#123;        let flags = super::flags::FlagComputation::for_kind(&amp;kind);        // It&#x27;s impossible to hash inference regions (and will ICE), so we don&#x27;t need to try to cache them.        // Without incremental, we rarely stable-hash types, so let&#x27;s not do it proactively.        let stable_hash = if flags.flags.intersects(TypeFlags::HAS_RE_INFER)            || sess.opts.incremental.is_none()        &#123;            Fingerprint::ZERO        &#125; else &#123;            let mut hasher = StableHasher::new();            let mut hcx = StableHashingContext::ignore_spans(                sess,                &amp;resolutions.definitions,                &amp;*resolutions.cstore,            );            kind.hash_stable(&amp;mut hcx, &amp;mut hasher);            hasher.finish()        &#125;;        let ty_struct = TyS &#123;            kind,            flags: flags.flags,            outer_exclusive_binder: flags.outer_exclusive_binder,            stable_hash,        &#125;;        InternedInSet(self.arena.alloc(ty_struct))      &#125;)      .0,  ))&#125;\n\n这里看起来大多是关于存储的细节，我也没有再过于深究了，但是要注意Ty的结构\n/// Use this rather than `TyS`, whenever possible.#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]#[rustc_diagnostic_item = &quot;Ty&quot;]#[rustc_pass_by_value]pub struct Ty&lt;&#x27;tcx&gt;(Interned&lt;&#x27;tcx, TyS&lt;&#x27;tcx&gt;&gt;);\n\n注意Ty这里保存了一个Interned，这个函数名本身也是intern_ty，那么这是代表了什么呢\n我们看一下Interned的注释\n\nA reference to a value that is interned, and is known to be unique.Note that it is possible to have a T and a Interned that are (or refer to) equal but different values. But if you have two different Interneds, they both refer to the same value, at a single location in memory. This means that equality and hashing can be done on the value’s address rather than the value’s contents, which can improve performance.The PrivateZst field means you can pattern match with Interned(v, _) but you can only construct a Interned with new_unchecked, and not directly.\n\nInterned本质是指向实际unique的值的一个引用。\n代码中可以看到将一个TyS传给了InternedInSet，而构建TyS的时候传入了一个stable_hash。关于这个stable_hash有着这样的注释\n\nThe stable hash of the type. This way hashing of types will not have to work on the address of the type anymore, but can instead just read this field\n\n在上面提及hir::Ty和ty::Ty的时候说过相同的类型最后会转换为同一个ty::Ty，我想应该就是通过这些行为做到的。\n要深入下去还有太多细节，而这些细节大多不是我目前关心的，所以就不深入了\n","categories":["Compiler","源码阅读"],"tags":["Rc-lang","Rust","Type"]},{"title":"Rc-lang开发周记17 一点AST检查","url":"/2022/05/01/rc-lang-dev-17/","content":"\n聪明如我怎么会写出ast有错误的代码 pixiv:69589494 \n\n先说一声五一快乐！久违的长假，之后会花一些时间把其他一些写到一半的博客整理出来\n本来想要好好做一下检查相关以及类型推导的工作，但是目前来说我更需要先学习优化方面的知识，因此关于ast的检查以及类型推导和类型检查做的比较简易，过后有时间再回来做。本周虽然做了部分类型推导和类型检查，但是只做了一半，剩下的部分可能要下周再说了。下周大概就能做完简单的类型推导和检查\nAST检查目前所实现的检查无外乎这么几类\n\n名称冲突\n未定义符号\n变量的声明类型或者初始值必须有一个存在\n\n我挑出一些经典的部分讲解，不过多赘述重复的部分了\n实际上能做的类型无关的检查还有非常多\n名称冲突def dupNameCheck(names: List[Ident]): Result = &#123;  dupCheck(names, &quot;Name&quot;)&#125;def dupCheck[T &lt;: ASTNode](values: List[T], valueName: String): Result = &#123;  val s = Set[T]()  values.filterNot(s.add).map(n =&gt; ValidateError(n, s&quot;$valueName $n Dup&quot;))&#125;def checkModule(module: RcModule): Result = &#123;  dupNameCheck(module.items.map(item =&gt; item match    case Item.Class(name, _, _, _) =&gt; name    case Item.Method(decl, _) =&gt; decl.name  )):::module.items.flatMap(checkItem)&#125;\n\n比如说Module的检查中对所有item的名字检查是否存在冲突，并且再check每个Item本身\n关于返回值的Result只是一个type alias\ntype Result = List[ValidateError]case class ValidateError(node: ASTNode, reason: String)\n\n这里还有很多待改进的空间，比如说将实际的错误分类，或者写一个diagnosis类来管理这些错误信息等等\n这里使用一个type alias也是为了后面修改时候方便\n这里可以看到所有的错误信息都是组合之后返回，原因是我想将代码中的副作用范围缩到最小，这样能够保证调用的结果尽可能的不受外部状态影响\n未定义的符号目前只做了一些简单的处理。这里还没有处理全局的符号（比如说函数和类）\ncase class Scope(var localTable: Set[Ident] = Set()) &#123;  def add(ident: Ident): Boolean = &#123;    localTable.add(ident)  &#125;  def contains(ident: Ident): Boolean = &#123;    localTable.contains(ident)  &#125;&#125;case class ScopeManager() &#123;  private var scopes = List[Scope]()  def enter[T](f:() =&gt; T): T = &#123;    enter(Params(List()), f)  &#125;  def enter[T](params: Params, f:() =&gt; T): T = &#123;    val oldScope = scopes    scopes ::= Scope(mutable.Set.from(params.params.map(_.name)))    val result = f()    scopes = oldScope    result  &#125;  def curScope: Scope = scopes.last  def add(ident: Ident): Boolean = curScope.add(ident)  def contains(ident: Ident): Boolean = &#123;    !scopes.exists(_.contains(ident))  &#125;  def curContains(ident: Ident): Boolean = curScope.contains(ident)&#125;\n\n每个Scope有自己的table，每次通过enter进入一个table则将当前的放到List中\ndef checkBlock(block: Block, params: Params = Params(List())): Result = &#123;  scopes.enter(params, () =&gt; &#123;    block.stmts.flatMap(checkStmt)  &#125;)&#125;def checkMethod(method: Method): Result = &#123;  checkMethodDecl(method.decl)  checkBlock(method.body, method.decl.inputs)&#125;\n\n在每次进入一个Block的时候则进入了一个新的scope，比如说一个Method的body的expr\n对于Id表达式则会去检查是否存在这个符号，\ncase Expr.Identifier(id) =&gt; checkCond(scopes.contains(id), expr, &quot;$name not decl&quot;)\n\n初始值与类型二选一def fieldDefValid(fieldDef: FieldDef): Result = &#123;  fieldDef.initValue match &#123;    case Some(expr) =&gt; checkExpr(expr)    case None =&gt; checkCond(fieldDef.ty != TyInfo.Infer, fieldDef, &quot;Field without initValue need spec Type&quot;)  &#125;&#125;\n\n对于类的field做了这样的检查，存在initValue则去检查expr，否则检查ty是否为需要Infer的。如果没有initValue也没有ty信息，那我们无法在后面类型推导的时候得出类型\n","categories":["Compiler"],"tags":["Rc-lang","AST"]},{"title":"Rc-lang开发周记18 简单类型推导","url":"/2022/05/08/rc-lang-dev-18/","content":"\n不要小看我，这种程度我也可以做得出！非pixiv \n\n本周主要都在了解MIR相关，但是还存有非常多的问题，因此先来讲一下之前写的TypeInfer的内容\n我将Infer的过程分为了两部分。第一部分是最纯粹的类型推导，第二部分是实际将ast转换为带有类型信息的ast。\nType目前先这样做了一个非常简易的样子\nenum Type:  case Boolean  case String  case Int32  case Float  case Nil  case Fn(ret: Type, params: List[Type])  case Infer  case Err(msg: String)\n\nTyped对于类型相关的操作来讲，首先本身是有类型的才能进行infer，因此有了这样一个trait\ntrait Typed &#123;  var ty:Type = Type.Infer  def withTy(ty: Type): this.type = &#123;    this.ty = ty    this  &#125;  def withInfer: this.type = withTy(infer)  def infer: Type = Infer(this)&#125;\n\n注意这里默认的是Type.Infer，表示需要Infer才行\ninfer的过程则是调用了case object Infer（单例对象），后面会讲到\n用的时候直接mixin这个trait即可\nenum Expr extends ASTNode with Typed:  case Number(v: Int)  case Identifier(ident: Ident)enum Item extends ASTNode with Typed:  case Method(decl: MethodDecl, body: Block) extends Item with Typed\n\nTyCtxtctxt的部分主要存放一个全局符号表，以及一个局部符号表（这里的符号表只包含了类型信息）\n而局部符号表又分为了当前scope以及outer的两部分。\n接口也很简单，简单的添加与查找，以及进入一个新的scope\ncase class TyCtxt(val global:Map[Ident, Type] = Map[Ident, Type]()) &#123;  var outer = List[Map[Ident, Type]]()  var local = Map[Ident, Type]()  def lookup(ident: Ident): Option[Type] = &#123;    val ty = local.get(ident) orElse outer.find(_.contains(ident)) orElse global.get(ident)    ty.asInstanceOf[Option[Type]]  &#125;  def enter[T](f: =&gt; T): T = &#123;    outer ::= local    local = Map[Ident, Type]()    val result = f    local = outer.head    outer = outer.tail    result  &#125;  def addLocal(k: Ident, v: Type): Unit = &#123;    local += (k -&gt; v)  &#125;&#125;\n\n关于enter的参数需要讲一下，既不是一个f: T，也不是一个f: () ⇒ T。\n使用f: ⇒ T的写法可以推迟实际传进来的求值过程。既可以接受一个简单的T，也可以接受一个函数计算结果的T，同样也可以接受一个() ⇒ T\n看一个测试就明白了\nit(&quot;nested&quot;) &#123;  tyCtxt.enter(() =&gt; &#123;    val id = Ident(&quot;a&quot;)    val ty = Nil    tyCtxt.addLocal(id, ty)    tyCtxt.enter(testEnter(id))    assert(tyCtxt.enter(id) == String)    assert(tyCtxt.lookup(id).contains(ty))  &#125;)&#125;def testEnter(id: Ident): Type = &#123;\tassert(tyCtxt.local.isEmpty)  val innerTy = String  tyCtxt.addLocal(id, innerTy)  assert(tyCtxt.lookup(id).contains(innerTy))  innerTy&#125;\n\n可以看到这里的enter存在两种写法。\n在进入testEnter之前添加了local，进入之后local变成了空的，也就是说进入了一个新的scope。\n最初是觉得每次tyCtxt.enter(() ⇒ f())都要写() ⇒ 感到非常麻烦，后来发现了这样的写法\nInfer成员变量只有一个tyCtxt\ncase object Infer &#123;  var tyCtxt: TyCtxt = TyCtxt()\t...&#125;\n\ninfer的入口处\ndef apply(typed: Typed, force: Boolean = false): Type = &#123;  infer(typed, force)&#125;private def infer(typed: Typed, force: Boolean): Type = &#123;  if(!force &amp;&amp; typed.ty != Type.Infer) &#123;    typed.ty  &#125; else &#123;    infer(typed)  &#125;&#125;private def infer(typed: Typed): Type = &#123;  typed match    case expr: Expr =&gt; infer(expr)    case item: Item =&gt; infer(item)    case method: Item.Method =&gt; infer(method)    case stmt: Stmt =&gt; infer(stmt)    case _ =&gt; ???&#125;\n\nforce也很好理解，不是force的情况下原来有type则直接返回，而不是进行推导\nExpr inferprivate def infer(expr: Expr): Type = &#123;  expr match    case Number(v) =&gt; Int32    case Identifier(ident) =&gt; lookup(ident)    case Bool(b) =&gt; Boolean    case Binary(op, lhs, rhs) =&gt; common(lhs, rhs)    case Str(str) =&gt; String    case If(cond, true_branch, false_branch) =&gt; false_branch match      case Some(fBr) =&gt; common(true_branch, fBr)      case None =&gt; infer(true_branch)    case Return(expr) =&gt; infer(expr)    case Block(stmts) =&gt; tyCtxt.enter(infer(stmts.last))    case Call(target, args) =&gt; lookup(target)&#125;\n\nInfer的部分主要还是在于表达式的类型推导，实际上也很直观。有的种类表达式自身类型是确定了，需要考虑id的就去lookup，像if和binary这种通过common来获取。\nlookupprivate def lookup(ident: Ident): Type = &#123;  tyCtxt.lookup(ident).getOrElse(Err(s&quot;$ident not found&quot;))&#125;\n\n简单的在ctxt中查找符号的信息\ncommonprivate def common(lhs: Expr, rhs: Expr): Type = &#123;  val lt = infer(lhs)  val rt = infer(rhs)  if lt == rt then lt else Err(&quot;failed&quot;)&#125;\n\n这里我还抱有一些疑问，在这里产生一个TypeErr是否合适，但是如果lhs和rhs的类型是不兼容的情况那也无法得出一个正确的Type\n虽然名字叫common，然而这里做的非常简单，只是简单判别类型是否相同而没有考虑到type compatible\nenterdef enter[T](tyCtxt: TyCtxt, f: =&gt; T): T = &#123;  this.tyCtxt = tyCtxt  tyCtxt.enter(f)&#125;def enter[T](f: =&gt; T): T = &#123;  tyCtxt.enter(f)&#125;\n\n除了普通的enter，还支持通过指定一个typeCtxt来推导\nTranslatorcase object TypedTranslator &#123;  var tyCtxt: TyCtxt = TyCtxt()  def apply(tyCtxt: TyCtxt)(module: RcModule): RcModule = &#123;    // update local table in TypedTranslator will cause Infer ctxt update    // because of pass a typCtxt by Ref    Infer.enter(tyCtxt, RcModuleTrans(module))  &#125;  ...&#125;\n\n这里传递一个ctxt的引用给Infer，之后在translator里面通过tyCtxt更新各种local信息，这样Infer只做infer就可以了，不需要关心其他的事情。翻译的最小单元则是一个Module\ntranslator主要的想法就是通过infer获取类型，之后返回一个保存有意义的类型信息的ASTNode\nExprdef exprTrans(expr: Expr): Expr =\t(expr match    case Binary(op, lhs, rhs) =&gt; Binary(op, lhs.withInfer, rhs.withInfer)    case If(cond, true_branch, false_branch) =&gt; &#123;      val false_br = false_branch match        case Some(fBr) =&gt; Some(fBr.withInfer)        case None =&gt; None      If(cond.withInfer,        true_branch.withInfer.asInstanceOf[Block],        false_br)    &#125;    case Call(target, args) =&gt; Call(target, args.map(_.withInfer))    case Return(expr) =&gt; Return(expr.withInfer)    case Block(stmts) =&gt; tyCtxt.enter(Block(stmts.map(stmtTrans)))    case _ =&gt; expr).withInfer\n\n可以看到就是简单的将参数withInfer，之后重新构建起这个表达式，并且将这个表达式整体进行infer。\n为了避免一个个调用withInfer，因此在最后将expr的结果统一调用withInfer\n对于Stmt的部分本质做法是差不多的，就不再赘述了\n最后下周开始会开始专注于适合优化层面IR的内容了。最早我给自己规定的每天写一部分功能，不过我后来已经将写与学习成为了习惯，因此不会再局限于每天写这种事情。现在更多的是了解各种不同的做法，分析不同做法之间的差异（了解这些的过程有些上瘾，一不小心就会陷进去）。也因此下周开始的内容可能写的篇幅会少一些，会多一些对比分析\n","categories":["Compiler"],"tags":["Rc-lang","Type"]},{"title":"我与博客","url":"/2022/05/08/IandBlog/","content":"\n你愿意和我一起读下去吗 pixiv: 44636666 \n\n读《暗时间》这本书的时候看到关于你为什么应该写博客的章节，想先把自己有关博客的想法做一个记录，因此就有了本文。\n我和博客的开始以前也尝试过建立博客，也搞过什么Wordpress之类的，但也都是搭建好新鲜感过去来，之后就没写什么东西，之后也就不了了之了。\n去年三月多的时候又将这个事情回想了起来，决定好好对待这件事情。结果去年一年也没写上几篇\n今年的话渐渐有了更多的想法，内容也逐渐的有了一些。\n博客所带来的好处反复思考写博客本身是一个反复思考复盘的过程。不论是单纯记录还是思考，写下的过程中会不断复习这些知识，在这个过程中自己对这些知识的记忆会更加牢靠，同时可能产生了新的问题，进而产生新的思考。同时梳理思考的过程中会无意中发现一些问题，我在写自己的开发周记的时候发现了一些自己的bug。\n在讲解给读者的时候会强迫自己去思考，读者可能会提出哪些问题？这些地方自己是否真的明白了？有的技术博客我在写的时候也会发现自己知识的漏洞，现去弥补一下知识漏洞再来接着写。\n这样长期反复梳理思考下去我觉得慢慢这种思考就会变成一种习惯，不仅是写博客，在做其他的事情也会受益。\n展示自我看博客能够知道你是什么样的人。你写什么样的博客，你关注哪些内容，你的思考方式是怎么样的等等。这也算是一种特殊的自我介绍了，在网络上看一个人的几条发言可能看不出一个人是怎样的，但是如果他一直持续输出内容，则可以从输出的内容中对这个人多几分了解。或许还会有志同道合的人因此和你成为朋友，也许其中还会有非常聊得来的人。（首页中的图标和关于都有我的联系方式，欢迎私信）\n积累与激励看到自己写了那么多博客，既是一种积累，后面再回来看，看着自己的内容不断精进，不断变化，意识到自己的进步与成长，进而给自信添砖加瓦，激励自己后续持续学习和思考。这是一种良性循环，只要熬过了最初不知道该写什么与不知道怎么写的阶段，就会不断有所收获。\n遇到过的问题出师不利：不知道该写什么在刚开始写的时候，这个问题是最让我头疼的。去年年底开始写开发周记之前，基本上都没什么内容。后来开发周记写了几篇，读书的时候也开始能够留下一些笔记和想法，渐渐的有了一些想写的东西。读书感悟，简单的科普，开发问题复盘，自己的一些想法，我还有很多想法都没有写出来，很多来不及整理的只能在我的笔记中默默等待\n仔细考虑的话，发生这种改变的本质原因是我去年开始做了各种各样的事情，同时渐渐开始养成记录内容的习惯（这个记录的习惯真的是非常重要，我的很多博客都是从碎片整理来的），因此我渐渐的有一些东西可说。如果你实在不知道怎么写，那就试着多留心观察自己的想法，自己经历的事情，说不定会找到什么答案。\n但是因为不知道写什么就放弃不去写了这件事情是完全不一样的。如果不去做些什么的话，你不管放弃几次回头看可能都不知道写什么。只要写了一篇，就更可能有第二篇，以此类推\n我在初学编程的时候也是不知道该写什么，因为我对这个东西没有形成一些印象，后来过了非常长的时间总算是多少入了门。在这个过程中我一直没有停止学习接触相关知识，即便现在看来都是错误的方式，但最终都是我过去的行为推动了我现在的行为\n想着一定要写好当然保证质量是很重要的事情，但是也因此有的博客过于追求质量、又或者说把握不住详细到什么地步就难产了。\n后来我在写第一篇读书笔记的时候写了一部分了，剩下的不知道怎么写，当我想到了我之前难产的博客以及如果再这么要求质量的话可能就完不成的时候我决定草草收尾。\n对于一开始来说我觉得还是坚持写下去更加重要，尤其是在你觉得自己很不擅长这件事情的时候。之前看到一个人的推特写目标是坚持输出内容，前二十多期可以不追求质量，这也是同样的道理。一开始总是不熟练，那就放低要求，先以完成为目的。\n写博客的误区除了我上面提到的问题，《暗时间》这本书中还提到了一些写博客的误区，我也在这里提及一下，加入了一些我自己的想法，有兴趣的读者可以去看原书\n担心自己的内容如果担心自己写的东西别人都已经写过了，我认为不需要去关心这些。这里要注意一个非常关键的点：写博客是为了更好的学习与思考，而不是说一定要去写什么别人没写过的东西。这不是毕业论文，不需要担心这些问题，你在成文的过程中的思考有所收获就够了。\n如果担心内容质量不佳，那就像上面说的想着一定要写好一样，不再赘述。如果担心想法有漏洞，那更不必担心，这个漏洞不会因为你不写出来而消失，写出来被别人指正反而是更好的改进方式。\n关注反馈上面也提到了写博客的目的，对于外部的反馈以及其他博客的好处来说这不过是附赠品，同时如果是为了外部反馈而写，那么很可能做出偏离学习与思考这一本意的行为。\n暗时间中有这样一句话\n\n只做你最感兴趣的事情，钱会随之而来\n\n这个例子是类似的，牢记初心，专注于你当前真正要做的事情，其他的附属品都会随之而来。\n碎碎念阅读博客的人更希望得到信息而非噪音。每个人都会有想法牢骚的冲动，但是这应该是在其他一些适合发牢骚的平台，比如说Twitter。\n我在之前也非常容易碎碎念，看到这条以后我下定决心以后其他输出内容的地方都不会掺杂各种碎碎念，还请读者们监督。\n亲自动手写了博客才发现的事情最大的感悟是输出内容真的是不容易。完成一篇内容充足的博客需要很久，同时又要保证质量的话是非常难的事情。\n看别人写和自己写完全是两回事。经常看别人在知乎上写了那么长一大段的干货，真到自己写的时候发现是多么困难。（这里我不禁好奇他们是怎么有时间能写那么多那么长的回答？）\n由于这些感受，我对持续输出内容的人逐渐开始有了更多的尊敬，因为输出内容确实是一件比较辛苦的事情。尽管有的时候输出内容也很开心，但是最终能够持续输出的还是少数。\n我与博客虽然我第一次接触博客的时候没有做下去，但庆幸的是现在我已经逐渐形成了这个习惯。即便去掉开发周记也还剩下许多其他博客，看到这些我感到十分欣慰。我会持续的输出内容，并且在保证不影响写完的前提下提升质量。\n文章的最后我想引用一句《暗时间》中的话\n\n人太容易为各种各样的事情分心，要集中注意力做一件事情是非常难的，而正因为难，少有人做到，那些做到的，就都变成了牛。\n\n只有坚持做下去才能做到，而实际上博客所带来的基本上都是好处，为什么不坚持做下去呢？\n不过能不能变成牛这不重要，只要坚持学习、思考与行动，最终总会变成大牛。\n","categories":["Think"],"tags":["Blog"]},{"title":"Rc-lang开发周记 一些变动","url":"/2022/05/15/rc-lang-change/","content":"关于开发周记周更这件事情现在继续做的必要性我开始产生了疑问。\n首先我写这个一方面是为了养成写博客的习惯，另一方面则是为了促进我形成写代码的习惯。然而随着我不断的做这样的事情，需要学习分析其他编译器实现的次数越来越多。这并非是因为我不继续做下去而要放弃，反而是我想要更好的做这件事情。这些分析的结果我更倾向于转换为其他系列的博客，因此我决定不再周更开发周记。\n当然并不是说后面完全不更新了，如果我代码开始写新的内容一定会更新的，同时之后写的新内容一定会关联到对应一期分析的博客。至于分析的内容，当我了解完成一个阶段以后会对这些内容进行一个整理并且发布到我的博客。更新频率未必会周更，视我学习的进度而定，主要是想要尽可能保证内容的完整与连贯，有一些内容还是放在一起写会比较合适。\n","categories":["Compiler"],"tags":["Rc-lang"]}]