<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Homura">
    
    <title>
        
            mold源码阅读十三 计算shdr以及osec offset |
        
        Homura&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fusionbolt.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpeg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"我们所度过的每个平凡的日常\n也许就是连续发生的奇迹\n"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
    <meta name="description" content="pixiv:94763079   本期的内容主要是更新section header以及set output section offsets相关。当这些操作结束后，虚拟地址会固定，因此输出文件的memory layout就固定下来了。 create_reloc_sections1234&#x2F;&#x2F; If --emit-relocs is given, we&amp;#x27;ll copy relocation">
<meta property="og:type" content="article">
<meta property="og:title" content="mold源码阅读十三 计算shdr以及osec offset">
<meta property="og:url" content="https://fusionbolt.github.io/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/index.html">
<meta property="og:site_name" content="Homura&#39;s Blog">
<meta property="og:description" content="pixiv:94763079   本期的内容主要是更新section header以及set output section offsets相关。当这些操作结束后，虚拟地址会固定，因此输出文件的memory layout就固定下来了。 create_reloc_sections1234&#x2F;&#x2F; If --emit-relocs is given, we&amp;#x27;ll copy relocation">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-13-compute-shdr-and-set-osec-offsets/Untitled.png">
<meta property="article:published_time" content="2023-07-15T12:02:55.000Z">
<meta property="article:modified_time" content="2023-07-15T12:04:27.230Z">
<meta property="article:author" content="Homura">
<meta property="article:tag" content="mold">
<meta property="article:tag" content="shdr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fusionbolt.github.io/images/mold-13-compute-shdr-and-set-osec-offsets/Untitled.png">

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0X2R555BND"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0X2R555BND');
</script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Homura's Blog" type="application/atom+xml">
</head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Homura&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/navigation"
                            >
                                导航
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/navigation">导航</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">mold源码阅读十三 计算shdr以及osec offset</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Homura</span>
                        
                            <span class="author-label">我摸到了！</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-07-15 20:02:55
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linker/">Linker</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/mold/">mold</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/shdr/">shdr</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>33 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-13-compute-shdr-and-set-osec-offsets/Untitled.png"
                      alt="Untitled"
                ></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:94763079</center> 

<p>本期的内容主要是更新section header以及set output section offsets相关。当这些操作结束后，虚拟地址会固定，因此输出文件的memory layout就固定下来了。</p>
<h1 id="create-reloc-sections"><a href="#create-reloc-sections" class="headerlink" title="create_reloc_sections"></a>create_reloc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --emit-relocs is given, we&#x27;ll copy relocation sections from input</span></span><br><span class="line"><span class="comment">// files to an output file.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emit_relocs)</span><br><span class="line">  <span class="built_in">create_reloc_sections</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里主要做了2件事情</p>
<ol>
<li>这里将relocation段从input拷贝到output中，即设置所有OutputSection中reloc_sec</li>
<li>加入到chunks中</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_reloc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;create_reloc_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create .rela.* sections</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      osec-&gt;reloc_sec.<span class="built_in">reset</span>(<span class="keyword">new</span> RelocSection&lt;E&gt;(ctx, *osec));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>, end = ctx.chunks.<span class="built_in">size</span>(); i &lt; end; i++)</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      <span class="keyword">if</span> (RelocSection&lt;E&gt; *x = osec-&gt;reloc_sec.<span class="built_in">get</span>())</span><br><span class="line">        ctx.chunks.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelocSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OutputSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  std::vector&lt;i64&gt; offsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中构造rel段的过程主要还是填写shdr的信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">RelocSection&lt;E&gt;::<span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec)</span><br><span class="line">  : <span class="built_in">output_section</span>(osec) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rela&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_RELA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rel&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_REL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_INFO_LINK;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_entsize = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute an offset for each input section</span></span><br><span class="line">  offsets.<span class="built_in">resize</span>(osec.members.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scan = [&amp;](<span class="keyword">const</span> tbb::blocked_range&lt;i64&gt; &amp;r, i64 sum, <span class="keyword">bool</span> is_final) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">      InputSection&lt;E&gt; &amp;isec = *osec.members[i];</span><br><span class="line">      <span class="keyword">if</span> (is_final)</span><br><span class="line">        offsets[i] = sum;</span><br><span class="line">      sum += isec.<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  i64 num_entries = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">    tbb::blocked_range&lt;i64&gt;(<span class="number">0</span>, osec.members.<span class="built_in">size</span>()), <span class="number">0</span>, scan, std::<span class="built_in">plus</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = num_entries * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造RelocSection的时候需要计算出rel的数量。每个OutputSection由多个InputSection组成，每个InputSection中又有多个rel段，这里遍历扫描计算出sum的数量。</p>
<p>这里构造的时候有rel和rela两种情况，它们有如下几种区别</p>
<ol>
<li>rel只是简单的保存了需要被resolve的地址</li>
<li>rela保存了额外信息，其中的a是append。具体什么信息</li>
</ol>
<blockquote>
<p><em>SHT_RELA The section holds relocation entries with explicit addends, such as type</em><br><em>Elf32_Rela for the 32-bit class of object files. An object file may have</em><br><em>multiple relocation sections. See “Relocation’’ below for details.</em></p>
</blockquote>
<p>另外RelocSection的shdr flag为SHF_INFO_LINK，意义如下</p>
<blockquote>
<p>This section headers sh_info field holds a section header table index.</p>
</blockquote>
<p>设置sh_info的过程则是在后续compute_section_headers中</p>
<h1 id="compute-section-headers"><a href="#compute-section-headers" class="headerlink" title="compute_section_headers"></a>compute_section_headers</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the section header values for all sections.</span></span><br><span class="line"><span class="built_in">compute_section_headers</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里主要做了这么几件事</p>
<ol>
<li>所有输出段更新shdr</li>
<li>移除所有空的chunk</li>
<li>重新设置所有chunk的index（因为上面移除了chunk，index发生了改变）</li>
<li>SymtabShndxSection的处理</li>
<li>再次更新所有的shdr</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_headers</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update sh_size for each chunk.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove empty chunks.</span></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;<span class="built_in">kind</span>() != OUTPUT_SECTION &amp;&amp; chunk-&gt;shdr.sh_size == <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set section indices.</span></span><br><span class="line">  i64 shndx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (ctx.chunks[i]-&gt;<span class="built_in">kind</span>() != HEADER)</span><br><span class="line">      ctx.chunks[i]-&gt;shndx = shndx++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab &amp;&amp; SHN_LORESERVE &lt;= shndx) &#123;</span><br><span class="line">    SymtabShndxSection&lt;E&gt; *sec = <span class="keyword">new</span> SymtabShndxSection&lt;E&gt;;</span><br><span class="line">    sec-&gt;shndx = shndx++;</span><br><span class="line">    sec-&gt;shdr.sh_link = ctx.symtab-&gt;shndx;</span><br><span class="line">    ctx.symtab_shndx = sec;</span><br><span class="line">    ctx.chunks.<span class="built_in">push_back</span>(sec);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(sec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;shdr.sh_size = shndx * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfShdr&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Some types of section header refer other section by index.</span></span><br><span class="line">  <span class="comment">// Recompute the section header to fill such fields with correct values.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab_shndx) &#123;</span><br><span class="line">    i64 symtab_size = ctx.symtab-&gt;shdr.sh_size / <span class="built_in"><span class="keyword">sizeof</span></span>(ElfSym&lt;E&gt;);</span><br><span class="line">    ctx.symtab_shndx-&gt;shdr.sh_size = symtab_size * <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update-shdr"><a href="#update-shdr" class="headerlink" title="update_shdr"></a>update_shdr</h2><p>大多数synthetic的chunk都有自己的实现，一些类型的section header通过index引用了其他段，因此需要重新计算shdr中对应字段的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk represents a contiguous region in an output file.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chunk</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如说OutputPhdr，在这里就需要update</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputPhdr&lt;E&gt;::<span class="built_in">update_shdr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  phdrs = <span class="built_in">create_phdr</span>(ctx);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = phdrs.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfPhdr&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移除空的chunk"><a href="#移除空的chunk" class="headerlink" title="移除空的chunk"></a>移除空的chunk</h2><p>这里选择了空的非OutputSection进行移除，判断是否为OutputSection则是根据ChunkKind</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> HEADER, OUTPUT_SECTION, SYNTHETIC &#125; ChunkKind;</span><br></pre></td></tr></table></figure>

<p>其中HEADER是用于output的phdr，ehdr，shdr，chunk默认是SYNTHETIC，也就是说相当于最终只是删除一些空的synthetic的段</p>
<h2 id="重新更新索引"><a href="#重新更新索引" class="headerlink" title="重新更新索引"></a>重新更新索引</h2><p>在普通的根据chunk的序列设置索引后有一个SHN_LORESERVE的判断，和SHN_LORESERVE相关的信息有这些</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man5/elf.5.html" >https://man7.org/linux/man-pages/man5/elf.5.html<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">e_shnum</span><br><span class="line">              This member holds the number of entries in the section</span><br><span class="line">              header table.  Thus the product of e_shent size and e_shnum</span><br><span class="line">              gives the section header table&#x27;s size in bytes.  If a file</span><br><span class="line">              has no section header table,e_shnum holds the value of</span><br><span class="line">              zero.</span><br><span class="line"></span><br><span class="line">              If the number of entries in the section header table is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), e_shnum</span><br><span class="line">              holds the value zero and the real number of entries in the</span><br><span class="line">              section header table is held in the sh_size member of the</span><br><span class="line">              initial entry in section header table.  Otherwise, the</span><br><span class="line">							sh_size member of the initial entry in the section header</span><br><span class="line">              table holds the value zero.</span><br><span class="line"></span><br><span class="line">e_shstrndx</span><br><span class="line">              This member holds the section header table index of the</span><br><span class="line">              entry associated with the section name string table.  If</span><br><span class="line">              the file has no section name string table, this member</span><br><span class="line">              holds the value SHN_UNDEF.</span><br><span class="line"></span><br><span class="line">              If the index of section name string table section is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), this</span><br><span class="line">              member holds SHN_XINDEX(0xffff) and the real index of the</span><br><span class="line">              section name string table section is held in thesh_link</span><br><span class="line">              member of the initial entry in section header table.</span><br><span class="line">              Otherwise, thesh_link member of the initial entry in</span><br><span class="line">              section header table contains the value zero.</span><br></pre></td></tr></table></figure>

<p>e_shnum和e_shstrndx是在EHDR中的信息。首先是shnum，当shdr table，也就是说section的数量超过SHN_LORESERVE的时候，e_shnum会设置为0，实际的数量会保存在shdr table的初始条目中的sh_size的字段里，其他情况这个条目的sh_size的字段是0。</p>
<p>这里创建了一个SymtabShndxSection，也就是”symtab_shndx”段，这个段保留了特殊的symbol table section index arrry，指向与符号表关联的shdr的索引。</p>
<blockquote>
<p><code>.symtab_shndx</code></p>
<p>This section holds the special symbol table section index array, as described above. The section’s attributes will include the <code>SHF_ALLOC</code> bit if the associated symbol table section does; otherwise that bit will be off.</p>
</blockquote>
<p>这个section的sh_type为SHT_SYMTAB_SHNDX</p>
<blockquote>
<p><code>SHT_SYMTAB_SHNDX</code></p>
<p>This section is associated with a section of type <code>SHT_SYMTAB</code> and is required if any of the section header indexes referenced by that symbol table contain the escape value <code>SHN_XINDEX</code>. The section is an array of <code>Elf32_Word</code> values. Each value corresponds one to one with a symbol table entry and appear in the same order as those entries. The values represent the section header indexes against which the symbol table entries are defined. Only if corresponding symbol table entry’s <code>st_shndx</code> field contains the escape value <code>SHN_XINDEX</code> will the matching <code>Elf32_Word</code> hold the actual section header index; otherwise, the entry must be <code>SHN_UNDEF</code> (<code>0</code>).</p>
</blockquote>
<p>关于e_shstrndx，这里也设置了ctx中的symtab_shndx。不论是e_shnum还是e_shstrndx都是在后续的过程中实际计算或者使用其信息，等到后面讲的时候再联系前面这些来看。</p>
<p>创建了SymtabShndxSection后则是设置其基本信息，至此compute_section_headers的过程就结束了。</p>
<h1 id="set-osec-offsets"><a href="#set-osec-offsets" class="headerlink" title="set_osec_offsets"></a>set_osec_offsets</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign offsets to output sections</span></span><br><span class="line">i64 filesize = <span class="built_in">set_osec_offsets</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>设置所有output section的offset，根据是否有section_order会选择不同的排列方式，导致output的offset是不同的。</p>
<p>主要分为如下几部分</p>
<ol>
<li>设置段的虚拟地址</li>
<li>设置段在文件中的offset</li>
<li>处理phdr并且返回文件的长度</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign virtual addresses and file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">set_osec_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;set_osec_offsets&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="built_in">set_virtual_addresses_regular</span>(ctx);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">set_virtual_addresses_by_order</span>(ctx);</span><br><span class="line"></span><br><span class="line">    i64 fileoff = <span class="built_in">set_file_offsets</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning new offsets may change the contents and the length</span></span><br><span class="line">    <span class="comment">// of the program header, so repeat it until converge.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.phdr)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line"></span><br><span class="line">    i64 sz = ctx.phdr-&gt;shdr.sh_size;</span><br><span class="line">    ctx.phdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (sz == ctx.phdr-&gt;shdr.sh_size)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="virtual-address设置规则"><a href="#virtual-address设置规则" class="headerlink" title="virtual address设置规则"></a>virtual address设置规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function assigns virtual addresses to output sections. Assigning</span></span><br><span class="line"><span class="comment">// addresses is a bit tricky because we want to pack sections as tightly</span></span><br><span class="line"><span class="comment">// as possible while not violating the constraints imposed by the hardware</span></span><br><span class="line"><span class="comment">// and the OS kernel. Specifically, we need to satisfy the following</span></span><br><span class="line"><span class="comment">// constraints:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Memory protection (readable, writable and executable) works at page</span></span><br><span class="line"><span class="comment">//   granularity. Therefore, if we want to set different memory attributes</span></span><br><span class="line"><span class="comment">//   to two sections, we need to place them into separate pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - The ELF spec requires that a section&#x27;s file offset is congruent to</span></span><br><span class="line"><span class="comment">//   its virtual address modulo the page size. For example, a section at</span></span><br><span class="line"><span class="comment">//   virtual address 0x401234 on x86-64 (4 KiB, or 0x1000 byte page</span></span><br><span class="line"><span class="comment">//   system) can be at file offset 0x3234 or 0x50234 but not at 0x1000.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We need to insert paddings between sections if we can&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">// above constraints without them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We don&#x27;t want to waste too much memory and disk space for paddings.</span></span><br><span class="line"><span class="comment">// There are a few tricks we can use to minimize paddings as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We want to place sections with the same memory attributes</span></span><br><span class="line"><span class="comment">//   contiguous as possible.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We can map the same file region to memory more than once. For</span></span><br><span class="line"><span class="comment">//   example, we can write code (with R and X bits) and read-only data</span></span><br><span class="line"><span class="comment">//   (with R bit) adjacent on file and map it twice as the last page of</span></span><br><span class="line"><span class="comment">//   the executable segment and the first page of the read-only data</span></span><br><span class="line"><span class="comment">//   segment. This doesn&#x27;t save memory but saves disk space.</span></span><br></pre></td></tr></table></figure>

<p>mold中不论是指定order还是不指定都是遵循基本的两条规则</p>
<ol>
<li>memory protection: 不同attr的section分配到不同的页中，为了满足每个段只有一个attr的条件</li>
<li>ELF spec requires: vaddr的地址的模要是page size，这里会在设置地址的时候进行align，也就是insert padding。</li>
</ol>
<p>这里提及的ticks:</p>
<ol>
<li>place sections with the same memory attributes contiguous as possible. 相同attr尽可能连续。（因为不同attr需要放入不同的页）</li>
<li>map the same file region to memory more than once. map两次，因此不会节约内存空间，但是会节约磁盘空间</li>
</ol>
<h2 id="set-virtual-addresses-regular"><a href="#set-virtual-addresses-regular" class="headerlink" title="set_virtual_addresses_regular"></a>set_virtual_addresses_regular</h2><p>在设置地址之前，需要先对tls chunk计算一个align。因为tls chunk需要满足如下条件</p>
<ol>
<li>tls块在vaddr中的起始地址地址需要对齐（普通内存块的要求是相同的）</li>
<li>当被拷贝到新线程区域时tls_begin的offset也必须对齐。更具体的说，tls会有多个块，而每个块都有一个tls_begin，实际上是这个值要求对齐。</li>
</ol>
<p>而mold的做法是选择其中最大的align值。</p>
<p>之后设置了起始地址image_base：默认0x200000</p>
<blockquote>
<p>-image-base ADDR Set the base address to a given value</p>
</blockquote>
<p>regular设置地址的过程有如下几种情况</p>
<ol>
<li>跳过不需要alloc的段，因为并不需要加载到内存中</li>
<li>relro_padding，一定是满足memory protection的。</li>
<li>指定section_start，不需要考虑memory protection，因为后面考虑这个的时候会和前一个的段进行比较。假设说连续两个都指定了start，即便不满足，那也是指定的行为。</li>
<li>满足memory protection的条件。当前chunk和下一个chunk都不是relro_padding的情况，如果两个chunk的attr不同，那么处理。处理后继续执行后面的代码</li>
<li>tbss：SHF_TLS &amp; SHT_NOBITS</li>
<li>剩余的情况就是简单的进行align然后更新addr信息</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_regular</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> i64 RELRO = <span class="number">1LL</span> &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_flags = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    i64 flags = <span class="built_in">to_phdr_flags</span>(ctx, chunk);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_relro</span>(ctx, chunk))</span><br><span class="line">      <span class="keyword">return</span> flags | RELRO;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign virtual addresses</span></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TLS chunks alignments are special: in addition to having their virtual</span></span><br><span class="line">  <span class="comment">// addresses aligned, they also have to be aligned when the region of</span></span><br><span class="line">  <span class="comment">// tls_begin is copied to a new thread&#x27;s storage area. In other words, their</span></span><br><span class="line">  <span class="comment">// offset against tls_begin also has to be aligned.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A good way to achieve this is to take the largest alignment requirement</span></span><br><span class="line">  <span class="comment">// of all TLS sections and make tls_begin also aligned to that.</span></span><br><span class="line">  Chunk&lt;E&gt; *first_tls_chunk = <span class="literal">nullptr</span>;</span><br><span class="line">  u64 tls_alignment = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_TLS) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!first_tls_chunk)</span><br><span class="line">        first_tls_chunk = chunk;</span><br><span class="line">      tls_alignment = std::<span class="built_in">max</span>(tls_alignment, (u64)chunk-&gt;shdr.sh_addralign);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> alignment = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk == first_tls_chunk ? tls_alignment : (u64)chunk-&gt;shdr.sh_addralign;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; chunks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .relro_padding is a padding section to extend a PT_GNU_RELRO</span></span><br><span class="line">    <span class="comment">// segment to cover an entire page. Technically, we don&#x27;t need a</span></span><br><span class="line">    <span class="comment">// .relro_padding section because we can leave a trailing part of a</span></span><br><span class="line">    <span class="comment">// segment an unused space. However, the `strip` command would delete</span></span><br><span class="line">    <span class="comment">// such an unused trailing part and make an executable invalid.</span></span><br><span class="line">    <span class="comment">// So we add a dummy section.</span></span><br><span class="line">    <span class="keyword">if</span> (chunks[i] == ctx.relro_padding) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_size = <span class="built_in">align_to</span>(addr, ctx.page_size) - addr;</span><br><span class="line">      addr += ctx.page_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle --section-start first</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = ctx.arg.section_start.<span class="built_in">find</span>(chunks[i]-&gt;name);</span><br><span class="line">        it != ctx.arg.section_start.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      addr = it-&gt;second;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">    <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">    <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; chunks[i - <span class="number">1</span>] != ctx.relro_padding) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">get_flags</span>(chunks[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">get_flags</span>(chunks[i]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X)) &#123;</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          [[fallthrough]];</span><br><span class="line">        <span class="keyword">case</span> NOSEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> (addr % ctx.page_size != <span class="number">0</span>)</span><br><span class="line">            addr += ctx.page_size;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">unreachable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS BSS sections are laid out so that they overlap with the</span></span><br><span class="line">    <span class="comment">// subsequent non-tbss sections. Overlapping is fine because a STT_TLS</span></span><br><span class="line">    <span class="comment">// segment contains an initialization image for newly-created threads,</span></span><br><span class="line">    <span class="comment">// and no one except the runtime reads its contents. Even the runtime</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t need a BSS part of a TLS initialization image; it just</span></span><br><span class="line">    <span class="comment">// leaves zero-initialized bytes as-is instead of copying zeros.</span></span><br><span class="line">    <span class="comment">// So no one really read tbss at runtime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We can instead allocate a dedicated virtual address space to tbss,</span></span><br><span class="line">    <span class="comment">// but that would be just a waste of the address and disk space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_tbss</span>(chunks[i])) &#123;</span><br><span class="line">      u64 addr2 = addr;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        addr2 = <span class="built_in">align_to</span>(addr2, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">        chunks[i]-&gt;shdr.sh_addr = addr2;</span><br><span class="line">        addr2 += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> == chunks.<span class="built_in">size</span>() || !<span class="built_in">is_tbss</span>(chunks[i + <span class="number">1</span>]))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">    chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="relro-padding"><a href="#relro-padding" class="headerlink" title="relro_padding"></a>relro_padding</h3><p>relro_padding用于确保RELRO页对齐，通常无需考虑，但是strip后会删除未使用的尾部空间，导致可执行文件无效。因此这里计算size的过程是用align的size减去当前的地址，之后addr直接递增一个page_size</p>
<p>关于PT_GNU_RELRO</p>
<blockquote>
<p>The array element specifies the location and size of a segment which may be made read-only after relocation shave been processed.</p>
</blockquote>
<h3 id="section-start"><a href="#section-start" class="headerlink" title="section_start"></a>section_start</h3><p>根据命令行参数指定对应段的地址为指定的位置，更新当前段地址，并且递增对应段的size。其中提到的命令行参数的介绍</p>
<blockquote>
<p>-Tbss=ADDR Set address to .bss<br>-Tdata Set address to .data<br>-Ttext Set address to .text</p>
</blockquote>
<h3 id="满足memory-protection"><a href="#满足memory-protection" class="headerlink" title="满足memory protection"></a>满足memory protection</h3><p>这里主要是针对相邻两个chunk的attr不同的情况。</p>
<p>根据链接选项可以分为三类</p>
<ol>
<li>SEPARATE_LOADABLE_SEGMENTS<ol>
<li>这里只是更新了当前的addr为根据page size进行align的值</li>
</ol>
</li>
<li>SEPARATE_CODE<ol>
<li>两个都不是PF_X（执行的权限）的情况下进行align</li>
</ol>
</li>
<li>NOSEPARATE_CODE<ol>
<li>如果当前的地址不是整除page size，那么直接增加一个page_size </li>
</ol>
</li>
</ol>
<h3 id="to-phdr-flags"><a href="#to-phdr-flags" class="headerlink" title="to_phdr_flags"></a>to_phdr_flags</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">to_phdr_flags</span><span class="params">(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All sections are put into a single RWX segment if --omagic</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.omagic)</span><br><span class="line">    <span class="keyword">return</span> PF_R | PF_W | PF_X;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> write = (chunk-&gt;shdr.sh_flags &amp; SHF_WRITE);</span><br><span class="line">  <span class="keyword">bool</span> exec = (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .text is not readable if --execute-only</span></span><br><span class="line">  <span class="keyword">if</span> (exec &amp;&amp; ctx.arg.execute_only) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--execute-only is not compatible with writable section: &quot;</span></span><br><span class="line">                 &lt;&lt; chunk-&gt;name;</span><br><span class="line">    <span class="keyword">return</span> PF_X;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .rodata is merged with .text if --no-rosegment</span></span><br><span class="line">  <span class="keyword">if</span> (!write &amp;&amp; !ctx.arg.rosegment)</span><br><span class="line">    exec = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PF_R | (write ? PF_W : <span class="number">0</span>) | (exec ? PF_X : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于页来说attr只有三种，读，写，执行。</p>
<p>如果指定omagic那么所有段都会塞到一个segment里面，因此其attr都是RWX的</p>
<blockquote>
<p>-N, –omagic Do not page align data, do not make text readonly<br>–no-omagic</p>
</blockquote>
<p>之后则是根据shdr的flag判断是否可写可执行返回对应的flag</p>
<h3 id="tbss"><a href="#tbss" class="headerlink" title="tbss"></a>tbss</h3><p>这里是针对tbss(tls bss) section的处理，其判断逻辑为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_tbss</span><span class="params">(Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (chunk-&gt;shdr.sh_type == SHT_NOBITS) &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_TLS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.bss的SHT为SHT_NOBITS，并且其Flag为SHF_ALLOC &amp; SHF_WRITE，因此这里只需要判断sh_type是否为SHT_NOBITS以及tls的判断条件就可以确定是否为tbss</p>
<blockquote>
<p>sh_offset: The byte offset from the beginning of the file to the first byte in the section. Section type SHT_NOBITS occupies no space in the file. Its sh_offset member locates the conceptual placement in the file.</p>
<p>sh_size: The section’s size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS can have a nonzero size, but it occupies no space in the file.</p>
<p>SHT_NOBITS: Identifies a section that occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</p>
</blockquote>
<p>tbss会和后续的非tbss段重叠，因为STT_TLS segment包含了一个初始化image，运行时才会读取，运行时也不需要tbss的初始化image，会保留零初始的变化字节不变，所以运行时不会实际读取。尽管可以单独给tbss分配空间，但是会浪费地址和磁盘空间。</p>
<p>所以这里的代码单独创建了一个地址进行递增，不会影响到正常更新的地址。</p>
<h2 id="set-virtual-addresses-by-order"><a href="#set-virtual-addresses-by-order" class="headerlink" title="set_virtual_addresses_by_order"></a>set_virtual_addresses_by_order</h2><p>根据order的信息来设置地址</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br></pre></td></tr></table></figure>

<p>根据SectionOrder信息的不同有如下几种情况处理</p>
<ol>
<li>SECTION<ol>
<li>计算一个地址赋给对应section的sh_addr以及更新当前的addr</li>
</ol>
</li>
<li>GROUP<ol>
<li>针对group段所有成员做和SECTION情况下相同的操作</li>
</ol>
</li>
<li>ADDR<ol>
<li>当前地址设置为SectionOrder中的值</li>
</ol>
</li>
<li>ALIGN<ol>
<li>当前地址设置为根据给定value对齐后的地址</li>
</ol>
</li>
<li>SYMBOL<ol>
<li>特定符号的地址设置为当前的地址</li>
</ol>
</li>
</ol>
<p>针对section的过程具体分为如下几步</p>
<ol>
<li>判断相邻段的attr，不同则进行将section根据page size进行padding</li>
<li>根据对应段的align计算一个地址，赋给section并且更新shdr以及当前addr的信息</li>
<li>找到下一个alloc的段</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_by_order</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;c = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> assign_addr = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">to_phdr_flags</span>(ctx, c[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">to_phdr_flags</span>(ctx, c[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">      <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">      <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X))</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, c[i]-&gt;shdr.sh_addralign);</span><br><span class="line">    c[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += c[i]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; ctx.arg.section_order.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    SectionOrder &amp;ord = ctx.arg.section_order[j];</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ord.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SECTION:</span><br><span class="line">      <span class="keyword">if</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::GROUP:</span><br><span class="line">      <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ADDR:</span><br><span class="line">      addr = ord.value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ALIGN:</span><br><span class="line">      addr = <span class="built_in">align_to</span>(addr, ord.value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SYMBOL:</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;value = addr;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-file-offsets"><a href="#set-file-offsets" class="headerlink" title="set_file_offsets"></a>set_file_offsets</h2><p>在设置完段的虚拟地址后，需要设定段在文件中的offset</p>
<ol>
<li>不需要alloc的情况，仍然需要计算其align更新size。有一些段需要占用空间，但是不需要载入内存，因此前面设置虚拟地址的时候跳过了所有不需要alloc的段，这里计算offset的时候还是要考虑到的。</li>
<li>bss段不做处理直接跳过</li>
<li>对offset做一次align。因为有的段可能并没有完整填充一个page size的空间，前面设置虚拟地址的过程并没有使得所有的size都满足page align。</li>
<li>给alloc section设置尽可能连续的文件的offset，因此会从当前的chunk开始循环设置offset。这样连续加载提高了效率，并且减少碎片空间。不符合条件的情况如下<ol>
<li>非alloc或者是bss</li>
<li>如果是给定了start_section的段，这样就无法设置连续的offset了，需要单独处理。包含了两种情况<ol>
<li>start的位置在开始循环的first chunk之前</li>
<li>相邻两个chunk的size过大，超过了page_size</li>
</ol>
</li>
</ol>
</li>
<li>使用最后一个设置offset的chunk的信息更新offset</li>
<li>找到下一个alloc的并且非SHT_NOBITS的chunk的index，之后处理下一个chunk</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> i64 <span class="title">set_file_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 fileoff = <span class="number">0</span>;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;first = *chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(first.shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">      first.shdr.sh_offset = fileoff;</span><br><span class="line">      fileoff += first.shdr.sh_size;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_type == SHT_NOBITS) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_addralign &gt; ctx.page_size)</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      fileoff = <span class="built_in">align_with_skew</span>(fileoff, ctx.page_size, first.shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign ALLOC sections contiguous file offsets as long as they</span></span><br><span class="line">    <span class="comment">// are contiguous in memory.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_offset =</span><br><span class="line">        fileoff + chunks[i]-&gt;shdr.sh_addr - first.shdr.sh_addr;</span><br><span class="line">      i++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= chunks.<span class="built_in">size</span>() ||</span><br><span class="line">          !(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">          chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, addresses may not increase</span></span><br><span class="line">      <span class="comment">// monotonically.</span></span><br><span class="line">      <span class="keyword">if</span> (chunks[i]-&gt;shdr.sh_addr &lt; first.shdr.sh_addr)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      i64 gap_size = chunks[i]-&gt;shdr.sh_addr - chunks[i - <span class="number">1</span>]-&gt;shdr.sh_addr -</span><br><span class="line">                     chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, there may be a large gap between</span></span><br><span class="line">      <span class="comment">// sections. We don&#x27;t want to allocate a disk space for a gap if</span></span><br><span class="line">      <span class="comment">// exists.</span></span><br><span class="line">      <span class="keyword">if</span> (gap_size &gt;= ctx.page_size)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileoff = chunks[i - <span class="number">1</span>]-&gt;shdr.sh_offset + chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">           (chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">           chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fileoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="riscv-resize-sections"><a href="#riscv-resize-sections" class="headerlink" title="riscv_resize_sections"></a>riscv_resize_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On RISC-V, branches are encode using multiple instructions so</span></span><br><span class="line"><span class="comment">// that they can jump to anywhere in ±2 GiB by default. They may</span></span><br><span class="line"><span class="comment">// be replaced with shorter instruction sequences if destinations</span></span><br><span class="line"><span class="comment">// are close enough. Do this optimization.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  filesize </span>= <span class="built_in">riscv_resize_sections</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里主要是针对riscv跳转在2GB范围的限制做的优化，优化后重新计算shdr</p>
<p>做了如下几个步骤</p>
<ol>
<li>获取eflag，unix通常假设RV64GC是baseline，所以这里flag要加上C扩展的flag（EF_RISCV_RVC），而C扩展则是允许压缩指令集，使用2字节编码指令。</li>
<li>针对resizeable的section进行shrink</li>
<li>修正符号值</li>
<li>重新执行上一步的计算offset操作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink sections by interpreting relocations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This operation seems to be optional, because by default longest</span></span><br><span class="line"><span class="comment">// instructions are being used. However, calling this function is actually</span></span><br><span class="line"><span class="comment">// mandatory because of R_RISCV_ALIGN. R_RISCV_ALIGN is a directive to the</span></span><br><span class="line"><span class="comment">// linker to align the location referred to by the relocation to a</span></span><br><span class="line"><span class="comment">// specified byte boundary. We at least have to interpret them to satisfy</span></span><br><span class="line"><span class="comment">// the alignment constraints.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">riscv_resize_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;riscv_resize_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// True if we can use the 2-byte instructions. This is usually true on</span></span><br><span class="line">  <span class="comment">// Unix because RV64GC is generally considered the baseline hardware.</span></span><br><span class="line">  <span class="keyword">bool</span> use_rvc = <span class="built_in">get_eflags</span>(ctx) &amp; EF_RISCV_RVC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find all the relocations that can be relaxed.</span></span><br><span class="line">  <span class="comment">// This step should only shrink sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_resizable</span>(ctx, isec.<span class="built_in">get</span>()))</span><br><span class="line">        <span class="built_in">shrink_section</span>(ctx, *isec, use_rvc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fix symbol values.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>();</span><br><span class="line">      <span class="keyword">if</span> (!isec || isec-&gt;extra.r_deltas.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), sym-&gt;value,</span><br><span class="line">                                 [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r, u64 val) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.r_offset &lt; val;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      sym-&gt;value -= isec-&gt;extra.r_deltas[it - rels.<span class="built_in">begin</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-compute section offset again to finalize them.</span></span><br><span class="line">  <span class="built_in">compute_section_sizes</span>(ctx);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">u64 <span class="title">get_eflags</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> EF_ARM_EABI_VER5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">    std::<span class="built_in">erase</span>(objs, ctx.internal_obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objs.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    u32 ret = objs[<span class="number">0</span>]-&gt;<span class="built_in">get_ehdr</span>().e_flags;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; objs.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span> (objs[i]-&gt;<span class="built_in">get_ehdr</span>().e_flags &amp; EF_RISCV_RVC)</span><br><span class="line">        ret |= EF_RISCV_RVC;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V2&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="resizable"><a href="#resizable" class="headerlink" title="resizable"></a>resizable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_resizable</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">         (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SHF_EXECINSTR</p>
<blockquote>
<p>This section contains executable machine instructions.</p>
</blockquote>
<p>需要分配空间且包含可执行的指令的段才能进行resize。</p>
<h2 id="shrink"><a href="#shrink" class="headerlink" title="shrink"></a>shrink</h2><p>针对所有的rel进行操作，最终为了更新delta值（shrink的size），用于后续fix symbol value</p>
<ol>
<li><p>更新delta的值</p>
</li>
<li><p>R_RISCV_ALIGN是用于align的部分，指向nop指令，因此需要删除nop指令使得对齐到指定alignment</p>
</li>
<li><p>针对一些无法优化的情况进行跳过</p>
<ol>
<li><p>未开启relax选项</p>
<p>其中的relax选项是</p>
<blockquote>
<p>–relax Optimize instructions (default)<br>–no-relax</p>
</blockquote>
</li>
<li><p>搜寻到了最后一个re l</p>
</li>
<li><p>另外下一个rel如果不是RELAX的也无法进行优化</p>
</li>
</ol>
</li>
<li><p>跳过internal_obj，因为synthetic符号还没有最终值，只有确定值的情况才能进行shrink</p>
</li>
<li><p>针对不同rel type进行处理，添加不同的delta值。这里细节不再深究</p>
</li>
<li><p>减少当前input section的size并且更新deltas的值</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scan relocations to shrink sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shrink_section</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec, <span class="keyword">bool</span> use_rvc)</span> </span>&#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  isec.extra.r_deltas.<span class="built_in">resize</span>(rels.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  i64 delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r = rels[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[r.r_sym];</span><br><span class="line">    isec.extra.r_deltas[i] = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling R_RISCV_ALIGN is mandatory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// R_RISCV_ALIGN refers NOP instructions. We need to eliminate some</span></span><br><span class="line">    <span class="comment">// or all of the instructions so that the instruction that immediately</span></span><br><span class="line">    <span class="comment">// follows the NOPs is aligned to a specified alignment boundary.</span></span><br><span class="line">    <span class="keyword">if</span> (r.r_type == R_RISCV_ALIGN) &#123;</span><br><span class="line">      <span class="comment">// The total bytes of NOPs is stored to r_addend, so the next</span></span><br><span class="line">      <span class="comment">// instruction is r_addend away.</span></span><br><span class="line">      u64 loc = isec.<span class="built_in">get_addr</span>() + r.r_offset - delta;</span><br><span class="line">      u64 next_loc = loc + r.r_addend;</span><br><span class="line">      u64 alignment = <span class="built_in">bit_ceil</span>(r.r_addend + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">assert</span>(alignment &lt;= (<span class="number">1</span> &lt;&lt; isec.p2align));</span><br><span class="line">      delta += next_loc - <span class="built_in">align_to</span>(loc, alignment);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling other relocations is optional.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.relax || i == rels.<span class="built_in">size</span>() - <span class="number">1</span> ||</span><br><span class="line">        rels[i + <span class="number">1</span>].r_type != R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linker-synthesized symbols haven&#x27;t been assigned their final</span></span><br><span class="line">    <span class="comment">// values when we are shrinking sections because actual values can</span></span><br><span class="line">    <span class="comment">// be computed only after we fix the file layout. Therefore, we</span></span><br><span class="line">    <span class="comment">// assume that relocations against such symbols are always</span></span><br><span class="line">    <span class="comment">// non-relaxable.</span></span><br><span class="line">    <span class="keyword">if</span> (sym.file == ctx.internal_obj)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      <span class="comment">// These relocations refer an AUIPC + JALR instruction pair to</span></span><br><span class="line">      <span class="comment">// allow to jump to anywhere in PC ± 2 GiB. If the jump target is</span></span><br><span class="line">      <span class="comment">// close enough to PC, we can use C.J, C.JAL or JAL instead.</span></span><br><span class="line">      i64 dist = <span class="built_in">compute_distance</span>(ctx, sym, isec, r);</span><br><span class="line">      <span class="keyword">if</span> (dist &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view contents = isec.contents;</span><br><span class="line">      i64 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + r.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rd == <span class="number">0</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc) &#123;</span><br><span class="line">        <span class="comment">// If rd is x0 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.J, saving 6 bytes.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rd == <span class="number">1</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc &amp;&amp; !E::is_64) &#123;</span><br><span class="line">        <span class="comment">// If rd is x1 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.JAL. This is RV32 only because C.JAL is RV32-only instruction.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(dist, <span class="number">20</span>) == dist) &#123;</span><br><span class="line">        <span class="comment">// If the jump target is within ±1 MiB, we can use JAL.</span></span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      <span class="comment">// If the upper 20 bits are all zero, we can remove LUI.</span></span><br><span class="line">      <span class="comment">// The corresponding instructions referred by LO12_I/LO12_S</span></span><br><span class="line">      <span class="comment">// relocations will use the zero register instead.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD: &#123;</span><br><span class="line">      <span class="comment">// These relocations are used to materialize the upper 20 bits of</span></span><br><span class="line">      <span class="comment">// an address relative to the thread pointer as follows:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  lui  a5,%tprel_hi(foo)         # R_RISCV_TPREL_HI20 (symbol)</span></span><br><span class="line">      <span class="comment">//  add  a5,a5,tp,%tprel_add(foo)  # R_RISCV_TPREL_ADD (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Then thread-local variable `foo` is accessed with a 12-bit offset</span></span><br><span class="line">      <span class="comment">// like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(a5)     # R_RISCV_TPREL_LO12_S (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// However, if the offset is ±2 KiB, we don&#x27;t need to materialize</span></span><br><span class="line">      <span class="comment">// the upper 20 bits in a register. We can instead access the</span></span><br><span class="line">      <span class="comment">// thread-local variable directly with TP like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(tp)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Here, we remove `lui` and `add` if the offset is within ±2 KiB.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx) + r.r_addend - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isec.extra.r_deltas[rels.<span class="built_in">size</span>()] = delta;</span><br><span class="line">  isec.sh_size -= deltfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">requires</span> is_riscv&lt;E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputSectionExtras</span>&lt;</span>E&gt; &#123;</span><br><span class="line">  std::vector&lt;i32&gt; r_deltas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：mold源码阅读十三 计算shdr以及osec offset</li>
        <li>本文作者：Homura</li>
        <li>创建时间：2023-07-15 20:02:55</li>
        <li>
            本文链接：https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/07/22/Life/catch-the-rain/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">赶雨</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/07/09/mold/mold-12-create-some-output-section/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">mold源码阅读十二 创建一些输出段</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2023&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Homura</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#create-reloc-sections"><span class="nav-number">1.</span> <span class="nav-text">create_reloc_sections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#compute-section-headers"><span class="nav-number">2.</span> <span class="nav-text">compute_section_headers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#update-shdr"><span class="nav-number">2.1.</span> <span class="nav-text">update_shdr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E7%A9%BA%E7%9A%84chunk"><span class="nav-number">2.2.</span> <span class="nav-text">移除空的chunk</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%96%B0%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95"><span class="nav-number">2.3.</span> <span class="nav-text">重新更新索引</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#set-osec-offsets"><span class="nav-number">3.</span> <span class="nav-text">set_osec_offsets</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#virtual-address%E8%AE%BE%E7%BD%AE%E8%A7%84%E5%88%99"><span class="nav-number">3.1.</span> <span class="nav-text">virtual address设置规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-virtual-addresses-regular"><span class="nav-number">3.2.</span> <span class="nav-text">set_virtual_addresses_regular</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#relro-padding"><span class="nav-number">3.2.1.</span> <span class="nav-text">relro_padding</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-start"><span class="nav-number">3.2.2.</span> <span class="nav-text">section_start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BB%A1%E8%B6%B3memory-protection"><span class="nav-number">3.2.3.</span> <span class="nav-text">满足memory protection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#to-phdr-flags"><span class="nav-number">3.2.4.</span> <span class="nav-text">to_phdr_flags</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tbss"><span class="nav-number">3.2.5.</span> <span class="nav-text">tbss</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-virtual-addresses-by-order"><span class="nav-number">3.3.</span> <span class="nav-text">set_virtual_addresses_by_order</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-file-offsets"><span class="nav-number">3.4.</span> <span class="nav-text">set_file_offsets</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#riscv-resize-sections"><span class="nav-number">4.</span> <span class="nav-text">riscv_resize_sections</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#resizable"><span class="nav-number">4.1.</span> <span class="nav-text">resizable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shrink"><span class="nav-number">4.2.</span> <span class="nav-text">shrink</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
