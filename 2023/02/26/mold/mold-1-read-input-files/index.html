<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Homura">
    
    <title>
        
            mold源码阅读 其一 读取输入文件 |
        
        Homura&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fusionbolt.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpeg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"我们所度过的每个平凡的日常\n也许就是连续发生的奇迹\n"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
    <meta name="description" content="上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。 首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可">
<meta property="og:type" content="article">
<meta property="og:title" content="mold源码阅读 其一 读取输入文件">
<meta property="og:url" content="https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/index.html">
<meta property="og:site_name" content="Homura&#39;s Blog">
<meta property="og:description" content="上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。 首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/Untitled.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/Untitled%201.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/Untitled%202.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/Untitled%203.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/Untitled%204.png">
<meta property="article:published_time" content="2023-02-26T09:40:55.000Z">
<meta property="article:modified_time" content="2023-02-26T09:45:10.272Z">
<meta property="article:author" content="Homura">
<meta property="article:tag" content="mold">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fusionbolt.github.io/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg">

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0X2R555BND"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0X2R555BND');
</script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Homura's Blog" type="application/atom+xml">
</head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Homura&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/navigation"
                            >
                                导航
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/navigation">导航</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">mold源码阅读 其一 读取输入文件</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Homura</span>
                        
                            <span class="author-label">我摸到了！</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-02-26 17:40:55
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linker/">Linker</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/mold/">mold</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>32 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg"
                      alt="图像"
                >上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。</p>
<p>首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可能从代码中去捋清不同结构之间的联系。</p>
<p>我们从elf_main函数中的read_input_files开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_input_files</span>(ctx, file_args);</span><br></pre></td></tr></table></figure>

<h1 id="read-input-files"><a href="#read-input-files" class="headerlink" title="read_input_files"></a>read_input_files</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_input_files</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::span&lt;std::string&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;read_input_files&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>&gt;&gt; state;</span><br><span class="line">  ctx.is_static = ctx.arg.is_static;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string_view arg = args[<span class="number">0</span>];</span><br><span class="line">    args = args.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="string">&quot;--as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bstatic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bdynamic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--start-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--end-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--version-script=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--version-script: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_version_script</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--dynamic-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dynamic-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol=&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">        ctx.default_version = VER_NDX_GLOBAL;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.version_patterns.<span class="built_in">push_back</span>(&#123;arg, <span class="string">&quot;--export-dynamic-symbol&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;global&quot;</span>, VER_NDX_GLOBAL, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--export-dynamic-symbol-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--push-state&quot;</span>) &#123;</span><br><span class="line">      state.<span class="built_in">push_back</span>(&#123;ctx.as_needed, ctx.whole_archive, ctx.is_static,</span><br><span class="line">                       ctx.in_lib&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--pop-state&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no state pushed before popping&quot;</span>;</span><br><span class="line">      std::<span class="built_in">tie</span>(ctx.as_needed, ctx.whole_archive, ctx.is_static, ctx.in_lib) =</span><br><span class="line">        state.<span class="built_in">back</span>();</span><br><span class="line">      state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;-l&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_library</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      mf-&gt;given_fullpath = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, std::<span class="built_in">string</span>(arg)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no input files&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.tg.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是根据命令行参数确定要读取的输入文件，这里大部分的分支是为了读取符号version信息相关的，主要是看read_file的实现。在看实现之前可以看到传入了一个MappedFile，而这个类的实现其实就是在打开文件的时候使用了mmap进行映射，而must_open则是进行判断，失败了直接报错，这里也不贴具体细节代码了。</p>
<h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.visited.<span class="built_in">contains</span>(mf-&gt;name))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  FileType type = <span class="built_in">get_file_type</span>(mf);</span><br><span class="line">	... 省略对不同type的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是get_file_type，这个是通过文件开头的值确定文件的类型，我们这里以ELF的代码为例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">FileType <span class="title">get_file_type</span><span class="params">(MappedFile&lt;C&gt; *mf)</span> </span>&#123;</span><br><span class="line">  std::string_view data = mf-&gt;<span class="built_in">get_contents</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> FileType::EMPTY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;\177ELF&quot;</span>)) &#123;</span><br><span class="line">    u8 byte_order = ((elf::EL32Ehdr *)data.<span class="built_in">data</span>())-&gt;e_ident[elf::EI_DATA];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (byte_order == elf::ELFDATA2LSB) &#123;</span><br><span class="line">      elf::EL32Ehdr &amp;ehdr = *(elf::EL32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::I386&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::X86_64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elf::EB32Ehdr &amp;ehdr = *(elf::EB32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::M68K&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::SPARC64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FileType::UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  ... 省略其他格式的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从数据开头的“\177ELF”确定为ELF文件，之后根据ELFHeader里面的内容读取更多的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FileType</span> &#123;</span></span><br><span class="line">  UNKNOWN,</span><br><span class="line">  EMPTY,</span><br><span class="line">  ELF_OBJ,</span><br><span class="line">  ELF_DSO,</span><br><span class="line">  MACH_OBJ,</span><br><span class="line">  MACH_EXE,</span><br><span class="line">  MACH_DYLIB,</span><br><span class="line">  MACH_BUNDLE,</span><br><span class="line">  MACH_UNIVERSAL,</span><br><span class="line">  AR,</span><br><span class="line">  THIN_AR,</span><br><span class="line">  TAPI,</span><br><span class="line">  TEXT,</span><br><span class="line">  GCC_LTO_OBJ,</span><br><span class="line">  LLVM_BITCODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>mold当前所支持的FileType就是这些，但是注意，GitHub中mold项目下只存在elf文件的支持，mach的格式则是在sold这个项目中处理。除此之外的文件格式都在以下的switch中进行处理</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/bluewhalesystems/sold" >https://github.com/bluewhalesystems/sold<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, mf, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_DSO:</span><br><span class="line">  ctx.dsos.<span class="built_in">push_back</span>(<span class="built_in">new_shared_file</span>(ctx, mf));</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::AR:</span><br><span class="line"><span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">  <span class="keyword">for</span> (MappedFile&lt;Context&lt;E&gt;&gt; *child : <span class="built_in">read_archive_members</span>(ctx, mf)) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(child)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">      ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, child, mf-&gt;name));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line">    <span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">      <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, child, mf-&gt;name))</span><br><span class="line">        ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::TEXT:</span><br><span class="line">  <span class="built_in">parse_linker_script</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line"><span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">  <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, mf, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: unknown file type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简化下来这里主要分为这么几类文件</p>
<ol>
<li>archive file</li>
<li>lto</li>
<li>linker_script</li>
<li>object_file</li>
<li>shared_file</li>
</ol>
<h2 id="archive-file"><a href="#archive-file" class="headerlink" title="archive file"></a>archive file</h2><p>archive file，也就是俗称的.a文件，其实就是许多个object文件塞到一起只需要解析其中所有member，之后将每个member进行读取即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">std::vector&lt;MappedFile&lt;C&gt; *&gt;</span><br><span class="line"><span class="built_in">read_archive_members</span>(C &amp;ctx, MappedFile&lt;C&gt; *mf) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(mf)) &#123;</span><br><span class="line">  <span class="keyword">case</span> FileType::AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_fat_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_thin_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于ar和thin ar</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://sourceware.org/binutils/docs/binutils/ar.html" >ar (GNU Binary Utilities)<i class="fas fa-external-link-alt"></i></a></p>
<blockquote>
<p>An archive can either be <em>thin</em> or it can be normal. It cannot be both at the same time. Once an archive is created its format cannot be changed without first deleting it and then creating a new archive in its place.</p>
</blockquote>
<p>这里的具体细节暂且略过，如感兴趣可自行查看源码</p>
<h2 id="lto"><a href="#lto" class="headerlink" title="lto"></a>lto</h2><p>lto是用于link time optimization的文件，而本质上还是一个object文件，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_lto_obj</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_lto_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.ignore_ir_file.<span class="built_in">count</span>(mf-&gt;<span class="built_in">get_identifier</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  ObjectFile&lt;E&gt; *file = <span class="built_in">read_lto_object</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  file-&gt;archive_name = archive_name;</span><br><span class="line">  file-&gt;is_in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  ctx.has_lto_object = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在mold中解析lto的方式是通过指定plugin，加载对应的so来进行处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">ObjectFile&lt;E&gt; *<span class="title">read_lto_object</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// V0 API&#x27;s claim_file is not thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_gcc_linker_api_v1)</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.plugin.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: don&#x27;t know how to handle this LTO object file &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;because no -plugin option was given. Please make sure you &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;added -flto not only for creating object files but also for &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;creating the final executable.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dlopen the linker plugin file</span></span><br><span class="line">  <span class="keyword">static</span> std::once_flag flag;</span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;] &#123; <span class="built_in">load_plugin</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure>

<p>学习解析文件的实现主要是要进一步了解ELF的格式，所以这里具体细节就不进行考据了。</p>
<h2 id="linker-script"><a href="#linker-script" class="headerlink" title="linker script"></a>linker script</h2><p>mold的linker script根据解析的过程来看比较简单，没有在ld的脚本中的指定SECTION地址之类的内容，主要是对format以及符号version的一些控制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_linker_script</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  current_file&lt;E&gt; = mf;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string_view&gt; vec = <span class="built_in">tokenize</span>(ctx, mf-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">  std::span&lt;std::string_view&gt; tok = vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!tok.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;OUTPUT_FORMAT&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_output_format</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;INPUT&quot;</span> || tok[<span class="number">0</span>] == <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_group</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;VERSION&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">      <span class="built_in">read_version_script</span>(ctx, tok);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok.<span class="built_in">size</span>() &gt; <span class="number">3</span> &amp;&amp; tok[<span class="number">1</span>] == <span class="string">&quot;=&quot;</span> &amp;&amp; tok[<span class="number">3</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      ctx.arg.defsyms.<span class="built_in">emplace_back</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">0</span>])),</span><br><span class="line">                                   <span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">2</span>])));</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SyntaxError</span>(ctx, tok[<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;unknown linker script token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h2><p>object file是解析过程的重点之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_object_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  ObjectFile&lt;E&gt; *file = ObjectFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf, archive_name, in_lib);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mold以链接速度快出名，而其快的原因之一就是充分利用了多线程，实际进行多线程操作的地方是在这里，ctx.tg.run，tg则是一个tbb::task_group，简而言之就是在这里开启了多线程的解析input file。</p>
<p>做了一些简单的in_lib参数处理，因为archive的链接机制默认是按需链接，而不是像shared file一样全部链接，之后在这里创建了object file并且开始parse。关于创建和parse的细节在后面再说。</p>
<h2 id="shared-file"><a href="#shared-file" class="headerlink" title="shared file"></a>shared file</h2><p>shared file同样是解析过程的重点之一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SharedFile&lt;E&gt; *</span></span><br><span class="line"><span class="function"><span class="title">new_shared_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  SharedFile&lt;E&gt; *file = SharedFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里做了和object file类似的事情。</p>
<h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>在详细讲解object file和shared file创建以及解析之前先介绍一下他们和InputFile类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/Untitled.png"
                      alt="Untitled"
                ></p>
<p>ObjectFile和SharedFile都是简单的从InputFile中继承下来的。而这里的InputFile更像是代表了一个输入的ELF文件，构造的过程中做了一些ELF的基础解析，同时还提供了一些通用的接口，交由ObjectFile和SharedFile各自实现。</p>
<p>我们来看一下InputFile的构造函数部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">InputFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : <span class="built_in">mf</span>(mf), <span class="built_in">filename</span>(mf-&gt;name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfEhdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: file too small&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(mf-&gt;data, <span class="string">&quot;\177ELF&quot;</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: not an ELF file&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfEhdr&lt;E&gt; &amp;ehdr = *(ElfEhdr&lt;E&gt; *)mf-&gt;data;</span><br><span class="line">  is_dso = (ehdr.e_type == ET_DYN);</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *sh_begin = (ElfShdr&lt;E&gt; *)(mf-&gt;data + ehdr.e_shoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shnum contains the total number of sections in an object file.</span></span><br><span class="line">  <span class="comment">// Since it is a 16-bit integer field, it&#x27;s not large enough to</span></span><br><span class="line">  <span class="comment">// represent &gt;65535 sections. If an object file contains more than 65535</span></span><br><span class="line">  <span class="comment">// sections, the actual number is stored to sh_size field.</span></span><br><span class="line">  i64 num_sections = (ehdr.e_shnum == <span class="number">0</span>) ? sh_begin-&gt;sh_size : ehdr.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; (u8 *)(sh_begin + num_sections))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: e_shoff or e_shnum corrupted: &quot;</span></span><br><span class="line">               &lt;&lt; mf-&gt;size &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_sections;</span><br><span class="line">  elf_sections = &#123;sh_begin, sh_begin + num_sections&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line">  <span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">  i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">    ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br><span class="line"></span><br><span class="line">  shstrtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shstrtab_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是从文件大小和文件头部标识信息进行ELF的校验，其次是做一些简单的解析。根据代码中可知，整个文件最开始的部分即可作为一个ElfEhdr（Ehdr：Elf Header）</p>
<p>根据header的信息可以解析出是否为dso文件，ElfShdr（Shdr：Section Header）的起始地址和长度，以及shstrtab（Section Header String Table）的位置。</p>
<p>大多数的参数直接可以获取，但是对于e_shnum和e_shstrndx来说，由于长度只有16bit的限制，因此如果值过大，则会分别存到第一个Shdr的sh_size以及sh_link中。</p>
<p>那么根据这段代码我们可以看出ELF的文件信息是这样的</p>
<h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先是ObjectFile的创建</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt; *</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                      std::string archive_name, <span class="keyword">bool</span> is_in_lib) &#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;(ctx, mf, archive_name, is_in_lib);</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">ObjectFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                          std::string archive_name, <span class="keyword">bool</span> is_in_lib)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf), <span class="built_in">archive_name</span>(archive_name), <span class="built_in">is_in_lib</span>(is_in_lib) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !is_in_lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectFile的构造函数被放入了private中，因此必须通过静态的create方法来创建实例。在每次创建的时候会将对应的obj对象放入到全局的ctx.obj_pool中，mold中的内存与生命周期的管理方式则是全部交由ctx保有，到最后一起释放。而对应的obj_pool为了多线程的设计也都使用了并发的数据结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbb::concurrent_vector&lt;std::unique_ptr&lt;ObjectFile&lt;E&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>ObjectFile的构造函数只是传递了参数，大部分的解析还是在InputFile的构造函数中执行。</p>
<h2 id="parse过程开始"><a href="#parse过程开始" class="headerlink" title="parse过程开始"></a>parse过程开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  sections.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>());</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_SYMTAB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (symtab_sec) &#123;</span><br><span class="line">    <span class="comment">// In ELF, all local symbols precede global symbols in the symbol table.</span></span><br><span class="line">    <span class="comment">// sh_info has an index of the first global symbol.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;first_global = symtab_sec-&gt;sh_info;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialize_sections</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_symbols</span>(ctx);</span><br><span class="line">  <span class="built_in">sort_relocations</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_ehframe_sections</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="symtab-sec"><a href="#symtab-sec" class="headerlink" title="symtab_sec"></a>symtab_sec</h2><p>首先是寻找symtab_sec的过程，寻找段的过程非常简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ElfShdr&lt;E&gt; *InputFile&lt;E&gt;::<span class="built_in">find_section</span>(i64 type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ElfShdr&lt;E&gt; &amp;sec : elf_sections)</span><br><span class="line">    <span class="keyword">if</span> (sec.sh_type == type)</span><br><span class="line">      <span class="keyword">return</span> &amp;sec;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>symtab_sec不存在的情况多半是strip了，直接在elf中搜索symtab是能搜到的，但是如果strip以后就无法找到这个段了，也就是为空的情况</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/Untitled%201.png"
                      alt="Untitled"
                ></p>
<p>sh_link和sh_info对于不同的section有不同的含义，对于这里的symtab来说sh_info就是保存了第一个global symbol的index，而sh_link就是保存了symbol_strtab的地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/Untitled%202.png"
                      alt="Untitled"
                ></p>
<h2 id="initialize-sections"><a href="#initialize-sections" class="headerlink" title="initialize_sections"></a>initialize_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Read sections</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br></pre></td></tr></table></figure>

<p>针对所有的sections开始处理，以下内容都在个循环体之中</p>
<h3 id="特殊SHT的处理"><a href="#特殊SHT的处理" class="headerlink" title="特殊SHT的处理"></a>特殊SHT的处理</h3><p>SHT（Section Header Type）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((shdr.sh_flags &amp; SHF_EXCLUDE) &amp;&amp; !(shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">    shdr.sh_type != SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>这几个段无法在ELF标准中查到，后来查到了这么一段介绍</p>
<p>SHF_EXCLUDE：This section is excluded from input to the link-edit of an executable or shared object. This flag is ignored if the SHF_ALLOC flag is also set, or if relocations exist against the section.</p>
<ol>
<li>如果alloc被set则失效，因此这里要SHF_EXCLUDE以及SHF_ALLOC都满足条件</li>
<li>同时sh_type为SHF_LLVM_ADDRSIG且不是relocatable</li>
</ol>
<p>关于SHF_LLVM_ADDRSIG</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://llvm.org/docs/Extensions.html#id20" >LLVM Extensions — LLVM 17.0.0git documentation<i class="fas fa-external-link-alt"></i></a></p>
<h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p>首先是关于Group的介绍</p>
<blockquote>
<p>This section defines a section group. A section group is a set of sections that are related and that must be treated specially by the linker (see <a class="link"   target="_blank" rel="noopener" href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html#section_groups" >below<i class="fas fa-external-link-alt"></i></a> for further details). Sections of type <code>SHT_GROUP</code> may appear only in relocatable objects (objects with the ELF header <code>e_type</code> member set to <code>ET_REL</code>). The section header table entry for a group section must appear in the section header table before the entries for any of the sections that are members of the group.</p>
</blockquote>
<p><a class="link"   target="_blank" rel="noopener" href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p>
<p>在实现中首先是寻找对应group的签名，签名是关联到了一个esym上，而这个符号的索引则是记录在sh_info中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the signature of this section group.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_info &gt;= <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid symbol index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[shdr.sh_info];</span><br><span class="line"></span><br><span class="line">std::string_view signature;</span><br><span class="line"><span class="keyword">if</span> (esym.st_type == STT_SECTION) &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() +</span><br><span class="line">              <span class="keyword">this</span>-&gt;elf_sections[esym.st_shndx].sh_name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是一些特殊情况的处理。</p>
<ol>
<li>跳过wm4</li>
<li>跳过entries[0]为0的情况</li>
<li>如果[0]不是GRP_COMDAT则是错误</li>
</ol>
<p>之后获取comdat group members，并使用signature来关联一个ComdatGroup</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ignore a broken comdat group GCC emits for .debug_macros.</span></span><br><span class="line"><span class="comment">// https://github.com/rui314/mold/issues/438</span></span><br><span class="line"><span class="keyword">if</span> (signature.<span class="built_in">starts_with</span>(<span class="string">&quot;wm4.&quot;</span>))</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get comdat group members.</span></span><br><span class="line">std::span&lt;U32&lt;E&gt;&gt; entries = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U32&lt;E&gt;&gt;(ctx, shdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: empty SHT_GROUP&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] != GRP_COMDAT)</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported SHT_GROUP format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.comdat_groups)</span>::const_accessor acc</span>;</span><br><span class="line">ctx.comdat_groups.<span class="built_in">insert</span>(acc, &#123;signature, <span class="built_in">ComdatGroup</span>()&#125;);</span><br><span class="line">ComdatGroup *group = <span class="keyword">const_cast</span>&lt;ComdatGroup *&gt;(&amp;acc-&gt;second);</span><br><span class="line">comdat_groups.<span class="built_in">push_back</span>(&#123;group, (u32)i, entries.<span class="built_in">subspan</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>关于上面处理过程中出现的成员的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in context</span></span><br><span class="line">tbb::concurrent_hash_map&lt;std::string_view, ComdatGroup, HashCmp&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ObjectFile</span></span><br><span class="line">std::vector&lt;ComdatGroupRef&lt;E&gt;&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComdatGroupRef</span> &#123;</span></span><br><span class="line">  ComdatGroup *group;</span><br><span class="line">  u32 sect_idx;</span><br><span class="line">  std::span&lt;U32&lt;E&gt;&gt; members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是根据签名关联一个group空，之后将对应group的引用传递给ObjectFile中的comdat_groups</p>
<p>里面的i就是section的index</p>
<p>来看一下这个group段的排布</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| SectionSize | Group1SectionIndex | Group2SectionIndex | … |</span><br></pre></td></tr></table></figure>

<p>关于GRP_COMDAT文档中也有提到</p>
<blockquote>
<p>This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded.</p>
</blockquote>
<h3 id="常规SHT处理"><a href="#常规SHT处理" class="headerlink" title="常规SHT处理"></a>常规SHT处理</h3><p>此处还有很长的特殊段以及开启—gdb-index后需要处理的内容，并非重点，此处先跳过。</p>
<p>常规处理就是简单创建了一个InputSection</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;sections[i] = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br></pre></td></tr></table></figure>

<h3 id="Attach-relocation-sections-to-their-target-sections"><a href="#Attach-relocation-sections-to-their-target-sections" class="headerlink" title="Attach relocation sections to their target sections."></a>Attach relocation sections to their target sections.</h3><p>到这里，所有的section已经执行过了一遍，最后再进行关联</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach relocation sections to their target sections.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_info &gt;= sections.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid relocated section index: &quot;</span></span><br><span class="line">               &lt;&lt; (u32)shdr.sh_info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;target = sections[shdr.sh_info]) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(target-&gt;relsec_idx == <span class="number">-1</span>);</span><br><span class="line">    target-&gt;relsec_idx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对RELA和REL处理，设置上对应的relsec_idx</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_rela = <span class="built_in"><span class="keyword">requires</span></span>(ElfRel&lt;E&gt; r) &#123; r.r_addend; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="initialize-symbols"><a href="#initialize-symbols" class="headerlink" title="initialize_symbols"></a>initialize_symbols</h2><p>这部分的过程主要是将esym转换为Symbol。esym则是ElfSym的缩写，也就是Elf文件中的Symbol定义，而Symbol则是mold中自己定义的，相当于转换为自己想要的格式。</p>
<p>这里的symtab_sec是parse刚开始的时候寻找的section，对应的符号表不存在则不进行这个过程。首先初始化了local_syms以及第0个符号</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;all_syms&quot;</span>)</span></span>;</span><br><span class="line">  counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize local symbols</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;first_global);</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].file = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].sym_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="local-symbol"><a href="#local-symbol" class="headerlink" title="local symbol"></a>local symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: common local symbol?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type == STT_SECTION)</span><br><span class="line">      name = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() + <span class="keyword">this</span>-&gt;elf_sections[<span class="built_in">get_shndx</span>(esym)].sh_name;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;local_syms[i];</span><br><span class="line">    sym.<span class="built_in">set_name</span>(name);</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.value = esym.st_value;</span><br><span class="line">    sym.sym_idx = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>())</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(sections[<span class="built_in">get_shndx</span>(esym)].<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>首先是对于common符号的判断</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_COMMON; &#125;</span><br></pre></td></tr></table></figure>

<p>关于这个SHN_COMMON</p>
<blockquote>
<p>SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.</p>
</blockquote>
<p>大意是common的话不能是local，比如这里说的unallocated C external variables，external和local就是冲突的。</p>
<p>除了报错的common符号之外，其他符号在后面获取对应的名字，如果是section name则去shstrtab中寻找，否则就是常规的符号名，去symbol_strtab中寻找。这里的名字本质上是一个距离对应字符串段的offset，因为字符串相关的数据都统一保存在这shstrtab和symbol_strtab中了。</p>
<p>之后就是获取local_syms的引用，开始设置对应的信息。</p>
<p>在最后，对非abs符号的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_ABS; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have <strong>absolute values and are not affected by relocation.</strong></p>
</blockquote>
<p>非abs符号，也就是说都是相对地址，会affected by relocation。</p>
<p>而实际set_input_section则是设置其mask位，用于区分什么性质的符号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_input_section</span>(InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> addr = (<span class="keyword">uintptr_t</span>)isec;</span><br><span class="line">  <span class="built_in">assert</span>((addr &amp; TAG_MASK) == <span class="number">0</span>);</span><br><span class="line">  origin = addr | TAG_ISEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用2bit区分不同情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol usually belongs to an input section, but it can belong</span></span><br><span class="line"><span class="comment">// to a section fragment, an output section or nothing</span></span><br><span class="line"><span class="comment">// (i.e. absolute symbol). `origin` holds one of them. We use the</span></span><br><span class="line"><span class="comment">// least significant two bits to distinguish type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">  TAG_ABS  = <span class="number">0b00</span>,</span><br><span class="line">  TAG_ISEC = <span class="number">0b01</span>,</span><br><span class="line">  TAG_OSEC = <span class="number">0b10</span>,</span><br><span class="line">  TAG_FRAG = <span class="number">0b11</span>,</span><br><span class="line">  TAG_MASK = <span class="number">0b11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="global-symbol"><a href="#global-symbol" class="headerlink" title="global symbol"></a>global symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbols.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">i64 num_globals = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="keyword">this</span>-&gt;first_global;</span><br><span class="line">symvers.<span class="built_in">resize</span>(num_globals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = &amp;<span class="keyword">this</span>-&gt;local_syms[i];</span><br></pre></td></tr></table></figure>

<p>在开始处理之前可以看到这里又有两个resize容器的位置，目前为止有三处，这里写明了对应的容器以及所处的类，用于区分这个信息是否为ObjectFile only的</p>
<ol>
<li>local symbols(InputFile)</li>
<li>symbols(InputFile)</li>
<li>symvers (ObjectFile)</li>
</ol>
<p>之后将local_sym绑定到symbols中</p>
<p>之后是详细的处理过程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize global symbols</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a symbol name</span></span><br><span class="line">  std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">  std::string_view name = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse symbol version after atsign</span></span><br><span class="line">  <span class="keyword">if</span> (i64 pos = name.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != name.npos) &#123;</span><br><span class="line">    std::string_view ver = name.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    name = name.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ver.<span class="built_in">empty</span>() &amp;&amp; ver != <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">        key = name;</span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">        symvers[i - <span class="keyword">this</span>-&gt;first_global] = ver.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">    has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; symvers;</span><br></pre></td></tr></table></figure>

<p>这里不需要再区分是否为Section的符号，因为global符号不包含section符号。</p>
<p>这里最主要的是需要解析symbol version，因为有的符号会依赖于版本号。要注意的是这个东西并非ELF的官方定义，而是GNU的一个扩展，因此去看elf specification是找不到的。关于名称规范也很简单，常规符号名后接@加符号版本</p>
<p>解析符号版本完成后设置到symvers中，关于这个版本号，最常见的就是GLIBC，以下是本机helloworld代码的示范</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/tmp &gt; nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line"> w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"> U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line"> U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure>

<p>之后是insert symbol，并且设置其common属性。要注意除了这些解析方式外，global symbol和local symbol相比还有一个比较隐藏的不同，global symbol没有设置对应的file，后面很多符号的处理会进行判断file。</p>
<p>接下来是insert symbol的实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a symbol object for a given key. This function handles</span></span><br><span class="line"><span class="comment">// the -wrap option.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Symbol&lt;E&gt; *<span class="title">insert_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string_view key, std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; name.<span class="built_in">starts_with</span>(<span class="string">&quot;__real_&quot;</span>) &amp;&amp;</span><br><span class="line">      ctx.arg.wrap.<span class="built_in">contains</span>(name.<span class="built_in">substr</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">7</span>), name.<span class="built_in">substr</span>(<span class="number">7</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym-&gt;wrap) &#123;</span><br><span class="line">    key = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(key));</span><br><span class="line">    name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(name));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">save_string</span><span class="params">(C &amp;ctx, <span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">  u8 *buf = <span class="keyword">new</span> u8[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">  buf[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  ctx.string_pool.<span class="built_in">push_back</span>(std::unique_ptr&lt;u8[]&gt;(buf));</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)buf, str.<span class="built_in">size</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里不只是不存在key就创建key并返回那么简单。</p>
<ol>
<li>关于save_string的问题，这里也是和之前一样，创建了string后由ctx来管理生命周期，返回一个string_view提供使用。</li>
<li>除此之外get_symbol的部分是实际执行了符号不存在则创建新符号并且返回的工作</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we haven&#x27;t seen the same `key` before, create a new instance</span></span><br><span class="line"><span class="comment">// of Symbol and returns it. Otherwise, returns the previously-</span></span><br><span class="line"><span class="comment">// instantiated object. `key` is usually the same as `name`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">Symbol&lt;E&gt; *<span class="title">get_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.symbol_map)</span>::const_accessor acc</span>;</span><br><span class="line">  ctx.symbol_map.<span class="built_in">insert</span>(acc, &#123;key, Symbol&lt;E&gt;(name)&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Symbol&lt;E&gt; *&gt;(&amp;acc-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>最后提一下-wrap option选项</li>
</ol>
<p>这个-wrap是在main中read_input_files之前的地方设置的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --wrap options if any.</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.wrap)</span><br><span class="line">  <span class="built_in">get_symbol</span>(ctx, name)-&gt;wrap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>关于这个选项我参考了这个回答里的内容，虽然是gcc的介绍，但是本质是相同的</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/46444052/how-to-wrap-functions-with-the-wrap-option-correctly">How to wrap functions with the <code>--wrap</code> option correctly?</a></p>
<p>我摘选了一些关键的段落</p>
<blockquote>
<p>-wrap=symbol<br>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.<br>…<br>If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.</p>
</blockquote>
<blockquote>
<p>… Any <strong>undefined reference</strong> to symbol will be resolved to “__wrap_symbol”. Any <strong>undefined reference</strong>  to “__real_symbol” will be resolved to symbol.</p>
</blockquote>
<p>至此，initialize_symbols就结束了</p>
<h2 id="sort-relocations"><a href="#sort-relocations" class="headerlink" title="sort_relocations"></a>sort_relocations</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relocations are usually sorted by r_offset in relocation tables,</span></span><br><span class="line"><span class="comment">// but for some reason only RISC-V does not follow that convention.</span></span><br><span class="line"><span class="comment">// We expect them to be sorted, so sort them if necessary.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">sort_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> less = [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.r_offset &lt; b.r_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i];</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">is_sorted</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), less))</span><br><span class="line">        <span class="built_in">sort</span>(rels, less);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释，这里的sort是为了将不遵守约定没按照r_offset排序的rv的relocations转换为遵循约定的格式</p>
<h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>关于这里的内容比较长，不仅要包含解析本身，还有ehframe本身的内容，因此留到下期再继续讲。</p>
<h1 id="图解总结"><a href="#图解总结" class="headerlink" title="图解总结"></a>图解总结</h1><p>画了一些比较粗糙的图示将今天的内容串联起来（未标记长度信息，部分大小不标准，没精力画了）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/Untitled%203.png"
                      alt="Untitled"
                ></p>
<p>首先是读取InputFile时的流程，主要是ElfHeader指向ELF文件的哪一部分</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-1-read-input-files/Untitled%204.png"
                      alt="Untitled"
                ></p>
<p>其次是读取Section的时候符号表相关的查找流程，这里还没来得及画具体取名字的部分</p>
<p>从Section Header Table中找到对应sh_type为SHT_SYMTAB的段，之后根据offset和size找到具体存放symbol的位置，同时通过sh_info确定第一个global symbol的index</p>
<h1 id="参考资料汇总"><a href="#参考资料汇总" class="headerlink" title="参考资料汇总"></a>参考资料汇总</h1><p><a class="link"   target="_blank" rel="noopener" href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >Sections<i class="fas fa-external-link-alt"></i></a></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://refspecs.linuxfoundation.org/elf/elf.pdf" >Elf Specification 1.2<i class="fas fa-external-link-alt"></i></a></p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：mold源码阅读 其一 读取输入文件</li>
        <li>本文作者：Homura</li>
        <li>创建时间：2023-02-26 17:40:55</li>
        <li>
            本文链接：https://homura.live/2023/02/26/mold/mold-1-read-input-files/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/04/05/mold/mold-2-read-shared-files/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">mold源码阅读 其二 读取SharedFile</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/02/19/Reading/brave-new-world/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">美丽新世界</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2025&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Homura</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#read-input-files"><span class="nav-number">1.</span> <span class="nav-text">read_input_files</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#read-file"><span class="nav-number">2.</span> <span class="nav-text">read_file</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#archive-file"><span class="nav-number">2.1.</span> <span class="nav-text">archive file</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lto"><span class="nav-number">2.2.</span> <span class="nav-text">lto</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linker-script"><span class="nav-number">2.3.</span> <span class="nav-text">linker script</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#object-file"><span class="nav-number">2.4.</span> <span class="nav-text">object file</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shared-file"><span class="nav-number">2.5.</span> <span class="nav-text">shared file</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InputFile"><span class="nav-number">3.</span> <span class="nav-text">InputFile</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ObjectFile"><span class="nav-number">4.</span> <span class="nav-text">ObjectFile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#create"><span class="nav-number">4.1.</span> <span class="nav-text">create</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parse%E8%BF%87%E7%A8%8B%E5%BC%80%E5%A7%8B"><span class="nav-number">4.2.</span> <span class="nav-text">parse过程开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#symtab-sec"><span class="nav-number">4.3.</span> <span class="nav-text">symtab_sec</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initialize-sections"><span class="nav-number">4.4.</span> <span class="nav-text">initialize_sections</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8ASHT%E7%9A%84%E5%A4%84%E7%90%86"><span class="nav-number">4.4.1.</span> <span class="nav-text">特殊SHT的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#groups"><span class="nav-number">4.4.2.</span> <span class="nav-text">groups</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84SHT%E5%A4%84%E7%90%86"><span class="nav-number">4.4.3.</span> <span class="nav-text">常规SHT处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Attach-relocation-sections-to-their-target-sections"><span class="nav-number">4.4.4.</span> <span class="nav-text">Attach relocation sections to their target sections.</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initialize-symbols"><span class="nav-number">4.5.</span> <span class="nav-text">initialize_symbols</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#local-symbol"><span class="nav-number">4.5.1.</span> <span class="nav-text">local symbol</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#global-symbol"><span class="nav-number">4.5.2.</span> <span class="nav-text">global symbol</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort-relocations"><span class="nav-number">4.6.</span> <span class="nav-text">sort_relocations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#initialize-ehframe-sections"><span class="nav-number">4.7.</span> <span class="nav-text">initialize_ehframe_sections</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%BE%E8%A7%A3%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">图解总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%E6%B1%87%E6%80%BB"><span class="nav-number">6.</span> <span class="nav-text">参考资料汇总</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
