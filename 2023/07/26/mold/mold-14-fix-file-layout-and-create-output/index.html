<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Homura">
    
    <title>
        
            mold源码阅读十四 固定文件layout以及创建输出 |
        
        Homura&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fusionbolt.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpeg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"我们所度过的每个平凡的日常\n也许就是连续发生的奇迹\n"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
    <meta name="description" content="mold源码阅读十四 fix file layout and create output pixiv:92848682   上一期主要讲解了shdr计算更新的部分以及osec offset的设置，这期则是做链接最后的工作。上期在对段shrink的时候也提到部分synthetic的符号值还未固定，本期就会从这部分的值提起，之后则是对debug_section进行压缩，同时文件的大小也会产生变化，到了">
<meta property="og:type" content="article">
<meta property="og:title" content="mold源码阅读十四 固定文件layout以及创建输出">
<meta property="og:url" content="https://fusionbolt.github.io/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/index.html">
<meta property="og:site_name" content="Homura&#39;s Blog">
<meta property="og:description" content="mold源码阅读十四 fix file layout and create output pixiv:92848682   上一期主要讲解了shdr计算更新的部分以及osec offset的设置，这期则是做链接最后的工作。上期在对段shrink的时候也提到部分synthetic的符号值还未固定，本期就会从这部分的值提起，之后则是对debug_section进行压缩，同时文件的大小也会产生变化，到了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-14-fix-file-layout-and-create-output/Untitled.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-14-fix-file-layout-and-create-output/Untitled%201.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-14-fix-file-layout-and-create-output/Untitled%202.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/mold-14-fix-file-layout-and-create-output/Untitled%203.png">
<meta property="article:published_time" content="2023-07-25T16:07:02.000Z">
<meta property="article:modified_time" content="2023-07-29T12:12:18.652Z">
<meta property="article:author" content="Homura">
<meta property="article:tag" content="mold">
<meta property="article:tag" content="rel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fusionbolt.github.io/images/mold-14-fix-file-layout-and-create-output/Untitled.png">

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0X2R555BND"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0X2R555BND');
</script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Homura's Blog" type="application/atom+xml">
</head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Homura&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/navigation"
                            >
                                导航
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/navigation">导航</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">mold源码阅读十四 固定文件layout以及创建输出</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Homura</span>
                        
                            <span class="author-label">我摸到了！</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2023-07-26 00:07:02
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/Linker/">Linker</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/mold/">mold</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/rel/">rel</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>6.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>35 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="mold源码阅读十四-fix-file-layout-and-create-output"><a href="#mold源码阅读十四-fix-file-layout-and-create-output" class="headerlink" title="mold源码阅读十四 fix file layout and create output"></a>mold源码阅读十四 fix file layout and create output</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled.png"
                      alt="Untitled"
                ></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:92848682</center> 

<p>上一期主要讲解了shdr计算更新的部分以及osec offset的设置，这期则是做链接最后的工作。上期在对段shrink的时候也提到部分synthetic的符号值还未固定，本期就会从这部分的值提起，之后则是对debug_section进行压缩，同时文件的大小也会产生变化，到了这里整个文件内部的layout以及文件的大小也就固定了。</p>
<p>接下来就是创建output file，将数据实际拷贝到对应的输出buffer中，实际apply relocate，以及一些其他的操作，此时链接的产物已经完成了。</p>
<h1 id="fix-synthetic-symbols"><a href="#fix-synthetic-symbols" class="headerlink" title="fix_synthetic_symbols"></a>fix_synthetic_symbols</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set actual addresses to linker-synthesized symbols.</span></span><br><span class="line"><span class="built_in">fix_synthetic_symbols</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里主要的任务是设置synthetic符号的值以及对应的origin。设置值的过程大部分都是设置对应chunk的shdr，origin则是标识符号来源，其他细节暂且不进行介绍，后面会单独一期详细查看所有synthetic的符号以及synthetic的section在整个链接过程中的行为，符号的具体作用等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fix_synthetic_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk, i64 bias = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + bias;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> stop = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + chunk-&gt;shdr.sh_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; sections;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;<span class="built_in">kind</span>() != HEADER &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      sections.<span class="built_in">push_back</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;](std::string name) -&gt; Chunk&lt;E&gt; * &#123;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections)</span><br><span class="line">      <span class="keyword">if</span> (chunk-&gt;name == name)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __bss_start</span></span><br><span class="line">  <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.bss&quot;</span>))</span><br><span class="line">    <span class="built_in">start</span>(ctx.__bss_start, chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr &amp;&amp; (ctx.ehdr-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">    ctx.__ehdr_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__ehdr_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">    ctx.__executable_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__executable_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.__dso_handle) &#123;</span><br><span class="line">    ctx.__dso_handle-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__dso_handle-&gt;value = sections[<span class="number">0</span>]-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __rel_iplt_start and __rel_iplt_end. These symbols need to be</span></span><br><span class="line">  <span class="comment">// defined in a statically-linked non-relocatable executable because</span></span><br><span class="line">  <span class="comment">// such executable lacks the .dynamic section and thus there&#x27;s no way</span></span><br><span class="line">  <span class="comment">// to find ifunc relocations other than these symbols.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We don&#x27;t want to set values to these symbols if we are creating a</span></span><br><span class="line">  <span class="comment">// static PIE due to a glibc bug. Static PIE has a dynamic section.</span></span><br><span class="line">  <span class="comment">// If we set values to these symbols in a static PIE, glibc attempts</span></span><br><span class="line">  <span class="comment">// to run ifunc initializers twice, with the second attempt with wrong</span></span><br><span class="line">  <span class="comment">// function addresses, causing a segmentation fault.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn &amp;&amp; ctx.arg.is_static &amp;&amp; !ctx.arg.pie) &#123;</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_start, ctx.reldyn);</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_end, ctx.reldyn);</span><br><span class="line"></span><br><span class="line">    ctx.__rel_iplt_start-&gt;value -=</span><br><span class="line">      <span class="built_in">get_num_irelative_relocs</span>(ctx) * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __&#123;init,fini&#125;_array_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (chunk-&gt;shdr.sh_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SHT_INIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__init_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__init_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_PREINIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__preinit_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__preinit_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_FINI_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__fini_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__fini_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _end, _etext, _edata and the like</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._end, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._etext, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.etext, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != SHT_NOBITS &amp;&amp;</span><br><span class="line">        (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._edata, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.edata, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _DYNAMIC</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._DYNAMIC, ctx.dynamic);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _GLOBAL_OFFSET_TABLE_. I don&#x27;t know why, but for the sake of</span></span><br><span class="line">  <span class="comment">// compatibility with existing code, it must be set to the beginning of</span></span><br><span class="line">  <span class="comment">// .got.plt instead of .got only on i386 and x86-64.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_x86&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">start</span><span class="params">(ctx._GLOBAL_OFFSET_TABLE_, ctx.gotplt)</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">start</span>(ctx._GLOBAL_OFFSET_TABLE_, ctx.got);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _PROCEDURE_LINKAGE_TABLE_. We need this on SPARC.</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._PROCEDURE_LINKAGE_TABLE_, ctx.plt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _TLS_MODULE_BASE_. This symbol is used to obtain the address of</span></span><br><span class="line">  <span class="comment">// the TLS block in the TLSDESC model. I believe GCC and Clang don&#x27;t</span></span><br><span class="line">  <span class="comment">// create a reference to it, but Intel compiler seems to be using</span></span><br><span class="line">  <span class="comment">// this symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx._TLS_MODULE_BASE_) &#123;</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;value = ctx.tls_begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __GNU_EH_FRAME_HDR</span></span><br><span class="line">  <span class="built_in">start</span>(ctx.__GNU_EH_FRAME_HDR, ctx.eh_frame_hdr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RISC-V&#x27;s __global_pointer$</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__global_pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.sdata&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__global_pointer, chunk, <span class="number">0x800</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.__global_pointer-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.__global_pointer-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ARM32&#x27;s __exidx_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__exidx_start) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.ARM.exidx&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__exidx_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__exidx_end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PPC64&#x27;s &quot;.TOC.&quot; symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.TOC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.got&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.toc&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.TOC-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.TOC-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __start_ and __stop_ symbols</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;std::string&gt; name = <span class="built_in">get_start_stop_name</span>(ctx, *chunk)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__start_&quot;</span> + *name)), chunk);</span><br><span class="line">      <span class="built_in">stop</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__stop_&quot;</span> + *name)), chunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.physical_image_base) &#123;</span><br><span class="line">        u64 paddr = <span class="built_in">to_paddr</span>(ctx, chunk-&gt;shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *x = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_start_&quot;</span> + *name));</span><br><span class="line">        x-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        x-&gt;value = paddr;</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *y = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_stop_&quot;</span> + *name));</span><br><span class="line">        y-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        y-&gt;value = paddr + chunk-&gt;shdr.sh_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --defsym=sym=value symbols</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; *sym = ctx.arg.defsyms[i].first;</span><br><span class="line">    std::variant&lt;Symbol&lt;E&gt; *, u64&gt; val = ctx.arg.defsyms[i].second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u64 *addr = std::get_if&lt;u64&gt;(&amp;val)) &#123;</span><br><span class="line">      sym-&gt;origin = <span class="number">0</span>;</span><br><span class="line">      sym-&gt;value = *addr;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; *sym2 = std::get&lt;Symbol&lt;E&gt; *&gt;(val);</span><br><span class="line">    <span class="keyword">if</span> (!sym2-&gt;file) &#123;</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--defsym: undefined symbol: &quot;</span> &lt;&lt; *sym2;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sym-&gt;value = sym2-&gt;value;</span><br><span class="line">    sym-&gt;origin = sym2-&gt;origin;</span><br><span class="line">    sym-&gt;visibility = sym2-&gt;visibility.<span class="built_in">load</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --section-order symbols</span></span><br><span class="line">  <span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">    <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="compress-debug-sections"><a href="#compress-debug-sections" class="headerlink" title="compress_debug_sections"></a>compress_debug_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --compress-debug-sections is given, compress .debug_* sections</span></span><br><span class="line"><span class="comment">// using zlib.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.compress_debug_sections != COMPRESS_NONE)</span><br><span class="line">  filesize = <span class="built_in">compress_debug_sections</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>压缩了所有debug相关的section，由于压缩了section，段的size发生改变，offset也会随之改变，因此之后还需要更新相关表的shdr，最后还会返回新的file size。具体的压缩过程这里就不详细看了。</p>
<blockquote>
<p>–compress-debug-sections [none,zlib,zlib-gabi,zstd]<br>                                        Compress .debug_* sections</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">compress_debug_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compress_debug_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;chunk = *ctx.chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((chunk.shdr.sh_flags &amp; SHF_ALLOC) || chunk.shdr.sh_size == <span class="number">0</span> ||</span><br><span class="line">        !chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Chunk&lt;E&gt; *comp = <span class="keyword">new</span> CompressedSection&lt;E&gt;(ctx, chunk);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(comp);</span><br><span class="line">    ctx.chunks[i] = comp;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.shstrtab-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr)</span><br><span class="line">    ctx.ehdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">u8 *<span class="title">get_uncompressed_data</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> uncompressed.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ElfChdr&lt;E&gt; chdr = &#123;&#125;;</span><br><span class="line">  std::unique_ptr&lt;Compressor&gt; compressed;</span><br><span class="line">  std::unique_ptr&lt;u8[]&gt; uncompressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">CompressedSection&lt;E&gt;::<span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>));</span><br><span class="line">  <span class="keyword">this</span>-&gt;name = chunk.name;</span><br><span class="line"></span><br><span class="line">  uncompressed.<span class="built_in">reset</span>(<span class="keyword">new</span> u8[chunk.shdr.sh_size]);</span><br><span class="line">  chunk.<span class="built_in">write_to</span>(ctx, uncompressed.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.compress_debug_sections) &#123;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZLIB:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZLIB;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZlibCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZSTD:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZSTD;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZstdCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chdr.ch_size = chunk.shdr.sh_size;</span><br><span class="line">  chdr.ch_addralign = chunk.shdr.sh_addralign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr = chunk.shdr;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags |= SHF_COMPRESSED;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="built_in"><span class="keyword">sizeof</span></span>(chdr) + compressed-&gt;compressed_size;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shndx = chunk.shndx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We don&#x27;t need to keep the original data unless --gdb-index is given.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.gdb_index)</span><br><span class="line">    uncompressed.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="create-output-file"><a href="#create-output-file" class="headerlink" title="create output file"></a>create output file</h1><p>到这个位置，所有memory以及file中的layout都就固定了，因此开始准备创建输出文件并且将chunks拷贝到output file中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an output file</span></span><br><span class="line">ctx.output_file =</span><br><span class="line">  OutputFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">open</span>(ctx, ctx.arg.output, filesize, <span class="number">0777</span>);</span><br><span class="line">ctx.buf = ctx.output_file-&gt;buf;</span><br></pre></td></tr></table></figure>

<p>这里的filesize是上一期的set_osec中最后得到的offset（如果经过压缩过debug_section那么就是上面压缩后的filesize），0777则是文件的权限</p>
<h1 id="copy-chunks"><a href="#copy-chunks" class="headerlink" title="copy chunks"></a>copy chunks</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy input sections to the output file and apply relocations.</span></span><br><span class="line"><span class="built_in">copy_chunks</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里遍历了所有chunk并且每个都拷贝到输出文件中。但是先拷贝了非rel的段，之后才拷贝所有rel段，因为在copy output section的时候会apply relocate，在rel_offset的位置写入数据，而在后面rel段copy_buf的时候还可能向同样的地址写入数据。</p>
<p>这里会介绍一下一些主要的copy_chunk的实现（RelSection，OutputSection），其他synthetic符号的细节等到之后的文章再看细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy chunks to an output file</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_chunks</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;copy_chunks&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> copy = [&amp;](Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">    std::string name = chunk.name.<span class="built_in">empty</span>() ? <span class="string">&quot;(header)&quot;</span> : std::<span class="built_in">string</span>(chunk.name);</span><br><span class="line">    <span class="function">Timer <span class="title">t2</span><span class="params">(ctx, name, &amp;t)</span></span>;</span><br><span class="line">    chunk.<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For --relocatable and --emit-relocs, we want to copy non-relocation</span></span><br><span class="line">  <span class="comment">// sections first. This is because REL-type relocation sections (as</span></span><br><span class="line">  <span class="comment">// opposed to RELA-type) stores relocation addends to target sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type == (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">report_undef_errors</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">fixup_arm_exidx_section</span><span class="params">(ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rel的查找过程"><a href="#rel的查找过程" class="headerlink" title="rel的查找过程"></a>rel的查找过程</h2><p>不论是否为rel的output section，都需要有一个定位rel具体位置的过程。首先会先找到所在的osec，一个osec由多个输入的isec组成，每个isec根据其offset在osec中定位，找到具体的isec后则是找到相关的所有rel段</p>
<h2 id="OutputSection"><a href="#OutputSection" class="headerlink" title="OutputSection"></a>OutputSection</h2><p>对nobits的output section写入数据</p>
<ol>
<li>拷贝InputSections的内容到output file中<ol>
<li>copy数据本身</li>
<li>apply relocate</li>
</ol>
</li>
<li>清理掉trail padding（设置为0）</li>
<li>处理thunk</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_type != SHT_NOBITS)</span><br><span class="line">    <span class="built_in">write_to</span>(ctx, ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">auto</span> clear = [&amp;](u8 *loc, i64 size) &#123;</span><br><span class="line">    <span class="comment">// As a special case, .init and .fini are filled with NOPs because the</span></span><br><span class="line">    <span class="comment">// runtime executes the sections as if they were a single function.</span></span><br><span class="line">    <span class="comment">// .init and .fini are superceded by .init_array and .fini_array and</span></span><br><span class="line">    <span class="comment">// being actively used only on s390x though.</span></span><br><span class="line">    <span class="keyword">if</span> (is_s390x&lt;E&gt; &amp;&amp; (<span class="keyword">this</span>-&gt;name == <span class="string">&quot;.init&quot;</span> || <span class="keyword">this</span>-&gt;name == <span class="string">&quot;.fini&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; size; i += <span class="number">2</span>)</span><br><span class="line">        *(ub16 *)(loc + i) = <span class="number">0x0700</span>; <span class="comment">// nop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(loc, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="comment">// Copy section contents to an output file</span></span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *members[i];</span><br><span class="line">    isec.<span class="built_in">write_to</span>(ctx, buf + isec.offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear trailing padding</span></span><br><span class="line">    u64 this_end = isec.offset + isec.sh_size;</span><br><span class="line">    u64 next_start = (i == members.<span class="built_in">size</span>() - <span class="number">1</span>) ?</span><br><span class="line">      (u64)<span class="keyword">this</span>-&gt;shdr.sh_size : members[i + <span class="number">1</span>]-&gt;offset;</span><br><span class="line">    <span class="built_in">clear</span>(buf + this_end, next_start - this_end);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(thunks,</span><br><span class="line">                           [&amp;](std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk) &#123;</span><br><span class="line">      thunk-&gt;<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%201.png"
                      alt="Untitled"
                ></p>
<p>根据osec→shdr.sh_addr以及isec.offset定位到具体的isec，并对每一个isec进行write_to</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_type == SHT_NOBITS || sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy data</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy_contents_riscv</span>(ctx, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">uncompress_to</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply relocations</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.relocatable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC)</span><br><span class="line">      <span class="built_in">apply_reloc_alloc</span>(ctx, buf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">apply_reloc_nonalloc</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="copy数据"><a href="#copy数据" class="headerlink" title="copy数据"></a>copy数据</h3><p>针对非压缩的数据则直接copy，对于压缩后的数据则进行解压</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="apply-reloc-alloc"><a href="#apply-reloc-alloc" class="headerlink" title="apply reloc alloc"></a>apply reloc alloc</h3><p>这个过程也是因架构而异的，下面的代码来自rv</p>
<p>针对每个rel段的位置填写对应符号的地址，因为ElfRel本身不携带这个信息，对应的参数只有r_offset, r_type, r_sym，rela还会多一个r_addend。但根据rel类型的不同计算的方式也有些许的差异。具体的不同rel的计算方式要参考官方的文档，比如说rv的</p>
<p><a class="link"   target="_blank" rel="noopener" href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc" >https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc<i class="fas fa-external-link-alt"></i></a></p>
<p>针对每个rel写入的loc的位置如图所示为osec→shdr.sh_addr + isec.offset + r_offset，不过注意这里的r_offset根据架构不同，可能会进行特殊处理，比如说下面rv的实现中有一个rel.r_offset - get_r_delta(i)的过程（之前shrink过程导致这里需要再处理delta的值）</p>
<p>另外apply_reloc_noalloc的过程也是类似，不再重复展示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%202.png"
                      alt="Untitled"
                ></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">apply_reloc_alloc</span>(Context&lt;E&gt; &amp;ctx, u8 *base) &#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = <span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *dynrel = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn)</span><br><span class="line">    dynrel = (ElfRel&lt;E&gt; *)(ctx.buf + ctx.reldyn-&gt;shdr.sh_offset +</span><br><span class="line">                           file.reldyn_offset + <span class="keyword">this</span>-&gt;reldyn_offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_r_delta = [&amp;](i64 idx) &#123;</span><br><span class="line">    <span class="keyword">return</span> extra.r_deltas.<span class="built_in">empty</span>() ? <span class="number">0</span> : extra.r_deltas[idx];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel = rels[i];</span><br><span class="line">    <span class="keyword">if</span> (rel.r_type == R_NONE || rel.r_type == R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *file.symbols[rel.r_sym];</span><br><span class="line">    i64 r_offset = rel.r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    i64 removed_bytes = <span class="built_in">get_r_delta</span>(i + <span class="number">1</span>) - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    u8 *loc = base + r_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](i64 val, i64 lo, i64 hi) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; lo || hi &lt;= val)</span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: relocation &quot;</span> &lt;&lt; rel &lt;&lt; <span class="string">&quot; against &quot;</span></span><br><span class="line">                   &lt;&lt; sym &lt;&lt; <span class="string">&quot; out of range: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; is not in [&quot;</span></span><br><span class="line">                   &lt;&lt; lo &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hi &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S   sym.get_addr(ctx)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A   rel.r_addend</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P   (get_addr() + r_offset)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G   (sym.get_got_idx(ctx) * sizeof(Word<span class="meta-string">&lt;E&gt;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOT ctx.got-&gt;shdr.sh_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rel.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32:</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(E::is_64)</span></span></span><br><span class="line"><span class="function">        *<span class="params">(U32&lt;E&gt; *)</span>loc </span>= S + A;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_64:</span><br><span class="line">      <span class="built_in">assert</span>(E::is_64);</span><br><span class="line">      <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">12</span>), <span class="number">1</span> &lt;&lt; <span class="number">12</span>);</span><br><span class="line">      <span class="built_in">write_btype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_JAL: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">20</span>), <span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">write_jtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      u32 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + rel.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; jal</span></span><br><span class="line">        *(ul32 *)loc = (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0b1101111</span>;</span><br><span class="line">        <span class="built_in">write_jtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.j</span></span><br><span class="line">        *(ul16 *)loc = <span class="number">0b101&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.jal</span></span><br><span class="line">        <span class="built_in">assert</span>(!E::is_64);</span><br><span class="line">        *(ul16 *)loc = <span class="number">0b001&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span>);</span><br><span class="line">        u64 val = sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>() ? <span class="number">0</span> : S + A - P;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">        <span class="built_in">write_itype</span>(loc + <span class="number">4</span>, val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = G + GOT + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_gottp_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_tlsgd_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">      <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>()) &#123;</span><br><span class="line">        <span class="comment">// Calling an undefined weak symbol does not make sense.</span></span><br><span class="line">        <span class="comment">// We make such call into an infinite loop. This should</span></span><br><span class="line">        <span class="comment">// help debugging of a faulty program.</span></span><br><span class="line">        *(ul32 *)loc = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(ul32 *)loc = S + A - P;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(x0)` if the address is</span></span><br><span class="line">      <span class="comment">// accessible relative to the zero register. If the upper 20 bits</span></span><br><span class="line">      <span class="comment">// are all zero, the corresponding LUI might have been removed.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">      <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span> || removed_bytes == <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, S + A - ctx.tp_addr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_TPREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(tp)` if the address is</span></span><br><span class="line">      <span class="comment">// directly accessible using tp. tp is x4.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD8:</span><br><span class="line">      loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB8:</span><br><span class="line">      loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ALIGN: &#123;</span><br><span class="line">      <span class="comment">// A R_RISCV_ALIGN is followed by a NOP sequence. We need to remove</span></span><br><span class="line">      <span class="comment">// zero or more bytes so that the instruction after R_RISCV_ALIGN is</span></span><br><span class="line">      <span class="comment">// aligned to a given alignment boundary.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We need to guarantee that the NOP sequence is valid after byte</span></span><br><span class="line">      <span class="comment">// removal (e.g. we can&#x27;t remove the first 2 bytes of a 4-byte NOP).</span></span><br><span class="line">      <span class="comment">// For the sake of simplicity, we always rewrite the entire NOP sequence.</span></span><br><span class="line">      i64 padding_bytes = rel.r_addend - removed_bytes;</span><br><span class="line">      <span class="built_in">assert</span>((padding_bytes &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      i64 i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt;= padding_bytes - <span class="number">4</span>; i += <span class="number">4</span>)</span><br><span class="line">        *(ul32 *)(loc + i) = <span class="number">0x0000&#x27;0013</span>; <span class="comment">// nop</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; padding_bytes)</span><br><span class="line">        *(ul16 *)(loc + i) = <span class="number">0x0001</span>;      <span class="comment">// c.nop</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">8</span>), <span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">      <span class="built_in">write_cbtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_JUMP: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">11</span>), <span class="number">1</span> &lt;&lt; <span class="number">11</span>);</span><br><span class="line">      <span class="built_in">write_cjtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((*loc - (S + A)) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((S + A) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET8:</span><br><span class="line">      *loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32_PCREL:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S:</span><br><span class="line">      <span class="comment">// These relocations are handled in the next loop.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> P</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> G</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GOT</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle PC-relative LO12 relocations. In the above loop, pcrel HI20</span></span><br><span class="line">  <span class="comment">// relocations overwrote instructions with full 32-bit values to allow</span></span><br><span class="line">  <span class="comment">// their corresponding pcrel LO12 relocations to read their values.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S: &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file.symbols[rels[i].r_sym];</span><br><span class="line">      <span class="built_in">assert</span>(sym.<span class="built_in">get_input_section</span>() == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)(base + sym.value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[i].r_type == R_RISCV_PCREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the original instructions pcrel HI20 relocations overwrote.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20: &#123;</span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)loc;</span><br><span class="line">      <span class="built_in">memcpy</span>(loc, contents.<span class="built_in">data</span>() + rels[i].r_offset, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%203.png"
                      alt="Untitled"
                ></p>
<p>rel会先计算r_offset，值为对应osec的地址 + isec.offset + r_offset（来自输入的elf文件），r_type则保留，这个计算方式和上面apply_reloc的过程完全一致</p>
<p>之后的处理过程如下</p>
<ol>
<li><p>针对section外的符号直接获取其index，以及addend的信息并且设置值</p>
</li>
<li><p>section的符号则获取到对应的osec的shndx，设置addend为对应section的offset + get_addend()。其中get_addend的过程因架构而异。</p>
<ol>
<li>针对SectionFragment则符号更改为output_section.shndx，原始符号或许是指向合并为fragment之前，由于已经merge到了一起，因此只能指向fragment所在的osec</li>
<li>针对普通section则直接设置为对应osec的shndx</li>
</ol>
</li>
<li><p>设置r_addend</p>
<ol>
<li><p>rela直接设置前面计算的addend</p>
</li>
<li><p>如果是relocatable，那么会根据rel的type在base + rel.r_offset的位置写入addend的值。这个base与上面的r_offset不同，但实际上都是指向最初计算的r_offset的位置，只是这里要写入文件，因此要以文件的buf为起点，而不是0。关于write_addend也是类似于get_addend，</p>
<p>relocatable的情况最后write_addend的位置，也就是之前apply_reloc_alloc写入信息的位置，针对没有addend的情况只能将信息覆盖到这里</p>
</li>
</ol>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelocSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">auto</span> write = [&amp;](ElfRel&lt;E&gt; &amp;out, InputSection&lt;E&gt; &amp;isec, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;out, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(out));</span><br><span class="line">    out.r_offset = isec.output_section-&gt;shdr.sh_addr + isec.offset + rel.r_offset;</span><br><span class="line">    out.r_type = rel.r_type;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().st_type == STT_SECTION) &#123;</span><br><span class="line">      i64 addend;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">        out.r_sym = frag-&gt;output_section.shndx;</span><br><span class="line">        addend = frag-&gt;offset + sym.value + <span class="built_in">get_addend</span>(isec, rel);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InputSection&lt;E&gt; *target = sym.<span class="built_in">get_input_section</span>();</span><br><span class="line">        OutputSection&lt;E&gt; *osec = target-&gt;output_section;</span><br><span class="line">        out.r_sym = osec-&gt;shndx;</span><br><span class="line">        addend = <span class="built_in">get_addend</span>(isec, rel) + target-&gt;offset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">        out.r_addend = addend;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.relocatable) &#123;</span><br><span class="line">        u8 *base = ctx.buf + isec.output_section-&gt;shdr.sh_offset + isec.offset;</span><br><span class="line">        <span class="built_in">write_addend</span>(base + rel.r_offset, addend, rel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym.sym_idx)</span><br><span class="line">        out.r_sym = sym.<span class="built_in">get_output_sym_idx</span>(ctx);</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">        out.r_addend </span>= rel.r_addend;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)output_section.members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    ElfRel&lt;E&gt; *buf = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset) + offsets[i];</span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *output_section.members[i];</span><br><span class="line">    std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; rels.<span class="built_in">size</span>(); j++)</span><br><span class="line">      <span class="built_in">write</span>(buf[j], isec, rels[j]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 Symbol&lt;E&gt;::<span class="built_in">get_output_sym_idx</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  i64 i = file-&gt;output_sym_indices[sym_idx];</span><br><span class="line">  <span class="built_in">assert</span>(i != <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_local</span>(ctx))</span><br><span class="line">    <span class="keyword">return</span> file-&gt;local_symtab_idx + i;</span><br><span class="line">  <span class="keyword">return</span> file-&gt;global_symtab_idx + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="gdb-index"><a href="#gdb-index" class="headerlink" title="gdb_index"></a>gdb_index</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Some part of .gdb_index couldn&#x27;t be computed until other debug</span></span><br><span class="line"><span class="comment">// sections are complete. We have complete debug sections now, so</span></span><br><span class="line"><span class="comment">// write the rest of .gdb_index.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.gdb_index)</span><br><span class="line">  ctx.gdb_index-&gt;<span class="built_in">write_address_areas</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>这里主要是gdb_index写入实际地址，因为在这里符号的地址都已经确定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GdbIndexSection&lt;E&gt;::<span class="built_in">write_address_areas</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;GdbIndexSection::write_address_areas&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  u8 *base = ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    std::string_view name = chunk-&gt;name;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_info&quot;</span>)</span><br><span class="line">      ctx.debug_info = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_abbrev&quot;</span>)</span><br><span class="line">      ctx.debug_abbrev = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_ranges&quot;</span>)</span><br><span class="line">      ctx.debug_ranges = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_addr&quot;</span>)</span><br><span class="line">      ctx.debug_addr = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_rnglists&quot;</span>)</span><br><span class="line">      ctx.debug_rnglists = chunk;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_info);</span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_abbrev);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">    ul64 start;</span><br><span class="line">    ul64 end;</span><br><span class="line">    ul32 attr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read address ranges from debug sections and copy them to .gdb_index.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;debug_info)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Entry *begin = (Entry *)(base + header.areas_offset + file-&gt;area_offset);</span><br><span class="line">    Entry *e = begin;</span><br><span class="line">    u64 offset = file-&gt;debug_info-&gt;offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;compunits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::vector&lt;u64&gt; addrs = <span class="built_in">read_address_areas</span>(ctx, *file, offset);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; addrs.<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Skip an empty range</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == addrs[j + <span class="number">1</span>])</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gdb crashes if there are entries with address 0.</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(e &lt; begin + file-&gt;num_areas);</span><br><span class="line">        e-&gt;start = addrs[j];</span><br><span class="line">        e-&gt;end = addrs[j + <span class="number">1</span>];</span><br><span class="line">        e-&gt;attr = file-&gt;compunits_idx + i;</span><br><span class="line">        e++;</span><br><span class="line">      &#125;</span><br><span class="line">      offset += file-&gt;compunits[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill trailing null entries with dummy values because gdb</span></span><br><span class="line">    <span class="comment">// crashes if there are entries with address 0.</span></span><br><span class="line">    u64 filler;</span><br><span class="line">    <span class="keyword">if</span> (e == begin)</span><br><span class="line">      filler = ctx.etext-&gt;<span class="built_in">get_addr</span>(ctx) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      filler = e[<span class="number">-1</span>].start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; e &lt; begin + file-&gt;num_areas; e++) &#123;</span><br><span class="line">      e-&gt;start = filler;</span><br><span class="line">      e-&gt;end = filler;</span><br><span class="line">      e-&gt;attr = file-&gt;compunits_idx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sort-reldyn"><a href="#sort-reldyn" class="headerlink" title="sort reldyn"></a>sort reldyn</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dynamic linker works better with sorted .rela.dyn section,</span></span><br><span class="line"><span class="comment">// so we sort them.</span></span><br><span class="line">ctx.reldyn-&gt;<span class="built_in">sort</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>对rel段排序，这么做的原理如注释所描述</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the reason why we sort dynamic relocations. Quote from</span></span><br><span class="line"><span class="comment">// https://www.airs.com/blog/archives/186:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   The dynamic linker in glibc uses a one element cache when processing</span></span><br><span class="line"><span class="comment">//   relocs: if a relocation refers to the same symbol as the previous</span></span><br><span class="line"><span class="comment">//   relocation, then the dynamic linker reuses the value rather than</span></span><br><span class="line"><span class="comment">//   looking up the symbol again. Thus the dynamic linker gets the best</span></span><br><span class="line"><span class="comment">//   results if the dynamic relocations are sorted so that all dynamic</span></span><br><span class="line"><span class="comment">//   relocations for a given dynamic symbol are adjacent.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   Other than that, the linker sorts together all relative relocations,</span></span><br><span class="line"><span class="comment">//   which don&#x27;t have symbols. Two relative relocations, or two relocations</span></span><br><span class="line"><span class="comment">//   against the same symbol, are sorted by the address in the output</span></span><br><span class="line"><span class="comment">//   file. This tends to optimize paging and caching when there are two</span></span><br><span class="line"><span class="comment">//   references from the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We group IFUNC relocations at the end of .rel.dyn because we want to</span></span><br><span class="line"><span class="comment">// apply all the other relocations before running user-supplied ifunc</span></span><br><span class="line"><span class="comment">// resolver functions.</span></span><br></pre></td></tr></table></figure>

<p>大意如下：</p>
<ol>
<li>glibc的linker有一个cache，如果一个relocation和前面的relocation引用了相同符号，那么会直2接引用值，而不是重新查找。</li>
<li>linker会将所有没有符号的relative relocation排序，两个relative relocation或者两个针对同一个符号的relocation会按照文件地址排序。存在同一页面的两个引用时可以优化分页和缓存</li>
</ol>
<p>对于一个符号有多个relocation的情况，比如说一个全局变量被不同代码段引用多次，那么每个引用都需要生成一个条目。另外没有符号的relative relocation，是指重定位的记录中不包含符号，只包含偏移，比如说基于pc的相对寻址。</p>
<p>mold在.rel.dyn的末尾对IFUNC重定位进行分组,因为希望在运行用户提供的ifunc解析函数之前应用所有其他重定位。</p>
<p>排序规则基于如下三个方面</p>
<ol>
<li>根据r_type计算的rank</li>
<li>r_sym：重定位的符号在符号表中的索引</li>
<li>r_offset：重定位的位置</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelDynSection&lt;E&gt;::<span class="built_in">sort</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_dynamic_relocs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *begin = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">  ElfRel&lt;E&gt; *end = (ElfRel&lt;E&gt; *)((u8 *)begin + <span class="keyword">this</span>-&gt;shdr.sh_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_rank = [](u32 r_type) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> E::R_RELATIVE: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> E::R_IRELATIVE: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_sort</span>(begin, end, [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(a.r_type), a.r_sym, a.r_offset) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(b.r_type), b.r_sym, b.r_offset);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="clear-padding"><a href="#clear-padding" class="headerlink" title="clear_padding"></a>clear_padding</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zero-clear paddings between sections</span></span><br><span class="line"><span class="built_in">clear_padding</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>将bss外的段中所有padding的空间设置为0，上一期只是设置offset来保证padding，但是padding范围内的值是未定的，在osec写到文件后再来将这部分空间置零。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   		      size          padding</span><br><span class="line">  |                     |         |</span><br><span class="line">offset                       next_offset</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_padding</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;clear_padding&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> zero = [&amp;](Chunk&lt;E&gt; *chunk, i64 next_start) &#123;</span><br><span class="line">    i64 pos = chunk-&gt;shdr.sh_offset + chunk-&gt;shdr.sh_size;</span><br><span class="line">    <span class="built_in">memset</span>(ctx.buf + pos, <span class="number">0</span>, next_start - pos);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; chunks = ctx.chunks;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;shdr.sh_type == SHT_NOBITS;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="built_in">zero</span>(chunks[i - <span class="number">1</span>], chunks[i]-&gt;shdr.sh_offset);</span><br><span class="line">  <span class="built_in">zero</span>(chunks.<span class="built_in">back</span>(), ctx.output_file-&gt;filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="buildid"><a href="#buildid" class="headerlink" title="buildid"></a>buildid</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .note.gnu.build-id section contains a cryptographic hash of the</span></span><br><span class="line"><span class="comment">// entire output file. Now that we wrote everything except build-id,</span></span><br><span class="line"><span class="comment">// we can compute it.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.buildid)</span><br><span class="line">  ctx.buildid-&gt;<span class="built_in">write_buildid</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>计算文件哈希，这对于elf来说并非必要的部分，但是有哈希可以用于校验文件是否完整是否有问题等，无需重新计算。</p>
<p>实际写入到header后的位置，因此写入地址是shdr.sh_offset + HEADER_SIZE。对于几种实现算法这里不再讨论。</p>
<blockquote>
<p>–build-id [none,md5,sha1,sha256,uuid,HEXSTRING]<br>                                     Generate build ID<br>–no-build-id</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildIdSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BuildIdSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.note.gnu.build-id&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_NOTE;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_buildid</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> i64 HEADER_SIZE = <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> BuildIdSection&lt;E&gt;::<span class="built_in">write_buildid</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;build_id&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.build_id.kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HEX:</span><br><span class="line">    <span class="built_in">write_vector</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE,</span><br><span class="line">                 ctx.arg.build_id.value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HASH:</span><br><span class="line">    <span class="comment">// Modern x86 processors have purpose-built instructions to accelerate</span></span><br><span class="line">    <span class="comment">// SHA256 computation, and SHA256 outperforms MD5 on such computers.</span></span><br><span class="line">    <span class="comment">// So, we always compute SHA256 and truncate it if smaller digest was</span></span><br><span class="line">    <span class="comment">// requested.</span></span><br><span class="line">    <span class="built_in">compute_sha256</span>(ctx, <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::UUID: &#123;</span><br><span class="line">    std::array&lt;u8, 16&gt; uuid = <span class="built_in">get_uuid_v4</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE, uuid.<span class="built_in">data</span>(), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="close-file"><a href="#close-file" class="headerlink" title="close file"></a>close file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close the output file. This is the end of the linker&#x27;s main job.</span></span><br><span class="line">ctx.output_file-&gt;<span class="built_in">close</span>(ctx);</span><br></pre></td></tr></table></figure>

<p>至此文件已经成功输出，只剩下最后的一些收尾工作，就留到下期再讲。</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：mold源码阅读十四 固定文件layout以及创建输出</li>
        <li>本文作者：Homura</li>
        <li>创建时间：2023-07-26 00:07:02</li>
        <li>
            本文链接：https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2023/07/29/mold/mold-15-end/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">mold源码阅读十五 最后的收尾工作</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2023/07/22/Life/catch-the-rain/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">赶雨</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Homura</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#mold%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%8D%81%E5%9B%9B-fix-file-layout-and-create-output"><span class="nav-number">1.</span> <span class="nav-text">mold源码阅读十四 fix file layout and create output</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fix-synthetic-symbols"><span class="nav-number">2.</span> <span class="nav-text">fix_synthetic_symbols</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#compress-debug-sections"><span class="nav-number">3.</span> <span class="nav-text">compress_debug_sections</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#create-output-file"><span class="nav-number">4.</span> <span class="nav-text">create output file</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#copy-chunks"><span class="nav-number">5.</span> <span class="nav-text">copy chunks</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rel%E7%9A%84%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B"><span class="nav-number">5.1.</span> <span class="nav-text">rel的查找过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutputSection"><span class="nav-number">5.2.</span> <span class="nav-text">OutputSection</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#copy%E6%95%B0%E6%8D%AE"><span class="nav-number">5.2.1.</span> <span class="nav-text">copy数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#apply-reloc-alloc"><span class="nav-number">5.2.2.</span> <span class="nav-text">apply reloc alloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rel"><span class="nav-number">5.3.</span> <span class="nav-text">rel</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#gdb-index"><span class="nav-number">6.</span> <span class="nav-text">gdb_index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sort-reldyn"><span class="nav-number">7.</span> <span class="nav-text">sort reldyn</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#clear-padding"><span class="nav-number">8.</span> <span class="nav-text">clear_padding</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#buildid"><span class="nav-number">9.</span> <span class="nav-text">buildid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#close-file"><span class="nav-number">10.</span> <span class="nav-text">close file</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
