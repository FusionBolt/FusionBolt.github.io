<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="Homura">
    
    <title>
        
            LLVM Pass 其三：PassBuilder |
        
        Homura&#39;s Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/logo.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"fusionbolt.github.io","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpeg","favicon":"/images/logo.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"我们所度过的每个平凡的日常\n也许就是连续发生的奇迹\n"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
    <meta name="description" content="LLVM Pass 其三：PassBuilder 出来吧，罪青眼白龙！（为什么这张卡台词这么简单   在前面几期中我们讲了新Pass，PassManager，Analysis是怎么样的，这期我们来讲一下PassBuilder以及实际许多Pass是如何组织起来的。 PassBuilder相关的源文件有这几个 include&#x2F;llvm&#x2F;Passes&#x2F;PassBuilder.h lib&#x2F;Passes&#x2F;P">
<meta property="og:type" content="article">
<meta property="og:title" content="LLVM Pass 其三：PassBuilder">
<meta property="og:url" content="https://fusionbolt.github.io/2022/07/10/llvm-pass/llvm-pass-3/index.html">
<meta property="og:site_name" content="Homura&#39;s Blog">
<meta property="og:description" content="LLVM Pass 其三：PassBuilder 出来吧，罪青眼白龙！（为什么这张卡台词这么简单   在前面几期中我们讲了新Pass，PassManager，Analysis是怎么样的，这期我们来讲一下PassBuilder以及实际许多Pass是如何组织起来的。 PassBuilder相关的源文件有这几个 include&#x2F;llvm&#x2F;Passes&#x2F;PassBuilder.h lib&#x2F;Passes&#x2F;P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%201.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%202.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%203.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%204.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%205.png">
<meta property="og:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled%206.png">
<meta property="article:published_time" content="2022-07-10T11:45:23.000Z">
<meta property="article:modified_time" content="2022-07-17T08:54:55.371Z">
<meta property="article:author" content="Homura">
<meta property="article:tag" content="LLVM">
<meta property="article:tag" content="Pass">
<meta property="article:tag" content="PassBuilder">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fusionbolt.github.io/images/llvm-pass-3/Untitled.png">

    <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-0X2R555BND"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-0X2R555BND');
</script>
<meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="Homura's Blog" type="application/atom+xml">
</head>
<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                Homura&#39;s Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/navigation"
                            >
                                导航
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                友链
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/navigation">导航</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">LLVM Pass 其三：PassBuilder</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">Homura</span>
                        
                            <span class="author-label">我摸到了！</span>
                        
                    </div>
                    <div class="meta-info">
                        .article-meta-info {
  font-size: 0.8rem;
  color: var(--third-text-color);

  .article-meta-item {
    margin-right: 10px;

    &:last-child {
      margin-right: 0;
    }
  }


  .article-tags, .article-categories {
    display: inline;

    ul, li {
      display: inline;
    }

    a {
      color: var(--third-text-color);

      &:hover {
        color: var(--primary-color);
      }
    }
  }


  .article-wordcount, .article-tags {
    +keep-mobile() {
      display: none;
    }
  }

  .article-min2read, .article-categories {

    +keep-tablet() {
      display: none;
    }

  }
}

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="LLVM-Pass-其三：PassBuilder"><a href="#LLVM-Pass-其三：PassBuilder" class="headerlink" title="LLVM Pass 其三：PassBuilder"></a>LLVM Pass 其三：PassBuilder</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled.png"
                      alt="Untitled"
                ></p>
<center style="font-size:14px;color:#C0C0C0;text-decoration:underline">出来吧，罪青眼白龙！（为什么这张卡台词这么简单</center> 

<p>在前面几期中我们讲了新Pass，PassManager，Analysis是怎么样的，这期我们来讲一下PassBuilder以及实际许多Pass是如何组织起来的。</p>
<p>PassBuilder相关的源文件有这几个</p>
<p>include/llvm/Passes/PassBuilder.h</p>
<p>lib/Passes/PassBuilder.cpp</p>
<p>lib/Passes/PassBuilderPipelines.cpp</p>
<h1 id="PassBuilder结构"><a href="#PassBuilder结构" class="headerlink" title="PassBuilder结构"></a>PassBuilder结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class provides access to building LLVM&#x27;s passes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Its members provide the baseline state available to passes during their</span></span><br><span class="line"><span class="comment">/// construction. The \c PassRegistry.def file specifies how to construct all</span></span><br><span class="line"><span class="comment">/// of the built-in passes, and those may reference these members during</span></span><br><span class="line"><span class="comment">/// construction.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassBuilder</span> &#123;</span></span><br><span class="line">  TargetMachine *TM;</span><br><span class="line">  PipelineTuningOptions PTO;</span><br><span class="line">  Optional&lt;PGOOptions&gt; PGOOpt;</span><br><span class="line">  PassInstrumentationCallbacks *PIC;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里有一个TargetMachine</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%201.png"
                      alt="Untitled"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%202.png"
                      alt="Untitled"
                ></p>
<p>可以看到由这么几类成员构成</p>
<ol>
<li>存放基本信息的成员，包括TargetMachine以及各种保存的callback等</li>
<li>registerXXXAnalysis / registerXXXCallback</li>
<li>buildXXXpipeline</li>
<li>parseXXXPass / parseXXXPasePipeline</li>
</ol>
<h1 id="PassBuilder的使用"><a href="#PassBuilder的使用" class="headerlink" title="PassBuilder的使用"></a>PassBuilder的使用</h1><p>我们从PassBuilder的使用开始理顺里面的流程。PassBuilder有两处主要的使用位置，一处是在lto中调用，另一处是这次主要讲解的LLVMRunPasses</p>
<p>这个函数对应的头文件是include/llvm-c/Transforms/PassBuilder.h</p>
<p>而LLVMRunPasses的实现在lib/Passes/PassBuilderBindings.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LLVMErrorRef <span class="title">LLVMRunPasses</span><span class="params">(LLVMModuleRef M, <span class="keyword">const</span> <span class="keyword">char</span> *Passes,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMTargetMachineRef TM,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMPassBuilderOptionsRef Options)</span> </span>&#123;</span><br><span class="line">  TargetMachine *Machine = <span class="built_in">unwrap</span>(TM);</span><br><span class="line">  LLVMPassBuilderOptions *PassOpts = <span class="built_in">unwrap</span>(Options);</span><br><span class="line">  <span class="keyword">bool</span> Debug = PassOpts-&gt;DebugLogging;</span><br><span class="line">  <span class="keyword">bool</span> VerifyEach = PassOpts-&gt;VerifyEach;</span><br><span class="line"></span><br><span class="line">  Module *Mod = <span class="built_in">unwrap</span>(M);</span><br><span class="line">  PassInstrumentationCallbacks PIC;</span><br><span class="line">  <span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line">  LoopAnalysisManager LAM;</span><br><span class="line">  FunctionAnalysisManager FAM;</span><br><span class="line">  CGSCCAnalysisManager CGAM;</span><br><span class="line">  ModuleAnalysisManager MAM;</span><br><span class="line">  PB.<span class="built_in">registerLoopAnalyses</span>(LAM);</span><br><span class="line">  PB.<span class="built_in">registerFunctionAnalyses</span>(FAM);</span><br><span class="line">  PB.<span class="built_in">registerCGSCCAnalyses</span>(CGAM);</span><br><span class="line">  PB.<span class="built_in">registerModuleAnalyses</span>(MAM);</span><br><span class="line">  PB.<span class="built_in">crossRegisterProxies</span>(LAM, FAM, CGAM, MAM);</span><br><span class="line"></span><br><span class="line">  <span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">  SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach) &#123;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">VerifierPass</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">run</span>(*Mod, MAM);</span><br><span class="line">  <span class="keyword">return</span> LLVMErrorSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的逻辑非常清晰</p>
<ol>
<li>先对每一种Analysis注册，之后注册Proxies</li>
<li>注册callback</li>
<li>parsePassPieline开始添加Pass到MPM中</li>
</ol>
<p>接下来我们对这三部分操作逐一讲解</p>
<h1 id="注册Analyses"><a href="#注册Analyses" class="headerlink" title="注册Analyses"></a>注册Analyses</h1><p>首先我们回顾一下之前讲过的Pass注册方式。LLVM内部的Pass注册需要在PassRegistry.def中以宏的方式写下，之后在include这个文件的前面定义这些宏，之后再include这个文件完成整个流程</p>
<h2 id="registerXXXAnalyses"><a href="#registerXXXAnalyses" class="headerlink" title="registerXXXAnalyses"></a>registerXXXAnalyses</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::registerModuleAnalyses</span><span class="params">(ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  MAM.registerPass([&amp;] &#123; return CREATE_PASS; &#125;);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModuleAnalysisRegistrationCallbacks)</span><br><span class="line">    <span class="built_in">C</span>(MAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里简单的注册一遍Analysis之后执行一下ModuleAnalysisRegistrationCallbacks</p>
<p>除了Module，Function，Loop之类的实现基本上一致，这里不再重复贴代码了</p>
<h2 id="crossRegisterProxies"><a href="#crossRegisterProxies" class="headerlink" title="crossRegisterProxies"></a>crossRegisterProxies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::crossRegisterProxies</span><span class="params">(LoopAnalysisManager &amp;LAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       FunctionAnalysisManager &amp;FAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       CGSCCAnalysisManager &amp;CGAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerModuleProxy</span>(FAM); &#125;);</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerModuleProxy</span>(CGAM); &#125;);</span><br><span class="line">  CGAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerCGSCCProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerFunctionProxy</span>(CGAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerFunctionProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">LoopAnalysisManagerFunctionProxy</span>(LAM); &#125;);</span><br><span class="line">  LAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerLoopProxy</span>(FAM); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是给各种的AnalysisManager注册了一个XXXXAnalysisManagerXXXProxy，而这些类型本质上是一个给proxy指定了部分模板参数的别名。比如说FunctionAnalysisManagerModuleProxy这个类型</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FunctionAnalysisManagerModuleProxy =</span><br><span class="line">    InnerAnalysisManagerProxy&lt;FunctionAnalysisManager, Module&gt;;</span><br></pre></td></tr></table></figure>

<p>和普通Pass使用adaptor不同的是一个Function的Manager注册了到Module的Proxy，而Module也注册了一个到Function的Proxy。注意这里的是Outer，而不再是Inner了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure>

<h2 id="InnerAnalysisManagerProxy"><a href="#InnerAnalysisManagerProxy" class="headerlink" title="InnerAnalysisManagerProxy"></a>InnerAnalysisManagerProxy</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%203.png"
                      alt="Untitled"
                ></p>
<p>对于Proxy来说功能也是类似于adaptor，用于在不同范围的IRUnit之间转换处理。Inner和adaptor一样，将一个小范围的pass的应用在大的范围上（Function的analysis应用到整个Module上）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAnalysisManagerProxy</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;</span><br><span class="line">          InnerAnalysisManagerProxy&lt;AnalysisManagerT, IRUnitT&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面addPass的行为以及类型声明可以看到Proxy也是一个Analysis，对于一个Analysis最主要的就是run以及Result里的行为了。</p>
<p>这里run的逻辑就是将InnerAM塞到InnerAnalysisManagerProxy::Result中返回</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">           ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Result</span>(*InnerAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(AnalysisManagerT &amp;InnerAM)</span> : InnerAM(&amp;InnerAM) &#123;</span>&#125;</span><br><span class="line">  ...</span><br><span class="line">	<span class="function">AnalysisManagerT &amp;<span class="title">getManager</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *InnerAM; &#125;</span><br><span class="line">  ...</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AnalysisManagerT *InnerAM;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的Result并不是一个具体的什么值，而是一个AnalysisManagerT的包装，这样做避免了每个AnalysisManager中塞入不必要的invalidate。</p>
<p>在实际使用的时候都是要先获取proxy的result再从中getManager，最后从AnalysisManager中获取某个具体的Analysis</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LazyCallGraph <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">    FunctionAnalysisManager &amp;FAM =</span><br><span class="line">        AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">    <span class="keyword">auto</span> GetTLI = [&amp;FAM](Function &amp;F) -&gt; TargetLibraryInfo &amp; &#123;</span><br><span class="line">      <span class="keyword">return</span> FAM.getResult&lt;TargetLibraryAnalysis&gt;(F);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LazyCallGraph</span>(M, GetTLI);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>对于一个Result来说invalidate的行为是最关键的。Result类内部本身并没有定义invalidate的行为，但是通过各种偏特化的形式定义不同IRUnit类型对应的invalidate方式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%204.png"
                      alt="Untitled"
                ></p>
<p>复杂的invalidate逻辑（已删去所有注释），这不是本期重点因此不赘述，整体逻辑应当和上一期的invalidate一致，如果要理顺这些可以看上一期作为参考</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> FunctionAnalysisManagerModuleProxy::Result::<span class="built_in">invalidate</span>(</span><br><span class="line">    Module &amp;M, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span><br><span class="line">    ModuleAnalysisManager::Invalidator &amp;Inv) &#123;</span><br><span class="line">  <span class="keyword">if</span> (PA.<span class="built_in">areAllPreserved</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// This is still a valid proxy.</span></span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.getChecker&lt;FunctionAnalysisManagerModuleProxy&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!PAC.<span class="built_in">preserved</span>() &amp;&amp; !PAC.preservedSet&lt;AllAnalysesOn&lt;Module&gt;&gt;()) &#123;</span><br><span class="line">    InnerAM-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> AreFunctionAnalysesPreserved =</span><br><span class="line">      PA.allAnalysesInSetPreserved&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    Optional&lt;PreservedAnalyses&gt; FunctionPA;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *OuterProxy =</span><br><span class="line">            InnerAM-&gt;getCachedResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F))</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;OuterInvalidationPair :</span><br><span class="line">           OuterProxy-&gt;<span class="built_in">getOuterInvalidations</span>()) &#123;</span><br><span class="line">        AnalysisKey *OuterAnalysisID = OuterInvalidationPair.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;InnerAnalysisIDs = OuterInvalidationPair.second;</span><br><span class="line">        <span class="keyword">if</span> (Inv.<span class="built_in">invalidate</span>(OuterAnalysisID, M, PA)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!FunctionPA)</span><br><span class="line">            FunctionPA = PA;</span><br><span class="line">          <span class="keyword">for</span> (AnalysisKey *InnerAnalysisID : InnerAnalysisIDs)</span><br><span class="line">            FunctionPA-&gt;<span class="built_in">abandon</span>(InnerAnalysisID);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (FunctionPA) &#123;</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, *FunctionPA);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AreFunctionAnalysesPreserved)</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, PA);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OuterAnalysisManagerProxy"><a href="#OuterAnalysisManagerProxy" class="headerlink" title="OuterAnalysisManagerProxy"></a>OuterAnalysisManagerProxy</h2><p>这个与上面提到的InnerAnalysisManagerProxy相反。将一个大范围的Analysis应用到一个小范围的IRUnit上。比如说这个</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure>

<p>除了Result之外的逻辑和InnerAnalysisManagerProxy基本上一致，但是Proxy保存的则是一个const AnalysisManagerT<em>，也就是说是一个只读的包装。Inner的Result是用来存放一个AnalysisManager，而Outer的Result则和外层的Manager一样保存的是一个const AnalysisManagerT</em>，也就是说是一个只读的包装。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span> : OuterAM(&amp;OuterAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Get a cached analysis. If the analysis can be invalidated, this will</span></span><br><span class="line">    <span class="comment">/// assert.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> PassT::Result *<span class="title">getCachedResult</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">if</span> (Res)</span><br><span class="line">        OuterAM-&gt;<span class="keyword">template</span> verifyNotInvalidated&lt;PassT&gt;(IR, Res);</span><br><span class="line">      <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Method provided for unit testing, not intended for general use.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cachedResultExists</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">return</span> Res != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// When invalidation occurs, remove any registered invalidation events.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IRUnitT &amp;IRUnit, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Loop over the set of registered outer invalidation mappings and if any</span></span><br><span class="line">      <span class="comment">// of them map to an analysis that is now invalid, clear it out.</span></span><br><span class="line">      SmallVector&lt;AnalysisKey *, <span class="number">4</span>&gt; DeadKeys;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;KeyValuePair : OuterAnalysisInvalidationMap) &#123;</span><br><span class="line">        AnalysisKey *OuterID = KeyValuePair.first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;InnerIDs = KeyValuePair.second;</span><br><span class="line">        llvm::<span class="built_in">erase_if</span>(InnerIDs, [&amp;](AnalysisKey *InnerID) &#123;</span><br><span class="line">          <span class="keyword">return</span> Inv.<span class="built_in">invalidate</span>(InnerID, IRUnit, PA);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (InnerIDs.<span class="built_in">empty</span>())</span><br><span class="line">          DeadKeys.<span class="built_in">push_back</span>(OuterID);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> OuterID : DeadKeys)</span><br><span class="line">        OuterAnalysisInvalidationMap.<span class="built_in">erase</span>(OuterID);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The proxy itself remains valid regardless of anything else.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register a deferred invalidation event for when the outer analysis</span></span><br><span class="line">    <span class="comment">/// manager processes its invalidations.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OuterAnalysisT, <span class="keyword">typename</span> InvalidatedAnalysisT&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerOuterAnalysisInvalidation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AnalysisKey *OuterID = OuterAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line">      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> &amp;InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];</span><br><span class="line">      <span class="comment">// Note, this is a linear scan. If we end up with large numbers of</span></span><br><span class="line">      <span class="comment">// analyses that all trigger invalidation on the same outer analysis,</span></span><br><span class="line">      <span class="comment">// this entire system should be changed to some other deterministic</span></span><br><span class="line">      <span class="comment">// data structure such as a `SetVector` of a pair of pointers.</span></span><br><span class="line">      <span class="keyword">if</span> (!llvm::<span class="built_in">is_contained</span>(InvalidatedIDList, InvalidatedID))</span><br><span class="line">        InvalidatedIDList.<span class="built_in">push_back</span>(InvalidatedID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Access the map from outer analyses to deferred invalidation requiring</span></span><br><span class="line">    <span class="comment">/// analyses.</span></span><br><span class="line">    <span class="keyword">const</span> SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt; &amp;</span><br><span class="line">    <span class="built_in">getOuterInvalidations</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> OuterAnalysisInvalidationMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> AnalysisManagerT *OuterAM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A map from an outer analysis ID to the set of this IR-unit&#x27;s analyses</span></span><br><span class="line">    <span class="comment">/// which need to be invalidated.</span></span><br><span class="line">    SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt;</span><br><span class="line">        OuterAnalysisInvalidationMap;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OuterAnalysisManagerProxy</span>(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span><br><span class="line">      : <span class="built_in">OuterAM</span>(&amp;OuterAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Run the analysis pass and create our proxy result object.</span></span><br><span class="line">  <span class="comment">/// Nothing to see here, it just forwards the \c OuterAM reference into the</span></span><br><span class="line">  <span class="comment">/// result.</span></span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">             ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(*OuterAM);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意这里的设计是不能修改OuterAM的因此只能获取cached的result，并且有一套自己的analysis Invalidation机制，这里就不展开讲解了。</p>
<p>我们来实际看一下使用的场合。目前实际有效的getResult的场合只搜到了这一处</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getModuleAAResultImpl</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AAResults &amp;AAResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;MAMProxy = AM.getResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *R =</span><br><span class="line">          MAMProxy.<span class="keyword">template</span> getCachedResult&lt;AnalysisT&gt;(*F.<span class="built_in">getParent</span>())) &#123;</span><br><span class="line">    AAResults.<span class="built_in">addAAResult</span>(*R);</span><br><span class="line">    MAMProxy</span><br><span class="line">        .<span class="keyword">template</span> registerOuterAnalysisInvalidation&lt;AnalysisT, AAManager&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我觉得是分析需要在Function内部做，但是全局变量的存在使得Function仍然需要一个全局范围内的别名分析</p>
<h2 id="AnalysisManager结构"><a href="#AnalysisManager结构" class="headerlink" title="AnalysisManager结构"></a>AnalysisManager结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">		FAM(FunctionAnalysisManager)</span><br><span class="line">		LAM(LoopAnalysisManager)</span><br><span class="line">		CGAM(CGSCCAnalysisManager)</span><br><span class="line">		MAM(ModuleAnalysisManager)</span><br><span class="line">		FAMP(FunctionAnalysisManagerModuleProxy)</span><br><span class="line">    CGAMP(CGSCCAnalysisManagerModuleProxy)</span><br><span class="line">    CGAFP(CGSCCAnalysisManagerFunctionProxy)</span><br><span class="line">    MCGAP(ModuleAnalysisManagerCGSCCProxy)</span><br><span class="line">		MAFP(ModuleAnalysisManagerFunctionProxy)</span><br><span class="line">		LAFP(LoopAnalysisManagerFunctionProxy)</span><br><span class="line">		FLAP(FunctionAnalysisManagerLoopProxy)</span><br><span class="line">    MAM --&gt;  FAMP --&gt; FAM</span><br><span class="line">		MAM --&gt; CGAMP --&gt; CGAM</span><br><span class="line">    CGAM --&gt; MCGAP --&gt; MAM</span><br><span class="line">		FAM --&gt; CGAFP --&gt; CGAM</span><br><span class="line">		FAM --&gt; MAFP --&gt; MAM</span><br><span class="line">		FAM --&gt; LAFP --&gt; LAM</span><br><span class="line">		LAM --&gt; FLAP --&gt; FAM</span><br></pre></td></tr></table></figure>

<p>感觉画出来的图非常奇怪…</p>
<p>至此Analysis的部分就已经处理结束了</p>
<h1 id="Callbacks-and-Instrumentation"><a href="#Callbacks-and-Instrumentation" class="headerlink" title="Callbacks and Instrumentation"></a>Callbacks and Instrumentation</h1><p>Analysis之后则是添加各种callback。而这里则是通过StandardInstrumentations来注册callback到PIC（PassInstrumentCallbacks）中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PassInstrumentationCallbacks PIC;</span><br><span class="line"><span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br></pre></td></tr></table></figure>

<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>include/llvm/IR/PassInstrumentation.h</p>
<p>先不说StandardInstrumentations，和PassInstrument相关的有这么两个类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%205.png"
                      alt="Untitled"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/llvm-pass-3/Untitled%206.png"
                      alt="Untitled"
                ></p>
<p>两个类的关系也非常简单，PassInstrumentation中保存了一个实际持有各种callback的PassInstrumentationCallbacks对象。里面保存的各种callbacks的作用从成员名就能看出，这里不再赘述细节</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>而获取PassInstrumentation则是通过PassInstrumentationAnalysis这个analysis获取的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassInstrumentationAnalysis</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"></span><br><span class="line">  PassInstrumentationCallbacks *Callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// PassInstrumentationCallbacks object is shared, owned by something else,</span></span><br><span class="line">  <span class="comment">/// not this analysis.</span></span><br><span class="line">  <span class="built_in">PassInstrumentationAnalysis</span>(PassInstrumentationCallbacks *Callbacks = <span class="literal">nullptr</span>)</span><br><span class="line">      : <span class="built_in">Callbacks</span>(Callbacks) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> Result = PassInstrumentation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManagerT &amp;, ExtraArgTs &amp;&amp;...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PassInstrumentation</span>(Callbacks);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>比如说我们之前讲过的PassManager中的代码（删掉了许多无关的代码）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">    PassInstrumentation PI =</span><br><span class="line">        detail::getAnalysisResult&lt;PassInstrumentationAnalysis&gt;(</span><br><span class="line">            AM, IR, std::tuple&lt;ExtraArgTs...&gt;(ExtraArgs...));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!PI.runBeforePass&lt;IRUnitT&gt;(*P, IR))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">      PreservedAnalyses PassPA;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(P-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">        PassPA = P-&gt;<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Call onto PassInstrumentation&#x27;s AfterPass callbacks immediately after</span></span><br><span class="line">      <span class="comment">// running the pass.</span></span><br><span class="line">      PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="StandardInstrumentations"><a href="#StandardInstrumentations" class="headerlink" title="StandardInstrumentations"></a>StandardInstrumentations</h2><p>StandardInstrumentations里面提供了注册standard pass instrumentations的接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardInstrumentations</span> &#123;</span></span><br><span class="line">  PrintIRInstrumentation PrintIR;</span><br><span class="line">  PrintPassInstrumentation PrintPass;</span><br><span class="line">  TimePassesHandler TimePasses;</span><br><span class="line">  OptNoneInstrumentation OptNone;</span><br><span class="line">  OptBisectInstrumentation OptBisect;</span><br><span class="line">  PreservedCFGCheckerInstrumentation PreservedCFGChecker;</span><br><span class="line">  IRChangedPrinter PrintChangedIR;</span><br><span class="line">  PseudoProbeVerifier PseudoProbeVerification;</span><br><span class="line">  InLineChangePrinter PrintChangedDiff;</span><br><span class="line">  DotCfgChangeReporter WebsiteChangeReporter;</span><br><span class="line">  VerifyInstrumentation Verify;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> VerifyEach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StandardInstrumentations</span>(<span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach = <span class="literal">false</span>,</span><br><span class="line">                           PrintPassOptions PrintPassOpts = <span class="built_in">PrintPassOptions</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all the standard instrumentation callbacks. If \p FAM is nullptr</span></span><br><span class="line">  <span class="comment">// then PreservedCFGChecker is not enabled.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FunctionAnalysisManager *FAM = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">TimePassesHandler &amp;<span class="title">getTimePasses</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TimePasses; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>提供了一些基本的Instrumentation，通过StandardInstrumentations::registerCallbacks来将这些callback注册到PIC中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StandardInstrumentations::<span class="built_in">StandardInstrumentations</span>(</span><br><span class="line">    <span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach, PrintPassOptions PrintPassOpts)</span><br><span class="line">    : <span class="built_in">PrintPass</span>(DebugLogging, PrintPassOpts), <span class="built_in">OptNone</span>(DebugLogging),</span><br><span class="line">      <span class="built_in">PrintChangedIR</span>(PrintChanged == ChangePrinter::PrintChangedVerbose),</span><br><span class="line">      <span class="built_in">PrintChangedDiff</span>(</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose,</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffQuiet),</span><br><span class="line">      <span class="built_in">WebsiteChangeReporter</span>(PrintChanged ==</span><br><span class="line">                            ChangePrinter::PrintChangedDotCfgVerbose),</span><br><span class="line">      <span class="built_in">Verify</span>(DebugLogging), <span class="built_in">VerifyEach</span>(VerifyEach) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardInstrumentations::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC, FunctionAnalysisManager *FAM)</span> </span>&#123;</span><br><span class="line">  PrintIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintPass.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  TimePasses.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptNone.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptBisect.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (FAM)</span><br><span class="line">    PreservedCFGChecker.<span class="built_in">registerCallbacks</span>(PIC, *FAM);</span><br><span class="line">  PrintChangedIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PseudoProbeVerification.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach)</span><br><span class="line">    Verify.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintChangedDiff.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  WebsiteChangeReporter.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看其中一个的实现（比较长，故省略了一部分，基本上都是在register各种callback</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debug logging for transformation and analysis passes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintPassInstrumentation</span> &#123;</span></span><br><span class="line">  <span class="function">raw_ostream &amp;<span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrintPassInstrumentation</span>(<span class="keyword">bool</span> Enabled, PrintPassOptions Opts)</span><br><span class="line">      : <span class="built_in">Enabled</span>(Enabled), <span class="built_in">Opts</span>(Opts) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span> Enabled;</span><br><span class="line">  PrintPassOptions Opts;</span><br><span class="line">  <span class="keyword">int</span> Indent = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">raw_ostream &amp;<span class="title">PrintPassInstrumentation::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Opts.Indent) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(Indent &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dbgs</span>().<span class="built_in">indent</span>(Indent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dbgs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPassInstrumentation::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Enabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;StringRef&gt; SpecialPasses;</span><br><span class="line">  <span class="keyword">if</span> (!Opts.Verbose) &#123;</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassManager&quot;</span>);</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassAdaptor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (!Opts.SkipAnalyses) &#123;</span><br><span class="line">    PIC.<span class="built_in">registerAnalysisInvalidatedCallback</span>([<span class="keyword">this</span>](StringRef PassID, Any IR) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Invalidating analysis: &quot;</span> &lt;&lt; PassID &lt;&lt; <span class="string">&quot; on &quot;</span> &lt;&lt; <span class="built_in">getIRName</span>(IR)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    PIC.<span class="built_in">registerAnalysesClearedCallback</span>([<span class="keyword">this</span>](StringRef IRName) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Clearing all analysis results for: &quot;</span> &lt;&lt; IRName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单的注册了各个阶段的callback</p>
<h1 id="ParsePipeline"><a href="#ParsePipeline" class="headerlink" title="ParsePipeline"></a>ParsePipeline</h1><p>在Analysis和callbacks都处理好以后开始执行parsePassPipeline。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="parsePassPipeline"><a href="#parsePassPipeline" class="headerlink" title="parsePassPipeline"></a>parsePassPipeline</h2><p>PassBuilder的成员函数和ParsePipeline相关的有两类，一个是ParseXXXPassPipeline，另一个是ParseXXXPass</p>
<p>这里我们就先不关心pipeline里面是怎样的形式以及parser的过程了，重点在于通过看这个pipeline了解整个PassManager的构建过程。从parsePassPipeline开始</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parsePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StringRef PipelineText)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> Pipeline = <span class="built_in">parsePipelineText</span>(PipelineText);</span><br><span class="line">  <span class="keyword">if</span> (!Pipeline || Pipeline-&gt;<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid pipeline &#x27;&#123;0&#125;&#x27;&quot;</span>, PipelineText).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(MPM, *Pipeline))</span><br><span class="line">    <span class="keyword">return</span> Err;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="parseModulePassPipeline"><a href="#parseModulePassPipeline" class="headerlink" title="parseModulePassPipeline"></a>parseModulePassPipeline</h2><p>关于parseModulePassPipeline</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ArrayRef&lt;PipelineElement&gt; Pipeline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;Element : Pipeline) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePass</span>(MPM, Element))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePass</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> PipelineElement &amp;E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;Name = E.Name;</span><br><span class="line">  <span class="keyword">auto</span> &amp;InnerPipeline = E.InnerPipeline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First handle complex passes like the pass managers which carry pipelines.</span></span><br><span class="line">  <span class="keyword">if</span> (!InnerPipeline.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">      ModulePassManager NestedMPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">      FunctionPassManager FPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                    Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal passes can&#x27;t have pipelines.</span></span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid use of &#x27;&#123;0&#125;&#x27; pass as module pipeline&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Manually handle aliases for pre-configured pipeline fragments.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startsWithDefaultPipelineAliasPrefix</span>(Name)) &#123;</span><br><span class="line">    SmallVector&lt;StringRef, <span class="number">3</span>&gt; Matches;</span><br><span class="line">    <span class="keyword">if</span> (!DefaultAliasRegex.<span class="built_in">match</span>(Name, &amp;Matches))</span><br><span class="line">      <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">          formatv(<span class="string">&quot;unknown default pipeline alias &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">          <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(Matches.<span class="built_in">size</span>() == <span class="number">3</span> &amp;&amp; <span class="string">&quot;Must capture two matched strings!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    OptimizationLevel L = StringSwitch&lt;OptimizationLevel&gt;(Matches[<span class="number">2</span>])</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O0&quot;</span>, OptimizationLevel::O0)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O1&quot;</span>, OptimizationLevel::O1)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O2&quot;</span>, OptimizationLevel::O2)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O3&quot;</span>, OptimizationLevel::O3)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Os&quot;</span>, OptimizationLevel::Os)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Oz&quot;</span>, OptimizationLevel::Oz);</span><br><span class="line">    <span class="keyword">if</span> (L == OptimizationLevel::O0 &amp;&amp; Matches[<span class="number">1</span>] != <span class="string">&quot;thinlto&quot;</span> &amp;&amp;</span><br><span class="line">        Matches[<span class="number">1</span>] != <span class="string">&quot;lto&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildO0DefaultPipeline</span>(L, Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span> ||</span><br><span class="line">                                                Matches[<span class="number">1</span>] == <span class="string">&quot;lto-pre-link&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is consistent with old pass manager invoked via opt, but</span></span><br><span class="line">    <span class="comment">// inconsistent with clang. Clang doesn&#x27;t enable loop vectorization</span></span><br><span class="line">    <span class="comment">// but does enable slp vectorization at Oz.</span></span><br><span class="line">    PTO.LoopVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line">    PTO.SLPVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildPerModuleDefaultPipeline</span>(L));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally expand the basic registered passes from the .inc file.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">...                                 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">      formatv(<span class="string">&quot;unknown module pass &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">      <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数实在太长了，省略掉了大部分。</p>
<ol>
<li>pipeline非空的情况下继续parseXXXPipeline。通过parseModulePipeline调用parseModulePass我们可以猜到每个parseXXPipeline都会调用对应的parseXXParse</li>
<li>根据优化等级以及一些lto选项添加一些buildXXXDefaultPipeline‘</li>
<li>展开PassRegistry中的定义</li>
</ol>
<p>在详细展开这些之前我们先来讲解一下上面出现的各种createXXAdaptor</p>
<h2 id="Adaptor"><a href="#Adaptor" class="headerlink" title="Adaptor"></a>Adaptor</h2><p>各种adaptor被用于将IRUnit范围更小的Pass应用到更大的IRUnit上，比如说这里的Function的范围比一个Module要小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionPassT&gt;</span><br><span class="line"><span class="function">ModuleToFunctionPassAdaptor</span></span><br><span class="line"><span class="function"><span class="title">createModuleToFunctionPassAdaptor</span><span class="params">(FunctionPassT &amp;&amp;Pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">bool</span> EagerlyInvalidate = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::PassModel&lt;Function, FunctionPassT, PreservedAnalyses,</span><br><span class="line">                        FunctionAnalysisManager&gt;;</span><br><span class="line">  <span class="comment">// Do not use make_unique, it causes too many template instantiations,</span></span><br><span class="line">  <span class="comment">// causing terrible compile times.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ModuleToFunctionPassAdaptor</span>(</span><br><span class="line">      std::unique_ptr&lt;ModuleToFunctionPassAdaptor::PassConceptT&gt;(</span><br><span class="line">          <span class="keyword">new</span> <span class="built_in">PassModelT</span>(std::forward&lt;FunctionPassT&gt;(Pass))),</span><br><span class="line">      EagerlyInvalidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleToFunctionPassAdaptor</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> PassInfoMixin&lt;ModuleToFunctionPassAdaptor&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;PassConceptT&gt; Pass;</span><br><span class="line">  <span class="keyword">bool</span> EagerlyInvalidate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里和一个常规Pass都差不多，主要是run有比较大的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">ModuleToFunctionPassAdaptor::run</span><span class="params">(Module &amp;M,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  FunctionAnalysisManager &amp;FAM =</span><br><span class="line">      AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">  PassInstrumentation PI = AM.getResult&lt;PassInstrumentationAnalysis&gt;(M);</span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    <span class="keyword">if</span> (F.<span class="built_in">isDeclaration</span>())</span><br><span class="line">      <span class="keyword">continue</span>; <span class="function">execution completely <span class="keyword">if</span> asked <span class="title">to</span> <span class="params">(callback returns</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// false).</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!PI.runBeforePass&lt;Function&gt;(*Pass, F))</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    PreservedAnalyses PassPA;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      TimeTraceScope TimeScope(Pass-&gt;name(), F.getName());</span></span></span><br><span class="line"><span class="params"><span class="function">      PassPA = Pass-&gt;run(F, FAM);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PI.runAfterPass(*Pass, F, PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    FAM.invalidate(F, EagerlyInvalidate ? PreservedAnalyses::none() : PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    PA.intersect(std::move(PassPA));</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserveSet&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserve&lt;FunctionAnalysisManagerModuleProxy&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> PA;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>首先是获取AnalysisManager（AM）这里的AM也是通过上面所讲过的Proxy获取的。由于是Function范围的Pass应用到Module的范围上，很自然要遍历大的IR中的所有Function。大体逻辑有点类似于一个PassManager。</p>
<h2 id="parseModulePass与更小范围的IR的parseXXPassPipeline"><a href="#parseModulePass与更小范围的IR的parseXXPassPipeline" class="headerlink" title="parseModulePass与更小范围的IR的parseXXPassPipeline"></a>parseModulePass与更小范围的IR的parseXXPassPipeline</h2><p>根据上面的内容所说，parsePassPipeline会进入到parseModulePipeline中。而在parseModulePass中有这样的处理代码，也就是说可能会嵌套Module，也可能去处理IRUnit范围更小的相关Pass，并通过adaptor来加入到ModulePassManager中。其他的parseXXXPass也是有类似的处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseCGSCCPassPipeline</span>(CGPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">    FunctionPassManager FPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                  Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createRepeatedPass</span>(*Count, std::<span class="built_in">move</span>(NestedMPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="BuildXXPipeline"><a href="#BuildXXPipeline" class="headerlink" title="BuildXXPipeline"></a>BuildXXPipeline</h2><p>相关的逻辑也很简单，就是在这个函数中按照顺序和各种选项添加Pass，返回了一个构建好的ModulePassManager。还记得吗，一个PassManager（PM）添加Pass时可以传另一个PM，此时的行为是直接将传入PM的Pass添加到被添加的PM的Pass列表中。</p>
<p>我们来看一下buildO0DefaultPipeline就好了，这里面不需要根据pipeline的text判断是否添加Pass，用一个非常不严谨的说法是这里面添加的逻辑和你是否指定了里面的Pass没有关系，不像之前的函数都是要先parse pipeline text之后根据parse得到的结果判断某个Pass是否要被添加</p>
<p>这部分的实现都在PassBuilderPipelines.cpp中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ModulePassManager <span class="title">PassBuilder::buildO0DefaultPipeline</span><span class="params">(OptimizationLevel Level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">bool</span> LTOPreLink)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Level == OptimizationLevel::O0 &amp;&amp;</span><br><span class="line">         <span class="string">&quot;buildO0DefaultPipeline should only be used with O0&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Build a minimal pipeline based on the semantics required by LLVM,</span></span><br><span class="line">  <span class="comment">// which is just that always inlining occurs. Further, disable generating</span></span><br><span class="line">  <span class="comment">// lifetime intrinsics to avoid enabling further optimizations during</span></span><br><span class="line">  <span class="comment">// code generation.</span></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">AlwaysInlinerPass</span>(</span><br><span class="line">      <span class="comment">/*InsertLifetimeIntrinsics=*/</span><span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PTO.MergeFunctions)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">MergeFunctionsPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EnableMatrix)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(</span><br><span class="line">        <span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">LowerMatrixIntrinsicsPass</span>(<span class="literal">true</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CGSCCOptimizerLateEPCallbacks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : CGSCCOptimizerLateEPCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(CGPM, Level);</span><br><span class="line">    <span class="keyword">if</span> (!CGPM.<span class="built_in">isEmpty</span>())</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ModulePassManager CoroPM;</span><br><span class="line">  CoroPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">CoroEarlyPass</span>()));</span><br><span class="line">  CGSCCPassManager CGPM;</span><br><span class="line">  CGPM.<span class="built_in">addPass</span>(<span class="built_in">CoroSplitPass</span>());</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (LTOPreLink)</span><br><span class="line">    <span class="built_in">addRequiredLTOPreLinkPasses</span>(MPM);</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">AnnotationRemarksPass</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MPM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="展开Registry"><a href="#展开Registry" class="headerlink" title="展开Registry"></a>展开Registry</h2><p>展开PassRegistry中的定义，有这么几类</p>
<h3 id="直接添加ModulePass"><a href="#直接添加ModulePass" class="headerlink" title="直接添加ModulePass"></a>直接添加ModulePass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>有的还需要传入参数构造Pass</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS_WITH_PARAMS(NAME, CLASS, CREATE_PASS, PARSER, PARAMS)      \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (checkParametrizedPassName(Name, NAME)) &#123;                                 \</span></span><br><span class="line"><span class="meta">    auto Params = parsePassParameters(PARSER, Name, NAME);                     \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (!Params)                                                               \</span></span><br><span class="line"><span class="meta">      return Params.takeError();                                               \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS(Params.get()));                                    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="通过adaptor的形式传入PassManager"><a href="#通过adaptor的形式传入PassManager" class="headerlink" title="通过adaptor的形式传入PassManager"></a>通过adaptor的形式传入PassManager</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS)                                       \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(CREATE_PASS));               \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<p>不仅是一层，甚至会有多层Adaptor</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_PASS(NAME, CREATE_PASS)                                           \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(                             \</span></span><br><span class="line"><span class="meta">        createFunctionToLoopPassAdaptor(CREATE_PASS, false, false)));          \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="AnalysisPass"><a href="#AnalysisPass" class="headerlink" title="AnalysisPass"></a>AnalysisPass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == <span class="meta-string">&quot;require&lt;&quot;</span> NAME <span class="meta-string">&quot;&gt;&quot;</span>) &#123;                                           \</span></span><br><span class="line"><span class="meta">    MPM.addPass(                                                               \</span></span><br><span class="line"><span class="meta">        RequireAnalysisPass&lt;                                                   \</span></span><br><span class="line"><span class="meta">            std::remove_reference<span class="meta-string">&lt;decltype(CREATE_PASS)&gt;</span>::type, Module&gt;());    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;                                  </span></span><br><span class="line">                                          \</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;invalidate&lt;&quot;</span> NAME <span class="string">&quot;&gt;&quot;</span>) &#123;                                        \</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(InvalidateAnalysisPass&lt;                                        \</span><br><span class="line">                std::remove_reference&lt;<span class="keyword">decltype</span>(CREATE_PASS)&gt;::type&gt;());        \</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();                                                   \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="PassManager中Pass的结构"><a href="#PassManager中Pass的结构" class="headerlink" title="PassManager中Pass的结构"></a>PassManager中Pass的结构</h2><p>实际还有CGSCC以及Loop之类的Pass，这里就挑出三个有代表性的结构展示关系了</p>
<p>一个是顶级的ModulePass，一个是一层adaptor，另一个是多层adaptor</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    R(ModulePassManager)</span><br><span class="line">    R--&gt;MP(ModulePass)</span><br><span class="line">    R--&gt;FP(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FP--&gt;FPS(FunctionPass)</span><br><span class="line">    R--&gt;FPTemp(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FPTemp--&gt;LPP(FunctionToLoopPassAdator)</span><br><span class="line">    LPP--&gt;LPPS(LoopPass)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="用户自定义添加Pass的方式"><a href="#用户自定义添加Pass的方式" class="headerlink" title="用户自定义添加Pass的方式"></a>用户自定义添加Pass的方式</h1><p>最后介绍一下讲解一下如何添加自己的Pass到LLVM中。在llvm官方的仓库里example目录中有这么一段代码</p>
<p>examples/Bye/Bye.cpp</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* New PM Registration */</span></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getByePluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Bye&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerVectorizerStartEPCallback</span>(</span><br><span class="line">                [](llvm::FunctionPassManager &amp;PM, OptimizationLevel Level) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, llvm::FunctionPassManager &amp;PM,</span><br><span class="line">                   ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;goodbye&quot;</span>) &#123;</span><br><span class="line">                    PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_BYE_LINK_INTO_TOOLS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getByePluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassPluginLibraryInfo</span> &#123;</span></span><br><span class="line">  <span class="comment">/// The API version understood by this plugin, usually \c</span></span><br><span class="line">  <span class="comment">/// LLVM_PLUGIN_API_VERSION</span></span><br><span class="line">  <span class="keyword">uint32_t</span> APIVersion;</span><br><span class="line">  <span class="comment">/// A meaningful name of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginName;</span><br><span class="line">  <span class="comment">/// The version of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginVersion;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The callback for registering plugin passes with a \c PassBuilder</span></span><br><span class="line">  <span class="comment">/// instance</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*RegisterPassBuilderCallbacks)(PassBuilder &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里我们先不考虑PassPlugin相关的具体细节。通过这种插件的方式可以给LLVM添加一些自己实现的Pass，可以看到有一个传入PassBuilder的lambda，之后通过注册各种callback来实现。LLVM也一定有某种机制找到对应的Plugin之后调用其callback</p>
<p>除此之外上面提及过的PassBuilder的构造函数有这么一段代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PassBuilder::<span class="built_in">PassBuilder</span>(TargetMachine *TM, PipelineTuningOptions PTO,</span><br><span class="line">                         Optional&lt;PGOOptions&gt; PGOOpt,</span><br><span class="line">                         PassInstrumentationCallbacks *PIC)</span><br><span class="line">    : <span class="built_in">TM</span>(TM), <span class="built_in">PTO</span>(PTO), <span class="built_in">PGOOpt</span>(PGOOpt), <span class="built_in">PIC</span>(PIC) &#123;</span><br><span class="line">  <span class="keyword">if</span> (TM)</span><br><span class="line">    TM-&gt;<span class="built_in">registerPassBuilderCallbacks</span>(*<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说如果你是调用LLVM进行生成代码而不是给llvm添加一个自己的Pass的话应该在自己继承的TargetMachine中实现registerPassBuilderCallbacks方法，而在这个方法中也应当是通过传入的PassBuilder添加各种callback的形式</p>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：LLVM Pass 其三：PassBuilder</li>
        <li>本文作者：Homura</li>
        <li>创建时间：2022-07-10 19:45:23</li>
        <li>
            本文链接：https://homura.live/2022/07/10/llvm-pass/llvm-pass-3/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/07/17/llvm-pass/llvm-pass-4/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LLVM Pass 其四：PassManager的改进与迁移现状</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/07/03/llvm-pass/llvm-pass-2/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">LLVM Pass 其二：Analysis与AnalysisManager</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">Homura</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LLVM-Pass-%E5%85%B6%E4%B8%89%EF%BC%9APassBuilder"><span class="nav-number">1.</span> <span class="nav-text">LLVM Pass 其三：PassBuilder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PassBuilder%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">PassBuilder结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#PassBuilder%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.</span> <span class="nav-text">PassBuilder的使用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%A8%E5%86%8CAnalyses"><span class="nav-number">4.</span> <span class="nav-text">注册Analyses</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#registerXXXAnalyses"><span class="nav-number">4.1.</span> <span class="nav-text">registerXXXAnalyses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#crossRegisterProxies"><span class="nav-number">4.2.</span> <span class="nav-text">crossRegisterProxies</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnerAnalysisManagerProxy"><span class="nav-number">4.3.</span> <span class="nav-text">InnerAnalysisManagerProxy</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Result"><span class="nav-number">4.3.1.</span> <span class="nav-text">Result</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#invalidate"><span class="nav-number">4.3.2.</span> <span class="nav-text">invalidate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OuterAnalysisManagerProxy"><span class="nav-number">4.4.</span> <span class="nav-text">OuterAnalysisManagerProxy</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AnalysisManager%E7%BB%93%E6%9E%84"><span class="nav-number">4.5.</span> <span class="nav-text">AnalysisManager结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Callbacks-and-Instrumentation"><span class="nav-number">5.</span> <span class="nav-text">Callbacks and Instrumentation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-number">5.1.</span> <span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">5.2.</span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StandardInstrumentations"><span class="nav-number">5.3.</span> <span class="nav-text">StandardInstrumentations</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ParsePipeline"><span class="nav-number">6.</span> <span class="nav-text">ParsePipeline</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#parsePassPipeline"><span class="nav-number">6.1.</span> <span class="nav-text">parsePassPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parseModulePassPipeline"><span class="nav-number">6.2.</span> <span class="nav-text">parseModulePassPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Adaptor"><span class="nav-number">6.3.</span> <span class="nav-text">Adaptor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#parseModulePass%E4%B8%8E%E6%9B%B4%E5%B0%8F%E8%8C%83%E5%9B%B4%E7%9A%84IR%E7%9A%84parseXXPassPipeline"><span class="nav-number">6.4.</span> <span class="nav-text">parseModulePass与更小范围的IR的parseXXPassPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BuildXXPipeline"><span class="nav-number">6.5.</span> <span class="nav-text">BuildXXPipeline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B1%95%E5%BC%80Registry"><span class="nav-number">6.6.</span> <span class="nav-text">展开Registry</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%B7%BB%E5%8A%A0ModulePass"><span class="nav-number">6.6.1.</span> <span class="nav-text">直接添加ModulePass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E8%BF%87adaptor%E7%9A%84%E5%BD%A2%E5%BC%8F%E4%BC%A0%E5%85%A5PassManager"><span class="nav-number">6.6.2.</span> <span class="nav-text">通过adaptor的形式传入PassManager</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AnalysisPass"><span class="nav-number">6.6.3.</span> <span class="nav-text">AnalysisPass</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PassManager%E4%B8%ADPass%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">6.7.</span> <span class="nav-text">PassManager中Pass的结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B7%BB%E5%8A%A0Pass%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">7.</span> <span class="nav-text">用户自定义添加Pass的方式</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>




    
<script src="/js/lazyload.js"></script>



<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        const pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
