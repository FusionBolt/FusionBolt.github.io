<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2022-06-26T11:52:51.307Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LLVM Pass其一：PassManager</title>
    <link href="https://fusionbolt.github.io/2022/06/26/llvm-pass-1/"/>
    <id>https://fusionbolt.github.io/2022/06/26/llvm-pass-1/</id>
    <published>2022-06-26T11:51:06.000Z</published>
    <updated>2022-06-26T11:52:51.307Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">现身吧，青眼亚白龙！ 把他给我烧的一干二净。毁灭的焦热疾风弹</center> <p>上一期我们讲到了每个Pass基本的结构，这期我们从PassManager开始讲述Pass从创建到执行的整个流程，以及涉及到的种种问题</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT,</span><br><span class="line">          <span class="keyword">typename</span> AnalysisManagerT = AnalysisManager&lt;IRUnitT&gt;,</span><br><span class="line">          <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line">class PassManager : <span class="keyword">public</span> PassInfoMixin&lt;</span><br><span class="line">                        PassManager&lt;IRUnitT, AnalysisManagerT, ExtraArgTs...&gt;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;PassConceptT&gt;&gt; Passes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于声明中要注意的有一点：上一期我们提到继承了PassInfoMixin的类我们就可以视为是一个Pass（从语法角度来说），也就是说PassManager本身也是一个Pass</p><p>接着来讲一下模板参数</p><h2 id="IRUnit"><a href="#IRUnit" class="headerlink" title="IRUnit"></a>IRUnit</h2><p>对于每个Pass有其作用的范围，有的是作用在函数上的，有的是作用到一个CFG中的</p><p>还记得上期里讲到新Pass是通过run传进去的参数来决定是作用到什么样的pass么</p><p>AnalysisManagerT</p><h1 id="添加一个Pass"><a href="#添加一个Pass" class="headerlink" title="添加一个Pass"></a>添加一个Pass</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!std::is_same&lt;PassT, PassManager&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::PassModel&lt;IRUnitT, PassT, PreservedAnalyses, AnalysisManagerT,</span><br><span class="line">                        ExtraArgTs...&gt;;</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  Passes.<span class="built_in">push_back</span>(std::unique_ptr&lt;PassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先不管enable_if_t的部分，参数也没什么可讲的，我们来看函数体的部分</p><p>可以看到实际传给PassManager的其实是一个PassModelT的实例，而不是一个Pass</p><h2 id="PassModel"><a href="#PassModel" class="headerlink" title="PassModel"></a>PassModel</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%201.png"                      alt="Untitled"                ></p><p>include/llvm/IR/PassManagerInternal.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT, <span class="keyword">typename</span> PreservedAnalysesT,</span><br><span class="line">          <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassModel</span> :</span> PassConcept&lt;IRUnitT, AnalysisManagerT, ExtraArgTs...&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="function">PreservedAnalysesT <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                         ExtraArgTs... ExtraArgs)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pass.<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">  &#125;</span><br><span class="line">PassT Pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PassModel做的事情也很简单，最重要的就是运行保存的Pass实例。</p><p>上期提到了实现Pass时isRequired是可选的。对于非required的pass也不需要手动编写一个返回false的函数，而秘密就在于这个函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">has_required_t</span> = <span class="keyword">decltype</span>(std::declval&lt;T &amp;&gt;().<span class="built_in">isRequired</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_required_t</span>, T&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">passIsRequiredImpl</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> T::<span class="built_in">isRequired</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_required_t</span>, T&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">passIsRequiredImpl</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> passIsRequiredImpl&lt;PassT&gt;(); &#125;</span><br></pre></td></tr></table></figure><p>而这部分类似的代码还存在于PassInstrumentation的代码中。对于PassInstrumentation来说接收的就是一个PassT，并不一定就是PassModel 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">has_required_t</span> = <span class="keyword">decltype</span>(std::declval&lt;PassT &amp;&gt;().<span class="built_in">isRequired</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_required_t</span>, PassT&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">isRequired</span>(<span class="keyword">const</span> PassT &amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">return</span> Pass.<span class="built_in">isRequired</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_required_t</span>, PassT&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">isRequired</span>(<span class="keyword">const</span> PassT &amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加一个PassManager"><a href="#添加一个PassManager" class="headerlink" title="添加一个PassManager"></a>添加一个PassManager</h2><p>除了可以添加一个常规的Pass，还可以添加一个PassManager到一个PassManager中，听起来很奇怪，但是PassManager的行为也是一种Pass</p><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;std::is_same&lt;PassT, PassManager&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;P : Pass.Passes)</span><br><span class="line">    Passes.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(P));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过使用enable_if_t来判断这个PassT是否为PassManager。</p><p>关于为什么要这么做，目前的PassManager run的部分没有处理嵌套的情况，注释中提到了</p><blockquote><p>cases rely on executing nested pass managers. Doing this could reduce implementation complexity and avoid potential invalidation issues that may happen with nested pass managers of the same type.</p></blockquote><p>大意就是减少实现复杂度以及减少问题</p><h1 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h1><p>先来大概看一遍代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Run all of the passes in this manager over the given unit of IR.</span></span><br><span class="line"><span class="comment">/// ExtraArgs are passed to each pass.</span></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Request PassInstrumentation from analysis manager, will use it to run</span></span><br><span class="line">  <span class="comment">// instrumenting callbacks for the passes later.</span></span><br><span class="line">  <span class="comment">// Here we use std::tuple wrapper over getResult which helps to extract</span></span><br><span class="line">  <span class="comment">// AnalysisManager&#x27;s arguments out of the whole ExtraArgs set.</span></span><br><span class="line">  PassInstrumentation PI =</span><br><span class="line">      detail::getAnalysisResult&lt;PassInstrumentationAnalysis&gt;(</span><br><span class="line">          AM, IR, std::tuple&lt;ExtraArgTs...&gt;(ExtraArgs...));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *P = Passes[Idx].<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">    <span class="comment">// pass, skip its execution completely if asked to (callback returns</span></span><br><span class="line">    <span class="comment">// false).</span></span><br><span class="line">    <span class="keyword">if</span> (!PI.runBeforePass&lt;IRUnitT&gt;(*P, IR))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    PreservedAnalyses PassPA;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(P-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">      PassPA = P-&gt;<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call onto PassInstrumentation&#x27;s AfterPass callbacks immediately after</span></span><br><span class="line">    <span class="comment">// running the pass.</span></span><br><span class="line">    PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the analysis manager as each pass runs and potentially</span></span><br><span class="line">    <span class="comment">// invalidates analyses.</span></span><br><span class="line">    AM.<span class="built_in">invalidate</span>(IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, intersect the preserved analyses to compute the aggregate</span></span><br><span class="line">    <span class="comment">// preserved set for this pass manager.</span></span><br><span class="line">    PA.<span class="built_in">intersect</span>(std::<span class="built_in">move</span>(PassPA));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation was handled after each pass in the above loop for the</span></span><br><span class="line">  <span class="comment">// current unit of IR. Therefore, the remaining analysis results in the</span></span><br><span class="line">  <span class="comment">// AnalysisManager are preserved. We mark this with a set so that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// need to inspect each one individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;IRUnitT&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里从PassInstrumentationAnalysis获取了一个PassInstrumentation（简称PI），PI中存了各种各样的callback，在跑Pass的前后会执行对应的callback。</p><p>这边的逻辑也比较简单，关键点在于Analysis与Instrumentation的各种callback相关的</p><h2 id="对Analysis的影响"><a href="#对Analysis的影响" class="headerlink" title="对Analysis的影响"></a>对Analysis的影响</h2><p>我们之前已经讲过通过PreservedAnalyses来管理Pass会导致哪些Analysis的结果失效，在跑Pass后会将结果的PreservedAnalyses用于修正AnalysisManager里保存的分析结果，也就是在这里AnalysisManager（以下简称AM）会实际更新内部保存的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AM.<span class="built_in">invalidate</span>(IR, PassPA);</span><br></pre></td></tr></table></figure><p>而在所有Pass跑完之后则preserve当前IRUnit类型的AnalysesSet，这里使用一个Set是为了避免和这个IRUnit类型的Analysis逐个比较。在最后preserve整个set的原因是在跑每个pass的时候都在不断的更新其中的AnalysisManager以及PreserveAnalyses信息，都跑完之后可以保证当前这个IRUnit类型的Analyses都确保是preserved的。</p><p>我一开始对这里的写法感到奇怪，为什么都跑完了、修改过了还是preserved的。我最初的想法是被保存的Analysis，理解上更偏向于是被缓存了的Pass，但是仔细一想我觉得换一种说法来描述PreserveAnalyses就好理解了：PreserveAnalyses中记录的是在这之后能够正确获取结果的Analyses。也就是说跑完PassManager这个“Pass”之后所有的Analysis依然是能够正确获取的</p><p>在编写自己Pass的时候要手动指定使得哪些Analysis失效，原因是因为你在这个Pass里面做过了修改并且没有更新AnalysisManager的信息，我觉得理论上来说如果每个人在Pass里面自己做了AM.invalidate的操作本质上是一样的，在这里只是PassManager帮你做了这个事情（这里不考虑这个做法是否有必要，只是讨论实现的本质）。那么如果要在Pass内部进行修改再做分析，也可以直接通过invalidate的操作更新AM之后再获取数据</p><p>关于Analysis更详细的部分会在下一期讲述</p><h2 id="runBeforePass"><a href="#runBeforePass" class="headerlink" title="runBeforePass"></a>runBeforePass</h2><p>include/llvm/IR/PassInstrumentation.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runBeforePass</span><span class="params">(<span class="keyword">const</span> PassT &amp;Pass, <span class="keyword">const</span> IRUnitT &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Callbacks)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> ShouldRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isRequired</span>(Pass)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;ShouldRunOptionalPassCallbacks)</span><br><span class="line">      ShouldRun &amp;= <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ShouldRun) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;BeforeNonSkippedPassCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;BeforeSkippedPassCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ShouldRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runBeforePass除了执行一些常规callback之外，不同之处在于做了是否要执行当前pass的判断。如果并非required的pass则根据callback中的函数来确定是否运行当前pass</p><p>而runAfterPass就是简单的执行所有callback，这里就不再赘述</p><h1 id="更具体的PassManager"><a href="#更具体的PassManager" class="headerlink" title="更具体的PassManager"></a>更具体的PassManager</h1><p>讲完了基础的PassManager，我们再来看一下通过PassManager衍生出更加具体的PassManager都是怎样的。不过不管怎么衍生，关于执行的结果以及analysis处理以及callback这些的处理大致是一致的，只是加了一些对于某类IRUnit专用的处理操作</p><p>主要有以下这么几种方式</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>根据IRUnit的不同，有这么几类PassManager</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%202.png"                      alt="Untitled"                ></p><p>代码中是这样的</p><p>PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModulePassManager = PassManager&lt;Module&gt;;</span><br><span class="line"><span class="keyword">using</span> FunctionPassManager = PassManager&lt;Function&gt;;</span><br></pre></td></tr></table></figure><p>这种没什么可讲的，就是简单的用了一个别名来标识</p><h2 id="针对Loop特化的PassManager"><a href="#针对Loop特化的PassManager" class="headerlink" title="针对Loop特化的PassManager"></a>针对Loop特化的PassManager</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%203.png"                      alt="Untitled"                ></p><p>include/llvm/Transforms/Scalar/LoopPassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Explicit specialization and instantiation declarations for the pass manager.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManager</span>&lt;</span>Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                  LPMUpdater &amp;&gt;</span><br><span class="line">    : <span class="keyword">public</span> PassInfoMixin&lt;</span><br><span class="line">          PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                      LPMUpdater &amp;&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PassManager</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过成员可以看到多了一些Loop相关的处理</p><h3 id="addPass"><a href="#addPass" class="headerlink" title="addPass"></a>addPass</h3><p>还是熟悉的enable_if，主要是根据参数是RepeatedPass还是普通Pass以及PassT是否满足HasRunOnLoopT产生了四种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> LoopPassModelT =</span><br><span class="line">      detail::PassModel&lt;Loop, PassT, PreservedAnalyses, LoopAnalysisManager,</span><br><span class="line">                        LoopStandardAnalysisResults &amp;, LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LoopPassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> LoopNestPassModelT =</span><br><span class="line">      detail::PassModel&lt;LoopNest, PassT, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopNestPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopNestPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LoopNestPassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Specializations of `addPass` for `RepeatedPass`. These are necessary since</span></span><br><span class="line"><span class="comment">// `RepeatedPass` has a templated `run` method that will result in incorrect</span></span><br><span class="line"><span class="comment">// detection of `HasRunOnLoopT`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(RepeatedPass&lt;PassT&gt; &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> RepeatedLoopPassModelT =</span><br><span class="line">      detail::PassModel&lt;Loop, RepeatedPass&lt;PassT&gt;, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">RepeatedLoopPassModelT</span>(std::<span class="built_in">move</span>(Pass))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(RepeatedPass&lt;PassT&gt; &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> RepeatedLoopNestPassModelT =</span><br><span class="line">      detail::PassModel&lt;LoopNest, RepeatedPass&lt;PassT&gt;, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopNestPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopNestPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">RepeatedLoopNestPassModelT</span>(std::<span class="built_in">move</span>(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Explicitly specialize the pass manager&#x27;s run method to handle loop nest</span></span><br><span class="line"><span class="comment">/// structure updates.</span></span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">            LPMUpdater &amp;&gt;::<span class="built_in">run</span>(Loop &amp;L, LoopAnalysisManager &amp;AM,</span><br><span class="line">                               LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U) &#123;</span><br><span class="line">  <span class="comment">// Runs loop-nest passes only when the current loop is a top-level one.</span></span><br><span class="line">  PreservedAnalyses PA = (L.<span class="built_in">isOutermost</span>() &amp;&amp; !LoopNestPasses.<span class="built_in">empty</span>())</span><br><span class="line">                             ? <span class="built_in">runWithLoopNestPasses</span>(L, AM, AR, U)</span><br><span class="line">                             : <span class="built_in">runWithoutLoopNestPasses</span>(L, AM, AR, U);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation for the current loop should be handled above, and other loop</span></span><br><span class="line">  <span class="comment">// analysis results shouldn&#x27;t be impacted by runs over this loop. Therefore,</span></span><br><span class="line">  <span class="comment">// the remaining analysis results in the AnalysisManager are preserved. We</span></span><br><span class="line">  <span class="comment">// mark this with a set so that we don&#x27;t need to inspect each one</span></span><br><span class="line">  <span class="comment">// individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;Loop&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Run either a loop pass or a loop-nest pass. Returns `None` if</span></span><br><span class="line"><span class="comment">/// PassInstrumentation&#x27;s BeforePass returns false. Otherwise, returns the</span></span><br><span class="line"><span class="comment">/// preserved analyses of the pass.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function">Optional&lt;PreservedAnalyses&gt;</span></span><br><span class="line"><span class="function"><span class="title">runSinglePass</span><span class="params">(IRUnitT &amp;IR, PassT &amp;Pass, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">              LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U,</span></span></span><br><span class="line"><span class="params"><span class="function">              PassInstrumentation &amp;PI)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">runWithLoopNestPasses</span><span class="params">(Loop &amp;L, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        LoopStandardAnalysisResults &amp;AR,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        LPMUpdater &amp;U)</span></span>;</span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">runWithoutLoopNestPasses</span><span class="params">(Loop &amp;L, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LoopStandardAnalysisResults &amp;AR,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LPMUpdater &amp;U)</span></span>;</span><br></pre></td></tr></table></figure><p>runSinglePass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function">Optional&lt;PreservedAnalyses&gt; <span class="title">LoopPassManager::runSinglePass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IRUnitT &amp;IR, PassT &amp;Pass, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">    LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U, PassInstrumentation &amp;PI)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get the loop in case of Loop pass and outermost loop in case of LoopNest</span></span><br><span class="line">  <span class="comment">// pass which is to be passed to BeforePass and AfterPass call backs.</span></span><br><span class="line">  <span class="keyword">const</span> Loop &amp;L = <span class="built_in">getLoopFromIR</span>(IR);</span><br><span class="line">  <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">  <span class="comment">// pass, skip its execution completely if asked to (callback returns false).</span></span><br><span class="line">  <span class="keyword">if</span> (!PI.runBeforePass&lt;Loop&gt;(*Pass, L))</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line"></span><br><span class="line">  PreservedAnalyses PA;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(Pass-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">    PA = Pass-&gt;<span class="built_in">run</span>(IR, AM, AR, U);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not pass deleted Loop into the instrumentation</span></span><br><span class="line">  <span class="keyword">if</span> (U.<span class="built_in">skipCurrentLoop</span>())</span><br><span class="line">    PI.runAfterPassInvalidated&lt;IRUnitT&gt;(*Pass, PA);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    PI.runAfterPass&lt;Loop&gt;(*Pass, L, PA);</span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系大概是这个样子的，这里就不贴其他的具体实现了，里面关于Analysis以及各种处理本质上都是类似的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">  run --&gt; runWithLoopNestPasses --&gt; runSinglePass</span><br><span class="line">  run --&gt; runWithOutLoopNestPasses --&gt; runSinglePass</span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>最后也是使用了一个别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                    LPMUpdater &amp;&gt;</span><br><span class="line">    LoopPassManager;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>include/llvm/CodeGen/MachinePassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// MachineFunctionPassManager adds/removes below features to/from the base</span></span><br><span class="line"><span class="comment">/// PassManager template instantiation.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Support passes that implement doInitialization/doFinalization. This is for</span></span><br><span class="line"><span class="comment">///   machine function passes to work on module level constructs. One such pass</span></span><br><span class="line"><span class="comment">///   is AsmPrinter.</span></span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"><span class="comment">/// - The base class `run` method is replaced by an alternative `run` method.</span></span><br><span class="line"><span class="comment">///   See details below.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Support codegening in the SCC order. Users include interprocedural</span></span><br><span class="line"><span class="comment">///   register allocation (IPRA).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MachineFunctionPassManager</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> PassManager&lt;MachineFunction, MachineFunctionAnalysisManager&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> Base = PassManager&lt;MachineFunction, MachineFunctionAnalysisManager&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MachineFunctionPassManager属于codegen的部分，而codegen的部分目前还未完全迁移到新的Pass架构中，因此为了兼容旧部分的内容做了一些特殊处理</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%204.png"                      alt="Untitled"                ></p><h3 id="addPass-1"><a href="#addPass-1" class="headerlink" title="addPass"></a>addPass</h3><p>在旧的Pass中有doInitialization以及doFinalization的部分，因此在addPass的时候同时会将init和final的Pass注册进去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt; <span class="function"><span class="keyword">void</span> <span class="title">addPass</span><span class="params">(PassT &amp;&amp;Pass)</span> </span>&#123;</span><br><span class="line">  Base::<span class="built_in">addPass</span>(std::forward&lt;PassT&gt;(Pass));</span><br><span class="line">  PassConceptT *P = Passes.<span class="built_in">back</span>().<span class="built_in">get</span>();</span><br><span class="line">  addDoInitialization&lt;PassT&gt;(P);</span><br><span class="line">  addDoFinalization&lt;PassT&gt;(P);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add machine module pass.</span></span><br><span class="line">  addRunOnModule&lt;PassT&gt;(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于addDoInitialization的处理是这样的，addDoFinalization以及addRunOnModule的函数也是类似的做法，只是更换了detected的条件，不再过多赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">  std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_init_t</span>, PassT&gt;::value&gt;</span><br><span class="line">  <span class="built_in">addDoInitialization</span>(PassConceptT *Pass) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">  std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_init_t</span>, PassT&gt;::value&gt;</span><br><span class="line">  <span class="built_in">addDoInitialization</span>(PassConceptT *Pass) &#123;</span><br><span class="line">    <span class="keyword">using</span> PassModelT =</span><br><span class="line">        detail::PassModel&lt;MachineFunction, PassT, PreservedAnalyses,</span><br><span class="line">                          MachineFunctionAnalysisManager&gt;;</span><br><span class="line">    <span class="keyword">auto</span> *P = <span class="keyword">static_cast</span>&lt;PassModelT *&gt;(Pass);</span><br><span class="line">    InitializationFuncs.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](Module &amp;M, MachineFunctionAnalysisManager &amp;MFAM) &#123;</span><br><span class="line">          <span class="keyword">return</span> P-&gt;Pass.<span class="built_in">doInitialization</span>(M, MFAM);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h3><p>之后在run的前后执行（这里省略绝大部分的细节），addDoInitialization以及addDoFinalization的部分在新的Pass架构中我觉得应当是要转换为callback的形式，就像之前的runBeforePass一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">MachineFunctionPassManager::run</span><span class="params">(Module &amp;M,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      MachineFunctionAnalysisManager &amp;MFAM)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Add a PIC to verify machine functions.</span></span><br><span class="line">  <span class="keyword">if</span> (VerifyMachineFunction) &#123;</span><br><span class="line">    PassInstrumentation PI = MFAM.getResult&lt;PassInstrumentationAnalysis&gt;(M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No need to pop this callback later since MIR pipeline is flat which means</span></span><br><span class="line">    <span class="comment">// current pipeline is the top-level pipeline. Callbacks are not used after</span></span><br><span class="line">    <span class="comment">// current pipeline.</span></span><br><span class="line">    PI.<span class="built_in">pushBeforeNonSkippedPassCallback</span>([&amp;MFAM](StringRef PassID, Any IR) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : InitializationFuncs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">F</span>(M, MFAM))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Run machine module passes</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : FinalizationFuncs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">F</span>(M, MFAM))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="针对SCC特化了run的PassManager"><a href="#针对SCC特化了run的PassManager" class="headerlink" title="针对SCC特化了run的PassManager"></a>针对SCC特化了run的PassManager</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Explicit specialization and instantiation declarations for the pass manager.</span></span><br><span class="line"><span class="comment">// See the comments on the definition of the specialization for details on how</span></span><br><span class="line"><span class="comment">// it differs from the primary template.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">            CGSCCUpdateResult &amp;&gt;::<span class="built_in">run</span>(LazyCallGraph::SCC &amp;InitialC,</span><br><span class="line">                                      CGSCCAnalysisManager &amp;AM,</span><br><span class="line">                                      LazyCallGraph &amp;G, CGSCCUpdateResult &amp;UR);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">PassManager</span>&lt;</span>LazyCallGraph::SCC, CGSCCAnalysisManager,</span><br><span class="line">                                  LazyCallGraph &amp;, CGSCCUpdateResult &amp;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The CGSCC pass manager.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// See the documentation for the PassManager template for details. It runs</span></span><br><span class="line"><span class="comment">/// a sequence of SCC passes over each SCC that the manager is run over. This</span></span><br><span class="line"><span class="comment">/// type serves as a convenient way to refer to this construct.</span></span><br><span class="line"><span class="keyword">using</span> CGSCCPassManager =</span><br><span class="line">    PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">                CGSCCUpdateResult &amp;&gt;;</span><br></pre></td></tr></table></figure><p>SCC的PassManager只是特化了run的部分。在原来PassManager的基础上加了一些SCC相关的处理，这里出现了proxy这个东西，先忽视它，我们之后再介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Explicitly specialize the pass manager run method to handle call graph</span></span><br><span class="line"><span class="comment">/// updates.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">            CGSCCUpdateResult &amp;&gt;::<span class="built_in">run</span>(LazyCallGraph::SCC &amp;InitialC,</span><br><span class="line">                                      CGSCCAnalysisManager &amp;AM,</span><br><span class="line">                                      LazyCallGraph &amp;G, CGSCCUpdateResult &amp;UR) &#123;</span><br><span class="line">  <span class="comment">// Request PassInstrumentation from analysis manager, will use it to run</span></span><br><span class="line">  <span class="comment">// instrumenting callbacks for the passes later.</span></span><br><span class="line">  PassInstrumentation PI =</span><br><span class="line">      AM.getResult&lt;PassInstrumentationAnalysis&gt;(InitialC, G);</span><br><span class="line"></span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The SCC may be refined while we are running passes over it, so set up</span></span><br><span class="line">  <span class="comment">// a pointer that we can update.</span></span><br><span class="line">  LazyCallGraph::SCC *C = &amp;InitialC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get Function analysis manager from its proxy.</span></span><br><span class="line">  FunctionAnalysisManager &amp;FAM =</span><br><span class="line">      AM.getCachedResult&lt;FunctionAnalysisManagerCGSCCProxy&gt;(*C)-&gt;<span class="built_in">getManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Pass : Passes) &#123;</span><br><span class="line">    <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">    <span class="comment">// pass, skip its execution completely if asked to (callback returns false).</span></span><br><span class="line">    <span class="keyword">if</span> (!PI.<span class="built_in">runBeforePass</span>(*Pass, *C))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    PreservedAnalyses PassPA;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(Pass-&gt;name())</span></span>;</span><br><span class="line">      PassPA = Pass-&gt;<span class="built_in">run</span>(*C, AM, G, UR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UR.InvalidatedSCCs.<span class="built_in">count</span>(C))</span><br><span class="line">      PI.runAfterPassInvalidated&lt;LazyCallGraph::SCC&gt;(*Pass, PassPA);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      PI.runAfterPass&lt;LazyCallGraph::SCC&gt;(*Pass, *C, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the SCC if necessary.</span></span><br><span class="line">    C = UR.UpdatedC ? UR.UpdatedC : C;</span><br><span class="line">    <span class="keyword">if</span> (UR.UpdatedC) &#123;</span><br><span class="line">      <span class="comment">// If C is updated, also create a proxy and update FAM inside the result.</span></span><br><span class="line">      <span class="keyword">auto</span> *ResultFAMCP =</span><br><span class="line">          &amp;AM.getResult&lt;FunctionAnalysisManagerCGSCCProxy&gt;(*C, G);</span><br><span class="line">      ResultFAMCP-&gt;<span class="built_in">updateFAM</span>(FAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the CGSCC pass wasn&#x27;t able to provide a valid updated SCC, the</span></span><br><span class="line">    <span class="comment">// current SCC may simply need to be skipped if invalid.</span></span><br><span class="line">    <span class="keyword">if</span> (UR.InvalidatedSCCs.<span class="built_in">count</span>(C)) &#123;</span><br><span class="line">      <span class="built_in">LLVM_DEBUG</span>(<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;Skipping invalidated root or island SCC!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check that we didn&#x27;t miss any update scenario.</span></span><br><span class="line">    <span class="built_in">assert</span>(C-&gt;<span class="built_in">begin</span>() != C-&gt;<span class="built_in">end</span>() &amp;&amp; <span class="string">&quot;Cannot have an empty SCC!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the analysis manager as each pass runs and potentially</span></span><br><span class="line">    <span class="comment">// invalidates analyses.</span></span><br><span class="line">    AM.<span class="built_in">invalidate</span>(*C, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, we intersect the final preserved analyses to compute the</span></span><br><span class="line">    <span class="comment">// aggregate preserved set for this pass manager.</span></span><br><span class="line">    PA.<span class="built_in">intersect</span>(std::<span class="built_in">move</span>(PassPA));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before we mark all of *this* SCC&#x27;s analyses as preserved below, intersect</span></span><br><span class="line">  <span class="comment">// this with the cross-SCC preserved analysis set. This is used to allow</span></span><br><span class="line">  <span class="comment">// CGSCC passes to mutate ancestor SCCs and still trigger proper invalidation</span></span><br><span class="line">  <span class="comment">// for them.</span></span><br><span class="line">  UR.CrossSCCPA.<span class="built_in">intersect</span>(PA);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation was handled after each pass in the above loop for the current</span></span><br><span class="line">  <span class="comment">// SCC. Therefore, the remaining analysis results in the AnalysisManager are</span></span><br><span class="line">  <span class="comment">// preserved. We mark this with a set so that we don&#x27;t need to inspect each</span></span><br><span class="line">  <span class="comment">// one individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;LazyCallGraph::SCC&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旧的PassManager体系"><a href="#旧的PassManager体系" class="headerlink" title="旧的PassManager体系"></a>旧的PassManager体系</h1><p>最后再简单讲一下我了解的旧PassManager的一些做法，不会涉及太多细节</p><p>核心实现在PassManagerImpl中</p><p>lib/IR/LegacyPassManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// PassManagerImpl manages MPPassManagers</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManagerImpl</span> :</span> <span class="keyword">public</span> Pass,</span><br><span class="line">                        <span class="keyword">public</span> PMDataManager,</span><br><span class="line">                        <span class="keyword">public</span> PMTopLevelManager &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">anchor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PassManagerImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : Pass(PT_PassManager, ID), PMTopLevelManager(new MPPassManager()) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \copydoc PassManager::add()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">schedulePass</span>(P);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// createPrinterPass - Get a module printer pass.</span></span><br><span class="line">  <span class="function">Pass *<span class="title">createPrinterPass</span><span class="params">(raw_ostream &amp;O,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> std::string &amp;Banner)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createPrintModulePass</span>(O, Banner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// run - Execute all of the passes scheduled for execution.  Keep track of</span></span><br><span class="line">  <span class="comment">/// whether any of the passes modifies the module, and if so, return true.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">run</span><span class="params">(Module &amp;M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> llvm::Pass::doInitialization;</span><br><span class="line">  <span class="keyword">using</span> llvm::Pass::doFinalization;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非常大的不同是LegacyPassManager（以下简称LegacyPM）每次添加Pass的时候需要进行一次schedule。LegacyPass中在Analysis内部保存Analysis的结果，而在schedule中管理Pass的顺序以及不再需要的Analysis的释放。</p><p>然后我们来看一下run</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// run - Execute all of the passes scheduled for execution.  Keep track of</span></span><br><span class="line"><span class="comment">/// whether any of the passes modifies the module, and if so, return true.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PassManagerImpl::run</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dumpArguments</span>();</span><br><span class="line">  <span class="built_in">dumpPasses</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ImmutablePass *ImPass : <span class="built_in">getImmutablePasses</span>())</span><br><span class="line">    Changed |= ImPass-&gt;<span class="built_in">doInitialization</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initializeAllAnalysisInfo</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index) &#123;</span><br><span class="line">    Changed |= <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">runOnModule</span>(M);</span><br><span class="line">    M.<span class="built_in">getContext</span>().<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ImmutablePass *ImPass : <span class="built_in">getImmutablePasses</span>())</span><br><span class="line">    Changed |= ImPass-&gt;<span class="built_in">doFinalization</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run的前后会执行doInitialization和doFinalization，这两个函数名是不是很眼熟？就是我们上面提到MachinePassManager中提及的</p><p>除了针对Module的PassManager还有一个针对Function的FunctionPassManager。对于FunctionPassManager来说也是需要每次addPass的时候进行schedule</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FunctionPassManagerImpl::run</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">initializeAllAnalysisInfo</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index) &#123;</span><br><span class="line">  Changed |= <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">runOnFunction</span>(F);</span><br><span class="line">  F.<span class="built_in">getContext</span>().<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index)</span><br><span class="line">  <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">cleanup</span>();</span><br><span class="line"></span><br><span class="line">wasRun = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-1/Un</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其零：新的Pass机制</title>
    <link href="https://fusionbolt.github.io/2022/06/19/llvm-pass-0/"/>
    <id>https://fusionbolt.github.io/2022/06/19/llvm-pass-0/</id>
    <published>2022-06-19T06:57:30.000Z</published>
    <updated>2022-06-19T07:17:20.871Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/2c8c0f197016eb2f404a18dc65212ff2ca62e772.jpg942w_1388h_progressive.jpg"                      alt="2c8c0f197016eb2f404a18dc65212ff2ca62e772.jpg@942w_1388h_progressive.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">以高攻击力著称的传说之龙。任何编程语言和目标平台都能被粉碎，其破坏力不可估量</center> <p>在目前的LLVM中存在两套Pass相关的机制，一套是基本上已经过时的被称为LegacyPass的机制（codegen的部分还没有迁移完毕），另一套则是现在主要使用的Pass机制</p><p>这个系列会讲解新Pass结构的各个方面（重点在于新的Pass结构），PassManager以及与Pass的联系、Pass相关基础设施，旧架构设计上的问题以及在新架构的解决方案等内容，而第一篇则是着重于Pass本身。这个系列有些一笔带过的内容通常都会在后续文章提及，后面不再赘述。</p><p>本文从以下几个点来对比分析这两类的不同并且着重看一下新的机制的实现</p><ol><li>Pass的类结构是怎样的</li><li>Pass的编写方式</li><li>Pass的注册方式（这里只提及LLVM本身的Pass）</li><li>Pass元信息的获取方式</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="类型关系链"><a href="#类型关系链" class="headerlink" title="类型关系链"></a>类型关系链</h2><p>在LegacyPass中通过类型严格区分了module pass，function pass等。通过这张图可以看到Pass的继承链。（这里图片太长我只截取部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/Untitled-5622778.png"                      alt="Untitled"                ></p><p>来源：<a class="link"   href="https://llvm.org/doxygen/classllvm_1_1Pass.html" >https://llvm.org/doxygen/classllvm_1_1Pass.html<i class="fas fa-external-link-alt"></i></a></p><p>LegacyPass中就是非常普通的继承链，从这个角度上来说没什么可讲的</p><p>而在新Pass中每个Pass都是一个满足了PassConcept的东西。而PassConcept的要求是和PassInfoMixin相关联起来的，也就是说继承了PassInfoMixin的类算是Pass。虽然说是mixin，但是C++语法层面没有这样的特性，因此通过特殊的技巧来实现这样的语义。</p><p>关于Pass的实现方式有这样一段注释，大意是说继承是非常不好的，因此采用了这种concept-based polymorphism方式。在这里不具体讲解相关细节了，有兴趣可以点进注释中提到的链接看下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Note that the implementations of the pass managers use concept-based</span></span><br><span class="line"><span class="comment">/// polymorphism as outlined in the &quot;Value Semantics and Concept-based</span></span><br><span class="line"><span class="comment">/// Polymorphism&quot; talk (or its abbreviated sibling &quot;Inheritance Is The Base</span></span><br><span class="line"><span class="comment">/// Class of Evil&quot;) by Sean Parent:</span></span><br><span class="line"><span class="comment">/// * http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations</span></span><br><span class="line"><span class="comment">/// * http://www.youtube.com/watch?v=_BpMYeUFXv8</span></span><br><span class="line"><span class="comment">/// * http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil</span></span><br></pre></td></tr></table></figure><p>我对这个概念没什么了解，按照我目前从代码中看到的，用我的话来说更像是一种编译期间执行的动态类型，只要有满足PassConcept接口的东西就可以成为Pass。在后续的内容中会提到各种各样的满足PassConcept的类，目前先说基本的Pass。</p><p>include/llvm/IR/PassManagerInternal.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassConcept</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PassConcept</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ExtraArgTs... ExtraArgs)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">printPipeline</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                function_ref&lt;StringRef(StringRef)&gt; MapClassName2PassName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> StringRef <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Polymorphic method to to let a pass optionally exempted from skipping by</span></span><br><span class="line">  <span class="comment">/// PassInstrumentation.</span></span><br><span class="line">  <span class="comment">/// To opt-in, pass should implement `static bool isRequired()`. It&#x27;s no-op</span></span><br><span class="line">  <span class="comment">/// to have `isRequired` always return false since that is the default.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意isRequired是可选的，不实现则会是默认false，处理这里则是在PassModel中</p><p>大概了解一下Concept有什么接口之后我们来看Mixin</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/Untitled%201-5622778.png"                      alt="Untitled"                ></p><p>图为各种继承了PassInfoMixin的Pass</p><p>对于PassInfoMixin来说只有name以及printPipeline的部分，而我们编写的Pass是要补全run的部分。那么我们来看一下PassInfoMixin的声明部分，实际上利用CRTP的机制来获取PassInfoMixin的子类信息并且返回，同样做到了多态的效果</p><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A CRTP mix-in to automatically provide informational APIs needed for</span></span><br><span class="line"><span class="comment">/// passes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This provides some boilerplate for types that are passes.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PassInfoMixin</span> &#123;</span></span><br><span class="line">  <span class="comment">/// Gets the name of the pass we are mixed into.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> StringRef <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_base_of&lt;PassInfoMixin, DerivedT&gt;::value,</span><br><span class="line">                  <span class="string">&quot;Must pass the derived type as the template argument!&quot;</span>);</span><br><span class="line">    StringRef Name = getTypeName&lt;DerivedT&gt;();</span><br><span class="line">    Name.<span class="built_in">consume_front</span>(<span class="string">&quot;llvm::&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPipeline</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                     function_ref&lt;StringRef(StringRef)&gt; MapClassName2PassName)</span> </span>&#123;</span><br><span class="line">    StringRef ClassName = DerivedT::<span class="built_in">name</span>();</span><br><span class="line">    <span class="keyword">auto</span> PassName = <span class="built_in">MapClassName2PassName</span>(ClassName);</span><br><span class="line">    OS &lt;&lt; PassName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="区分Analysis"><a href="#区分Analysis" class="headerlink" title="区分Analysis"></a>区分Analysis</h2><p>对于LegacyPass来说要注意的是对于LegacyPass来说不论是Analysis还是Transform都是一个Pass，只是Analysis是一种ImmutablePass，在注册的时候也会需要这个信息。</p><p>但是对于新Pass来说Analysis就是Analysis，并不是一种Pass。比如我们来看一个Analysis的签名</p><p>include/llvm/Analysis/AssumptionCache.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssumptionAnalysis</span> :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;AssumptionAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;AssumptionAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Result = AssumptionCache;</span><br><span class="line">  <span class="function">AssumptionCache <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显这个run的返回结果是不满足PassConcept的，Analysis有自己的一套AnalysisConcept</p><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><p>lib/Transforms/Scalar/FlattenCFGPass.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlattenCFGLegacyPass</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">FlattenCFGLegacyPass</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;</span><br><span class="line">    <span class="built_in">initializeFlattenCFGLegacyPassPass</span>(*PassRegistry::<span class="built_in">getPassRegistry</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    AU.addRequired&lt;AAResultsWrapperPass&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AliasAnalysis *AA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FlattenCFGLegacyPass::runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">  AA = &amp;getAnalysis&lt;AAResultsWrapperPass&gt;().<span class="built_in">getAAResults</span>();</span><br><span class="line">  <span class="keyword">bool</span> EverChanged = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// iterativelyFlattenCFG can make some blocks dead.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">iterativelyFlattenCFG</span>(F, AA)) &#123;</span><br><span class="line">    <span class="built_in">removeUnreachableBlocks</span>(F);</span><br><span class="line">    EverChanged = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EverChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlattenCFGPass</span> :</span> PassInfoMixin&lt;FlattenCFGPass&gt; &#123;</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">FlattenCFGPass::run</span><span class="params">(Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      FunctionAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> EverChanged = <span class="literal">false</span>;</span><br><span class="line">  AliasAnalysis *AA = &amp;AM.getResult&lt;AAManager&gt;(F);</span><br><span class="line">  <span class="comment">// iterativelyFlattenCFG can make some blocks dead.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">iterativelyFlattenCFG</span>(F, AA)) &#123;</span><br><span class="line">    <span class="built_in">removeUnreachableBlocks</span>(F);</span><br><span class="line">    EverChanged = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EverChanged ? PreservedAnalyses::<span class="built_in">none</span>() : PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂的LegacyPass"><a href="#复杂的LegacyPass" class="headerlink" title="复杂的LegacyPass"></a>复杂的LegacyPass</h2><p>对比代码可以看到LegacyPass非常麻烦</p><ol><li>添加initializeXXXPass</li><li>声明一个PassID</li><li>用到的analysis还需要手动addRequired</li></ol><p>而新的Pass则不需要关心那么多其他的事情，只需要专注于编写实现就可以了</p><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>这里可以看到两者run的参数是有区别的，对于新的Pass来说还需要传递一个AnalysisManager</p><p>而run中传进来的类型（被称为IRUnitT）以及AnalysisManager的类型共同体现了这个Pass是作用范围是什么（是一个Function又或是一个Module等等）</p><p>对于返回的结果两者也不相同。LegacyPass返回的是 是否修改的bool值，对于新的Pass返回的是这个Pass不会影响到哪些Analysis</p><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>LegacyPass的注册方式是在一个全局的Registry变量中add每一个Pass的info</p><p>lib/Transforms/Scalar/FlattenCFGPass.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> FlattenCFGLegacyPass::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">INITIALIZE_PASS_BEGIN</span>(FlattenCFGLegacyPass, <span class="string">&quot;flattencfg&quot;</span>, <span class="string">&quot;Flatten the CFG&quot;</span>,</span><br><span class="line">                      <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">INITIALIZE_PASS_DEPENDENCY</span>(AAResultsWrapperPass)</span><br><span class="line"><span class="built_in">INITIALIZE_PASS_END</span>(FlattenCFGLegacyPass, <span class="string">&quot;flattencfg&quot;</span>, <span class="string">&quot;Flatten the CFG&quot;</span>,</span><br><span class="line">                    <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_PASS_BEGIN(passName, arg, name, cfg, analysis)              \</span></span><br><span class="line"><span class="meta">  static void *initialize##passName##PassOnce(PassRegistry &amp;Registry) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_PASS_DEPENDENCY(depName) initialize##depName##Pass(Registry);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_AG_DEPENDENCY(depName)                                      \</span></span><br><span class="line"><span class="meta">  initialize##depName##AnalysisGroup(Registry);</span></span><br></pre></td></tr></table></figure><p>展开宏是这个样子的，看到这个initialize函数是不是有点眼熟？这就是刚才在构造函数中实际调用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">initializeFlattenCFGLegacyPassPassOnce</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">initializeAAResultsWrapperPassPass</span>(Registry);</span><br><span class="line">  PassInfo *PI =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassInfo</span>(<span class="string">&quot;Flatten the CFG&quot;</span>, <span class="string">&quot;flattencfg&quot;</span>, &amp;FlattenCFGLegacyPass::ID,</span><br><span class="line">                   PassInfo::<span class="built_in">NormalCtor_t</span>(callDefaultCtor&lt;FlattenCFGLegacyPass&gt;),</span><br><span class="line">                   <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  Registry.<span class="built_in">registerPass</span>(*PI, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> llvm::once_flag InitializeFlattenCFGLegacyPassPassFlag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llvm::initializeFlattenCFGLegacyPassPass</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  llvm::<span class="built_in">call_once</span>(InitializeFlattenCFGLegacyPassPassFlag,</span><br><span class="line">                  initializeFlattenCFGLegacyPassPassOnce, std::<span class="built_in">ref</span>(Registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏的最后两个bool参数分别是 是否为CFGPass和AnalysisPass</p><p>新的则是在lib/Passes/PassRegistry.def中使用这样的方式注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FUNCTION_PASS</span>(<span class="string">&quot;flattencfg&quot;</span>, <span class="built_in">FlattenCFGPass</span>())</span><br></pre></td></tr></table></figure><p>对于新的Pass来说不需要再添加选项区分是否为Analysis，而是通过采用了不同名称的宏来实现，比如说有这样一个用于注册Analysis的宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_ANALYSIS(NAME, CREATE_PASS)</span></span><br></pre></td></tr></table></figure><p>而宏的具体实现则是根据使用的上下文来实现。通过先define这个宏的具体实现再include这个def文件完成各种流程（我并不知道这个做法叫什么..）</p><p>在lib/Passes/PassBuilder.cpp中有这样一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseFunctionPass</span><span class="params">(FunctionPassManager &amp;FPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> PipelineElement &amp;E)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// Now expand the basic registered passes from the .inc file.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS)                                       \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    FPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这个宏还会被用于一些其他的地方，比如说打印Pass名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::printPassNames</span><span class="params">(raw_ostream &amp;OS)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">OS &lt;&lt; <span class="string">&quot;Function passes:\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h1><h2 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h2><p>对于LegacyPass来说通过声明的静态成员变量来区分。上面的编写Pass的时候添加静态成员变量ID，之后在注册的宏内构建了PassInfo并且将整个ID传进去</p><p>对于新的Pass我觉得是根据name来区分的。因为name是通过获取Pass的TypeName得到的。这一点对于Analysis也一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PassInfoMixin</span> &#123;</span></span><br><span class="line">  <span class="comment">/// Gets the name of the pass we are mixed into.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> StringRef <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_base_of&lt;PassInfoMixin, DerivedT&gt;::value,</span><br><span class="line">                  <span class="string">&quot;Must pass the derived type as the template argument!&quot;</span>);</span><br><span class="line">    StringRef Name = getTypeName&lt;DerivedT&gt;();</span><br><span class="line">    Name.<span class="built_in">consume_front</span>(<span class="string">&quot;llvm::&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>对于LegacyPass来说PassInfo基本上都在PassInfo中了，而上面也提到注册的时候会将PassInfo塞到一个全局的Registry对象中，获取的话通过Registry对象的getPassInfo方法传入Id或者注册的时候填写的arg来获取到对应的PassInfo实例。</p><p>include/llvm/PassInfo.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> NormalCtor_t = Pass* (*)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  StringRef PassName;     <span class="comment">// Nice name for Pass</span></span><br><span class="line">  StringRef PassArgument; <span class="comment">// Command Line argument to run this pass</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *PassID;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsCFGOnlyPass = <span class="literal">false</span>;      <span class="comment">// Pass only looks at the CFG.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsAnalysis;                 <span class="comment">// True if an analysis pass.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsAnalysisGroup;            <span class="comment">// True if an analysis group.</span></span><br><span class="line">  std::vector&lt;<span class="keyword">const</span> PassInfo *&gt; ItfImpl; <span class="comment">// Interfaces implemented by this pass</span></span><br><span class="line">  NormalCtor_t NormalCtor = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Registry获取PassInfo的里有这样的代码</p><p>include/llvm/PassRegistry.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> PassInfo *<span class="title">PassRegistry::getPassInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *TI)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="function">sys::SmartScopedReader&lt;<span class="literal">true</span>&gt; <span class="title">Guard</span><span class="params">(Lock)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> PassInfoMap.<span class="built_in">lookup</span>(TI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PassInfoMap - Keep track of the PassInfo object for each registered pass.</span></span><br><span class="line"><span class="keyword">using</span> MapType = DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> PassInfo *&gt;;</span><br><span class="line">MapType PassInfoMap;</span><br></pre></td></tr></table></figure><p>对于新的Pass来说原本的PassInfo中绝大部分信息都已经不再需要了，比如说是否为Analysis，是否为CFGOnly，ID等。PassInfo中有一个叫NormalCtor的成员，LegacyPass是通过PassInfo创建的因此需要保存构造Pass的方法，但新Pass这里采用了其他的做法，因此这个成员也是不需要的。</p><p>唯一需要的就是name信息。由于Transform Pass和Analysis都是由ID区分的，在PassBuilder中也有isAnalysisPassName这样根据ID来帮助我们判断是什么的函数</p><h1 id="简单区分"><a href="#简单区分" class="headerlink" title="简单区分"></a>简单区分</h1><p>由于同时存在两套机制，我在初次接触的时候也感到很困惑，之前想要获取新Pass元信息的时候还在尝试LegacyPass的方法</p><p>在对整个结构不了解的时候想要区分一个Pass相关的内容是旧的还是新的可以通过这么两个思路</p><ol><li>通过所使用的类的声明位置，LegacyPass的基础设施相关头文件目前都放到了include/llvm的路径下，而新Pass的基础设施则是分散在include/llvm/IR/ 和include/llvm/Passes/下</li><li>LegacyPass的名字都改为了XXXLegacyPass</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-0/2c</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>司机与列车</title>
    <link href="https://fusionbolt.github.io/2022/05/21/driver-and-train/"/>
    <id>https://fusionbolt.github.io/2022/05/21/driver-and-train/</id>
    <published>2022-05-21T09:18:52.000Z</published>
    <updated>2022-05-21T09:45:39.739Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/driver-and-train/Nanchefengmian.jpg"                      alt="Nanchefengmian"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">与我在列车道相交处相遇吧</center> <center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图片出自萌娘百科：天朝铁道少女:南车篇条目</center> <h1 id="列车"><a href="#列车" class="headerlink" title="列车"></a>列车</h1><ol><li>提到列车，你第一时间想到的是什么？</li></ol><p>是去旅游的时候在列车上看到的沿途风景，还是在回家的时候的思乡之情。</p><ol start="2"><li>那么提到停不下来的列车呢？</li></ol><p>我的第一想法是人生，但仔细想下去这趟列车最终还是会停止的，尽管那是非常久以后的事情了。而对于这个年纪的我们还难以感知到终点，就像停不下来了一样</p><ul><li>坐在永远不会停下的列车会是怎么样的感受呢？</li></ul><p>是好奇后面的旅途？是对后面不确定的旅途感到恐惧？还是说一段时间之后将其视为理所当然，在列车上的这一意识逐渐淡薄？</p><ul><li>对于列车来说，最重要的应当是司机。上面几种情况的司机又是什么样的存在？</li></ul><p>对于1这样的普通情况来讲，自然是辛苦工作的司机了。而对于2这样的情况，那列车的司机可能是自己。</p><ul><li>除了司机，列车本身的形态又是怎样的呢？</li></ul><p>对于1来说自然就是平常看到的列车了，那对于2来说又是怎样的？我想自己能够看清列车内部构造，却看不清这趟列车的形态的，即便你能够“从窗口探出头”，那也只能看到一部分。但对于别人来说，他们能够看清你的外部形态，却看不到你的内部构造。</p><ul><li>看到的风景又是怎样的呢</li></ul><p>对于1来说自然是沿途的风景：有山川、有城市、有农田、有。对于2来说，可能取决于你是以怎样的视角看过去，而且对于每个人来说是完全不同的内容。</p><h1 id="hoka与列车"><a href="#hoka与列车" class="headerlink" title="hoka与列车"></a>hoka与列车</h1><p>hoka是UXCoffee这档播客的主持人。对于hoka而言，她不知道什么时候坐上了一趟看起来不会停下来的列车。而启动这辆车的司机是谁呢？列车的形态是怎样的？在列车上能看到怎样的风景？</p><h2 id="名为自己的列车"><a href="#名为自己的列车" class="headerlink" title="名为自己的列车"></a>名为自己的列车</h2><p>去年4月，她晋升为了设计经理。晋升本是一件好事，但是随着她的晋升也带来了问题：要做的事情指数级增长，事情太多来不及处理。晚上夜深人静的时候会想起白天做不完的事情，这些事情在脑中挥之不去导致她开始失眠，甚至入睡了还会梦到相关的事情并且惊醒。</p><p>每天超负荷工作，别人给到自身计划之外的任务会叹气，开始烦。工作日考虑要不要加班，不加班内心内疚，要不要加班和实际加班中内心争斗，无法做内心放松的事情，很焦虑，焦虑久了变得抑郁了。</p><p>她的身体也逐渐开始发出信号：溃疡和胃炎。她开始觉得应当休息一下，但又觉得国内的人都是996，是不是只有自己不够努力，因此并没有停下来。</p><p>她渐渐开始觉得自己像是不会停止的，永远在跑的列车。</p><h2 id="无法停下的列车"><a href="#无法停下的列车" class="headerlink" title="无法停下的列车"></a>无法停下的列车</h2><p>她意识到了这一点，既然自己是这辆列车本身，那应当自己能够停下来才对，但是她并没有做到。她开始害怕：害怕工作安排的没有那么满就会有报应，害怕别人看出来自己没有安排那么满；害怕如果做得少了、慢了、做的不好了以后可能会失去我现在的认可吧；觉得自己努力，成长比较快，如果工作不那么满了会不会成长没有这么快，会不会被别人追上了。</p><h2 id="开始逐渐获取列车掌控权"><a href="#开始逐渐获取列车掌控权" class="headerlink" title="开始逐渐获取列车掌控权"></a>开始逐渐获取列车掌控权</h2><p>她最首先想到的自然是去旅游放松以下，但是在旅游的时候依然持续工作状态导致最后并没有真正得到休息。</p><p>后来去咨询有经验的前辈，也得到了许多有意义的建议，她的想法开始些许改变，在这之前她认为这个样子是不得了的大事，遇到了人生的挫折，需要做出改变与换工作。但是在这之后她明白了人生会经历许多次这样的事情，并非每一次都要换工作来解决，如果她自身对工作的期待不变的话则很快就会迎来下一次。但这些还没有真正让她真的脱离当前的状态。</p><p>直到去年年底的时候，已经没有什么任务了，大家纷纷开始结束了办公状态。她每天会和朋友做软陶，而工作的过程没有deadline，没有deadline也不觉得负罪，因为实在没办法有deadline。</p><p>但是这个时候她意识到自己出乎意料的开心</p><blockquote><p>以前感觉自己没有在做正事就会有自己是一事无成的loser的感觉<br>从来没想到如果做的每一件事情都是当下觉得喜欢且度过的时光里大部分都很开心，这样的日子里却没有在意有没有取得成绩、做的好不好<br>很难得的是在那些日子里觉得就这样也挺好的，躺平做咸鱼也挺好的。过的比较轻松，即便依然有事情想要做好，但基本上生活的节奏还是比较轻松。</p></blockquote><blockquote><p>如何不去想那些恐惧与焦虑，面对这个问题我以前觉得对抗这些地方是做的更好，害怕自己做的不够好，所以就去做得更好。做的越来越好、跑的越来越快，但我没想到我感动、放松、舒服、满足和快乐的时候，那些最原本的焦虑和恐惧直接不见了。我意识到是不是一开始就问错问题了，我问自己的时候是怎么样做更多去应对自己做的不够多的焦虑，但我没想到答案竟然好像是我做的更少、我让自己开心的话焦虑就随风而散了</p></blockquote><p>意识到可以这个样子来解决问题的时候，她开始尽可能保持比较好的状态，减少工作量，或者说把工作量控制在能够的负荷的程度上，尽可能减少工作里面不必要的焦虑，让我自己保持在一个相对比较轻松比较愉悦的状态逐渐的她所看到的风景也发生了变化。</p><h2 id="列车与风景的变化"><a href="#列车与风景的变化" class="headerlink" title="列车与风景的变化"></a>列车与风景的变化</h2><p>她开始觉得更喜欢休息那段时间那个样子的自己，更接受自己，也更善待他人，而在另一位主持人眼中也看到了她更加接受自己和善待自己的样子。</p><p>她的视角开始发生了变化，她看到的风景也开始发生了变化。</p><p>在这之前疲于处理人际关系，为了别人五分钟能处理事情的请求感到暴躁。同时不想社交，觉得社交浪费时间。</p><p>在这之后，她和同事的工作和交流更有耐心，更加能够接受同事的一些问题。</p><p>在这之前如果别人会议没有邀请她则会心里想“为什么不邀请我，是不是上一次交流的时候做错了什么，是不是他不喜欢我，是不是他觉得我很没用，他是不是不需要我不喜欢我“，一直在反复思考这样的事情。</p><p>但是在这之后她开始问自己：这是自己想感受到的焦虑？这焦虑是不是有必要的？这对我是不是有帮助的？她开始能够产生情绪的时候多分析一下情绪本身，意识到这些以后负面想法自然而然的灰飞烟灭，并且能够正确的方式去解决问题。</p><h1 id="我与列车"><a href="#我与列车" class="headerlink" title="我与列车"></a>我与列车</h1><p>听到这一档播客的时候越听到最后越觉得非常沉重。并不是说节目的过程或者内容真的是多么沉重的内容，而是和我的想法几乎一模一样。</p><h2 id="控制列车前进"><a href="#控制列车前进" class="headerlink" title="控制列车前进"></a>控制列车前进</h2><p>注：这里以及后面的工作不是指去公司上班这样的工作，我觉得用自己认为自己要做的任务比较合适一些。</p><p>觉得自己不行，就要想方设法的去做些什么，觉得自己本来就很没用如果不做些什么只会越来越没用。不过实际上我很多能力客观来讲确实有不足，加上本身精力极其差，很快就失去了控制，也就无法踩下刹车。</p><p>现在依然觉得我各方面做的都很差，各方面都是非常有问题的一个人，但是我开始对于自评的准确性产生了更多的怀疑，自己看到的自己究竟多少是正确的，多少是错误的。</p><h2 id="与其他列车的轨道交错"><a href="#与其他列车的轨道交错" class="headerlink" title="与其他列车的轨道交错"></a>与其他列车的轨道交错</h2><p>与他人交流的时候会有相似的想法，自己是不是做的不够好，是不是哪里做错了什么。我的客观情况是以前确实存在过许多类似的情况，但是数年过去我依然将想法停留在过去什么都没有做的我身上，而没有正视现在的自己的努力，正视自己的变化，正视周边的环境。</p><p>我现在还是会因为各种和人之间交流中出现的各种错误而自责，但是我或许应该多一分对自己的宽容，多怀着这是应当被解决问题的角度去看待。</p><h2 id="尝试控制列车"><a href="#尝试控制列车" class="headerlink" title="尝试控制列车"></a>尝试控制列车</h2><p>我尝试了许多，尝试了解自己这个样子的形成原因；尝试通过运动从身体层面改善；尝试一些有意思的兴趣爱好；尝试像卧室摆花这样的方式来感受生活；尝试培养许多习惯增强自己对生活的掌控感；尝试去强迫自己主动与他人建立连接。</p><p>也尝试过和hoka一样的方法，遇到问题的时候反思这个焦虑是否合理、焦虑是怎么产生的，但是这个方法之前几次尝试对我来说效果不大。这个方法我在其他地方也见过多次，这也说明了同一个方法对于不同人的适用性是不同的。</p><p>尝试了这么多，不过很多时候我还是无法快速恢复到原来的状态，但是我觉得通过这些努力在部分方面有一些进步，对我来说需要的可能不是契机，而是需要再经过一些时间。</p><h2 id="hoka的列车带给我的想法"><a href="#hoka的列车带给我的想法" class="headerlink" title="hoka的列车带给我的想法"></a>hoka的列车带给我的想法</h2><p>听这期节目的时候感觉非常压抑，但是节目最后有这样一句话</p><blockquote><p>这是一个契机帮助我了解我自己，我相信我一定可以从这个状态走出来，所以我不再害怕了</p></blockquote><p>也许是负面想法过于相似的缘故，听到这里感受到了一股温暖，压抑感也消失了一大半。</p><p>很难说听了一期播客就能都想开了，但是这期节目又让我强迫自己去面对这样的想法，去审视反思自己该怎么做，如何将他人的经验能作为参考。</p><p>不过比起上面说的那些，对我来说更重要的可能是这么厉害的人也会有这样的想法，让我觉得安心一些了。</p><p>之前也见过“厉害的人也会有一些认为自己不行“的说法（并不是说越了解越发现自己无知的那种，而是觉得自己这个人不行），但是终究没有真实感，没有经历过终究只是一行文字罢了。</p><p>只是听或许只是留下深刻印象，但是写这篇文章的时候我需要再次强迫自己重新审视自己，类似的情况自己是怎么样的，这些是只停留在听远远达不到的。</p><h1 id="列车交错"><a href="#列车交错" class="headerlink" title="列车交错"></a>列车交错</h1><p>这里不论自身的工作（职业与自我）还是面对他人的想法，终究都要归到人上。能力的高低需要和人进行比较，工作做的怎么样会影响到他人的评判进而影响到别人的看法。不论好与坏，都是如此。但是实际上人生就像列车一样并不需要和其他人做比较，每个人有着各自属于自己的独一无二的路线。</p><p>但是大多数人并不能从心底接受这个想法（我也一样），因此我们在与他人建立联系的时候产生的不安全感，产生了焦虑、恐惧。</p><p>说到这些内容，我回想起《神经症与人性的成长》这本书提到的人的基本焦虑（这本书十分推荐给大家，不要因为书名有神经症就放弃了这本书，这本书能够帮助你理解你在成长过程中遇到的一些问题的根本成因）</p><blockquote><p>“其结果是使得小孩缺乏对“我们”的“归属感”与“连带感”，而代之以深刻的不安全感与莫名的恐惧，此种现象我称之为“基本焦虑”，是因处身于自己所认为敌对的世界中，而产生的一种被孤立或无助的感觉。这种基本焦虑会使小孩无法抒发真正的情感以与人相沟通，并可因而逼他去寻求对付别人的方法。他一定会（潜意识地）需要以某种方式来对付别人，而且这种方式必须不会激起或增加此种基本焦虑，而是会缓和它。由此种潜意识的策略需要所产生的特殊态度，须视小孩子的气质及环境的偶然性而定；简言之，他会试图去依附周遭最有权势的人；会反抗与格斗；会使他的内在生活与他人隔绝开来，且意气用事地远离他人；通常这意味着他会<strong>亲近</strong>、<strong>反抗</strong>或者<strong>逃避</strong>他人。</p></blockquote><p>注：关于这里提及的内容如果觉得说的太过于绝对还请看原书上下文，都有更详尽的解释。</p><p>对我来说一个人的时候就不会有这些内耗，想着不去建立联系就没有那么多问题了，这就是回避。但是这终究是错误的，同时也是不可能实现的。人们像列车一样总会以某种方式建立联系，对于列车来说可能会停在一起，可能会跑过相同的铁轨，可能相反会擦肩而过，可能会相同的方向发车。人们不也是如此吗，和别人相遇，和别人分离。好的联系，坏的联系；想要的联系，不想要的联系；会产生幸福感的联系，会产生焦虑感的联系，<strong>人们总会以某种方式产生关联，无法脱离开来</strong>。</p><p>对于我这样经常回避的人来说，一定要意识到回避掉是不可能的这件事情，然后去做出改变才可能打破现状。而对于非回避的情况我认为很大程度上也需要认识到人与人之间的关系，并且去寻求前人的经验，寻求身边的人帮助。</p><p>人的问题出在人与人之间的连接，但是解决问题的过程甚至最终方案依然要依赖于人与人之间的连接。</p><h1 id="各自的人生列车"><a href="#各自的人生列车" class="headerlink" title="各自的人生列车"></a>各自的人生列车</h1><p>每个人的问题都是不同的，即便会有相似的情况，可以参考一部分别人的做法，但是不太可能完全依靠和他人相同的解决方案解决自身的问题。每个人根据自己的性格特点以及现状解决方案都是各不相同的，但我觉得大多数情况是需要<strong>自己做出什么改变</strong>，因为操控这辆列车的人是你自己。即便有外部因素将你推动到另一个方向上，你依然可以让列车回到正规。</p><p>列车的行驶中一切不可能总是一帆风顺，如果这趟列车脱离了轨道，那请将这视为一个契机，发现问题，去解决问题。如果一时没能解决，很多时候并不是你的方法不对（就像hoka去旅游放松，本身并不是坏的选择），而是可能需要一些时间，可能需要一些其他契机。我认为最重要的是不管怎样不要害怕面对这个问题，即便你没有什么解决问题的想法。霍金说过“有生命就有希望”。</p><p>最后贴上这期节目的地址</p><p><a class="link"   href="https://uxcoffee.com/episodes/93" >https://uxcoffee.com/episodes/93<i class="fas fa-external-link-alt"></i></a></p><p>我挺喜欢这个节目的，尽管我对设计没什么了解，但是听了很多期都非常喜欢，在这里也推荐这档播客给读到结尾的你。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/driver-and-tra</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="Podcast" scheme="https://fusionbolt.github.io/tags/Podcast/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记 一些变动</title>
    <link href="https://fusionbolt.github.io/2022/05/15/rc-lang-change/"/>
    <id>https://fusionbolt.github.io/2022/05/15/rc-lang-change/</id>
    <published>2022-05-15T14:42:50.000Z</published>
    <updated>2022-05-15T14:44:21.653Z</updated>
    
    <content type="html"><![CDATA[<p>关于开发周记周更这件事情现在继续做的必要性我开始产生了疑问。</p><p>首先我写这个一方面是为了养成写博客的习惯，另一方面则是为了促进我形成写代码的习惯。然而随着我不断的做这样的事情，需要学习分析其他编译器实现的次数越来越多。这并非是因为我不继续做下去而要放弃，反而是我想要更好的做这件事情。这些分析的结果我更倾向于转换为其他系列的博客，因此我决定不再周更开发周记。</p><p>当然并不是说后面完全不更新了，如果我代码开始写新的内容一定会更新的，同时之后写的新内容一定会关联到对应一期分析的博客。至于分析的内容，当我了解完成一个阶段以后会对这些内容进行一个整理并且发布到我的博客。更新频率未必会周更，视我学习的进度而定，主要是想要尽可能保证内容的完整与连贯，有一些内容还是放在一起写会比较合适。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于开发周记周更这件事情现在继续做的必要性我开始产生了疑问。&lt;/p&gt;
&lt;p&gt;首先我写这个一方面是为了养成写博客的习惯，另一方面则是为了促进我形成写代码的习惯。然而随着我不断的做这样的事情，需要学习分析其他编译器实现的次数越来越多。这并非是因为我不继续做下去而要放弃，反而是我</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>我与博客</title>
    <link href="https://fusionbolt.github.io/2022/05/08/IandBlog/"/>
    <id>https://fusionbolt.github.io/2022/05/08/IandBlog/</id>
    <published>2022-05-08T03:42:36.000Z</published>
    <updated>2022-05-21T09:22:06.346Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/IandBlog/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">你愿意和我一起读下去吗 pixiv: 44636666</center> <p>读《暗时间》这本书的时候看到关于你为什么应该写博客的章节，想先把自己有关博客的想法做一个记录，因此就有了本文。</p><h1 id="我和博客的开始"><a href="#我和博客的开始" class="headerlink" title="我和博客的开始"></a>我和博客的开始</h1><p>以前也尝试过建立博客，也搞过什么Wordpress之类的，但也都是搭建好新鲜感过去来，之后就没写什么东西，之后也就不了了之了。</p><p>去年三月多的时候又将这个事情回想了起来，决定好好对待这件事情。<del>结果去年一年也没写上几篇</del></p><p>今年的话渐渐有了更多的想法，内容也逐渐的有了一些。</p><h1 id="博客所带来的好处"><a href="#博客所带来的好处" class="headerlink" title="博客所带来的好处"></a>博客所带来的好处</h1><h2 id="反复思考"><a href="#反复思考" class="headerlink" title="反复思考"></a>反复思考</h2><p>写博客本身是一个反复思考复盘的过程。不论是单纯记录还是思考，写下的过程中会不断复习这些知识，在这个过程中自己对这些知识的记忆会更加牢靠，同时可能产生了新的问题，进而产生新的思考。同时梳理思考的过程中会无意中发现一些问题，我在写自己的开发周记的时候发现了一些自己的bug。</p><p>在讲解给读者的时候会强迫自己去思考，读者可能会提出哪些问题？这些地方自己是否真的明白了？有的技术博客我在写的时候也会发现自己知识的漏洞，现去弥补一下知识漏洞再来接着写。</p><p>这样长期反复梳理思考下去我觉得慢慢这种思考就会变成一种习惯，不仅是写博客，在做其他的事情也会受益。</p><h2 id="展示自我"><a href="#展示自我" class="headerlink" title="展示自我"></a>展示自我</h2><p>看博客能够知道你是什么样的人。你写什么样的博客，你关注哪些内容，你的思考方式是怎么样的等等。这也算是一种特殊的自我介绍了，在网络上看一个人的几条发言可能看不出一个人是怎样的，但是如果他一直持续输出内容，则可以从输出的内容中对这个人多几分了解。或许还会有志同道合的人因此和你成为朋友，也许其中还会有非常聊得来的人。（<del>首页中的图标和关于都有我的联系方式，欢迎私信</del>）</p><h2 id="积累与激励"><a href="#积累与激励" class="headerlink" title="积累与激励"></a>积累与激励</h2><p>看到自己写了那么多博客，既是一种积累，后面再回来看，看着自己的内容不断精进，不断变化，意识到自己的进步与成长，进而给自信添砖加瓦，激励自己后续持续学习和思考。这是一种良性循环，只要熬过了最初不知道该写什么与不知道怎么写的阶段，就会不断有所收获。</p><h1 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h1><h2 id="出师不利：不知道该写什么"><a href="#出师不利：不知道该写什么" class="headerlink" title="出师不利：不知道该写什么"></a>出师不利：不知道该写什么</h2><p>在刚开始写的时候，这个问题是最让我头疼的。去年年底开始写开发周记之前，基本上都没什么内容。后来开发周记写了几篇，读书的时候也开始能够留下一些笔记和想法，渐渐的有了一些想写的东西。读书感悟，简单的科普，开发问题复盘，自己的一些想法，我还有很多想法都没有写出来，很多来不及整理的只能在我的笔记中默默等待</p><p>仔细考虑的话，发生这种改变的本质原因是我去年开始做了各种各样的事情，同时渐渐开始养成记录内容的习惯（这个记录的习惯真的是非常重要，我的很多博客都是从碎片整理来的），因此我渐渐的有一些东西可说。如果你实在不知道怎么写，那就试着多留心观察自己的想法，自己经历的事情，说不定会找到什么答案。</p><p>但是因为不知道写什么就放弃不去写了这件事情是完全不一样的。如果不去做些什么的话，你不管放弃几次回头看可能都不知道写什么。只要写了一篇，就更可能有第二篇，以此类推</p><p>我在初学编程的时候也是不知道该写什么，因为我对这个东西没有形成一些印象，后来过了非常长的时间总算是多少入了门。在这个过程中我一直没有停止学习接触相关知识，即便现在看来都是错误的方式，但最终都是我过去的行为推动了我现在的行为</p><h2 id="想着一定要写好"><a href="#想着一定要写好" class="headerlink" title="想着一定要写好"></a>想着一定要写好</h2><p>当然保证质量是很重要的事情，但是也因此有的博客过于追求质量、又或者说把握不住详细到什么地步就难产了。</p><p>后来我在写第一篇读书笔记的时候写了一部分了，剩下的不知道怎么写，当我想到了我之前难产的博客以及如果再这么要求质量的话可能就完不成的时候我决定草草收尾。</p><p>对于一开始来说我觉得还是坚持写下去更加重要，尤其是在你觉得自己很不擅长这件事情的时候。之前看到一个人的推特写目标是坚持输出内容，前二十多期可以不追求质量，这也是同样的道理。一开始总是不熟练，那就放低要求，先以完成为目的。</p><h1 id="写博客的误区"><a href="#写博客的误区" class="headerlink" title="写博客的误区"></a>写博客的误区</h1><p>除了我上面提到的问题，《暗时间》这本书中还提到了一些写博客的误区，我也在这里提及一下，加入了一些我自己的想法，有兴趣的读者可以去看原书</p><h2 id="担心自己的内容"><a href="#担心自己的内容" class="headerlink" title="担心自己的内容"></a>担心自己的内容</h2><p>如果担心自己写的东西别人都已经写过了，我认为不需要去关心这些。这里要注意一个非常关键的点：<strong>写博客是为了更好的学习与思考，</strong>而不是说一定要去写什么别人没写过的东西。这不是毕业论文，不需要担心这些问题，你在成文的过程中的思考有所收获就够了。</p><p>如果担心内容质量不佳，那就像上面说的想着一定要写好一样，不再赘述。如果担心想法有漏洞，那更不必担心，这个漏洞不会因为你不写出来而消失，写出来被别人指正反而是更好的改进方式。</p><h2 id="关注反馈"><a href="#关注反馈" class="headerlink" title="关注反馈"></a>关注反馈</h2><p>上面也提到了写博客的目的，对于外部的反馈以及其他博客的好处来说这不过是附赠品，同时如果是为了外部反馈而写，那么很可能做出偏离学习与思考这一本意的行为。</p><p>暗时间中有这样一句话</p><blockquote><p>只做你最感兴趣的事情，钱会随之而来</p></blockquote><p>这个例子是类似的，牢记初心，专注于你当前真正要做的事情，其他的附属品都会随之而来。</p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>阅读博客的人更希望得到信息而非噪音。每个人都会有想法牢骚的冲动，但是这应该是在其他一些适合发牢骚的平台，比如说Twitter。</p><p>我在之前也非常容易碎碎念，看到这条以后我下定决心以后其他输出内容的地方都不会掺杂各种碎碎念，还请读者们监督。</p><h1 id="亲自动手写了博客才发现的事情"><a href="#亲自动手写了博客才发现的事情" class="headerlink" title="亲自动手写了博客才发现的事情"></a>亲自动手写了博客才发现的事情</h1><p>最大的感悟是输出内容真的是不容易。完成一篇内容充足的博客需要很久，同时又要保证质量的话是非常难的事情。</p><p>看别人写和自己写完全是两回事。经常看别人在知乎上写了那么长一大段的干货，真到自己写的时候发现是多么困难。（这里我不禁好奇他们是怎么有时间能写那么多那么长的回答？）</p><p>由于这些感受，我对持续输出内容的人逐渐开始有了更多的尊敬，因为输出内容确实是一件比较辛苦的事情。尽管有的时候输出内容也很开心，但是最终能够持续输出的还是少数。</p><h1 id="我与博客"><a href="#我与博客" class="headerlink" title="我与博客"></a>我与博客</h1><p>虽然我第一次接触博客的时候没有做下去，但庆幸的是现在我已经逐渐形成了这个习惯。即便去掉开发周记也还剩下许多其他博客，看到这些我感到十分欣慰。我会持续的输出内容，并且在保证不影响写完的前提下提升质量。</p><p>文章的最后我想引用一句《暗时间》中的话</p><blockquote><p>人太容易为各种各样的事情分心，要集中注意力做一件事情是非常难的，而正因为难，少有人做到，那些做到的，就都变成了牛。</p></blockquote><p>只有坚持做下去才能做到，而实际上博客所带来的基本上都是好处，为什么不坚持做下去呢？</p><p>不过能不能变成牛这不重要，只要坚持学习、思考与行动，最终总会变成大牛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/IandBlog/Untit</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="Blog" scheme="https://fusionbolt.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记18 简单类型推导</title>
    <link href="https://fusionbolt.github.io/2022/05/08/rc-lang-dev-18/"/>
    <id>https://fusionbolt.github.io/2022/05/08/rc-lang-dev-18/</id>
    <published>2022-05-08T03:17:10.000Z</published>
    <updated>2022-05-08T03:29:24.275Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-18/timg.jpg"                      alt="timg.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">不要小看我，这种程度我也可以做得出！非pixiv</center> <p>本周主要都在了解MIR相关，但是还存有非常多的问题，因此先来讲一下之前写的TypeInfer的内容</p><p>我将Infer的过程分为了两部分。第一部分是最纯粹的类型推导，第二部分是实际将ast转换为带有类型信息的ast。</p><h1 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h1><p>目前先这样做了一个非常简易的样子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Type</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Boolean</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">String</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Int32</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Float</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Fn</span>(ret: <span class="type">Type</span>, params: <span class="type">List</span>[<span class="type">Type</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Infer</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Err</span>(msg: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><h1 id="Typed"><a href="#Typed" class="headerlink" title="Typed"></a>Typed</h1><p>对于类型相关的操作来讲，首先本身是有类型的才能进行infer，因此有了这样一个trait</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Typed</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ty:<span class="type">Type</span> = <span class="type">Type</span>.<span class="type">Infer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withTy</span></span>(ty: <span class="type">Type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.ty = ty</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withInfer</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> = withTy(infer)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>: <span class="type">Type</span> = <span class="type">Infer</span>(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里默认的是Type.Infer，表示需要Infer才行</p><p>infer的过程则是调用了case object Infer（单例对象），后面会讲到</p><p>用的时候直接mixin这个trait即可</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">ASTNode</span> <span class="keyword">with</span> <span class="type">Typed</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(ident: <span class="type">Ident</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Item</span> <span class="keyword">extends</span> <span class="type">ASTNode</span> <span class="keyword">with</span> <span class="type">Typed</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Method</span>(decl: <span class="type">MethodDecl</span>, body: <span class="type">Block</span>) <span class="keyword">extends</span> <span class="type">Item</span> <span class="keyword">with</span> <span class="type">Typed</span></span><br></pre></td></tr></table></figure><h1 id="TyCtxt"><a href="#TyCtxt" class="headerlink" title="TyCtxt"></a>TyCtxt</h1><p>ctxt的部分主要存放一个全局符号表，以及一个局部符号表（这里的符号表只包含了类型信息）</p><p>而局部符号表又分为了当前scope以及outer的两部分。</p><p>接口也很简单，简单的添加与查找，以及进入一个新的scope</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TyCtxt</span>(<span class="params">val global:<span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>] = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>](</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> outer = <span class="type">List</span>[<span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]]()</span><br><span class="line">  <span class="keyword">var</span> local = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(ident: <span class="type">Ident</span>): <span class="type">Option</span>[<span class="type">Type</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> ty = local.get(ident) orElse outer.find(_.contains(ident)) orElse global.get(ident)</span><br><span class="line">    ty.asInstanceOf[<span class="type">Option</span>[<span class="type">Type</span>]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    outer ::= local</span><br><span class="line">    local = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]()</span><br><span class="line">    <span class="keyword">val</span> result = f</span><br><span class="line">    local = outer.head</span><br><span class="line">    outer = outer.tail</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addLocal</span></span>(k: <span class="type">Ident</span>, v: <span class="type">Type</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    local += (k -&gt; v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于enter的参数需要讲一下，既不是一个f: T，也不是一个f: () ⇒ T。</p><p>使用f: ⇒ T的写法可以推迟实际传进来的求值过程。既可以接受一个简单的T，也可以接受一个函数计算结果的T，同样也可以接受一个() ⇒ T</p><p>看一个测试就明白了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;nested&quot;</span>) &#123;</span><br><span class="line">  tyCtxt.enter(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> id = <span class="type">Ident</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ty = <span class="type">Nil</span></span><br><span class="line">    tyCtxt.addLocal(id, ty)</span><br><span class="line">    tyCtxt.enter(testEnter(id))</span><br><span class="line">    assert(tyCtxt.enter(id) == <span class="type">String</span>)</span><br><span class="line">    assert(tyCtxt.lookup(id).contains(ty))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testEnter</span></span>(id: <span class="type">Ident</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">assert(tyCtxt.local.isEmpty)</span><br><span class="line">  <span class="keyword">val</span> innerTy = <span class="type">String</span></span><br><span class="line">  tyCtxt.addLocal(id, innerTy)</span><br><span class="line">  assert(tyCtxt.lookup(id).contains(innerTy))</span><br><span class="line">  innerTy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的enter存在两种写法。</p><p>在进入testEnter之前添加了local，进入之后local变成了空的，也就是说进入了一个新的scope。</p><p>最初是觉得每次tyCtxt.enter(() ⇒ f())都要写() ⇒ 感到非常麻烦，后来发现了这样的写法</p><h1 id="Infer"><a href="#Infer" class="headerlink" title="Infer"></a>Infer</h1><p>成员变量只有一个tyCtxt</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Infer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tyCtxt: <span class="type">TyCtxt</span> = <span class="type">TyCtxt</span>()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>infer的入口处</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(typed: <span class="type">Typed</span>, force: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  infer(typed, force)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(typed: <span class="type">Typed</span>, force: <span class="type">Boolean</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span>(!force &amp;&amp; typed.ty != <span class="type">Type</span>.<span class="type">Infer</span>) &#123;</span><br><span class="line">    typed.ty</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    infer(typed)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(typed: <span class="type">Typed</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  typed <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> expr: <span class="type">Expr</span> =&gt; infer(expr)</span><br><span class="line">    <span class="keyword">case</span> item: <span class="type">Item</span> =&gt; infer(item)</span><br><span class="line">    <span class="keyword">case</span> method: <span class="type">Item</span>.<span class="type">Method</span> =&gt; infer(method)</span><br><span class="line">    <span class="keyword">case</span> stmt: <span class="type">Stmt</span> =&gt; infer(stmt)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>force也很好理解，不是force的情况下原来有type则直接返回，而不是进行推导</p><h2 id="Expr-infer"><a href="#Expr-infer" class="headerlink" title="Expr infer"></a>Expr infer</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(expr: <span class="type">Expr</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  expr <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(v) =&gt; <span class="type">Int32</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Identifier</span>(ident) =&gt; lookup(ident)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bool</span>(b) =&gt; <span class="type">Boolean</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Binary</span>(op, lhs, rhs) =&gt; common(lhs, rhs)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Str</span>(str) =&gt; <span class="type">String</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">If</span>(cond, true_branch, false_branch) =&gt; false_branch <span class="keyword">match</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(fBr) =&gt; common(true_branch, fBr)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; infer(true_branch)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Return</span>(expr) =&gt; infer(expr)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Block</span>(stmts) =&gt; tyCtxt.enter(infer(stmts.last))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Call</span>(target, args) =&gt; lookup(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Infer的部分主要还是在于表达式的类型推导，实际上也很直观。有的种类表达式自身类型是确定了，需要考虑id的就去lookup，像if和binary这种通过common来获取。</p><h2 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(ident: <span class="type">Ident</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  tyCtxt.lookup(ident).getOrElse(<span class="type">Err</span>(<span class="string">s&quot;<span class="subst">$ident</span> not found&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的在ctxt中查找符号的信息</p><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">common</span></span>(lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> lt = infer(lhs)</span><br><span class="line">  <span class="keyword">val</span> rt = infer(rhs)</span><br><span class="line">  <span class="keyword">if</span> lt == rt then lt <span class="keyword">else</span> <span class="type">Err</span>(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我还抱有一些疑问，在这里产生一个TypeErr是否合适，但是如果lhs和rhs的类型是不兼容的情况那也无法得出一个正确的Type</p><p>虽然名字叫common，然而这里做的非常简单，只是简单判别类型是否相同而没有考虑到type compatible</p><h2 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](tyCtxt: <span class="type">TyCtxt</span>, f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  <span class="keyword">this</span>.tyCtxt = tyCtxt</span><br><span class="line">  tyCtxt.enter(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  tyCtxt.enter(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了普通的enter，还支持通过指定一个typeCtxt来推导</p><h1 id="Translator"><a href="#Translator" class="headerlink" title="Translator"></a>Translator</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">TypedTranslator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tyCtxt: <span class="type">TyCtxt</span> = <span class="type">TyCtxt</span>()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(tyCtxt: <span class="type">TyCtxt</span>)(module: <span class="type">RcModule</span>): <span class="type">RcModule</span> = &#123;</span><br><span class="line">    <span class="comment">// update local table in TypedTranslator will cause Infer ctxt update</span></span><br><span class="line">    <span class="comment">// because of pass a typCtxt by Ref</span></span><br><span class="line">    <span class="type">Infer</span>.enter(tyCtxt, <span class="type">RcModuleTrans</span>(module))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传递一个ctxt的引用给Infer，之后在translator里面通过tyCtxt更新各种local信息，这样Infer只做infer就可以了，不需要关心其他的事情。翻译的最小单元则是一个Module</p><p>translator主要的想法就是通过infer获取类型，之后返回一个保存有意义的类型信息的ASTNode</p><h2 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exprTrans</span></span>(expr: <span class="type">Expr</span>): <span class="type">Expr</span> =</span><br><span class="line">(expr <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Binary</span>(op, lhs, rhs) =&gt; <span class="type">Binary</span>(op, lhs.withInfer, rhs.withInfer)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">If</span>(cond, true_branch, false_branch) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> false_br = false_branch <span class="keyword">match</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(fBr) =&gt; <span class="type">Some</span>(fBr.withInfer)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></span><br><span class="line">      <span class="type">If</span>(cond.withInfer,</span><br><span class="line">        true_branch.withInfer.asInstanceOf[<span class="type">Block</span>],</span><br><span class="line">        false_br)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Call</span>(target, args) =&gt; <span class="type">Call</span>(target, args.map(_.withInfer))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Return</span>(expr) =&gt; <span class="type">Return</span>(expr.withInfer)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Block</span>(stmts) =&gt; tyCtxt.enter(<span class="type">Block</span>(stmts.map(stmtTrans)))</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; expr).withInfer</span><br></pre></td></tr></table></figure><p>可以看到就是简单的将参数withInfer，之后重新构建起这个表达式，并且将这个表达式整体进行infer。</p><p>为了避免一个个调用withInfer，因此在最后将expr的结果统一调用withInfer</p><p>对于Stmt的部分本质做法是差不多的，就不再赘述了</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>下周开始会开始专注于适合优化层面IR的内容了。最早我给自己规定的每天写一部分功能，不过我后来已经将写与学习成为了习惯，因此不会再局限于每天写这种事情。现在更多的是了解各种不同的做法，分析不同做法之间的差异（了解这些的过程有些上瘾，一不小心就会陷进去）。也因此下周开始的内容可能写的篇幅会少一些，会多一些对比分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-18</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Type" scheme="https://fusionbolt.github.io/tags/Type/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记17 一点AST检查</title>
    <link href="https://fusionbolt.github.io/2022/05/01/rc-lang-dev-17/"/>
    <id>https://fusionbolt.github.io/2022/05/01/rc-lang-dev-17/</id>
    <published>2022-05-01T02:37:41.000Z</published>
    <updated>2022-05-01T02:39:16.944Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-17/69589494_p0.png"                      alt="69589494_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">聪明如我怎么会写出ast有错误的代码 pixiv:69589494</center> <p>先说一声五一快乐！久违的长假，之后会花一些时间把其他一些写到一半的博客整理出来</p><p>本来想要好好做一下检查相关以及类型推导的工作，但是目前来说我更需要先学习优化方面的知识，因此关于ast的检查以及类型推导和类型检查做的比较简易，过后有时间再回来做。本周虽然做了部分类型推导和类型检查，但是只做了一半，剩下的部分可能要下周再说了。下周大概就能做完简单的类型推导和检查</p><h1 id="AST检查"><a href="#AST检查" class="headerlink" title="AST检查"></a>AST检查</h1><p>目前所实现的检查无外乎这么几类</p><ol><li>名称冲突</li><li>未定义符号</li><li>变量的声明类型或者初始值必须有一个存在</li></ol><p>我挑出一些经典的部分讲解，不过多赘述重复的部分了</p><p>实际上能做的类型无关的检查还有非常多</p><h1 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dupNameCheck</span></span>(names: <span class="type">List</span>[<span class="type">Ident</span>]): <span class="type">Result</span> = &#123;</span><br><span class="line">  dupCheck(names, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dupCheck</span></span>[<span class="type">T</span> &lt;: <span class="type">ASTNode</span>](values: <span class="type">List</span>[<span class="type">T</span>], valueName: <span class="type">String</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> s = <span class="type">Set</span>[<span class="type">T</span>]()</span><br><span class="line">  values.filterNot(s.add).map(n =&gt; <span class="type">ValidateError</span>(n, <span class="string">s&quot;<span class="subst">$valueName</span> <span class="subst">$n</span> Dup&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkModule</span></span>(module: <span class="type">RcModule</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  dupNameCheck(module.items.map(item =&gt; item <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Item</span>.<span class="type">Class</span>(name, _, _, _) =&gt; name</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Item</span>.<span class="type">Method</span>(decl, _) =&gt; decl.name</span><br><span class="line">  )):::module.items.flatMap(checkItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说Module的检查中对所有item的名字检查是否存在冲突，并且再check每个Item本身</p><p>关于返回值的Result只是一个type alias</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span> </span>= <span class="type">List</span>[<span class="type">ValidateError</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateError</span>(<span class="params">node: <span class="type">ASTNode</span>, reason: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>这里还有很多待改进的空间，比如说将实际的错误分类，或者写一个diagnosis类来管理这些错误信息等等</p><p>这里使用一个type alias也是为了后面修改时候方便</p><p>这里可以看到所有的错误信息都是组合之后返回，原因是我想将代码中的副作用范围缩到最小，这样能够保证调用的结果尽可能的不受外部状态影响</p><h1 id="未定义的符号"><a href="#未定义的符号" class="headerlink" title="未定义的符号"></a>未定义的符号</h1><p>目前只做了一些简单的处理。这里还没有处理全局的符号（比如说函数和类）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Scope</span>(<span class="params">var localTable: <span class="type">Set</span>[<span class="type">Ident</span>] = <span class="type">Set</span>(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    localTable.add(ident)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    localTable.contains(ident)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> scopes = <span class="type">List</span>[<span class="type">Scope</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f:() =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    enter(<span class="type">Params</span>(<span class="type">List</span>()), f)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](params: <span class="type">Params</span>, f:() =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> oldScope = scopes</span><br><span class="line">    scopes ::= <span class="type">Scope</span>(mutable.<span class="type">Set</span>.from(params.params.map(_.name)))</span><br><span class="line">    <span class="keyword">val</span> result = f()</span><br><span class="line">    scopes = oldScope</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">curScope</span></span>: <span class="type">Scope</span> = scopes.last</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = curScope.add(ident)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    !scopes.exists(_.contains(ident))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">curContains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = curScope.contains(ident)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Scope有自己的table，每次通过enter进入一个table则将当前的放到List中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkBlock</span></span>(block: <span class="type">Block</span>, params: <span class="type">Params</span> = <span class="type">Params</span>(<span class="type">List</span>())): <span class="type">Result</span> = &#123;</span><br><span class="line">  scopes.enter(params, () =&gt; &#123;</span><br><span class="line">    block.stmts.flatMap(checkStmt)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkMethod</span></span>(method: <span class="type">Method</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  checkMethodDecl(method.decl)</span><br><span class="line">  checkBlock(method.body, method.decl.inputs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次进入一个Block的时候则进入了一个新的scope，比如说一个Method的body的expr</p><p>对于Id表达式则会去检查是否存在这个符号，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Identifier</span>(id) =&gt; checkCond(scopes.contains(id), expr, <span class="string">&quot;$name not decl&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="初始值与类型二选一"><a href="#初始值与类型二选一" class="headerlink" title="初始值与类型二选一"></a>初始值与类型二选一</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fieldDefValid</span></span>(fieldDef: <span class="type">FieldDef</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  fieldDef.initValue <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(expr) =&gt; checkExpr(expr)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; checkCond(fieldDef.ty != <span class="type">TyInfo</span>.<span class="type">Infer</span>, fieldDef, <span class="string">&quot;Field without initValue need spec Type&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类的field做了这样的检查，存在initValue则去检查expr，否则检查ty是否为需要Infer的。如果没有initValue也没有ty信息，那我们无法在后面类型推导的时候得出类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-17</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="AST" scheme="https://fusionbolt.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记16 Rust源码学习之初识类型</title>
    <link href="https://fusionbolt.github.io/2022/04/26/rc-lang-dev-16/"/>
    <id>https://fusionbolt.github.io/2022/04/26/rc-lang-dev-16/</id>
    <published>2022-04-25T16:19:02.000Z</published>
    <updated>2022-04-26T16:10:52.233Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-16/74795024_p0.jpg"                      alt="74795024_p0.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">类型和猫咪先生有多少相似之处呢 pixiv:74795024</center> <p>本周先了解了一些Rust Type相关的代码，之后开始写一些类型无关的语法检查。</p><p>虽然上周看了Rust中desugar的代码，但我这里就先不做desugar了，现在东西比较少，没什么价值。由于语法检查还没写多少，xs因此留到下周讲解。本周还是讲一下我看Rust Type相关的信息的一些了解，其中大部分信息是文档中介绍的，在这里算是一个简单概括。</p><p><a class="link"   href="https://rustc-dev-guide.rust-lang.org/ty.html" >https://rustc-dev-guide.rust-lang.org/ty.html<i class="fas fa-external-link-alt"></i></a></p><h1 id="不同的类型表示"><a href="#不同的类型表示" class="headerlink" title="不同的类型表示"></a>不同的类型表示</h1><p>在Rust中，目前我看到的部分有这么“几种”类型</p><ol><li>ast::Ty</li><li>hir::Ty(rustc_hir::Ty)</li><li>ty::Ty</li></ol><p>关于ast::Ty到hir::Ty本质上是进行了desugar，所代表的Ty本质是没有变化的。至于为什么这么说，这就要谈及hir::Ty和ty::Ty的区别</p><h1 id="hir-Ty-vs-ty-Ty"><a href="#hir-Ty-vs-ty-Ty" class="headerlink" title="hir::Ty vs ty::Ty"></a>hir::Ty vs ty::Ty</h1><p>先来讲我认为最根本的区别。</p><p>hir::Ty所表示的是在源码中出现的一个应当出现在需要类型位置的类型，换句话说它是关联到源码的Ty</p><p>而ty::Ty则是编译器中对中间表示（这里是hir）分析过后产生的一种类型，包含了更切实的语义，换句话说是关联到编译器内部类型表示的Ty</p><p>我来引用一下官方文档中出现的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">u32</span>) → <span class="built_in">u32</span> &#123; x &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中出现了两个u32，很显然这段代码的上下文中这两个u32都是同一个类型（注意不同lifetime的type是不同类型的）</p><p>每个u32本质上是关联到源码中某个位置的u32，比如说第一个关联的是源码第一行第10个字符开始的u32，而第二个则是关联到源码后面那个位置的u32。在没有type infer和type check之前我们并不知道是否关联相同的语义</p><p>而对于最终的type infer以及type check之后在这个语义环境下这两个u32会被视为同一个类型，最终这两个u32会被转换为相同的ty::Ty</p><p>文档中有这样一句</p><blockquote><p>they have two different <code>[Span</code>s](<a class="link"   href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html" >https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html<i class="fas fa-external-link-alt"></i></a>) (locations).</p></blockquote><p>之后我们来看一下官方文档中的总结表格，一切描述都是围绕着同一个核心区别</p><table><thead><tr><th>rustc_hir::Ty</th><th>ty::Ty</th></tr></thead><tbody><tr><td>Describe the syntax of a type: what the user wrote (with some desugaring).</td><td>Describe the semantics of a type: the meaning of what the user wrote.</td></tr><tr><td>Each rustc_hir::Ty has its own spans corresponding to the appropriate place in the program.</td><td>Doesn’t correspond to a single place in the user’s program.</td></tr><tr><td>rustc_hir::Ty has generics and lifetimes; however, some of those lifetimes are special markers like LifetimeName::Implicit.</td><td>ty::Ty has the full type, including generics and lifetimes, even if the user left them out</td></tr><tr><td>fn foo(x: u32) → u32 { } - Two rustc_hir::Ty representing each usage of u32. Each has its own Spans, etc.- rustc_hir::Ty doesn’t tell us that both are the same type</td><td>fn foo(x: u32) → u32 { } - One ty::Ty for all instances of u32throughout the program.- ty::Ty tells us that both usages of u32 mean the same type.</td></tr><tr><td>fn foo(x: &amp;u32) -&gt; &amp;u32)- Two rustc_hir::Ty again.- Lifetimes for the references show up in the rustc_hir::Tys using a special marker, LifetimeName::Implicit.</td><td>fn foo(x: &amp;u32) -&gt; &amp;u32)- A single ty::Ty.- The ty::Ty has the hidden lifetime param</td></tr></tbody></table><p>要注意一个我刚才没有详细提及的点，那就是lifetime。由于经常会省略编写lifetime因此对于hir来说很可能不会包含其信息，这样的信息都是会转成hir之后再隐式插入的</p><h1 id="类型之间转换流程"><a href="#类型之间转换流程" class="headerlink" title="类型之间转换流程"></a>类型之间转换流程</h1><p>根据文档所说，在ast转换为HIR的时候会做一些基本的type infer以及type check。在type infer的过程中会产生ty::Ty并实际进行检查</p><p>发生转换的入口则是在ast_ty_to_ty这里，而这个函数则是在AstConv这个trait中</p><p>先来简单看一下十分直观的函数签名，传入一个hir::Ty返回一个ty::Ty</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parses the programmer&#x27;s textual representation of a type into our</span></span><br><span class="line"><span class="comment">/// internal notion of a type.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ast_ty_to_ty</span></span>(&amp;<span class="keyword">self</span>, ast_ty: &amp;hir::Ty&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.ast_ty_to_ty_inner(ast_ty, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ast-ty-to-ty-inner"><a href="#ast-ty-to-ty-inner" class="headerlink" title="ast_ty_to_ty_inner"></a>ast_ty_to_ty_inner</h1><h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>这个函数依然属于AstConv</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ast_ty_to_ty_inner</span></span>(&amp;<span class="keyword">self</span>, ast_ty: &amp;hir::Ty&lt;<span class="symbol">&#x27;_</span>&gt;, borrowed: <span class="built_in">bool</span>, in_path: <span class="built_in">bool</span>) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> tcx = <span class="keyword">self</span>.tcx();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result_ty = <span class="keyword">match</span> ast_ty.kind &#123; ... &#125;</span><br><span class="line">debug!(?result_ty);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);</span><br><span class="line">  result_ty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略转换的细节，看一下整体做了什么</p><ol><li>获取TyCtxt</li><li>实际转换</li><li>记录类型</li></ol><h2 id="tcx和record"><a href="#tcx和record" class="headerlink" title="tcx和record"></a>tcx和record</h2><p>self.tcx和self.record都是AstConv本身未实现的方法</p><p>再来看一下一个实现了AstConv的部分实现（以下涉及AstConv未实现的部分都会以FnCtxt的实现作为参考）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;tcx</span>&gt; AstConv&lt;<span class="symbol">&#x27;tcx</span>&gt; <span class="keyword">for</span> FnCtxt&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">tcx</span></span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>) -&gt; TyCtxt&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.tcx</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">record_ty</span></span>(&amp;<span class="keyword">self</span>, hir_id: hir::HirId, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;, _span: Span) &#123;</span><br><span class="line">    <span class="keyword">self</span>.write_ty(hir_id, ty)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FnCtxt &#123;</span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_ty</span></span>(&amp;<span class="keyword">self</span>, id: hir::HirId, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;) &#123;</span><br><span class="line">    debug!(<span class="string">&quot;write_ty(&#123;:?&#125;, &#123;:?&#125;) in fcx &#123;&#125;&quot;</span>, id, <span class="keyword">self</span>.resolve_vars_if_possible(ty), <span class="keyword">self</span>.tag());</span><br><span class="line">    <span class="keyword">self</span>.typeck_results.borrow_mut().node_types_mut().insert(id, ty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ty.references_error() &#123;</span><br><span class="line">        <span class="keyword">self</span>.has_errors.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_tainted_by_errors();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcx没什么可说的，大多数都是这样简单的返回</p><p>record_ty中将一个hir的id与它的Ty进行关联，而这个hir的id则是hir::Ty的id。如果只看FnCtxt的record_ty的本身很容易以为一定是其他有类型的东西（比如expr或者Fn）的id关联到一个类型，但是往上看调用处没想到还会将一个hir::Ty指向ty::Ty</p><h2 id="ast-ty-to-ty"><a href="#ast-ty-to-ty" class="headerlink" title="ast_ty to ty"></a>ast_ty to ty</h2><p>内容比较多，这里选择几个讲一下</p><p>先来看一下里面是什么样子的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result_ty = <span class="keyword">match</span> ast_ty.kind &#123;</span><br><span class="line">    hir::TyKind::Slice(<span class="keyword">ref</span> ty) =&gt; tcx.mk_slice(<span class="keyword">self</span>.ast_ty_to_ty(ty)),</span><br><span class="line">    hir::TyKind::Ptr(<span class="keyword">ref</span> mt) =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ast_ty的不同kind做不同处理（下面只选取某一个kind的处理方式讲解）</p><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p>先来看一下infer</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">hir::TyKind::Infer =&gt; &#123;</span><br><span class="line">    <span class="comment">// Infer also appears as the type of arguments or return</span></span><br><span class="line">    <span class="comment">// values in an ExprKind::Closure, or as</span></span><br><span class="line">    <span class="comment">// the type of local variables. Both of these cases are</span></span><br><span class="line">    <span class="comment">// handled specially and will not descend into this routine.</span></span><br><span class="line">    <span class="keyword">self</span>.ty_infer(<span class="literal">None</span>, ast_ty.span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl AstConv for FnCtxt</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ty_infer</span></span>(&amp;<span class="keyword">self</span>, param: <span class="built_in">Option</span>&lt;&amp;ty::GenericParamDef&gt;, span: Span) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(param) = param &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> GenericArgKind::Type(ty) = <span class="keyword">self</span>.var_for_def(span, param).unpack() &#123;</span><br><span class="line">            <span class="keyword">return</span> ty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unreachable!</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.next_ty_var(TypeVariableOrigin &#123;</span><br><span class="line">            kind: TypeVariableOriginKind::TypeInference,</span><br><span class="line">            span,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Impl inferCtxt</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">next_ty_var</span></span>(&amp;<span class="keyword">self</span>, origin: TypeVariableOrigin) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.tcx.mk_ty_var(<span class="keyword">self</span>.next_ty_var_id(origin))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty_var</span></span>(<span class="keyword">self</span>, v: TyVid) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty_infer(TyVar(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty_infer</span></span>(<span class="keyword">self</span>, it: InferTy) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(Infer(it))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty</span></span>(<span class="keyword">self</span>, st: TyKind&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.interners.intern_ty(st, <span class="keyword">self</span>.sess, &amp;<span class="keyword">self</span>.gcx.untracked_resolutions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套娃比较多，不过内容也比较直观。关于intern_ty下一部分再仔细讲一下，先来看一下其他的例子</p><p>注意一点，这里infer产生的代码是unchecked的，上面也提到过</p><blockquote><p>在type infer的过程中会产生ty::Ty并实际进行检查</p></blockquote><h3 id="一些其他的"><a href="#一些其他的" class="headerlink" title="一些其他的"></a>一些其他的</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hir::TyKind::Tup(fields) =&gt; tcx.mk_tup(fields.iter().map(|t| <span class="keyword">self</span>.ast_ty_to_ty(t))),</span><br><span class="line">hir::TyKind::Slice(<span class="keyword">ref</span> ty) =&gt; tcx.mk_slice(<span class="keyword">self</span>.ast_ty_to_ty(ty)),</span><br><span class="line">hir::TyKind::Ptr(<span class="keyword">ref</span> mt) =&gt; &#123;</span><br><span class="line">    tcx.mk_ptr(ty::TypeAndMut &#123; ty: <span class="keyword">self</span>.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_tup</span></span>&lt;I: InternAs&lt;[Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;], Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;&gt;&gt;(<span class="keyword">self</span>, iter: I) -&gt; I::Output &#123;</span><br><span class="line">    iter.intern_with(|ts| <span class="keyword">self</span>.mk_ty(Tuple(<span class="keyword">self</span>.intern_type_list(&amp;ts))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_slice</span></span>(<span class="keyword">self</span>, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(Slice(ty))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ptr</span></span>(<span class="keyword">self</span>, tm: TypeAndMut&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(RawPtr(tm))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来都比较直观，而每一个mk_xxx本质上都是直接或者间接调用了mk_ty，再进入intern_ty做处理</p><h1 id="InternTy"><a href="#InternTy" class="headerlink" title="InternTy"></a>InternTy</h1><p>实现代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Interns a type.</span></span><br><span class="line"><span class="meta">#[allow(rustc::usage_of_ty_tykind)]</span></span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">intern_ty</span></span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    kind: TyKind&lt;<span class="symbol">&#x27;tcx</span>&gt;,</span><br><span class="line">    sess: &amp;Session,</span><br><span class="line">    resolutions: &amp;ty::ResolverOutputs,</span><br><span class="line">) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  Ty(Interned::new_unchecked(</span><br><span class="line">    <span class="keyword">self</span>.type_</span><br><span class="line">      .intern(kind, |kind| &#123;</span><br><span class="line">        <span class="keyword">let</span> flags = super::flags::FlagComputation::for_kind(&amp;kind);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It&#x27;s impossible to hash inference regions (and will ICE), so we don&#x27;t need to try to cache them.</span></span><br><span class="line">        <span class="comment">// Without incremental, we rarely stable-hash types, so let&#x27;s not do it proactively.</span></span><br><span class="line">        <span class="keyword">let</span> stable_hash = <span class="keyword">if</span> flags.flags.intersects(TypeFlags::HAS_RE_INFER)</span><br><span class="line">            || sess.opts.incremental.is_none()</span><br><span class="line">        &#123;</span><br><span class="line">            Fingerprint::ZERO</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> hasher = StableHasher::new();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> hcx = StableHashingContext::ignore_spans(</span><br><span class="line">                sess,</span><br><span class="line">                &amp;resolutions.definitions,</span><br><span class="line">                &amp;*resolutions.cstore,</span><br><span class="line">            );</span><br><span class="line">            kind.hash_stable(&amp;<span class="keyword">mut</span> hcx, &amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">            hasher.finish()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ty_struct = TyS &#123;</span><br><span class="line">            kind,</span><br><span class="line">            flags: flags.flags,</span><br><span class="line">            outer_exclusive_binder: flags.outer_exclusive_binder,</span><br><span class="line">            stable_hash,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        InternedInSet(<span class="keyword">self</span>.arena.alloc(ty_struct))</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="number">0</span>,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看起来大多是关于存储的细节，我也没有再过于深究了，但是要注意Ty的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Use this rather than `TyS`, whenever possible.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]</span></span><br><span class="line"><span class="meta">#[rustc_diagnostic_item = <span class="meta-string">&quot;Ty&quot;</span>]</span></span><br><span class="line"><span class="meta">#[rustc_pass_by_value]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ty</span></span>&lt;<span class="symbol">&#x27;tcx</span>&gt;(Interned&lt;<span class="symbol">&#x27;tcx</span>, TyS&lt;<span class="symbol">&#x27;tcx</span>&gt;&gt;);</span><br></pre></td></tr></table></figure><p>注意Ty这里保存了一个Interned，这个函数名本身也是intern_ty，那么这是代表了什么呢</p><p>我们看一下Interned的注释</p><blockquote><p>A reference to a value that is interned, and is known to be unique.<br>Note that it is possible to have a T and a Interned<T> that are (or refer to) equal but different values. But if you have two different Interned<T>s, they both refer to the same value, at a single location in memory. This means that equality and hashing can be done on the value’s address rather than the value’s contents, which can improve performance.<br>The PrivateZst field means you can pattern match with Interned(v, _) but you can only construct a Interned with new_unchecked, and not directly.</p></blockquote><p>Interned本质是指向实际unique的值的一个引用。</p><p>代码中可以看到将一个TyS传给了InternedInSet，而构建TyS的时候传入了一个stable_hash。关于这个stable_hash有着这样的注释</p><blockquote><p>The stable hash of the type. This way hashing of types will not have to work on the address of the type anymore, but can instead just read this field</p></blockquote><p>在上面提及hir::Ty和ty::Ty的时候说过相同的类型最后会转换为同一个ty::Ty，我想应该就是通过这些行为做到的。</p><p>要深入下去还有太多细节，而这些细节大多不是我目前关心的，所以就不深入了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-16</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="源码阅读" scheme="https://fusionbolt.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="Type" scheme="https://fusionbolt.github.io/tags/Type/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记15 Rust源码学习之desugar</title>
    <link href="https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/"/>
    <id>https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/</id>
    <published>2022-04-17T06:23:11.000Z</published>
    <updated>2022-06-19T07:13:12.358Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-15/68232005_p0.png"                      alt="68232005_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:68232005</center> <p>这周可以说几乎没写什么代码，都在学习别人的实现。在参考别人的做法之前自己写一版比较合适，这样会对整体有个了解（这样有利于阅读代码），知道哪些地方会有问题，看别人的代码后会发现哪里不一样并且去思考差异。不过我之前已经写过简易的实现了，因此直接来参考Rust的实现了</p><p>本周看的内容一半是desugar，另一半是关于MIR的。讲解的话目前先讲一下desugar的内容，内容相对较少能够一篇讲完。MIR的东西非常多，笔记也没有整理好，之后会单独开启一个源码阅读系列的坑</p><p>在讲之前首先要提的是<strong>为什么要学习他人的实现</strong>。尽管写出来能跑是没有问题的，但是参考这样的项目的过程中能学到他人写代码的方式，学到更多不一样的实现方式</p><h1 id="desugar"><a href="#desugar" class="headerlink" title="desugar"></a>desugar</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>我们现在在使用的编程语言中有一些语法糖，这些语法糖本质上是对一些功能的包装，让我们用的更方便，但是没有做到一些什么没有这个语法糖所做不到的东西。</p><p>这里举一个很直观的例子，ruby中有一个关键字是unless，它的功能是如果false则执行第一个分支，否则执行第二个分支，相当于if !cond</p><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><p>上面也提到了只是包装，那么可能多种不同形式的语法糖都是针对同一种功能，像C语言中的while和for本质都是一个loop（Rust的for并不是，后面会提到这种for的desugar过程）</p><p>desugar的过程是将这些都转换为了更本质的东西，我觉得这属于一种“去重”的过程。还是上面的例子，假设需要对loop做优化，没有desugar的情况下我们需要对while和for两者都进行处理，两者又有轻微的差别，导致实现起来更不方便，每个优化都需要对这些细节做处理，那不如直接全部转换成一种形式来处理处理</p><p>关于Rust的文档中的介绍是这样</p><blockquote><p>This means many structures are removed if they are irrelevant for type analysis or similar syntax agnostic analyses.</p></blockquote><h1 id="Rust的实现"><a href="#Rust的实现" class="headerlink" title="Rust的实现"></a>Rust的实现</h1><p>官方的文档介绍</p><p><a class="link"   href="https://rustc-dev-guide.rust-lang.org/lowering.html" >https://rustc-dev-guide.rust-lang.org/lowering.html<i class="fas fa-external-link-alt"></i></a></p><p>在这里我要给Rust一个好评，开发文档比较详细，而且一些注释也相对容易懂一些。后面的很多东西都会以注释为参考讲了大概做了什么，注意这里<strong>我们的目的并不是搞清楚细节，而是搞清楚都做了什么操作，所以细节部分点到为止</strong>，细节深究下去是无底洞，有兴趣可以去源码处深入看一下</p><p>desugar相关代码不特别说明根目录都是rustc_ast_lowering</p><h2 id="读代码之前需要了解的"><a href="#读代码之前需要了解的" class="headerlink" title="读代码之前需要了解的"></a>读代码之前需要了解的</h2><p>了解了这些能够更容易看明白代码</p><ol><li>各种参数更多是使用ir来标识以及获取的</li><li>span用于记录源码相关信息</li><li>arean.alloc是用于分配构建ir的，看实现的时候不需要在意这里的细节，只需要看传进去的IR</li></ol><h2 id="DesugaringKind"><a href="#DesugaringKind" class="headerlink" title="DesugaringKind"></a>DesugaringKind</h2><p>这个类型在rustc_span/src/hygine.rs中</p><p>实际使用的时候主要用于创建span的时候填入相关信息，因此并没有放到ast_lowering的位置</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DesugaringKind</span></span> &#123;</span><br><span class="line">    <span class="comment">/// We desugar `if c &#123; i &#125; else &#123; e &#125;` to `match $ExprKind::Use(c) &#123; true =&gt; i, _ =&gt; e &#125;`.</span></span><br><span class="line">    <span class="comment">/// However, we do not want to blame `c` for unreachability but rather say that `i`</span></span><br><span class="line">    <span class="comment">/// is unreachable. This desugaring kind allows us to avoid blaming `c`.</span></span><br><span class="line">    <span class="comment">/// This also applies to `while` loops.</span></span><br><span class="line">    CondTemporary,</span><br><span class="line">    QuestionMark,</span><br><span class="line">    TryBlock,</span><br><span class="line">    <span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line">    <span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line">    <span class="comment">/// `impl Trait` with `Foo`.</span></span><br><span class="line">    OpaqueTy,</span><br><span class="line">    Async,</span><br><span class="line">    Await,</span><br><span class="line">    ForLoop,</span><br><span class="line">    LetElse,</span><br><span class="line">    WhileLoop,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不考虑Async和Await，我们来一个个说其他的</p><h2 id="CondTemporary"><a href="#CondTemporary" class="headerlink" title="CondTemporary"></a>CondTemporary</h2><p>这部分都在src/expr.rs中</p><p>我们先来看一下它的调用位置，发现是在manage_let_cond这个函数中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`</span></span><br><span class="line"><span class="comment">// in a temporary block.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">manage_let_cond</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cond: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_let_expr</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt;(expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> expr.kind &#123;</span><br><span class="line">            hir::ExprKind::Binary(_, lhs, rhs) =&gt; has_let_expr(lhs) || has_let_expr(rhs),</span><br><span class="line">            hir::ExprKind::Let(..) =&gt; <span class="literal">true</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> has_let_expr(cond) &#123;</span><br><span class="line">        cond</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reason = DesugaringKind::CondTemporary;</span><br><span class="line">        <span class="keyword">let</span> span_block = <span class="keyword">self</span>.mark_span_with_reason(reason, cond.span, <span class="literal">None</span>);</span><br><span class="line">        <span class="keyword">self</span>.expr_drop_temps(span_block, cond, AttrVec::new())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换条件"><a href="#转换条件" class="headerlink" title="转换条件"></a>转换条件</h3><p>根据函数名和参数我们可以得知这个是处理cond不为let的情况下，既然是cond那么应当会出现在while和if中</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实际查看manage_let_cond的usage也正是如此。这两处的处理都是类似的，因此我选取一段来介绍</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.lower_expr(cond);</span><br><span class="line"><span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br></pre></td></tr></table></figure><p>可以看到十分简单，就是先对cond本身lower，然后再对整个cond lower</p><p>然后我们再回到manage_let_cond的实现中</p><p>根据实现可以看到对expr递归判断，如果包含let则直接返回原始cond，否则进行转换</p><p>span_block是用于记录信息的，关键在expr_drop_temps中</p><h3 id="本质行为"><a href="#本质行为" class="headerlink" title="本质行为"></a>本质行为</h3><p>进入实现可以看到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In terms of drop order, it has the same effect as wrapping `expr` in</span></span><br><span class="line"><span class="comment">/// `&#123; let _t = $expr; _t &#125;` but should provide better compile-time performance.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The drop order can be important in e.g. `if expr &#123; .. &#125;`.</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_drop_temps_mut(span, expr, attrs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps_mut</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.expr(span, hir::ExprKind::DropTemps(expr), attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际做的事情就是转换为了DropTemps这种类型的Expr</p><h2 id="QuestionMark"><a href="#QuestionMark" class="headerlink" title="QuestionMark"></a>QuestionMark</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>QuestionMark是Result为Err或者Option为None的时候直接抛出错误的一种语法糖，摘选一段官方的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">try_to_parse</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="string">&quot;123&quot;</span>.parse()?; <span class="comment">// x = 123</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">i32</span> = <span class="string">&quot;24a&quot;</span>.parse()?; <span class="comment">// returns an Err() immediately</span></span><br><span class="line">    <span class="literal">Ok</span>(x + y)                    <span class="comment">// Doesn&#x27;t run.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = try_to_parse();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, res);</span><br><span class="line"><span class="built_in">assert!</span>(res.is_err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看QuestionMark的usage，找到了lower_expr_try这个函数</p><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>先来看注释，这里的注释可以说是非常清楚了，将一个QuestionMark转换为了一个模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprKind::Try` from: `&lt;expr&gt;?` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// match Try::branch(&lt;expr&gt;) &#123;</span></span><br><span class="line"><span class="comment">///     ControlFlow::Continue(val) =&gt; #[allow(unreachable_code)] val,,</span></span><br><span class="line"><span class="comment">///     ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">///         #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">///         // If there is an enclosing `try &#123;...&#125;`:</span></span><br><span class="line"><span class="comment">///         break &#x27;catch_target Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">///         // Otherwise:</span></span><br><span class="line"><span class="comment">///         return Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, span: Span, sub_expr: &amp;Expr) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt;</span><br></pre></td></tr></table></figure><p>既然是返回了一个match，那么我们先看一下Expr::Match的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A `match` block, with a source that indicates whether or not it is</span></span><br><span class="line"><span class="comment">/// the result of a desugaring, and if so, which kind.</span></span><br><span class="line">Match(&amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;, &amp;<span class="symbol">&#x27;hir</span> [Arm&lt;<span class="symbol">&#x27;hir</span>&gt;], MatchSource)</span><br></pre></td></tr></table></figure><p>根据注释的内容看上去分为三个部分</p><ol><li>Try::branch(<expr>)</li></ol><p>非常直接的操作，直接lower传进来的sub_expr</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Try::branch(&lt;expr&gt;)`</span></span><br><span class="line"><span class="keyword">let</span> scrutinee = &#123;</span><br><span class="line">    <span class="comment">// expand &lt;expr&gt;</span></span><br><span class="line">    <span class="keyword">let</span> sub_expr = <span class="keyword">self</span>.lower_expr_mut(sub_expr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.expr_call_lang_item_fn(</span><br><span class="line">        unstable_span,</span><br><span class="line">        hir::LangItem::TryTraitBranch,</span><br><span class="line">        arena_vec![<span class="keyword">self</span>; sub_expr],</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>ControlFlow::Continue(val)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的arm是构建了hir的Match的Arm参数</p><ol><li>ControlFlow::Break(residual)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和上面差不多，细节都在省略的部分</p><p>在实际的处理中在最前面的有一部分像上面的CondTemporary一样，先创建一个span用于记录源码相关的信息，源码不再赘述</p><p>还会创建一个*<code>#[allow(unreachable_code)]</code>* 供后面的match使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = &#123;</span><br><span class="line">    <span class="comment">// `allow(unreachable_code)`</span></span><br><span class="line">    <span class="keyword">let</span> allow = &#123;</span><br><span class="line">        <span class="keyword">let</span> allow_ident = Ident::new(sym::allow, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_ident = Ident::new(sym::unreachable_code, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_nested = attr::mk_nested_word_item(uc_ident);</span><br><span class="line">        attr::mk_list_item(allow_ident, <span class="built_in">vec!</span>[uc_nested])</span><br><span class="line">    &#125;;</span><br><span class="line">    attr::mk_attr_outer(allow)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> attrs = <span class="built_in">vec!</span>[attr];</span><br></pre></td></tr></table></figure><h2 id="TryBlock"><a href="#TryBlock" class="headerlink" title="TryBlock"></a>TryBlock</h2><p>在lower_expr_try_block中被用到</p><h3 id="做了什么-1"><a href="#做了什么-1" class="headerlink" title="做了什么"></a>做了什么</h3><p>这里的注释解释的比较清楚了，我就不再赘述</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `try &#123; &lt;stmts&gt;; &lt;expr&gt; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(&lt;expr&gt;) &#125;`,</span></span><br><span class="line"><span class="comment">/// `try &#123; &lt;stmts&gt;; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(()) &#125;`</span></span><br><span class="line"><span class="comment">/// and save the block id to use it as a break target for desugaring of the `?` operator.</span></span><br></pre></td></tr></table></figure><p>最终都是转换为一个包含stmts和::std::ops::Try::from_output的block</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们从返回值往上看，可以看到返回了一个Block，Block的第二个参数是Label，这里并不需要因此设置为了None</p><p>那么我们顺着第一个参数block往上看来源，又回到了函数的开始</p><p>和注释所讲的一样，根据是否有一个expr来做两种不同的处理方式，也是比较直观的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, body: &amp;Block) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.with_catch_scope(body.id, |this| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> block = this.lower_block_noalloc(body, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Final expression of the block (if present) or `()` with span at the end of block</span></span><br><span class="line">        <span class="keyword">let</span> (try_span, tail_expr) = <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(expr) = block.expr.take() &#123;</span><br><span class="line">            (</span><br><span class="line">                this.mark_span_with_reason(</span><br><span class="line">                    DesugaringKind::TryBlock,</span><br><span class="line">                    expr.span,</span><br><span class="line">                    this.allow_try_trait.clone(),</span><br><span class="line">                ),</span><br><span class="line">                expr,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> try_span = this.mark_span_with_reason(</span><br><span class="line">                DesugaringKind::TryBlock,</span><br><span class="line">                this.sess.source_map().end_point(body.span),</span><br><span class="line">                this.allow_try_trait.clone(),</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            (try_span, this.expr_unit(try_span))</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ok_wrapped_span =</span><br><span class="line">            this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `::std::ops::Try::from_output($tail_expr)`</span></span><br><span class="line">        block.expr = <span class="literal">Some</span>(this.wrap_in_try_constructor(</span><br><span class="line">            hir::LangItem::TryTraitFromOutput,</span><br><span class="line">            try_span,</span><br><span class="line">            tail_expr,</span><br><span class="line">            ok_wrapped_span,</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        hir::ExprKind::Block(this.arena.alloc(block), <span class="literal">None</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpaqueTy"><a href="#OpaqueTy" class="headerlink" title="OpaqueTy"></a>OpaqueTy</h2><h3 id="OpaqueTy是什么"><a href="#OpaqueTy是什么" class="headerlink" title="OpaqueTy是什么"></a>OpaqueTy是什么</h3><p>OpaqueTy是impl Trait的一种别名，看一下这个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Foo</span></span> = <span class="keyword">impl</span> Bar;</span><br></pre></td></tr></table></figure><p>实际参数使用Foo的时候只能使用Bar中的接口，不论实现了Bar的类型是否实现了其他类型</p><h3 id="lower做了什么"><a href="#lower做了什么" class="headerlink" title="lower做了什么"></a>lower做了什么</h3><p>关于这个lower的操作，在DesugaringKind::OpaqueTy的位置写的非常清楚了，只是做了简单的类型替换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line"><span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line"><span class="comment">/// `impl Trait` with `Foo`.</span></span><br></pre></td></tr></table></figure><h3 id="lower操作"><a href="#lower操作" class="headerlink" title="lower操作"></a>lower操作</h3><p>lower操作在lower_opaque_impl_trait这个函数中(src/lib.rs)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_opaque_impl_trait</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        span: Span,</span><br><span class="line">        fn_def_id: <span class="built_in">Option</span>&lt;LocalDefId&gt;,</span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">        opaque_ty_node_id: NodeId,</span><br><span class="line">        capturable_lifetimes: <span class="built_in">Option</span>&lt;&amp;FxHashSet&lt;hir::LifetimeName&gt;&gt;,</span><br><span class="line">        lower_bounds: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>) -&gt; hir::GenericBounds&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    ) -&gt; hir::TyKind&lt;<span class="symbol">&#x27;hir</span>&gt; </span><br></pre></td></tr></table></figure><p>来看一下返回值的部分，可以看到主要处理分为两部分，一部分是处理ID相关的，另一部分是处理lifetime</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `impl Trait` now just becomes `Foo&lt;&#x27;a, &#x27;b, ..&gt;`.</span></span><br><span class="line">    hir::TyKind::OpaqueDef(hir::ItemId &#123; def_id: opaque_ty_def_id &#125;, lifetimes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也就不展开了，上面的细节很多是关于type相关的，这部分我不了解，内容也比较长。</p><p>lower_opaque_impl_trait这个函数则是被在上面的lower_ty_direct()调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TyKind::ImplTrait(def_node_id, <span class="keyword">ref</span> bounds) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> span = t.span;</span><br><span class="line">  <span class="keyword">match</span> itctx &#123;</span><br><span class="line">      ImplTraitContext::ReturnPositionOpaqueTy &#123; fn_def_id, origin &#125; =&gt; <span class="keyword">self</span></span><br><span class="line">          .lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">Some</span>(fn_def_id),</span><br><span class="line">              origin,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              |this| this.lower_param_bounds(bounds, itctx),</span><br><span class="line">          ),</span><br><span class="line">      ImplTraitContext::TypeAliasesOpaqueTy &#123; <span class="keyword">ref</span> capturable_lifetimes &#125; =&gt; &#123;</span><br><span class="line">          <span class="comment">// Reset capturable lifetimes, any nested impl trait</span></span><br><span class="line">          <span class="comment">// types will inherit lifetimes from this opaque type,</span></span><br><span class="line">          <span class="comment">// so don&#x27;t need to capture them again.</span></span><br><span class="line">          <span class="keyword">let</span> nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy &#123;</span><br><span class="line">              capturable_lifetimes: &amp;<span class="keyword">mut</span> FxHashSet::default(),</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">self</span>.lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              hir::OpaqueTyOrigin::TyAlias,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">Some</span>(capturable_lifetimes),</span><br><span class="line">              |this| this.lower_param_bounds(bounds, nested_itctx),</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这里的TypeKind为ImplTrait且ImplTraitContext为TypeAliasesOpaqueTy或者ReturnPositionOpaqueTy的时候才会做这个desugar操作</p><ul><li><input disabled="" type="checkbox"> 这里我其实不是很明白。。</li></ul><h3 id="ImpltraitContext"><a href="#ImpltraitContext" class="headerlink" title="ImpltraitContext"></a>ImpltraitContext</h3><p>来看一下ImpltraitContext，根据Disallowed注释大意和成员可以得知这个类主要关联了一个位置是否可以使用impl trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,</span></span><br><span class="line"><span class="comment">/// and if so, what meaning it has.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImplTraitContext</span></span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new universal generic parameter.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a fresh universal parameter like `fn foo&lt;T: Debug&gt;(x: T)`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Newly generated parameters should be inserted into the given `Vec`.</span></span><br><span class="line">    Universal(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;hir::GenericParam&lt;<span class="symbol">&#x27;a</span>&gt;&gt;, LocalDefId),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new opaque type.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo() -&gt; impl Debug`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a new opaque type like `type T = impl Debug; fn foo() -&gt; T`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    ReturnPositionOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// `DefId` for the parent function, used to look up necessary</span></span><br><span class="line">        <span class="comment">/// information later.</span></span><br><span class="line">        fn_def_id: LocalDefId,</span><br><span class="line">        <span class="comment">/// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,</span></span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// Impl trait in type aliases.</span></span><br><span class="line">    TypeAliasesOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// Set of lifetimes that this opaque type can capture, if it uses</span></span><br><span class="line">        <span class="comment">/// them. This includes lifetimes bound since we entered this context.</span></span><br><span class="line">        <span class="comment">/// For example:</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">/// type A&lt;&#x27;b&gt; = impl for&lt;&#x27;a&gt; Trait&lt;&#x27;a, Out = impl Sized + &#x27;a&gt;;</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// Here the inner opaque type captures `&#x27;a` because it uses it. It doesn&#x27;t</span></span><br><span class="line">        <span class="comment">/// need to capture `&#x27;b` because it already inherits the lifetime</span></span><br><span class="line">        <span class="comment">/// parameter from `A`.</span></span><br><span class="line">        <span class="comment">// FIXME(impl_trait): but `required_region_bounds` will ICE later</span></span><br><span class="line">        <span class="comment">// anyway.</span></span><br><span class="line">        capturable_lifetimes: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> FxHashSet&lt;hir::LifetimeName&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// `impl Trait` is not accepted in this position.</span></span><br><span class="line">    Disallowed(ImplTraitPosition),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在上面只有ReturnPositionOpaqueTy和TypeAliasesOpaqueTy的情况下可以使用，当然从名字就可以看出来这两种情况就是为了OpaqueTy而设计的</p><h2 id="ForLoop"><a href="#ForLoop" class="headerlink" title="ForLoop"></a>ForLoop</h2><p>调用处的函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_for</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        e: &amp;Expr,</span><br><span class="line">        pat: &amp;Pat,</span><br><span class="line">        head: &amp;Expr,</span><br><span class="line">        body: &amp;Block,</span><br><span class="line">        opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">    ) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>注释写的非常详细了，将一个ForLoop转换为一个iterator操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprForLoop` from: `[opt_ident]: for &lt;pat&gt; in &lt;head&gt; &lt;body&gt;` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">///     let result = match IntoIterator::into_iter(&lt;head&gt;) &#123;</span></span><br><span class="line"><span class="comment">///         mut iter =&gt; &#123;</span></span><br><span class="line"><span class="comment">///             [opt_ident]: loop &#123;</span></span><br><span class="line"><span class="comment">///                 match Iterator::next(&amp;mut iter) &#123;</span></span><br><span class="line"><span class="comment">///                     None =&gt; break,</span></span><br><span class="line"><span class="comment">///                     Some(&lt;pat&gt;) =&gt; &lt;body&gt;,</span></span><br><span class="line"><span class="comment">///                 &#125;;</span></span><br><span class="line"><span class="comment">///             &#125;</span></span><br><span class="line"><span class="comment">///         &#125;</span></span><br><span class="line"><span class="comment">///     &#125;;</span></span><br><span class="line"><span class="comment">///     result</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><p>实现比较长就不贴了，想要了解更详细的可以去源码处查看</p><h2 id="LetElse"><a href="#LetElse" class="headerlink" title="LetElse"></a>LetElse</h2><h3 id="什么情况会转换"><a href="#什么情况会转换" class="headerlink" title="什么情况会转换"></a>什么情况会转换</h3><p>在lower_let_else中被调用，而这个lower_let_else则是在lower_stmts中</p><p>这是lower_stmts中的处理代码，可以看到是InitElse的情况下会进行处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> expr = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> [s, tail @ ..] = ast_stmts &#123;</span><br><span class="line">            <span class="keyword">match</span> s.kind &#123;</span><br><span class="line">                StmtKind::Local(<span class="keyword">ref</span> local) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> hir_id = <span class="keyword">self</span>.lower_node_id(s.id);</span><br><span class="line">                    <span class="keyword">match</span> &amp;local.kind &#123;</span><br><span class="line">                        LocalKind::InitElse(init, els) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">let</span> e = <span class="keyword">self</span>.lower_let_else(hir_id, local, init, els, tail);</span><br><span class="line">                            expr = <span class="literal">Some</span>(e);</span><br><span class="line"><span class="comment">// remaining statements are in let-else expression</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注意这里的break</p><p>来看一下InitElse</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">LocalKind</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// Local declaration with an initializer and an `else` clause.</span></span><br><span class="line"><span class="comment">/// Example: `let Some(x) = y else &#123; return &#125;;`</span></span><br><span class="line">InitElse(P&lt;Expr&gt;, P&lt;Block&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>一开始看到函数签名中的tail产生了一些疑惑，不知道用途是什么。一开始想到的是会往里添加东西，但是一看类型是immutable的（传进来的是一个array的slice），后面看到调用处的break才明白过来，具体用途后面会讲到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> ty = local</span><br><span class="line">      .ty</span><br><span class="line">      .as_ref()</span><br><span class="line">      .map(|t| <span class="keyword">self</span>.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(local.span);</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.mark_span_with_reason(DesugaringKind::LetElse, span, <span class="literal">None</span>);</span><br><span class="line">  <span class="keyword">let</span> init = <span class="keyword">self</span>.lower_expr(init);</span><br><span class="line">  <span class="keyword">let</span> local_hir_id = <span class="keyword">self</span>.lower_node_id(local.id);</span><br><span class="line">  <span class="keyword">self</span>.lower_attrs(local_hir_id, &amp;local.attrs);</span><br><span class="line">  <span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">          hir_id: local_hir_id,</span><br><span class="line">          pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">          ty,</span><br><span class="line">          init,</span><br><span class="line">          span,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(let_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(else_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.arena.alloc(hir::Expr &#123;</span><br><span class="line">      hir_id: stmt_hir_id,</span><br><span class="line">      span,</span><br><span class="line">      kind: hir::ExprKind::If(let_expr, then_expr, <span class="literal">Some</span>(else_expr)),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> !<span class="keyword">self</span>.sess.features_untracked().let_else &#123;</span><br><span class="line">      feature_err(</span><br><span class="line">          &amp;<span class="keyword">self</span>.sess.parse_sess,</span><br><span class="line">          sym::let_else,</span><br><span class="line">          local.span,</span><br><span class="line">          <span class="string">&quot;`let...else` statements are unstable&quot;</span>,</span><br><span class="line">      )</span><br><span class="line">      .emit();</span><br><span class="line">  &#125;</span><br><span class="line">  if_expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从返回值向上看，可以看到if_expr的参数是let_expr, then_expr, else_expr</p><ol><li>let_expr的部分转成了HIR的let</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">        hir_id: local_hir_id,</span><br><span class="line">        pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">        ty,</span><br><span class="line">        init,</span><br><span class="line">        span,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看一下定义和注释</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Represents a `let &lt;pat&gt;[: &lt;ty&gt;] = &lt;expr&gt;` expression (not a Local), occurring in an `if-let` or</span></span><br><span class="line"><span class="comment">/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In an if-let, imagine it as `if (let &lt;pat&gt; = &lt;expr&gt;) &#123; ... &#125;`; in a let-else, it is part of the</span></span><br><span class="line"><span class="comment">/// desugaring to if-let. Only let-else supports the type annotation at present.</span></span><br><span class="line"><span class="meta">#[derive(Debug, HashStable_Generic)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Let</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> hir_id: HirId,</span><br><span class="line">    <span class="keyword">pub</span> span: Span,</span><br><span class="line">    <span class="keyword">pub</span> pat: &amp;<span class="symbol">&#x27;hir</span> Pat&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> ty: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;hir</span> Ty&lt;<span class="symbol">&#x27;hir</span>&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> init: &amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExprKind</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// A `let $pat = $expr` expression.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// These are not `Local` and only occur as expressions.</span></span><br><span class="line">  <span class="comment">/// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.</span></span><br><span class="line">  Let(&amp;<span class="symbol">&#x27;hir</span> Let&lt;<span class="symbol">&#x27;hir</span>&gt;),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>then_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里解答了我对传进来的tail的疑惑。这里的意思是then的话那么会继续lower tail的部分，将这部分插入到then的block中</p><ol><li>else_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里将传进来的els（InitElse的else block）lower到了一个block</p><h3 id="实际做了什么转换"><a href="#实际做了什么转换" class="headerlink" title="实际做了什么转换"></a>实际做了什么转换</h3><p>单个看起来可能不够直观，将三个部分组合起来的话这个逻辑就是</p><p>cond中创建了一个expr bind</p><p>true：将后面的stmts lower到一个新的block中（因此外面需要break）</p><p>false：将els的部分lower到block</p><h3 id="false为什么不lower-tail"><a href="#false为什么不lower-tail" class="headerlink" title="false为什么不lower tail"></a>false为什么不lower tail</h3><p>像我一样不了解这里语法的情况会觉得false的行为很奇怪，false就不走tail了吗</p><p>于是我就写了这样的一个用例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(let_else)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y:<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接报了编译错误，else中的内容是要强制从当前函数返回才行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: `<span class="keyword">else</span>` clause of `<span class="keyword">let</span>...<span class="keyword">else</span>` does not diverge</span><br><span class="line"> --&gt; src/main.rs:<span class="number">4</span>:<span class="number">26</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |       <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">  |  __________________________^</span><br><span class="line"><span class="number">5</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">  | |__________________________^ expected `!`, found `()`</span><br><span class="line">  |</span><br><span class="line">  = note: expected <span class="class"><span class="keyword">type</span> `!`</span></span><br><span class="line"><span class="class">             <span class="title">found</span></span> <span class="class"><span class="keyword">type</span> `()`</span></span><br><span class="line"><span class="class">  = <span class="title">help</span></span>: <span class="keyword">try</span> adding a diverging expression, such <span class="keyword">as</span> `<span class="keyword">return</span>` or `<span class="built_in">panic!</span>(..)`</span><br><span class="line">  = help: ...or <span class="keyword">use</span> `<span class="keyword">match</span>` instead of `<span class="keyword">let</span>...<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `playground` due to previous error</span><br></pre></td></tr></table></figure><h2 id="WhileLoop"><a href="#WhileLoop" class="headerlink" title="WhileLoop"></a>WhileLoop</h2><p>在lower_expr_mut中被调用，在外部创建span信息然后在lower_expr_while_in_loop_scope中实际进行lower</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ExprKind::While(<span class="keyword">ref</span> cond, <span class="keyword">ref</span> body, opt_label) =&gt; &#123;</span><br><span class="line">      <span class="keyword">self</span>.with_loop_scope(e.id, |this| &#123;</span><br><span class="line">          <span class="keyword">let</span> span =</span><br><span class="line">              this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, <span class="literal">None</span>);</span><br><span class="line">          this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="做了什么-2"><a href="#做了什么-2" class="headerlink" title="做了什么"></a>做了什么</h3><p>注释也非常易懂，将一个while转换为一个loop加一个，cond作为一个if，cond为false则break</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We desugar: `&#x27;label: while $cond $body` into:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">// &#x27;label: loop &#123;</span></span><br><span class="line"><span class="comment">//   if &#123; let _t = $cond; _t &#125; &#123;</span></span><br><span class="line"><span class="comment">//     $body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   else &#123;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wrap in a construct equivalent to `&#123; let _t = $cond; _t &#125;`</span></span><br><span class="line"><span class="comment">// to preserve drop semantics since `while $cond &#123; ... &#125;` does not</span></span><br><span class="line"><span class="comment">// let temporaries live outside of `cond`.</span></span><br></pre></td></tr></table></figure><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>实际的实现代码也是非常直接，没什么可讲的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_while_in_loop_scope</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    cond: &amp;Expr,</span><br><span class="line">    body: &amp;Block,</span><br><span class="line">    opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.with_loop_condition_scope(|t| t.lower_expr(cond));</span><br><span class="line">    <span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br><span class="line">    <span class="keyword">let</span> then = <span class="keyword">self</span>.lower_block_expr(body);</span><br><span class="line">    <span class="keyword">let</span> expr_break = <span class="keyword">self</span>.expr_break(span, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> stmt_break = <span class="keyword">self</span>.stmt_expr(span, expr_break);</span><br><span class="line">    <span class="keyword">let</span> else_blk = <span class="keyword">self</span>.block_all(span, arena_vec![<span class="keyword">self</span>; stmt_break], <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> else_expr = <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(else_blk, ThinVec::new()));</span><br><span class="line">    <span class="keyword">let</span> if_kind = hir::ExprKind::If(new_cond, <span class="keyword">self</span>.arena.alloc(then), <span class="literal">Some</span>(else_expr));</span><br><span class="line">    <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.expr(span, if_kind, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_expr(<span class="keyword">self</span>.arena.alloc(if_expr));</span><br><span class="line">    <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(span.with_hi(cond.span.hi()));</span><br><span class="line">    <span class="keyword">let</span> opt_label = <span class="keyword">self</span>.lower_label(opt_label);</span><br><span class="line">    hir::ExprKind::Loop(block, opt_label, hir::LoopSource::While, span)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来以为desugar的东西比较少就想都写完，但是越写发现越多，这还忽略了很多细节上的东西，导致了文章比较长</p><p>在读代码的时候一开始我是没看到DesugaringKind这个类型的，想着既然要lower，那么首先将ast和hir的定义进行比较。由于内容比较多，只选了熟悉的Expr和Stmt进行对比。查看实际有哪些成员发生了变化，之后再去找到实现的位置。查看实现的过程中偶然看到DesugaringKind，之后看的过程就顺畅了许多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-15</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="源码阅读" scheme="https://fusionbolt.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="Desugar" scheme="https://fusionbolt.github.io/tags/Desugar/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记14 重构与AST Visitor</title>
    <link href="https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/"/>
    <id>https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/</id>
    <published>2022-04-10T03:22:23.000Z</published>
    <updated>2022-04-10T03:49:21.753Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-14/noire.jpg"                      alt="noire"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">非pixiv作品</center> <p>本周先是解决了上周遗留下来的一个非常头疼的问题，之后重构了Token和AST的定义以及考虑了一下Visitor。之后也编写了建立符号表的代码以及一半转换到vm指令的代码，但是总觉得哪里不太对劲就先停了下来，后续确认无误了再一起拿出来讲。还学习了一些rust的实现方式，关于IR方面有更多了解以后有意向再单独出一篇文章讲解自己的一些了解</p><h1 id="PackratReader"><a href="#PackratReader" class="headerlink" title="PackratReader"></a>PackratReader</h1><p>上周为了解决左递归的语法使用了PackratParser，但是这会引入一个问题，PackratParser会使用PackratReader管理输入，而PackratReader并没有重载toString，因此在<strong>log的时候</strong>都是类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trying class member at scala.util.parsing.combinator.PackratParsers$$anon$1@4d3167f4</span><br></pre></td></tr></table></figure><p>我的解决思路如下</p><p>首先尝试继承并且实现一个自己的PackratReader，因为之前TokenReader就是继承并实现了Reader。但是发现经过了PackratParser的处理后又会变成系统自带的reader</p><p>查看源码发现有这么一段内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rest</span></span>: <span class="type">Reader</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">PackratReader</span>(underlying.rest) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> cache = outer.cache</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> recursionHeads = outer.recursionHeads</span><br><span class="line">  lrStack = outer.lrStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次获取rest的时候都会重新构造一个PackratReader，因此继承这条路行不通。之后我的思路一直在想着如何hack这个类的toString（用ruby的话我一定会这么做的，对于ruby来说这种做法是理所应当的），但是对于Scala来说并没有那么过分的元编程能力（至少我没有搜寻到相关解决方案）。</p><p>反复尝试无果后，只好继续硬调代码了。调试的过程中偶然想到我可以重载log这个函数，前面的思路都是我需要它的字符串，但是我实际的需求是能够log输出正确的信息</p><p>这是我重载以后的行为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>[<span class="type">T</span>](p: <span class="type">Reader</span>[<span class="type">T</span>], n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; !p.atEnd) then p.first::take(p.rest, n - <span class="number">1</span>) <span class="keyword">else</span> <span class="type">Nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reader: <span class="type">PackratReader</span>[<span class="type">Token</span>] =&gt;</span><br><span class="line">      println(<span class="string">s&quot;trying <span class="subst">$&#123;name&#125;</span> at (<span class="subst">$&#123;take(reader, 3).mkString(&quot;, &quot;)&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      println(<span class="string">&quot;trying &quot;</span> + name + <span class="string">&quot; at &quot;</span> + in)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是原本的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  println(<span class="string">&quot;trying &quot;</span>+ name +<span class="string">&quot; at &quot;</span>+ in)</span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>之前的博客也提到过Token的定义不太好，之前思路过于死板，只想着用enum来解决，但是这里可以更灵活的将trait和enum组合起来，可以通过类型更好的区分不同的Token，AST也是如此。以下这是新的定义的部分代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Token</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Literal</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Delimiter</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Ident</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">UPPER_IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Keyword</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="comment">// local</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br></pre></td></tr></table></figure><p>据我所了解rust的trait是不能携带变量的，在这方面上Scala好用的多，不需要再在每个Token里面保存一个position信息</p><p>举一个这样写法实际比较有帮助的例子，比如说我现在Lexer结束获得了一个List[Token]，想要将其中Keyword的部分全部提取出来并且将这些信息传给编辑器插件高亮处理，那么我不需要再费力的去写一个麻烦的逻辑判断是否是Keyword的方法，而是直接匹配类型。再写其他逻辑不仅是麻烦的问题，实际也容易出错，比如说漏掉什么或者多写了什么，而这些东西直接写到类型定义中大大减少了问题的产生</p><p>我没有写过插件，不知道实际是否是需要这样，但是这种想法和思路都是一样的</p><p>实际处理代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokens.filter &#123;</span><br><span class="line">  <span class="keyword">case</span> k: <span class="type">Keyword</span> =&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>大体思路都在Token部分讲的差不多了，这里贴一下部分关键的AST定义就好了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTNode</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">BinaryOp</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Constant</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Ident</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Ident</span>, value: ast.<span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><p>之前写的str与Id的隐式转换函数放到了一个object中，需要的时候直接import这个object中的一个函数或者全部函数，将隐式转换函数都放在一个位置进行管理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitConversions</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToId</span></span>(str: <span class="type">String</span>): <span class="type">Ident</span> = <span class="type">Ident</span>(str)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">IdToStr</span></span>(id: <span class="type">Ident</span>): <span class="type">String</span> = id.str</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">boolToAST</span></span>(b: <span class="type">Boolean</span>): <span class="type">Expr</span>.<span class="type">Bool</span> = <span class="type">Expr</span>.<span class="type">Bool</span>(b)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToAST</span></span>(i: <span class="type">Int</span>): <span class="type">Expr</span>.<span class="type">Number</span> = <span class="type">Expr</span>.<span class="type">Number</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的时候</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast.<span class="type">ImplicitConversions</span>.*</span><br></pre></td></tr></table></figure><h1 id="AST-Visitor"><a href="#AST-Visitor" class="headerlink" title="AST Visitor"></a>AST Visitor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>虽然在公司做的ai compiler的项目里也有visitor，但那终究只是对特殊形式对expr处理的，也可以说是针对一种DSL的，并不能直接套用。之前用ruby写的版本存在很多问题，同时也使用了动态语言才能写出来的方式。</p><p>编写遍历的时候关键在于遍历函数的签名。除了结点本身之外应当传递什么参数？返回值又是怎样的？</p><p>我的思路是先想一下之后的使用场景是怎么样的。能想到的场景大致有这么几种</p><ol><li>ast check</li><li>type infer</li><li>lower</li><li>其他pass</li></ol><p>ast check这个显然是要遍历所有结点</p><p>type infer没有做过，对于实际要怎么做我还没有一个思路</p><p>lower在很多编译器也是作为一种pass存在，而我目前暂时想先作为一个单独的流程存在。</p><p>其他pass只是参与过公司项目，但是传统compiler还没有做过。关于这个我还存有许多问题，比如说都会用到什么样的访问方式？我目前想到的方面是针对表达式或者说某个特定类型的结点进行处理，那么应用的时候是需要做</p><p>最后结论还是去学习一下前人的做法，尝试查看Scala和rust的实现，Scala实现方式过于复杂，因此最终参考的是rust的实现（但Scala但是实现我还是挺感兴趣但，可能会再花一些时间研究一下）</p><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><p>rust中写了一个visitor的trait，其中包含了各种ast中出现的内容：crate，stmt，ident等都有。其中每一个visit_xxx的默认实现都是调用了walk_xxx，而walk是访问当前这个节点的所有成员，因此默认实现的整个逻辑是：先进入visit，visit调用到了walk，walk对每一个节点进行visit，而每个节点的visit又是调用了walk</p><p>从上面提及的函数签名的角度来看，传递了一个所需的ast结点，无返回值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub <span class="class"><span class="keyword">trait</span> <span class="title">Visitor&lt;</span>&#x27;<span class="title">ast&gt;</span></span>: <span class="type">Sized</span> &#123;</span><br><span class="line">...</span><br><span class="line">fn visit_crate(&amp;mut self, krate: &amp;<span class="symbol">&#x27;ast</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_crate(self, krate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn walk_crate&lt;<span class="symbol">&#x27;a</span>, <span class="type">V</span>: <span class="type">Visitor</span>&lt;<span class="symbol">&#x27;a</span>&gt;&gt;(visitor: &amp;mut <span class="type">V</span>, krate: &amp;<span class="symbol">&#x27;a</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_list!(visitor, visit_item, &amp;krate.items);</span><br><span class="line">    walk_list!(visitor, visit_attribute, &amp;krate.attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个小问题我即便在写到这里的时候我还是没能理解，为什么要传一个visitor进来，直接作为trait的成员不就好了吗？rust的高层IR有好几层，起初我以为是为了给其他的ir使用（思考完这个问题我才意识到这是一个不良设计，每一层的东西应当隔离开来），但经过查看每一层但IR都是完全单独的visitor和walk，偶尔使用walk也是在impl ast visitor的时候</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>选取片段</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTVisitor</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">R</span> </span>= <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(modules: <span class="type">Modules</span>): <span class="type">R</span> = visitRecursive(modules)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(module: <span class="type">RcModule</span>): <span class="type">R</span> = visitRecursive(module)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = visitRecursive(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(expr: <span class="type">Expr</span>): <span class="type">R</span> = visitRecursive(expr)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">visitRecursive</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = &#123;</span><br><span class="line">    item <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> method: <span class="type">Item</span>.<span class="type">Method</span> =&gt; visit(method)</span><br><span class="line">      <span class="keyword">case</span> klass: <span class="type">Item</span>.<span class="type">Class</span> =&gt; visit(klass)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;NoneItem&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于返回值的地方我也纠结了一下，虽然留有了一个R的类型，但是没想好之后怎么用。因此就先这样实现吧，之后根据需求再改。在不了解的情况下不应当想着一口气写出合适的实现，而是先从能用开始，再不断修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-14</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="AST" scheme="https://fusionbolt.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记13 另一些Parser</title>
    <link href="https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/"/>
    <id>https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/</id>
    <published>2022-04-04T02:21:54.000Z</published>
    <updated>2022-04-10T03:41:48.893Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-13/52EA4D4A98FF564EE062964187F4D6B0.jpg"                      alt="52EA4D4A98FF564EE062964187F4D6B0"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:40165995</center> <p>本周的内容主要就是添加剩下的一些parser，主要是和类相关的，同时还添加了数组的下标索引。内容稍微少一些，我觉得也没有太多值得讲的，基本上就是确定语法 + 直接写实现。代码写的也不多，花了不少时间在另一篇博客上，同时还要添加测试。到此为止原先的parser支持的差不多了。还增加了类型以及下标索引的内容，同时还有了更合理的测试。今天收下尾差不多可以开始写其他的内容了</p><h1 id="本周出现的所有语法"><a href="#本周出现的所有语法" class="headerlink" title="本周出现的所有语法"></a>本周出现的所有语法</h1><p>首先我们要确定要写出什么样的语法。语法大致先这样，不知道怎么样的语法才是优雅的，先都做出来再说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &lt;</span> Parent <span class="comment">// 继承，类型名必须首字母大写</span></span><br><span class="line">  v1: Fun <span class="comment">// 成员变量</span></span><br><span class="line">  v2: Int = <span class="number">1</span> <span class="comment">// 成员变量默认值</span></span><br><span class="line"></span><br><span class="line">  def update() <span class="comment">// 成员函数</span></span><br><span class="line">@v2 = @v2 + <span class="number">1</span> <span class="comment">// @获取成员变量</span></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def f()</span><br><span class="line">var v = F.<span class="keyword">new</span>() <span class="comment">// Class.new()的形式构建变量。new本质是object基类的方法</span></span><br><span class="line">v.update() <span class="comment">// 调用成员函数</span></span><br><span class="line">  var arr = Array.<span class="keyword">new</span>(<span class="number">2</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 常规的取数组下标</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>其实我有点中意下面这种写法，将vars和methods都限制在一起，但是后面如果类中可以添加新的东西那会麻烦一些，所以这个想法暂时保留</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line">vars:</span><br><span class="line">  v1: <span class="type">Fun</span></span><br><span class="line">  v2: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">methods:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>()</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classDefine</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>.<span class="type">Class</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">CLASS</span> ~&gt; sym ~ (<span class="type">OPERATOR</span>(<span class="string">&quot;&lt;&quot;</span>) ~&gt; sym).?) ~ log(item | field | noneItem)(<span class="string">&quot;class member&quot;</span>).* &lt;~ log(<span class="type">END</span>)(<span class="string">&quot;class end&quot;</span>) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> klass ~ parent ~ defines =&gt;</span><br><span class="line">      <span class="type">Item</span>.<span class="type">Class</span>(klass, parent,</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Field</span>]).map(_.asInstanceOf[<span class="type">Field</span>]),</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]).map(_.asInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noneItem</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  <span class="type">EOL</span> ^^^ <span class="type">Item</span>.<span class="type">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">field</span></span>: <span class="type">Parser</span>[<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">VAR</span> ~&gt; (id &lt;~ <span class="type">COLON</span>) ~ sym ~ (<span class="type">EQL</span> ~&gt; expr).?) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ ty ~ value =&gt; <span class="type">Field</span>(id, <span class="type">Type</span>.<span class="type">Spec</span>(ty), value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  oneline(method | classDefine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h1><p>新增加的ast成员。其中Constant是大写字母开头的名字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line"><span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Constant</span>(id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><h2 id="MethodCall"><a href="#MethodCall" class="headerlink" title="MethodCall"></a>MethodCall</h2><p>调用成员函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memCall</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">MethodCall</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ~ parSround(repsep(termExpr, <span class="type">COMMA</span>)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ id ~ args =&gt; <span class="type">Expr</span>.<span class="type">MethodCall</span>(obj, id, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ name =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(obj, name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selfField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">AT</span> ~&gt; id) ^^ (id =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(<span class="type">Expr</span>.<span class="type">Self</span>, id))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayIndex</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Index</span>] = positioned &#123;</span><br><span class="line">  termExpr ~ squareSround(termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> expr ~ index =&gt; <span class="type">Expr</span>.<span class="type">Index</span>(expr, index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">squareSround</span></span>[<span class="type">T</span>](p: <span class="type">Parser</span>[<span class="type">T</span>]) = <span class="type">LEFT_SQUARE</span> ~&gt; p &lt;~ <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> beginWithTerm: <span class="type">PackratParser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  memCall | memField | arrayIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | selfField | call | beginWithTerm | sym ^^ <span class="type">Expr</span>.<span class="type">Constant</span> | idExpr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了如上几个语法后，语法已经变成了左递归的形式。遇到这种问题一般来说是转成非左递归的语法，因为左递归的情况很容易堆栈溢出，而Scala的parser combaintor提供了记忆化的能力，简单来说就是能够缓存遍历过的情况，第二次递归到某个情况，如果这个情况已经被遍历过那么直接从缓存中取出即可，而不需要再次递归搜索</p><p>想要使用这个功能需要两个步骤</p><ol><li>parser继承自PackratParsers。之前我的parser都是继承自Parsers，而更换成PackratParsers是兼容的，直接修改继承类名即可</li><li>显式指定需要这个功能的parser返回PackratParser</li><li>函数必须改成lazy val</li></ol><p>可以看到上面的beginWithTerm已经修改为了这种形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-13</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>与CI和链接大战三百回合</title>
    <link href="https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/"/>
    <id>https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/</id>
    <published>2022-03-29T15:34:17.000Z</published>
    <updated>2022-04-04T08:48:10.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/solve-ci-and-link/54707001_p0.png"                      alt="54707001_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">攻撃隊、出撃！Vorwärts！ pixiv:54707001</center> <h1 id="噩梦开始的地方"><a href="#噩梦开始的地方" class="headerlink" title="噩梦开始的地方"></a>噩梦开始的地方</h1><p>在C#的CI测试中（目前仅开启了ubuntu）DllImport报错DllNotFoundException。而报错的位置是我对自己搞的一个capi做的C#包装</p><h1 id="本地尝试"><a href="#本地尝试" class="headerlink" title="本地尝试"></a>本地尝试</h1><p>遇到这种问题，我的第一反应还是先在本地的环境确认一下，这样的做法相对来说成本低很多，能够初步确认一些问题（但是由于自己配的环境的影响会导致很多问题无法排查）</p><p>自然本地是失败了，切到了Windows的机器上依然失败，又切到了公司内部的ubuntu服务器（我没有做过什么环境配置，可以认为相对干净一些）依然是失败了</p><h1 id="查看类似的情况"><a href="#查看类似的情况" class="headerlink" title="查看类似的情况"></a>查看类似的情况</h1><p>项目中也有其他使用我们自己做的C#包装的测试，因此我想到了确认一下它的正确性。我使用了自己的分支，而主分支是没有问题的。自己这里确认的过程中还是不够严谨，应该直接查看对应测试成功与失败的用例的执行情况，只是用这样想当然的想法来考虑。</p><h1 id="CI调试神器"><a href="#CI调试神器" class="headerlink" title="CI调试神器"></a>CI调试神器</h1><p>各种尝试无果（忘了做了哪些，总之都没有效果），之后尝试在Windows和mac下进行测试，这两者居然是能通过的。</p><p>一时之间也没能想到有什么决定性的因素，后来想到以前看过本地模拟ci环境的东西，因此去搜索关于ci调试的信息，并且发现了这个神器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">tmate</span> <span class="string">session</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">mxschmitt/action-tmate@v3</span></span><br></pre></td></tr></table></figure><p>只要将这一段加到GitHub action的yaml文件中，即可在执行到这里的时候停住。此时会不断刷新ssh连接的命令。</p><h1 id="进入CI后"><a href="#进入CI后" class="headerlink" title="进入CI后"></a>进入CI后</h1><p>我做的第一时间是检查so本身是否存在问题</p><p>像以往一样写了一个最简单的main.c，之后 <code>gcc main.c -L . llibname</code> 查看报错。</p><p>我一直使用这样的方式来检查实际链接的时候因为哪些符号是undefined导致链接挂掉，简单易实施，久而久之也开始潜意识的认为这样能过链接就没有问题了，还是对链接了解不够。</p><p>这里出现了一个我忽略了的问题，也正是这个问题导致我浪费了大半天时间。因为这个库是我自己写的自己编的，不会依赖于系统库之外的so，<strong>我潜意识认为这里不会出问题，所以我没有使用ldd进行确认链接状态</strong>。</p><h1 id="启动一个裸docker测试"><a href="#启动一个裸docker测试" class="headerlink" title="启动一个裸docker测试"></a>启动一个裸docker测试</h1><p>前面那一步做好也就不会有后面的那么多操作了..总之后面的操作也回顾一下</p><p>为了和跑测试的ci版本一致，启动了一个ubuntu18.04的docker（后面可以看到，幸好我这里选择了一致的版本，不然可能解决问题的时间需要更久…）</p><p>由于是非常干净的镜像，什么都没有，折腾了半天安装所需要的基本组建，开始编译并且执行测试，依然是存在问题。之后也没什么好思路，后来跑了一下上面提及的类似性质的相关测试的正确性，发现docker中也是错的。（这里如果我之前更严谨的确认了可能也会减少一些重复过程）</p><p>之后我就喊实现这块的同事和我一起看问题，切到了主分支测试也不能通过。后来不记得为什么了我随手敲了个ldd看了一下他的so，他看到了错误信息，一提醒我才看到。自己思考问题经常会钻牛角尖，以及经常会忽略掉一些信息，有的时候换个人从旁观者角度来看会好很多，自己想切换到旁观者角度还是有些难。</p><h1 id="GLIBC-x-xx-not-found"><a href="#GLIBC-x-xx-not-found" class="headerlink" title="GLIBC_x.xx not found"></a>GLIBC_x.xx not found</h1><p>看到的错误信息是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBCXX_3.xx&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>由于这是一个非常干净的ubuntu，所以甚至没有这个东西。这个时候我意识到了自己的库在CI中会不会也是类似的原因，我之前是否ldd检查过，检查过的话是否是忽略了这么重要的调试信息？（这个时候由于没有清晰的思路和严谨的做法，开始怀疑之前是否做过这个测试）</p><p>随后意识到在ci中会不会也是类似的问题。于是进入了ci调试器，看到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>测试能通过的so中是没有类似的错误信息。使用<code>strings /usr/lib/x86_64-linux-gnu/libc.so.6</code> 查看其中的glibc版本信息，发现其中并没有我们所需的版本（注意不要去看libc.so，它虽然叫so但不是动态链接库，用file可以看到实际上是一个文本文件）</p><p>这时可以确认问题就在这里了。</p><h1 id="“失误”"><a href="#“失误”" class="headerlink" title="“失误”"></a>“失误”</h1><p>这个时候我觉得离谱的是这个库我是通过github ci编译的，最后ci不能通过，也许还有什么因素应该控制但是我没有做好的。</p><p>本来还想吐槽这个，最后想办法处理GLIBC版本不一致的时候发现自己编的时候用的是ubuntu-latest的ci…而测试的地方是18.04。这一部分是我不知道从哪里直接就拷贝过来的，没有确认是否有问题就进行拷贝（之前也没有遇到过这样的情况，确认可能也不会想到这一点。但是我也确实没有进行过核对）</p><p>同时这次的经历意识到了自己编的库还是应该尽量依赖低版本的glibc</p><h1 id="关于glibc和GLIBC-XX"><a href="#关于glibc和GLIBC-XX" class="headerlink" title="关于glibc和GLIBC_XX"></a>关于glibc和GLIBC_XX</h1><p>这个我整理起来发现东西不少，以及要控制一下文章长度，因此整理到了另一篇博客上</p><p><a class="link"   href="https://homura.live/2022/03/29/glibc-version/" >https://homura.live/2022/03/29/glibc-version/<i class="fas fa-external-link-alt"></i></a></p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ol><li>GLIBC的version版本对应不上（错误的根本原因）</li><li>在写编译的ci的时候没有认真写，而是随便找了一个抄上就完事（错误的产生原因）</li><li>没有一套严谨的确认问题的思路（花费了我大半天的原因）</li></ol><p>太多意想不到的地方出了问题，不论是ldd还是最后发现是系统版本错，也许是自己在这些地方都没有太注意，最后各种小问题堆积太多导致出现了这种坑。</p><h1 id="事后诸葛亮"><a href="#事后诸葛亮" class="headerlink" title="事后诸葛亮"></a><del>事后诸葛亮</del></h1><p>在此写一下理想的解决思路应该是怎么样的</p><ol><li>发现CI出现问题，查看错误是DllNotFoundException</li><li>本地相同系统测试能通过，那么要确认查找的过程没有问题。多半是要排除掉环境变量的影响因素</li><li>确认路径查找是没有问题的以后进入CI环境查看dll的状态<ol><li>ldd查看依赖是否满足（本次错误看到a即可）</li><li>如果依赖满足的则再手动链接查看是否有undefined的符号之类</li></ol></li><li>发现是glibc的问题，确认是否真的找不到版本（这里我真的遇到过（虽然是GLIBCXX）…安了conda以后因为会先找到conda的glibc，而这个版本可能又是不合要求的，然后就会报错了..解决方案是直接修改链接，如果你遇到类似的问题一搜就能搜到解决方案）</li><li>glibc通常和环境有关，真的是没有匹配版本那么要查看环境的不同</li><li>由于是ci环境，那么肯定首先要看ci的yaml文件，对比配置的差异（问题解决）</li></ol><p>先确认第三步其实也可以，最好的情况下我们先去做了第三步是会省了第二步的问题。但我觉得这种dll链接相关的路径查找的问题可能更多一些，总之这些都是需要确认的步骤。</p><p>这个思路是在本地能够通过测试的前提条件下。需要调的这种情况一般是要合并了之类，这种情况肯定是要先在本地做好测试的。没有做好的情况肯定是要先测试的</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>自己经常会遇到这种离谱的问题，然而每个问题看起来再离谱最终都是会找到原因的，而且这个原因往往出现在意想不到的地方。想要减少这种现象的出现，只有明确自己行为的后果，以及不断踩坑的过程中形成一套自己的应对策略。（如果是别人的库那首先要注意的肯定是查看相关位置的源码）</p><p>这些问题的解决方式大多貌似都是口口相传，因此我打算再遇到这样类似的问题就进行一个记录。记录下我的思路，最终是如何解决问题的以及在这个途中有什么错误的想法，尽量避免第二次犯同样的错误，不断反思形成一套自己的解决问题方案，同时又会重新回顾在这之中有什么细节或者知识点是遗漏的。以后会增加更多这样的博客</p><p>遇到这种问题很重要的一点是如果不能调试，那解决问题可能要付出成倍的时间代价。像这个例子如果我不进去ci环境查看，也比较难确定是否真的是版本问题，不断更新ci打log也可以，但是非常非常麻烦且低效。</p><p>后面应该再写一个链接问题定位的博客（写的话大概会说一些自己踩过的坑）。我的思路未必全面，但是一定有着参考价值<del>（下次一定，在新建文件了，难不成我还能咕咕咕吗）</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/solve-ci-and-l</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CI" scheme="https://fusionbolt.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>关于glibc与GLIBC_XX</title>
    <link href="https://fusionbolt.github.io/2022/03/29/glibc-version/"/>
    <id>https://fusionbolt.github.io/2022/03/29/glibc-version/</id>
    <published>2022-03-29T15:33:44.000Z</published>
    <updated>2022-04-04T08:46:53.477Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/glibc-version/67650124_p0.jpg"                      alt="67650124_p0.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">是GLIBC的版本多还是miku的版本多? pixiv:67650124</center> <h1 id="glibc位置"><a href="#glibc位置" class="headerlink" title="glibc位置"></a>glibc位置</h1><p>这个不同系统不一致，linux中比较多的存在于/lib/libc.so.6</p><p>想要查找libc的位置可以通过ldd(linux)/otool(mac)查看依赖于libc.so的库（有的库会静态塞进去，这种的是看不了）</p><p>有的时候ldd看到的错误信息也会包含glibc的路径，这些还是根据不同的情况来查找</p><h1 id="确认当前环境glibc版本信息"><a href="#确认当前环境glibc版本信息" class="headerlink" title="确认当前环境glibc版本信息"></a>确认当前环境glibc版本信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, gnu_get_libc_version());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者都可以</p><h1 id="GLIBC-Version兼容性"><a href="#GLIBC-Version兼容性" class="headerlink" title="GLIBC Version兼容性"></a>GLIBC Version兼容性</h1><p>本质上这是一个so的不同版本兼容性问题。通常我们看到的so的版本号是 主版本号.次版本号，比如说2.6。<strong>链接的时候只会进行主版本号的判断</strong>，不同主版本号可能是不兼容的（不管实际如何，我们都应该视为不兼容，链接器也会报错的）。而次版本号保证新版本会兼容旧版本，比如说2.6兼容2.4</p><h1 id="关于自己编译的库"><a href="#关于自己编译的库" class="headerlink" title="关于自己编译的库"></a>关于自己编译的库</h1><h2 id="查看GLIBC的依赖"><a href="#查看GLIBC的依赖" class="headerlink" title="查看GLIBC的依赖"></a>查看GLIBC的依赖</h2><p>简单的命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings libxxx.so | grep <span class="string">&quot;^GLIBC&quot;</span></span><br></pre></td></tr></table></figure><p>你会看到多个版本号，由于新版本兼容旧版本，因此其中最新的一个GLIBC版本号是我们所需要的。这时你可能有很多小问号，让我们一个一个的来解决</p><h2 id="自己的库的GLIBC-Version怎么来的？"><a href="#自己的库的GLIBC-Version怎么来的？" class="headerlink" title="自己的库的GLIBC Version怎么来的？"></a>自己的库的GLIBC Version怎么来的？</h2><p>上面也提及了次版本号会高版本兼容低版本，但是如果依赖高版本的却运行于低版本时可能会出现找不到符号的情况，因此引入了<strong>基于符号的版本机制</strong>。即对应符号可以依赖于某个特定的次版本号</p><p>我们从一个例子来将这些串联起来。以下以上面提到过的确认当前环境GLIBC信息的示例代码为例，实际GLIBC版本大概率不会相同，与你的系统环境有关</p><p>首先使用strings查看，可以看到搜到了两个版本</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GLIBC_2</span><span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="type">GLIBC_2</span><span class="number">.34</span></span><br></pre></td></tr></table></figure><p>当然我想你可能已经尝试过前面确认当前版本GLIBC Version的命令，发现这里的符号和当前版本的符号并不相同。我们先讲解这些版本的来源，之后就会明白原因了</p><p>那么为什么会有两个版本呢？两个版本又是怎么来的呢？让我们用nm查看一下其中的符号</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000000039</span>c r __abi_tag</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">B</span> __bss_start</span><br><span class="line"><span class="number">0000000000004038</span> b completed<span class="number">.0</span></span><br><span class="line">                 w __cxa_finalize<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">0000000000004028</span> <span class="type">D</span> __data_start</span><br><span class="line"><span class="number">0000000000004028</span> <span class="type">W</span> data_start</span><br><span class="line"><span class="number">0000000000001080</span> t deregister_tm_clones</span><br><span class="line"><span class="number">00000000000010</span>f0 t __do_global_dtors_aux</span><br><span class="line"><span class="number">0000000000003</span>df0 d __do_global_dtors_aux_fini_array_entry</span><br><span class="line"><span class="number">0000000000004030</span> <span class="type">D</span> __dso_handle</span><br><span class="line"><span class="number">0000000000003</span>df8 d _DYNAMIC</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">D</span> _edata</span><br><span class="line"><span class="number">0000000000004040</span> <span class="type">B</span> _end</span><br><span class="line"><span class="number">0000000000001170</span> <span class="type">T</span> _fini</span><br><span class="line"><span class="number">0000000000001140</span> t frame_dummy</span><br><span class="line"><span class="number">0000000000003</span>de8 d __frame_dummy_init_array_entry</span><br><span class="line"><span class="number">00000000000020</span>a8 r __FRAME_END__</span><br><span class="line"><span class="number">0000000000004000</span> d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 w __gmon_start__</span><br><span class="line"><span class="number">0000000000002008</span> r __GNU_EH_FRAME_HDR</span><br><span class="line">                 <span class="type">U</span> gnu_get_libc_version<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">0000000000001000</span> <span class="type">T</span> _init</span><br><span class="line"><span class="number">0000000000002000</span> <span class="type">R</span> _IO_stdin_used</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">                 <span class="type">U</span> __libc_start_main<span class="meta">@GLIBC</span>_2<span class="number">.34</span></span><br><span class="line"><span class="number">0000000000001149</span> <span class="type">T</span> main</span><br><span class="line">                 <span class="type">U</span> printf<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">00000000000010</span>b0 t register_tm_clones</span><br><span class="line"><span class="number">0000000000001050</span> <span class="type">T</span> _start</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">D</span> __TMC_END__</span><br></pre></td></tr></table></figure><p>可以看到 __cxa_finalize, gnu_get_libc_version, printf是基于2.2.5，而__libc_start_main是基于2.34，这正好与我们前面看到的符号相关联。</p><p>看到这里你应该已经明白了，自己的库中GLIBC版本是来源于所使用的符号所标明的版本，因此我们在当前环境编出来的库的依赖版本实际上是当前环境的库中对应符号所依赖的版本号</p><h1 id="libc-so与libc-so-6"><a href="#libc-so与libc-so-6" class="headerlink" title="libc.so与libc.so.6"></a>libc.so与libc.so.6</h1><p>libc.so虽然长得像so，但它并不是，甚至不是一个软链接。内容大致是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some functions are only in</span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">GROUP ( /usr/lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /usr/lib/ld-linux-x86-64.so.2 ) )</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>程序员的自我修养：链接、装载与库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/glibc-version/</summary>
      
    
    
    
    <category term="C" scheme="https://fusionbolt.github.io/categories/C/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
  </entry>
  
  <entry>
    <title>我原本计划停下一周，然而...</title>
    <link href="https://fusionbolt.github.io/2022/03/28/rest-for-a-week/"/>
    <id>https://fusionbolt.github.io/2022/03/28/rest-for-a-week/</id>
    <published>2022-03-28T15:59:09.000Z</published>
    <updated>2022-03-28T16:23:12.230Z</updated>
    
    <content type="html"><![CDATA[<p>最近的精神状态愈发差劲，无止境的压力涌入身体，我也没有什么好的排解途径（本文不是讲我状态多差的，但是这些属于所需要了解的上下文，希望不要看到这个就直接关掉了文章）。我觉得不能再这个样子了，因此我想要尝试为期一周的“在家只休息”计划<del>（过于直接的命名）</del></p><h1 id="这周是如何度过的"><a href="#这周是如何度过的" class="headerlink" title="这周是如何度过的"></a>这周是如何度过的</h1><p>计划很美好，现实嘛…大家都懂</p><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>清理了卧室的垃圾，做了一些轻微的收拾。之后的时间都是习惯性的就要去抓手机，想要放音乐。看到这里，你可以一会尝试一下一段时间什么也不做是怎样的感受。</p><p>停下来什么都不做还是很难，不知所措的时候突然想到一些东西就开始记了下来，最后花了一个小时的时间手写了满满一页纸的想法（这也不算是在休息）。最后也是不知不觉就十二点了，早睡也没能成功</p><h3 id="后面几天"><a href="#后面几天" class="headerlink" title="后面几天"></a>后面几天</h3><p>本周的精神状态极差，回家只想获取简单快速的反馈，因此结果和我预料的也差不多，第二天开始回家只有各种刷视频，以及玩一些游戏。后面几天愈发过分，甚至到了快一点</p><p>周末由于事情比较多导致只有晚上在家，然而周末晚上也没有多少改善</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发现自己现在的情况，所谓的休息在情绪高压下根本就是找理由刷推特和视频，这种休息还不如不休，但是不休息又会持续积累压力和疲劳，那…</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rest-for-a-week/mami.png"                      alt="Untitled"                ></p><p>仔细想想还是应该注重维持我的日常规划的同时在不同任务之间进行轻微的休息，而减少大片的休息时间。这是非常必要的事情，不能一直紧绷着精神。否则就会像我现在这个样子，在状态差到只想刷刷刷以及处理任务之间反复游走，从来没有真正的休息过</p><h1 id="第一天我都写了些啥？"><a href="#第一天我都写了些啥？" class="headerlink" title="第一天我都写了些啥？"></a>第一天我都写了些啥？</h1><p>尽管写满了一页A4纸，在这里只挑出一些提及一下。</p><p>很久没有这样决定不逼着自己做些什么了（但是另一种角度说我还是在逼着自己不做事情，尽管也没能成功。</p><p>回想起以前的各种略悠闲的生活：回想起三年前在家的时候自己买菜做饭自己去海边溜达的日子，回想起在学校和舍友满学校找猫喂猫的日子。我也有那样的时光啊。</p><p>而现在的我显得忙碌与疲劳，不断给自己添加非常多的压力，这给我的第一反应是与之前的生活有着极大的反差。</p><p>但是后来想起现在的我会去买花，会去公园拍照，会去看星星拍星星，会关心云彩是什么样的，这样想下去现在也没有那么枯燥无谓。相比之前能做以及实际去做的事情都多了非常多，感兴趣的事情也多了许多，自己渐渐开始主动接触各种各样的事物，自己不再是只知道上学学习与打游戏的一个人了。</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>休息也不能白休，偶尔也会感受一下，会想一下自己的状态，进而记录了一些想法。</p><h2 id="外界push"><a href="#外界push" class="headerlink" title="外界push"></a>外界push</h2><p>不论因为什么，我目前都是处于一个身体不想做事情的状态（实际表现就是想做什么但并不会去做）。这个现象我一直隐约有所察觉，但是并没有做过多想法，或许是想了也没有用，再怎么想还是会这样。对于现在的话，更多的是将这个东西有意识的提醒自己，这是很重要的问题自然不能忽略</p><p>我有那么多想做的事情，都是觉得有意思想要尝试的东西，最后没有利用时间去做大多是如此。由于总处于疲惫状态，不管学的东西再有意思也不可能在累的时候还想要用力</p><p>关于这个问题，想起了我第一次接触精神药物的时候，当时因为睡眠不好大夫给我开了黛力新，之后的半个月内真的是精神十足，没有觉得累，也不像以往一样什么都不愿做，讨厌的英语材料也能一直在啃（<del>绝不是给我现在回避啃英语找借口</del>），随后一些原因效果都没了，一共也就吃了两个月。那段时间我在看各种书的lab，然而药效小了以后的效率最多只有原来一半，只能硬逼着自己做，逼着自己做也会很快就产生厌烦，完全找不回那半个月的精神劲。如果能持续保持那样的状态那我大概几个月就会产生更为巨大的变化吧，可惜已经一去不复返了</p><p>想要身体去做事情只有通过各种方式进行push，至少对我来说在被轻度push的时候状态基本上都是相对良好（重度可能会增加焦虑），之前也看到类似这样的话</p><blockquote><p>自己一个人努力是难的，需要有人拉你一把</p></blockquote><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>然而不是总能有人来帮你，大多数情况需要靠自己。而对自己push对于我这样的情况来说是相对比较困难的，但我之前依然每天都能够坚持做些什么，这完全归功于习惯。</p><p>只要逐渐养成习惯，那么做这些事情所需的阻力逐渐会减小，那么即便是相对疲惫的状态也能够一直做下去。</p><p>关于如何逐渐养成习惯这些，我推荐去阅读《掌控习惯》这本书。这本书最初是由推友在推特推荐给我的，阅读之后觉得收益非常多。虽然只能将书中的少部分内容运用到实际中，但依然促进了我许多改变。</p><p>关于习惯，周六心情不错的时候我一度认为这就是我破局最重要的东西之一。我写下了这样的一段话：我也不需要再担心自己会一直魔怔了，不过那要到何时我就不知道了。魔怔能不能解决我不知道，但是一定会帮助我解决非常多的问题。在这里我想起了上面提到的《掌控习惯》中提及了这样的内容</p><blockquote><p>不是应当达到某个目的，而是要达到某个系统</p></blockquote><p>一旦所需的习惯系统形成了，目的自然而然也就能够达到了</p><h2 id="“应该做的”"><a href="#“应该做的”" class="headerlink" title="“应该做的”"></a>“应该做的”</h2><p>停摆了一个周，很多事情没有去做也没有那么大的影响。（当然不是说我现在所做的事情都是不该做的意思）</p><p>想到了自己时常会被自己心中所谓的“应该做的”事情所限制所约束所浪费时间。之前总是会把很多这样的事情塞给自己，然后就开始拖。拖到最后太多了就狠心全部清空，实际最后也没有太大的影响。</p><p>你有多少事情也是这样？不过想明白自己真正应该做什么绝非易事，生活中的噪音太多了，而且即便没有这些噪音这也是一个非常难的问题。</p><h1 id="这一周我究竟得到了什么"><a href="#这一周我究竟得到了什么" class="headerlink" title="这一周我究竟得到了什么"></a>这一周我究竟得到了什么</h1><p>这一周的时间，我对所处的情况进行了一些思考，得出了一些结论。在写下成文的过程中再一次强化对这些想法的感知，希望能够帮助我强化一些正确的想法在脑中的印象并且更好的去实施提到的应当做的事情。</p><p>意识到了习惯究竟有多么的重要，看到离开了习惯的我是如何打回原形的；意识到了应该什么时候休息，缺乏休息的后果。这些虽然潜意识的有意识到，但是这种事情还是需要从潜意识中提取出来才能真正开始产生一些影响。</p><p>赶往目的地很重要，但是偶尔还是应该停下脚步，看看周边的风景</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的精神状态愈发差劲，无止境的压力涌入身体，我也没有什么好的排解途径（本文不是讲我状态多差的，但是这些属于所需要了解的上下文，希望不要看到这个就直接关掉了文章）。我觉得不能再这个样子了，因此我想要尝试为期一周的“在家只休息”计划&lt;del&gt;（过于直接的命名）&lt;/del&gt;&lt;/</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="Habits" scheme="https://fusionbolt.github.io/tags/Habits/"/>
    
    <category term="Rest" scheme="https://fusionbolt.github.io/tags/Rest/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记12 部分Parser</title>
    <link href="https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/"/>
    <id>https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/</id>
    <published>2022-03-20T04:16:15.000Z</published>
    <updated>2022-03-20T07:13:24.958Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-12/IMG_2114.JPG"                      alt="IMG_2114"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:95518122</center> <p>本周内容主要就是parser，而ast的内容会穿插其中</p><h1 id="Parser的一些问题"><a href="#Parser的一些问题" class="headerlink" title="Parser的一些问题"></a>Parser的一些问题</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>由于是由换行来分句，我觉得一个头疼的点在于要想清楚哪里要换行，想清楚这个parser都是由什么组成，然后拼接在一起。但是写到这里的时候我才想到如果表达式有多行（这个也是非常常见的情况）就支持不了了…以后再做支持吧，这个或许可以对于表达式单独添加换行的支持。</p><p>我目前的换行策略是统一由stmt以及item吃掉eol，其中的子parser是不会处理eol的。stmt是很自然的，一行是一个stmt，item的话目前则是由函数或者class组成，而函数和class也不需要管理换行统一由item管理</p><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><p>这个问题留到下次再讲<del>（因为我还没写）</del></p><h1 id="关于设计"><a href="#关于设计" class="headerlink" title="关于设计"></a>关于设计</h1><p>在重写的时候发现很多原来的设计并不好，但是又一时不知该如何设计。后面觉得还是先实现一种，先功能完备再来考虑美化语法</p><p>关于具体的设计还是要看parser和ast的实现</p><h1 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(id: <span class="type">Id</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">String</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br></pre></td></tr></table></figure><p>关于Expr, Stmt, Block之间不知道以什么样的形式比较好，就暂且学习了Rust的做法。自己不知道怎么做那去学习一些比较好的语言，这样的想法我觉得应该是没问题的。之前做的时候也是经常会参考Ruby的实现</p><p>关于Expr我就不一个个放parser了，大部分比较简单没有什么可讲的内容。着重讲几个关键的点。代码中出现log的部分可以忽略</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="ast的变化"><a href="#ast的变化" class="headerlink" title="ast的变化"></a>ast的变化</h3><p>首先ast的定义相比于之前发生了变化</p><p>这是之前if的ast定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>参考了rust中的if而现在转换成了这个样子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br></pre></td></tr></table></figure><p>false_branch可以是一个普通的else，也可以是接的另一个if，也就是将elsif这一语法糖还原为原始的if了，而elsif的if里又是同样的定义</p><p>同时之前的if是一个stmt，而现在的if是expr。返回的是对应分支block的返回值。block是由多个stmt组成，其返回值则是最后一条stmt</p><h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span></span>: <span class="type">Parser</span>[<span class="type">Block</span>] = positioned &#123;</span><br><span class="line">  rep(statement) ^^ (stmts =&gt; <span class="type">Block</span>(stmts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiLineIf</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">IF</span> ~&gt; expr) ~ block ~ elsif.* ~ (oneline(<span class="type">ELSE</span>) ~&gt; block).? &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ if_branch ~ elsif ~ else_branch</span><br><span class="line">    =&gt; <span class="type">If</span>(cond, if_branch, elsif.foldRight(else_branch.asInstanceOf[<span class="type">Option</span>[<span class="type">Expr</span>]])(</span><br><span class="line">      (next, acc) =&gt; <span class="type">Some</span>(<span class="type">If</span>(next.cond, next.true_branch, acc))))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elsif</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">ELSIF</span> ~&gt; termExpr) ~ block ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ branch =&gt; <span class="type">If</span>(cond, branch, <span class="type">None</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到elsif在这里被编译为了if，多个elsif则是被编译为了一个List[If]，在这里通过FoldRight的方式折叠为一个if。以else为初始值，不断的将List最右边的元素设置为下一个if的else</p><p>逻辑展开是这样的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">C</span>, <span class="type">ELSE</span>: <span class="type">Option</span>[<span class="type">Expr</span>]</span><br><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))</span><br><span class="line"><span class="type">A</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>)))</span><br><span class="line"><span class="type">Some</span>(<span class="type">IF</span>(<span class="type">A</span>.cond, <span class="type">A</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))))</span><br></pre></td></tr></table></figure><p>代码中出现的asInstanceOf是因为我不知道这里的类型是怎样处理的，索性通过这种方式来回避编译错误。</p><h2 id="termExpr"><a href="#termExpr" class="headerlink" title="termExpr"></a>termExpr</h2><p>termExpr只是为了parser的时候区分各种expr的一种方式，所以ast表示上是和常规的expr是一样的。可以看到term是一些可以用于各种操作符的东西，比如说1 + 1，1是一个term，整个是一个termExpr。后面我们需要将这一系列的term和operator组合成一个expr，因此需要有后面的termToBinary</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  multiLineIf | termExpr | ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | call | memField | memCall | idExpr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于termsToBinary的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BinaryTranslator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> opDefaultInfix = <span class="type">HashMap</span>(<span class="string">&quot;+&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;-&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;*&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;/&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;&gt;&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;&lt;&quot;</span>-&gt;<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findMaxInfixIndex</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Int</span> =</span><br><span class="line">    terms</span><br><span class="line">      .zipWithIndex</span><br><span class="line">      .filter((x, _) =&gt; x.isInstanceOf[<span class="type">OPERATOR</span>])</span><br><span class="line">      .map((x, index) =&gt; (x.asInstanceOf[<span class="type">OPERATOR</span>], index))</span><br><span class="line">      .minBy((op, index) =&gt; opDefaultInfix(op.op))._2</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">replaceBinaryOp</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>], index: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Positional</span>] = &#123;</span><br><span class="line">    <span class="keyword">var</span> t = terms(index)</span><br><span class="line">    <span class="keyword">val</span> left = terms.slice(<span class="number">0</span>, index - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> bn = <span class="type">Expr</span>.<span class="type">Binary</span>(</span><br><span class="line">      terms(index).asInstanceOf[<span class="type">OPERATOR</span>].op,</span><br><span class="line">      terms(index - <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>],</span><br><span class="line">      terms(index + <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>])</span><br><span class="line">    <span class="keyword">val</span> rights = terms.slice(index + <span class="number">2</span>, terms.size)</span><br><span class="line">    left.appended(bn):::(rights)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(term: <span class="type">Expr</span>, terms: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Positional</span>]]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> terms.isEmpty then <span class="keyword">return</span> term</span><br><span class="line">    termsToBinary(term :: terms.flatten)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> newTerms = terms</span><br><span class="line">    <span class="keyword">while</span> (newTerms.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> max_index = findMaxInfixIndex(newTerms)</span><br><span class="line">      newTerms = replaceBinaryOp(newTerms, max_index)</span><br><span class="line">    &#125;</span><br><span class="line">    newTerms.head.asInstanceOf[<span class="type">Expr</span>.<span class="type">Binary</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑：</p><ol><li><p>如果只有开头的一个term则返回该term</p><p>否则将开头的和后面的terms组合起来进行处理</p></li><li><p>找到最高优先级的op的位置</p></li><li><p>将该位置以及左右的term组合为一个expr并且替换</p></li><li><p>重复这个过程直至剩下一个term</p></li></ol><p>这里我觉得实现的有点脏…基本上是把我用ruby写的那一套抄过来了，我一时也没想到什么好的方案</p><p>由于要对替换以后的expr再进行组合，这个过程中index会发生变动；如果要将组合后的拿出来，那还要处理哪些是拿出来的哪些是没有拿出来的，这样获取前后的term也会很不方便</p><h1 id="Stmt"><a href="#Stmt" class="headerlink" title="Stmt"></a>Stmt</h1><h2 id="ast-1"><a href="#ast-1" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Id</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Id</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br></pre></td></tr></table></figure><p>这里的while和rust的不太一样，rust的while也是一个expr，尽管能够从理性上认识到这样做是为了返回最后一个block的结果，但我仍然觉得这个做法好奇怪。目前还是先将其作为stmt，以后发现了哪里不合适再进行修正</p><h2 id="parser-1"><a href="#parser-1" class="headerlink" title="parser"></a>parser</h2><p>这边也比较简单。内容不多就直接贴出来了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">VAR</span> ~&gt; id) ~ (<span class="type">EQL</span> ~&gt; termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Local</span>(id, <span class="type">Type</span>.<span class="type">Nil</span>, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret</span></span>: <span class="type">Parser</span>[<span class="type">Return</span>] = positioned &#123;</span><br><span class="line">  <span class="type">RETURN</span> ~&gt; termExpr ^^ <span class="type">Return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assign</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">Assign</span>] = positioned &#123;</span><br><span class="line">  (id &lt;~ <span class="type">EQL</span>) ~ termExpr ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Assign</span>(id, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileStmt</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">While</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">WHILE</span> ~&gt; parSround(termExpr)) ~ block &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ body =&gt; <span class="type">Stmt</span>.<span class="type">While</span>(cond, body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果读者能够读到这里（<del>虽然并不会有几个人，其中大概也不会有追更的</del>），那很大概率不嫌弃我的内容，在这里可能要提前和各位说一声对不起，下周很有可能将是我第二次断更。（其实本周也有好几天都没写了…）</p><p>下周工作之外的事情除了最低限度的练琴，我会尽可能的不去做什么事情。眼睛疼（写的现在也在疼），精神极其不稳定（经常不受控制的胡思乱想），这些都是原因。</p><p>我也不想停，重写的进程还是比较慢，我的开发效率又偏低同时又要各种测试确保正确性。我好想赶快把这些基础的迁移完，然后去学习做优化，学习加上类型系统，等等，还想要多学习一些Scala，除此之外有很多创意想要实现还想去学swiftUI</p><p>但是或许此刻再不停就真的要断线了，我需要花时间好好冷静一下，平复情绪，进行休整。我无法努力获得温暖，那就只有努力去平复情绪。面对至今为止最重要也最大的挑战（当前的不良状态），我也应该拿出应有的态度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-12</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记11 重构与Lexer</title>
    <link href="https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/"/>
    <id>https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/</id>
    <published>2022-03-13T03:08:42.000Z</published>
    <updated>2022-03-13T08:33:02.179Z</updated>
    
    <content type="html"><![CDATA[<p>本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。</p><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>vm目前代码很少，做的重构主要是将一些东西抽象拆分出来</p><p>这是之前vm的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line"><span class="keyword">size_t</span> _pc = <span class="number">0</span>;</span><br><span class="line">EvalStack _eval_stack;</span><br><span class="line">std::string _cur_fun;</span><br><span class="line"><span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> _pc_need_incr = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relative_pc</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">size_t</span> <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EvalStack&amp; <span class="title">eval_stack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _eval_stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string&amp; klass, <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> FunInfo&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">pc_need_incr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc_need_incr; &#125;</span><br></pre></td></tr></table></figure><h2 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h2><p>首先就是关于pc的部分，零碎的放在了vm的实现中，我们单独将这些实现挑出来作为一个类来实现，因此就有了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PC</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PC</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">absolute_jump</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relative_jump</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">size_t</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">current</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">force_need_incr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _inst_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _need_increase = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>其次是代码段的内容。和代码段相关的虽然只有一个指令的vector和一个load method方法，但是为了组件之间减少耦合、方便测试还是要拆出来（虽然我还没有写更多的测试…）。最后结果是多了一个这样的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string &amp;klass, <span class="keyword">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> FunInfo &amp;f)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; <span class="built_in">inst_list</span>() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;VMInst&gt; <span class="title">get_inst</span><span class="params">(<span class="keyword">size_t</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;VMInst&gt; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构后的成员"><a href="#重构后的成员" class="headerlink" title="重构后的成员"></a>重构后的成员</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function">PC <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EvalStack &amp;<span class="title">eval_stack</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _eval_stack; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">out_of_code_segment</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMInstVisitor</span>;</span></span><br><span class="line">    std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">    CodeSegment _code_segment;</span><br><span class="line">    EvalStack _eval_stack;</span><br><span class="line">    std::string _cur_fun;</span><br><span class="line">    <span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line">    PC _pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上去清爽了许多。目前先改到这里了</p><h1 id="相关前置知识"><a href="#相关前置知识" class="headerlink" title="相关前置知识"></a>相关前置知识</h1><p>之后的内容开始设计lexer和parser。假设读者没有相关知识，我先来大概讲一下编译器从源码生成到ast的流程。</p><ol><li><p>对输入的源码进行分词，生成一系列Token，我们称之为词法分析</p><p>分词是什么呢？说的直白一些就是把字符串划分开，哪一部分是名字，哪一部分又是空格，哪一部分是数字，诸如此类。Token就是表明了这个东西到底是哪种词，如果不明白可以看后面的代码部分。</p></li><li><p>将Token根据特定的规则进行解析，生成抽象语法树，我们称之为语法分析</p></li></ol><p>这些过程的实现方式不外乎两类</p><ol><li>使用生成器进行生成：常见的是Lex（生成词法分析器） + YACC（生成语法分析器）。这些需要自己编写一下规则，喂给生成器进行生成</li><li>自行手写实现：手写的灵活性灵活度是会比生成器要高的，但是相对比较复杂</li></ol><p>关于手写方式有一种叫parser combaintor的技术，能够通过组合不同的函数来实现解析，实现起来自然是比传统的手写方式方便，而我这里选择的也正是这种方案</p><h1 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h1><p>虽说是parser，但是肯定还是要先做分词的。之前的实现中是没有做分词的，很多地方都搞的比较难受。一开始我还疑惑了一会使用parser combaintor是否还要做分词，但是写了一会意识到还是需要，虽然可以直接隐含了分词的部分，但是这样会把两类逻辑全部糊在一起，对于调试、测试都是非常难受的问题，而且对于空格、换行之类的也会非常麻烦。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>先来看一下Token的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Token</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OPERATOR</span>(op: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> <span class="type">EOL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">COMMA</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">EQL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SPACE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">IF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">THEN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSIF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">WHILE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">CLASS</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SUPER</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><p>通过extends Positional进而让Token都携带了位置信息（行号列号）</p><p>这是一份不是很好的定义。写这个的时候来不及改了，下周会改正，但是在这里将这个不太好的范例拿出来讲。我一开始也觉得这样很奇怪，但是也没深入思考有没有什么更好的方式（再一次见到了自己的惰性），对于Token来说这样平着展开也不能说不对，但是可以做得更好</p><p>后来看到Rust中Token的一些地方我才反应过来，还是应该将keyword和一些间隔符单独揪出来，而不是这么完全扁平化。写这篇的时候来不及改了，只能拖到下周再说了</p><h2 id="一些简单的实现"><a href="#一些简单的实现" class="headerlink" title="一些简单的实现"></a>一些简单的实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NoValueToken</span></span>(str: <span class="type">String</span>, token: <span class="type">Token</span>): <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">    str ^^^ token</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eol</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;\n&quot;</span>, <span class="type">EOL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eql</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;=&quot;</span>, <span class="type">EQL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comma</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;,&quot;</span>, <span class="type">COMMA</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trueLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;true&quot;</span>, <span class="type">TRUE</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">falseLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;false&quot;</span>, <span class="type">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;var&quot;</span>, <span class="type">VAR</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;val&quot;</span>, <span class="type">VAL</span>)</span><br></pre></td></tr></table></figure><p>这个也非常简单，读取到对应的字符串直接返回对应的token。外面包了positioned以后内部的内容就能够携带行号和列号的信息</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ops</span> </span>= <span class="string">&quot;[+\\-*/%^~!&gt;&lt;]&quot;</span>.r</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  ops ^^ <span class="type">OPERATOR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个通过正则表达式匹配的例子，这里的^数量由三个变成了两个，三个的情况下是左边的条件匹配成功则返回右边的值，而两个的情况下是条件匹配成功后执行右边的函数并且返回其值。</p><p>operator这里是通过正则表达式来进行匹配，ops则是一个正则表达式</p><p>这里可能有一些引起困惑的地方。为什么下面需要返回函数的时候填的是返回的类型？我没有正经学过Scala，用我在其他语言学过的东西来说这大概是因为虽然OPERATOR本身是类型，但在这里是一个值构造器，用另一种表达方式的话就是一个传入OPERATOR所需参数返回一个OPERATOR实例的函数</p><p>这里我可能解释的不是很正确，如有哪里用词/描述不当还请联系我指出</p><h2 id="间隔符与非间隔符"><a href="#间隔符与非间隔符" class="headerlink" title="间隔符与非间隔符"></a>间隔符与非间隔符</h2><p>核心代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allTokens</span></span>: <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">Token</span>]] = &#123;</span><br><span class="line">((rep1sepNoDis(repN(<span class="number">1</span>,notSpacer),spacer.+) ~spacer.*) |</span><br><span class="line"><span class="comment">// BAA is imposible</span></span><br><span class="line">(rep1sepNoDis(spacer.+, repN(<span class="number">1</span>,notSpacer)) ~notSpacer.?)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> list ~ t =&gt;</span><br><span class="line">      list</span><br><span class="line">        .fold(<span class="type">List</span>())(_:::_)</span><br><span class="line">        .concat(t <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(v) =&gt; <span class="type">List</span>(v)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">List</span>()</span><br><span class="line">          <span class="keyword">case</span> _ =&gt; t</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(_ != <span class="type">SPACE</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^^前都是解析的部分，解析部分的～是连接的意思，也就是说前面的解析完会接着解析后面的内容。后面处理的部分只是将每个解析部分生成的输出都连接起来，成为一个List[Token]。由于觉得用不到因此我在这里干掉了SPACE</p><p>其中出现过的一些函数的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">space</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  whiteSpace.+ ^^^ <span class="type">SPACE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notSpacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = keyword | value | eol</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = symbol | operator | eql | space</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keyword</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = stringLiteral | trueLiteral | falseLiteral |</span><br><span class="line">    defStr | endStr | ifStr | thenStr | elsifStr | elseStr | whileStr |</span><br><span class="line">    classStr | superStr | varStr | valStr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbol</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = comma | eol | leftParentTheses | rightParentTheses | leftSquare | rightSquare</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = number | identifier</span><br></pre></td></tr></table></figure><p>这里对我来说是一个比较难写的点，上周在写的时候头痛了好一阵子，想明白逻辑以后再回来看会好很多</p><h3 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h3><p>这里的逻辑是这样的：我们先定义不能作为间隔符的为A（notSpacer），可以作为间隔符的为B（spacer），那么我们需要的是A(B+A)*B*，或者是B+(AB+)*A?</p><p>注：这里的*+?都是正则表达式的语义</p><h3 id="拆分逻辑"><a href="#拆分逻辑" class="headerlink" title="拆分逻辑"></a>拆分逻辑</h3><p>关于为什么要这么设定，我们先从B开始。</p><ol><li><p>可以看到B包含了一些运算符，空格，一些标点符号，这些本身是和任何字符相连都是无歧义的（目前来说B中的内容是无歧义的），那么它们连续存在依然不会产生歧义。B本身是要存在的，因此这里可以推导出B+</p></li><li><p>而A中的内容，比如说两个keyword之间一定要有空格，不然会被识别成一个identifier了，比如说传递参数的时候需要逗号分开（symbol），那么A是不可能连续存在的，因此这里可以推导出A</p></li><li><p>由于我们需要A和B间隔放置，我首先想到的是rep1sep(A, B+)，而由于A和B都可能在第一个，因此有了rep1sep(A, B+) | rep1sep(B+, A)。（repsep举个例子，repsep(str, ‘,’)，对应的就是str, str, str这种以，分割的）但是repsep会扔掉B，因此我从rep1sep抄了一份修改了一下，变成了不扔掉B的版本</p><p>以下rep1sepNoDis都用rep1sep代替</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sepNoDis</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~ p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y.map(x =&gt; <span class="type">List</span>(x._1.asInstanceOf[<span class="type">T</span>], x._2)).fold(<span class="type">List</span>())(_:::_)&#125;</span><br></pre></td></tr></table></figure><p>原版</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sep</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~&gt; p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y&#125;</span><br></pre></td></tr></table></figure><ol><li>但是只是repsep的做法无法处理AB（会残留一个B未解析），那么很自然的就会想到再后面接一个可选的B，因此就有了rep1sep(A, B+) ~ B?，同理无法处理BA，也就有了 rep1sep(B+, A) ~ A? 组合起来就有了 rep1sep(A, B+) ~ B? | rep1sep(B+, A) ~ A? </li></ol><p>事后回顾思路还算是捋的比较清晰，一直这样写或许也会有利于我之后写代码的时候逻辑梳理的能力。不过当时写的时候真的是整个人都不好了…这块写代码的时候想了半天，写博客尽管逻辑很流畅了但是还是写了很久</p><h3 id="逻辑与实现的一些出入"><a href="#逻辑与实现的一些出入" class="headerlink" title="逻辑与实现的一些出入"></a>逻辑与实现的一些出入</h3><p>拆分完逻辑后将</p><p>rep1sep = rep1sepNoDis</p><p>A = notSpacer</p><p>B = spacer</p><p>代入后，会发现有一些不一样的地方。我在rep1sep的A中做了repN(1, A)的操作。至于为什么这么写，是为了保证A和B哪一个在前哪一个在后都可以使用。一个值和一个List交换顺序还能连接的实现不知道有什么可用的，自己尝试写了一个</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l: <span class="type">List</span>[<span class="type">T</span>], v: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = l:::v::<span class="type">Nil</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](v: <span class="type">T</span>, l: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = v::l</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l1: <span class="type">List</span>[<span class="type">T</span>], l2: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = l1:::l2</span><br></pre></td></tr></table></figure><p>但是和前面的函数组合起来，在处理的时候一些看起来很自然的东西并没有通过类型检查，对于Scala的类型理解不到位也难以解决问题，因此就只好先这个样子。虽然用起了Scala，但是并没有学太多，凭着其他语言的经验直接就来写</p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><p>这么说过于抽象，我们通过看测试来实际理解以下例子。</p><p>之所以要搞得这么复杂，是因为最后一个测试用例的那种情况。对于我之前lexer和parser混在一起写的做法处理这样的情况是非常难的。不过我不敢说已经想全面了，有问题再改吧</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&quot;spacer&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// a is notSpacer, b is spacer</span></span><br><span class="line">it(<span class="string">&quot;AB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>), <span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BAB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; id &quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABABB space and eol&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;def f \n&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>), <span class="type">EOL</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; def f&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;only space&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; &quot;</span>, <span class="type">List</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;local&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> v = <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;a&quot;</span>), <span class="type">EQL</span>, <span class="type">NUMBER</span>(<span class="number">1</span>))</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1 &quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a =1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a=1&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来是想写一些parser的内容的，但是没想到这个token间隔符相关的逻辑就花了我这么久的时间。这块我觉得写的还是相对比较清晰，也算是比较满意，所以本周就先这么结束了。关于token一般来说不会有什么特别的内容了，所以关于解析输入，之后基本上就是parser的内容了。</p><p>这个周我觉得进度比较慢，不会调加上前几天整个人都过于不稳定，回家会花一些时间在刷刷刷上，进而减少了编码的时间，不知道什么时候能做完重写啊…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。&lt;/p&gt;
&lt;h1 id=&quot;重构&quot;&gt;&lt;a href=&quot;#重构&quot; class=&quot;headerlink&quot; title=&quot;重构&quot;&gt;&lt;/a&gt;重构&lt;/h1&gt;&lt;p&gt;vm目前代码很少，做的重构主要是将一些东</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Lexer" scheme="https://fusionbolt.github.io/tags/Lexer/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记10 分支与循环</title>
    <link href="https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/"/>
    <id>https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/</id>
    <published>2022-03-05T03:56:29.000Z</published>
    <updated>2022-03-05T03:58:12.762Z</updated>
    
    <content type="html"><![CDATA[<p>开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来</p><p>本周更新的内容主要是修复之前的问题以及处理了分支循环</p><h1 id="继承与成员变量"><a href="#继承与成员变量" class="headerlink" title="继承与成员变量"></a>继承与成员变量</h1><p>首先是上周遗留的继承的情况下成员变量id会有问题，我们先来看一下成员变量相关的实现</p><ol><li>使用id标明</li><li>运行时存一个hash，按照名字来取</li></ol><p>我选择在添加parent的时候将parent的成员变量添加到当前的instance_vars中。这样需要布局在编译器确定，无法应对动态添加成员变量的情况，不过先不管那些</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_var_keys</span></span></span><br><span class="line">  <span class="variable">@instance_vars</span>.sort_by(&amp;<span class="symbol">:last</span>).map &#123;<span class="params">|k, _|</span>k&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_parents</span><span class="params">(parent_name, parent_table)</span></span></span><br><span class="line">  <span class="variable">@parent</span> = parent_name</span><br><span class="line">  <span class="keyword">unless</span> parent_table.is_a? ClassTable</span><br><span class="line">    raise <span class="string">&quot;parent_table should be a ClassTable&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  parent_table.instance_vars.each <span class="keyword">do</span> <span class="params">|var_name, _|</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">@instance_vars</span>.<span class="keyword">include</span>? var_name</span><br><span class="line">      add_instance_var(var_name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>最近才发现我还没有做分支以及循环的内容</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator"><a href="#translator" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_if</span><span class="params">(node)</span></span></span><br><span class="line">  list = node.stmt_list.map <span class="keyword">do</span> <span class="params">|cond, stmt|</span></span><br><span class="line">    c = visit(cond)</span><br><span class="line">    s = [visit(stmt), JumpAfterIf.new].flatten</span><br><span class="line">    cmp_and_jmp = push_eq_jmp(s.size)</span><br><span class="line">    [c, cmp_and_jmp, s].flatten</span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line">  els = visit(node.else_stmts)</span><br><span class="line">  list = list + els</span><br><span class="line">  list.each_with_index <span class="keyword">do</span> <span class="params">|inst, index|</span></span><br><span class="line">    <span class="keyword">if</span> inst.is_a? JumpAfterIf</span><br><span class="line">      list[index] = RelativeJump.new(list.size - index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  list</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_eq_jmp</span><span class="params">(true_branch_size)</span></span></span><br><span class="line">  [Push.new(<span class="number">1</span>), EQ.new, JumpFalse.new(true_branch_size + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每一组（if或者elsif）if条件和stmt进行遍历</p><ol><li><p>生成判断条件的指令</p></li><li><p>生成比较指令</p><p>将判断执行的结果与true进行eq操作，失败则跳转到下一组elsif，也就是true分支之后的第一条指令</p></li><li><p>生成当前组if中对应的true的分支</p><p>最后要添加一个跳转到整个if结束的指令</p></li></ol><h3 id="新指令"><a href="#新指令" class="headerlink" title="新指令"></a>新指令</h3><p>可以看到这里引入了几个新的指令</p><p>JumpAfterIf：用于跳转到if结束语句，提前占好指令位置，最后由RelativeJump代替</p><p>RelativeJump：跳转到一个相对地址</p><p>对于分支来说，判断指令也是需要的，因此还引入了GT，LT，EQ三个指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_op</span><span class="params">(op)</span></span></span><br><span class="line">  <span class="keyword">case</span> op.op</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    LT.new</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    GT.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&#x27;unsupported op&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">While</span> &lt; Struct.<span class="title">new</span>(:<span class="title">cond</span>, :<span class="title">body</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator-1"><a href="#translator-1" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_while</span><span class="params">(node)</span></span></span><br><span class="line">  cond = visit(node.cond)</span><br><span class="line">  body = visit(node.body).flatten</span><br><span class="line">  cmp_and_jmp = push_eq_jmp(body.size + <span class="number">1</span>)</span><br><span class="line">  while_inst = [cond, cmp_and_jmp, body].flatten</span><br><span class="line">  while_inst + [RelativeJump.new(-while_inst.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的内容更简单，相比if来说只需要处理一个分支判断和true的语句，最后加一个回到while开头的跳转即可</p><h1 id="指令的VM实现"><a href="#指令的VM实现" class="headerlink" title="指令的VM实现"></a>指令的VM实现</h1><h2 id="新的pc寻址方式"><a href="#新的pc寻址方式" class="headerlink" title="新的pc寻址方式"></a>新的pc寻址方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span> </span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidVM::<span class="built_in">relative_pc</span>(<span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="built_in">DEBUG_CHECK</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_pc) + offset &lt; <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;invalid pc, pc:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot;offset:&quot;</span> + std::<span class="built_in">to_string</span>(offset))</span><br><span class="line">    <span class="built_in">set_pc</span>(_pc + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> EQ &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::EQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> GT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::GT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> LT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::LT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里，我把一些binary的op做了一下处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(_opname, _op) \</span></span><br><span class="line"><span class="meta">   case BinaryOp::_opname: \</span></span><br><span class="line"><span class="meta">      push(v1 _op v2);     \</span></span><br><span class="line"><span class="meta">      break;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LT GT, FILO</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">        <span class="built_in">PUSH</span>(Add, +)</span><br><span class="line">        <span class="built_in">PUSH</span>(Sub, -)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mul, *)</span><br><span class="line">        <span class="built_in">PUSH</span>(Div, /)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mod, %)</span><br><span class="line">        <span class="built_in">PUSH</span>(EQ, ==)</span><br><span class="line">        <span class="built_in">PUSH</span>(LT, &lt;)</span><br><span class="line">        <span class="built_in">PUSH</span>(GT, &gt;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PUSH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的点是第一个pop出来的是表达式右侧的变量，因为栈是先进后出的。不仅比较操作需要注意，减法和除法也是如此</p><h2 id="RelativeJump"><a href="#RelativeJump" class="headerlink" title="RelativeJump"></a>RelativeJump</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(constRelativeJump &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JumpFalse"><a href="#JumpFalse" class="headerlink" title="JumpFalse"></a>JumpFalse</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]] <span class="keyword">const</span> JumpFalse &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cond = _eval_stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(cond == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>过于急切的去摸了一点oop的边，甚至连基本的分支跳转之类的都没有做，这么匆匆忙忙是否表示我已经不想做了呢…不管怎么说，这个坑决定开了，不想做也要做下去，做的烂总比什么都没做要强的多（最近几周的内容不论是数量还是质量都开始大幅下降了…</p><p>开始不想接着写当前的了，vm那边我觉得虽然没写多少但已经开始有屎山的倾向了，应该花点时间重新考虑下代码结构以及测试。</p><p>优化以及类型分析之类的我觉得还是换一门静态类型的语言来做。最近也在开始进行编译器重写的工作，好在实际上东西不是很多。重写过后就会从优化以及类型开始做一些工作，而下周开始可能会花更大比例的时间在重写上。尽管东西不多，但由于我对新语言对不熟悉，而且尽可能的改用好的设计，还是要花上一定的时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来&lt;/p&gt;
&lt;p&gt;本周更新的内容主要是修复之前的问题以及处理了分支循环&lt;/p&gt;
&lt;h1 id=&quot;继承与成员变量&quot;&gt;&lt;a href=&quot;#继承与成员变量&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记9 OOP之继承</title>
    <link href="https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/"/>
    <id>https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/</id>
    <published>2022-02-20T04:12:17.000Z</published>
    <updated>2022-02-20T04:54:14.092Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分</p><h1 id="类的符号信息"><a href="#类的符号信息" class="headerlink" title="类的符号信息"></a>类的符号信息</h1><p>对于之前的类表实现是只有方法和成员变量的，而现在在获取符号表信息遍历到class的时候需要再添加一个parent的信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span>, <span class="symbol">:parent</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="VM方法查找"><a href="#VM方法查找" class="headerlink" title="VM方法查找"></a>VM方法查找</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject *obj, <span class="keyword">const</span> string &amp;f, <span class="keyword">bool</span> super)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = super ? <span class="built_in">get_parent_class</span>(obj) : obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">method_search</span>(klass, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> string &amp;klass, <span class="keyword">const</span> string &amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;class_table = global_class_table[klass];</span><br><span class="line">    <span class="keyword">if</span> (class_table._methods.<span class="built_in">contains</span>(f)) &#123;</span><br><span class="line">        <span class="keyword">return</span> class_table._methods[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(class_table._parent.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MethodNotFoundException</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">method_search</span>(class_table._parent, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下之前的实现做一个对比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然多了去父类查找的部分。</p><h1 id="调用父类同名函数"><a href="#调用父类同名函数" class="headerlink" title="调用父类同名函数"></a>调用父类同名函数</h1><p>既然要继承了，那么也一定要涉及到调用父类的同名函数的问题。在上面的method_search的实现中，可以看到从obj查找method的时候有一个叫super的参数。因此如果要调用super的话一定是从父类开始查找，而不是从当前类</p><p>而这个在源代码中是通过一个super方法来实现的，大概是这个样子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span></span><br><span class="line">  <span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="AST定义"><a href="#AST定义" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:args</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="variable">@args</span> = args</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper<span class="subst">#&#123;args_to_s(<span class="variable">@args</span>)&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义"><a href="#VM指令定义" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span> &lt; Struct.<span class="title">new</span>(:<span class="title">argc</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:argc</span> =&gt; <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper <span class="subst">#&#123;argc&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意AST中保存的是实参，而指令中已经提前push好了参数，这里只需要传递一个argc用于寻找参数之前push的this指针就可以了</p><h2 id="ast翻译到vm指令的实现"><a href="#ast翻译到vm指令的实现" class="headerlink" title="ast翻译到vm指令的实现"></a>ast翻译到vm指令的实现</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_invoke_super</span><span class="params">(node)</span></span></span><br><span class="line">  [PushThis.new] + push_args(node.args.map) + [InvokeSuper.new(node.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="vm指令的执行"><a href="#vm指令的执行" class="headerlink" title="vm指令的执行"></a>vm指令的执行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> InvokeSuper &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">begin_call</span>(_eval_stack.<span class="built_in">current_method</span>(), inst.argc, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::begin_call</span><span class="params">(<span class="keyword">const</span> string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f, super);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也非常简单，比起之前的实现，现在begin_call里添加了一个super传递给method_search</p><h1 id="成员变量储存"><a href="#成员变量储存" class="headerlink" title="成员变量储存"></a>成员变量储存</h1><p>既然要继承，那么就要保存父类成员的变量。目前的做法是像ruby一样直接覆盖父类同名变量，因此在创建对象的时候获取整个类继承链中所有变量的集合，然后获取其长度，在创建变量的时候使用这个长度来分配对应的空间。</p><p>这个长度应该是编译期间就算出来的，这里这样写有一种应付的感觉…虽然说这样能够处理动态修改父类定义的方法，但是现在并没有做的那么动态，很多设计还没有敲定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">find_all_var</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> parents = global_class_table[klass]._parent;</span><br><span class="line">    <span class="keyword">auto</span> &amp;vars = global_class_table[klass]._vars;</span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">set</span>(vars.<span class="built_in">begin</span>(), vars.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(parents.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.<span class="built_in">merge</span>(<span class="built_in">find_all_var</span>(parents));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_vars_size</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_all_var</span>(klass).<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写成员变量"><a href="#读写成员变量" class="headerlink" title="读写成员变量"></a>读写成员变量</h1><h2 id="AST定义-1"><a href="#AST定义-1" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:name</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义-1"><a href="#VM指令定义-1" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><p>对应了读和写两条指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;GetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;SetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>id是用于标识是这个对象field域中的对象编号</p><p>我目前是通过固定一个变量在field中的位置来读写变量，这样其实没有任何灵活性可言，无法支持动态定义新的变量。想要更灵活那就得存一个hash用名字索引才行，ruby中是这样做的。我这里也没有太想好要怎么样做，只能先做着，可能做下去以后再看就会有来新的看法。</p><p>写博客的时候意识到了存在一个很大的bug，就是我没有处理继承成员时的id…所以说关于id的方面就不要作为参考实现了，写下来只是作为一个出错记录。</p><h2 id="翻译过程"><a href="#翻译过程" class="headerlink" title="翻译过程"></a>翻译过程</h2><p>常规的读会直接翻译成对应的vm指令，从class表中获取要读的这个对象的编号</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_get_class_member_var</span><span class="params">(node)</span></span></span><br><span class="line">  GetClassMemberVar.new(get_class_var(node))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_class_var</span><span class="params">(var_obj)</span></span></span><br><span class="line">  cur_class_table.instance_vars[var_obj.name]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于成员变量的赋值，则是在assign中，如果被赋值的对象是一个AST::GetClassMemberVar的话，则会转换成一个SetClassMember指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_assign</span><span class="params">(node)</span></span></span><br><span class="line">  value = visit(node.expr)</span><br><span class="line">  <span class="keyword">if</span> value.is_a? Value <span class="keyword">or</span> value.is_a? Ref</span><br><span class="line">    value = push(value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> node.var_obj.is_a? Rc::AST::GetClassMemberVar</span><br><span class="line">    [value, SetClassMemberVar.new(get_class_var(node.var_obj))]</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res = visit(node.var_obj)</span><br><span class="line">    [value, SetLocal.new(res.ref)]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="keyword">if</span> node.is_a? Value</span><br><span class="line">    Push.new(node.value)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? Ref</span><br><span class="line">    GetLocal.new(node.ref)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? GetClassMemberVar</span><br><span class="line">    node</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&quot;Unsupported node type <span class="subst">#&#123;node.<span class="keyword">class</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而push也略有不同，函数的参数都是遍历然后对每一个进行push。在成员变量作为参数传入函数的时候，visit的结果则是一个GetClassMemberVar指令，因此需要添加对应的支持。</p><h2 id="VM实现"><a href="#VM实现" class="headerlink" title="VM实现"></a>VM实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> SetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">set_value</span>(inst.id, _eval_stack.<span class="built_in">pop</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> GetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    _eval_stack.<span class="built_in">push</span>(obj-&gt;<span class="built_in">get_number_field</span>(inst.id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set与get的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span><span class="params">(<span class="keyword">int</span> index, RcObject *value)</span> </span>&#123;</span><br><span class="line">    fields[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    fields[index] = <span class="keyword">reinterpret_cast</span>&lt;RcObject*&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RcObject *<span class="title">get_ptr_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fields[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">get_number_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(fields[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields是<code>std::vector&lt;RcObject*&gt; fields</code> 用于保存所有的成员</p><p>由于stack中取出来的是值，那么我们直接将值转换为指针赋值给成员，如果成员确实是值，那么我们将成员转换为指针存储（这里是一个非常不安全的操作，也许应该添加检查）。取的时候再根据需要取出不同的值</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>多态以及接口这些，现阶段是不需要做的。因为目前偏向于鸭子类型，只要你有同名方法就OK，不需要走什么接口。等到后面加上了各种类型相关的操作再考虑引入这些东西</p><p>关于鸭子类型，wiki是这样写的</p><blockquote><p><strong>鸭子类型</strong>（英语：<strong>duck typing</strong>）在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" >程序设计<i class="fas fa-external-link-alt"></i></a>中是<a class="link"   href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1" >动态类型<i class="fas fa-external-link-alt"></i></a>的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" >方法<i class="fas fa-external-link-alt"></i></a>和属性的集合”决定</p></blockquote><p>实现oop的时候许多地方已经开始和类型系统强相关了。现在许多语言中也可以兼顾动态类型，kotlin和C#都有类似于dynamic class的概念。现在先按照动态类型的实现来做，即便之后要全面切入到静态类型，这些依然可以作为动态类型的类的实现</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>很多地方都不知道该如何设计，同时也有应付了事的成分…目前的开发流程算是一次试水吧，后面的时候我会尽量克制应付了事的冲动，不仅是在代码上，做其他的事情我也是容易有相同的问题。昨天钢琴课老师也说，一定要先着重练好手型再去弹，速度多慢都不要紧，这另一种方面也是一种需要克制住“对手型应付了事”的冲动，克制住去做后面更有意思的事情的冲动。克制这件事不仅牵扯到能否做好，如果不克制可能还会浪费更多的时间，这对于时间本就不充足的我是一个很大的影响，在克制这方面我还是要多下功夫。</p><p>过一段时间可能会迁移到另一门语言上，那个时候可以从头梳理一遍目前所做过的决策，同时对好的进行保留，坏的进行剔除。前面的parser我觉得写的一塌糊涂，而且这几周的内容也能看出来很多地方开始乱搞了，都是没有决定好一个语言的方向，导致一个地方偏向这个样子，另一个地方又会偏向完全相反的样子。</p><p>要着重注意的是，重构是好的，但不要过于依赖重构来保证代码的好设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分&lt;/p&gt;
&lt;h1 id=&quot;类的符号信息&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记8 OOP之成员函数调用</title>
    <link href="https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/"/>
    <id>https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/</id>
    <published>2022-02-12T02:45:49.000Z</published>
    <updated>2022-02-12T03:47:10.851Z</updated>
    
    <content type="html"><![CDATA[<p>本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。</p><h1 id="成员函数调用的过程"><a href="#成员函数调用的过程" class="headerlink" title="成员函数调用的过程"></a>成员函数调用的过程</h1><p>我们先来想一下这个过程大致是怎样的</p><ol><li>被调用对象<br>非静态方法的时候首先成员函数要依赖于一个具体的对象，那么我们则需要在调用之前先将被调用对象的指针push到栈上</li><li>方法查找<br>根据对象的信息找到对应的类表，然后在类表中找到对应方法的地址（牵扯到继承的话也是在这里找父类的方法）</li></ol><h1 id="编译器的实现"><a href="#编译器的实现" class="headerlink" title="编译器的实现"></a>编译器的实现</h1><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>成员函数调用的AST是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMemberAccess</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:instance_name</span>, <span class="symbol">:member_name</span>, <span class="symbol">:args</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实这里当初设计想的是能够同时支持函数和成员变量的调用（也会加上无括号调用），但是我们现在认为它就是一个成员函数调用</p><h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_class_member_access</span><span class="params">(access)</span></span></span><br><span class="line">  argc = access.args.size</span><br><span class="line">  push_this = <span class="keyword">if</span> access.instance_name == <span class="string">&quot;self&quot;</span></span><br><span class="line">    PushThis.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push Ref.new cur_fun_env[access.instance_name].id</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  call = Call.new(access.member_name, argc)</span><br><span class="line">  [push_this] + access.args.map&#123; <span class="params">|arg|</span> push(visit(arg))&#125; + [call]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  [PushThis.new] + fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(fun_call.name, fun_call.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>再对比看一下旧的fun_call</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(<span class="variable">@cur_class_name</span>, fun_call.name)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>没什么可讲的，非常直观</p><h1 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h1><h2 id="call的实现思路"><a href="#call的实现思路" class="headerlink" title="call的实现思路"></a>call的实现思路</h2><p>之前的call的参数是一个类和一个函数名，完全可以说是用于静态函数调用的做法。（关于静态函数调用的实现我们之后再考虑）</p><p>上面提到非静态方法需要依赖于具体对象，因此我们需要先将被调用对象的指针push到栈上。而类信息可以从对象上获取，因此不需要call参数中的类型名。而获取指针则需要知道有多少个参数，因此我们需要传递进去参数的数量。这个做法也可以处理变长参数的情况</p><p>传递参数数量在ruby中也是类似的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0004</span> opt_mult &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;[CcCr]</span><br></pre></td></tr></table></figure><p>写到这里的时候我突然想到了一个问题，为什么要先push被调用对象指针？顾思考了一下，如果在push完所有参数之后再push被调用对象指针则前面的参数无法直接作用于被调用函数中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f);</span><br><span class="line">    <span class="keyword">if</span>(fun.begin == UndefinedAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        fun.begin = <span class="built_in">load_method</span>(obj-&gt;<span class="built_in">klass</span>(), f, fun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc + <span class="number">1</span>, obj);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    <span class="built_in">set_pc</span>(fun.begin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXEC_LOG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; new PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot; ret pc:&quot;</span></span><br><span class="line">        + std::<span class="built_in">to_string</span>(_eval_stack.<span class="built_in">current_frame</span>()-&gt;<span class="built_in">ret_addr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很直观，先获取被调用对象，之后找到函数，开始处理调用栈，除了获取调用对象的部分和之前差不多。而栈帧会多保存一个当前的obj。在这里我新记录了调用栈的深度，便于调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">size_t</span> argc, <span class="keyword">size_t</span> locals, <span class="keyword">size_t</span> ret_addr, RcObject *this_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.set stack base</span></span><br><span class="line">    <span class="keyword">auto</span> *base = <span class="built_in">get_args_begin</span>(argc);</span><br><span class="line">    <span class="comment">// 2.alloc local var space</span></span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(base, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(locals));</span><br><span class="line">    <span class="comment">// 3.create new stack frame</span></span><br><span class="line">    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr, this_ptr);</span><br><span class="line">    <span class="comment">// 4.increase depth</span></span><br><span class="line">    ++_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set_pc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了一个控制pc是否递增的成员，pc跳转的时候不应当继续递增pc，所以在各种跳转指令中都会直接使用set_pc</p><p>而递增的逻辑也相应的发生了变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_pc_need_incr)</span><br><span class="line">    &#123;</span><br><span class="line">        ++_pc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _pc_need_incr = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。&lt;/p&gt;
&lt;h1 id=&quot;成员函数调用的过程&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记7 GC也没有那么可怕 其一</title>
    <link href="https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/"/>
    <id>https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/</id>
    <published>2022-02-06T04:36:30.000Z</published>
    <updated>2022-02-12T03:46:28.889Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。</p><p>由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说，<del>可以等到下周养肥再一起看</del></p><p>本周从质和量来说都无法令人满意，状态比较差要写不下去了，但是起码比咕了强</p><h1 id="GC的对象表示"><a href="#GC的对象表示" class="headerlink" title="GC的对象表示"></a>GC的对象表示</h1><p>对象被保存在内存中，而对象则分为<strong>头</strong>和<strong>域</strong>两部分。</p><p>其中头被用于标识对象信息，比如说类型，以及gc的tag信息，利用tag信息来判断当前对象的状态</p><p>域则是能够被编程语言访问到的部分。域很显然可能是一个值，也可能是一个指向对象的指针</p><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>让我们看一下Ruby的RObject的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Basic part, including flags and class. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span> <span class="title">basic</span>;</span></span><br><span class="line">    <span class="comment">/** Object&#x27;s specific fields. */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> numiv;</span><br><span class="line">            VALUE *ivptr;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">st_table</span> *<span class="title">iv_index_tbl</span>;</span></span><br><span class="line">        &#125; heap;</span><br><span class="line">        VALUE ary[ROBJECT_EMBED_LEN_MAX];</span><br><span class="line">    &#125; as;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不需要关心过多的细节，可以看到很明显是分为了头和域两部分。</p><p>让我们再来看一下头部 RBasic</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct</span></span><br><span class="line"><span class="function"><span class="title">RUBY_ALIGNAS</span><span class="params">(SIZEOF_VALUE)</span></span></span><br><span class="line"><span class="function">RBasic </span>&#123;</span><br><span class="line">    VALUE flags;</span><br><span class="line">    <span class="keyword">const</span> VALUE klass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，一个标记和一个类信息。Ruby采用的也是标记算法，这里有flags保存标记信息</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>再来看一下Python的实现。这次我们从头部开始看起</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>Object本质上是对象的头部信息。python是通过引用计数实现的GC，可以看到有一个ob_refcnt，同时还有一个保存Type的对象，</p><p>第一行的_PyObject_HEAD_EXTRA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到这是为了方便测试以及跟踪执行情况而添加的内容</p><p>看一下Python的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>其中的ob_size是用于可变长对象使用的，例如List</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Python是每个对象的头部有一个PyObject的指针，不同的类型是基于这个扩展的</p><p>而Ruby是每个对象是一个RObject，对象内部也有一个相同的头部RBasic，而不同的类型都是RObject本身</p><p>虽然实现的方式略有不同，但是本质上还是一样的。而对于GC的实现也是一样，所以我们之后只是大概提一下实现方式的本质</p><h1 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h1><p>在这里只简单谈及标记清除、引用计数以及复制，这三者是最基本的算法，改进版本暂且也不会提及，本周的内容的目的只是希望读者能够对GC有一些了解。其他算法都是从它们衍生出来的本质并没有发生变化（<del>其实主要是因为我只看了这三个</del>）</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除，我个人觉得用追溯更形象一些，因为需要从一些节点开始遍历访问所有的对象，对这些对象设置上tag，之后再对没有打上tag的对象进行回收</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在对象的头部设置一个字段用于标记有几个对象正在应用当前对象，在被创建的时候会设置标记为1，而被一个新的对象引用的时候计数就加1</p><p>当然这个做法存在一个很明显的问题，就是如果两个对象互相保存了对方的引用，那么就会造成循环引用的情况。C++的智能指针也是使用循环计数，因此依然会遇到这样的问题，而在C++中的解决方案是需要使用一个不获取对象所有权的weak_ptr来解决这个问题。</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>对于复制算法来讲，实际上将堆等分为两部分。一部分是正在使用的空间，另一部分是作为复制的临时空间。</p><p>复制算法将所有的活动对象从当前正在使用的空间复制到临时空间，之后直接将两块空间交换，也就是说没被复制的对象直接被销毁了</p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>垃圾回收的算法与实现</p><p>Python源码剖析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。&lt;/p&gt;
&lt;p&gt;由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说</summary>
      
    
    
    
    <category term="GC" scheme="https://fusionbolt.github.io/categories/GC/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
</feed>
