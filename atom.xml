<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2022-03-20T07:12:35.050Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rc-lang开发周记12 部分Parser</title>
    <link href="https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/"/>
    <id>https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/</id>
    <published>2022-03-20T04:16:15.000Z</published>
    <updated>2022-03-20T07:12:35.050Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-12/IMG_2114.JPG"                      alt="IMG_2114"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:95518122</center> <p>本周内容主要就是parser，而ast的内容会穿插其中</p><h1 id="Parser的一些问题"><a href="#Parser的一些问题" class="headerlink" title="Parser的一些问题"></a>Parser的一些问题</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>由于是由换行来分句，我觉得一个头疼的点在于要想清楚哪里要换行，想清楚这个parser都是由什么组成，然后拼接在一起。但是写到这里的时候我才想到如果表达式有多行（这个也是非常常见的情况）就支持不了了…以后再做支持吧，这个或许可以对于表达式单独添加换行的支持。</p><p>我目前的换行策略是统一由stmt以及item吃掉eol，其中的子parser是不会处理eol的。stmt是很自然的，一行是一个stmt，item的话目前则是由函数或者class组成，而函数和class也不需要管理换行统一由item管理</p><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><p>这个问题留到下次再讲<del>（因为我还没写）</del></p><h1 id="关于设计"><a href="#关于设计" class="headerlink" title="关于设计"></a>关于设计</h1><p>在重写的时候发现很多原来的设计并不好，但是又一时不知该如何设计。后面觉得还是先实现一种，先功能完备再来考虑美化语法</p><p>关于具体的设计还是要看parser和ast的实现</p><h1 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(id: <span class="type">Id</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">String</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br></pre></td></tr></table></figure><p>关于Expr, Stmt, Block之间不知道以什么样的形式比较好，就暂且学习了Rust的做法。自己不知道怎么做那去学习一些比较好的语言，这样的想法我觉得应该是没问题的。之前做的时候也是经常会参考Ruby的实现</p><p>关于Expr我就不一个个放parser了，大部分比较简单没有什么可讲的内容。着重讲几个关键的点。代码中出现log的部分可以忽略</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="ast的变化"><a href="#ast的变化" class="headerlink" title="ast的变化"></a>ast的变化</h3><p>首先ast的定义相比于之前发生了变化</p><p>这是之前if的ast定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>参考了rust中的if而现在转换成了这个样子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br></pre></td></tr></table></figure><p>false_branch可以是一个普通的else，也可以是接的另一个if，也就是将elsif这一语法糖还原为原始的if了，而elsif的if里又是同样的定义</p><p>同时之前的if是一个stmt，而现在的if是expr。返回的是对应分支block的返回值。block是由多个stmt组成，其返回值则是最后一条stmt</p><h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span></span>: <span class="type">Parser</span>[<span class="type">Block</span>] = positioned &#123;</span><br><span class="line">  rep(statement) ^^ (stmts =&gt; <span class="type">Block</span>(stmts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiLineIf</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">IF</span> ~&gt; expr) ~ block ~ elsif.* ~ (oneline(<span class="type">ELSE</span>) ~&gt; block).? &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ if_branch ~ elsif ~ else_branch</span><br><span class="line">    =&gt; <span class="type">If</span>(cond, if_branch, elsif.foldRight(else_branch.asInstanceOf[<span class="type">Option</span>[<span class="type">Expr</span>]])(</span><br><span class="line">      (next, acc) =&gt; <span class="type">Some</span>(<span class="type">If</span>(next.cond, next.true_branch, acc))))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elsif</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">ELSIF</span> ~&gt; termExpr) ~ block ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ branch =&gt; <span class="type">If</span>(cond, branch, <span class="type">None</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到elsif在这里被编译为了if，多个elsif则是被编译为了一个List[If]，在这里通过FoldRight的方式折叠为一个if。以else为初始值，不断的将List最右边的元素设置为下一个if的else</p><p>逻辑展开是这样的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">C</span>, <span class="type">ELSE</span>: <span class="type">Option</span>[<span class="type">Expr</span>]</span><br><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))</span><br><span class="line"><span class="type">A</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>)))</span><br><span class="line"><span class="type">Some</span>(<span class="type">IF</span>(<span class="type">A</span>.cond, <span class="type">A</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))))</span><br></pre></td></tr></table></figure><p>代码中出现的asInstanceOf是因为我不知道这里的类型是怎样处理的，索性通过这种方式来回避编译错误。</p><h2 id="termExpr"><a href="#termExpr" class="headerlink" title="termExpr"></a>termExpr</h2><p>termExpr只是为了parser的时候区分各种expr的一种方式，所以ast表示上是和常规的expr是一样的。可以看到term是一些可以用于各种操作符的东西，比如说1 + 1，1是一个term，整个是一个termExpr。后面我们需要将这一系列的term和operator组合成一个expr，因此需要有后面的termToBinary</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  multiLineIf | termExpr | ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | call | memField | memCall | idExpr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于termsToBinary的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BinaryTranslator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> opDefaultInfix = <span class="type">HashMap</span>(<span class="string">&quot;+&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;-&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;*&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;/&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;&gt;&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;&lt;&quot;</span>-&gt;<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findMaxInfixIndex</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Int</span> =</span><br><span class="line">    terms</span><br><span class="line">      .zipWithIndex</span><br><span class="line">      .filter((x, _) =&gt; x.isInstanceOf[<span class="type">OPERATOR</span>])</span><br><span class="line">      .map((x, index) =&gt; (x.asInstanceOf[<span class="type">OPERATOR</span>], index))</span><br><span class="line">      .minBy((op, index) =&gt; opDefaultInfix(op.op))._2</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">replaceBinaryOp</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>], index: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Positional</span>] = &#123;</span><br><span class="line">    <span class="keyword">var</span> t = terms(index)</span><br><span class="line">    <span class="keyword">val</span> left = terms.slice(<span class="number">0</span>, index - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> bn = <span class="type">Expr</span>.<span class="type">Binary</span>(</span><br><span class="line">      terms(index).asInstanceOf[<span class="type">OPERATOR</span>].op,</span><br><span class="line">      terms(index - <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>],</span><br><span class="line">      terms(index + <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>])</span><br><span class="line">    <span class="keyword">val</span> rights = terms.slice(index + <span class="number">2</span>, terms.size)</span><br><span class="line">    left.appended(bn):::(rights)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(term: <span class="type">Expr</span>, terms: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Positional</span>]]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> terms.isEmpty then <span class="keyword">return</span> term</span><br><span class="line">    termsToBinary(term :: terms.flatten)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> newTerms = terms</span><br><span class="line">    <span class="keyword">while</span> (newTerms.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> max_index = findMaxInfixIndex(newTerms)</span><br><span class="line">      newTerms = replaceBinaryOp(newTerms, max_index)</span><br><span class="line">    &#125;</span><br><span class="line">    newTerms.head.asInstanceOf[<span class="type">Expr</span>.<span class="type">Binary</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑：</p><ol><li><p>如果只有开头的一个term则返回该term</p><p>否则将开头的和后面的terms组合起来进行处理</p></li><li><p>找到最高优先级的op的位置</p></li><li><p>将该位置以及左右的term组合为一个expr并且替换</p></li><li><p>重复这个过程直至剩下一个term</p></li></ol><p>这里我觉得实现的有点脏…基本上是把我用ruby写的那一套抄过来了，我一时也没想到什么好的方案</p><p>由于要对替换以后的expr再进行组合，这个过程中index会发生变动；如果要将组合后的拿出来，那还要处理哪些是拿出来的哪些是没有拿出来的，这样获取前后的term也会很不方便</p><h1 id="Stmt"><a href="#Stmt" class="headerlink" title="Stmt"></a>Stmt</h1><h2 id="ast-1"><a href="#ast-1" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Id</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Id</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br></pre></td></tr></table></figure><p>这里的while和rust的不太一样，rust的while也是一个expr，尽管能够从理性上认识到这样做是为了返回最后一个block的结果，但我仍然觉得这个做法好奇怪。目前还是先将其作为stmt，以后发现了哪里不合适再进行修正</p><h2 id="parser-1"><a href="#parser-1" class="headerlink" title="parser"></a>parser</h2><p>这边也比较简单。内容不多就直接贴出来了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">VAR</span> ~&gt; id) ~ (<span class="type">EQL</span> ~&gt; termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Local</span>(id, <span class="type">Type</span>.<span class="type">Nil</span>, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret</span></span>: <span class="type">Parser</span>[<span class="type">Return</span>] = positioned &#123;</span><br><span class="line">  <span class="type">RETURN</span> ~&gt; termExpr ^^ <span class="type">Return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assign</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">Assign</span>] = positioned &#123;</span><br><span class="line">  (id &lt;~ <span class="type">EQL</span>) ~ termExpr ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Assign</span>(id, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileStmt</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">While</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">WHILE</span> ~&gt; parSround(termExpr)) ~ block &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ body =&gt; <span class="type">Stmt</span>.<span class="type">While</span>(cond, body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果读者能够读到这里（<del>虽然并不会有几个人，其中大概也不会有追更的</del>），那很大概率不嫌弃我的内容，在这里可能要提前和各位说一声对不起，下周很有可能将是我第二次断更。（其实本周也有好几天都没写了…）</p><p>下周工作之外的事情除了最低限度的练琴，我会尽可能的不去做什么事情。眼睛疼（写的现在也在疼），精神极其不稳定（经常不受控制的胡思乱想），这些都是原因。</p><p>我也不想停，重写的进程还是比较慢，我的开发效率又偏低同时又要各种测试确保正确性。我好想赶快把这些基础的迁移完，然后去学习做优化，学习加上类型系统，等等，还想要多学习一些Scala，除此之外有很多创意想要实现还想去学swiftUI</p><p>但是或许此刻再不停就真的要断线了，我需要花时间好好冷静一下，平复情绪，进行休整。我无法努力获得温暖，那就只有努力去平复情绪。面对至今为止最重要也最大的挑战（当前的不良状态），我也应该拿出应有的态度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-12</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记11 重构与Lexer</title>
    <link href="https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/"/>
    <id>https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/</id>
    <published>2022-03-13T03:08:42.000Z</published>
    <updated>2022-03-13T08:33:02.179Z</updated>
    
    <content type="html"><![CDATA[<p>本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。</p><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>vm目前代码很少，做的重构主要是将一些东西抽象拆分出来</p><p>这是之前vm的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line"><span class="keyword">size_t</span> _pc = <span class="number">0</span>;</span><br><span class="line">EvalStack _eval_stack;</span><br><span class="line">std::string _cur_fun;</span><br><span class="line"><span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> _pc_need_incr = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relative_pc</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">size_t</span> <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EvalStack&amp; <span class="title">eval_stack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _eval_stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string&amp; klass, <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> FunInfo&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">pc_need_incr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc_need_incr; &#125;</span><br></pre></td></tr></table></figure><h2 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h2><p>首先就是关于pc的部分，零碎的放在了vm的实现中，我们单独将这些实现挑出来作为一个类来实现，因此就有了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PC</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PC</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">absolute_jump</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relative_jump</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">size_t</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">current</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">force_need_incr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _inst_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _need_increase = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>其次是代码段的内容。和代码段相关的虽然只有一个指令的vector和一个load method方法，但是为了组件之间减少耦合、方便测试还是要拆出来（虽然我还没有写更多的测试…）。最后结果是多了一个这样的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string &amp;klass, <span class="keyword">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> FunInfo &amp;f)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; <span class="built_in">inst_list</span>() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;VMInst&gt; <span class="title">get_inst</span><span class="params">(<span class="keyword">size_t</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;VMInst&gt; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构后的成员"><a href="#重构后的成员" class="headerlink" title="重构后的成员"></a>重构后的成员</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function">PC <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EvalStack &amp;<span class="title">eval_stack</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _eval_stack; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">out_of_code_segment</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMInstVisitor</span>;</span></span><br><span class="line">    std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">    CodeSegment _code_segment;</span><br><span class="line">    EvalStack _eval_stack;</span><br><span class="line">    std::string _cur_fun;</span><br><span class="line">    <span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line">    PC _pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上去清爽了许多。目前先改到这里了</p><h1 id="相关前置知识"><a href="#相关前置知识" class="headerlink" title="相关前置知识"></a>相关前置知识</h1><p>之后的内容开始设计lexer和parser。假设读者没有相关知识，我先来大概讲一下编译器从源码生成到ast的流程。</p><ol><li><p>对输入的源码进行分词，生成一系列Token，我们称之为词法分析</p><p>分词是什么呢？说的直白一些就是把字符串划分开，哪一部分是名字，哪一部分又是空格，哪一部分是数字，诸如此类。Token就是表明了这个东西到底是哪种词，如果不明白可以看后面的代码部分。</p></li><li><p>将Token根据特定的规则进行解析，生成抽象语法树，我们称之为语法分析</p></li></ol><p>这些过程的实现方式不外乎两类</p><ol><li>使用生成器进行生成：常见的是Lex（生成词法分析器） + YACC（生成语法分析器）。这些需要自己编写一下规则，喂给生成器进行生成</li><li>自行手写实现：手写的灵活性灵活度是会比生成器要高的，但是相对比较复杂</li></ol><p>关于手写方式有一种叫parser combaintor的技术，能够通过组合不同的函数来实现解析，实现起来自然是比传统的手写方式方便，而我这里选择的也正是这种方案</p><h1 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h1><p>虽说是parser，但是肯定还是要先做分词的。之前的实现中是没有做分词的，很多地方都搞的比较难受。一开始我还疑惑了一会使用parser combaintor是否还要做分词，但是写了一会意识到还是需要，虽然可以直接隐含了分词的部分，但是这样会把两类逻辑全部糊在一起，对于调试、测试都是非常难受的问题，而且对于空格、换行之类的也会非常麻烦。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>先来看一下Token的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Token</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OPERATOR</span>(op: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> <span class="type">EOL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">COMMA</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">EQL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SPACE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">IF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">THEN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSIF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">WHILE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">CLASS</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SUPER</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><p>通过extends Positional进而让Token都携带了位置信息（行号列号）</p><p>这是一份不是很好的定义。写这个的时候来不及改了，下周会改正，但是在这里将这个不太好的范例拿出来讲。我一开始也觉得这样很奇怪，但是也没深入思考有没有什么更好的方式（再一次见到了自己的惰性），对于Token来说这样平着展开也不能说不对，但是可以做得更好</p><p>后来看到Rust中Token的一些地方我才反应过来，还是应该将keyword和一些间隔符单独揪出来，而不是这么完全扁平化。写这篇的时候来不及改了，只能拖到下周再说了</p><h2 id="一些简单的实现"><a href="#一些简单的实现" class="headerlink" title="一些简单的实现"></a>一些简单的实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NoValueToken</span></span>(str: <span class="type">String</span>, token: <span class="type">Token</span>): <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">    str ^^^ token</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eol</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;\n&quot;</span>, <span class="type">EOL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eql</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;=&quot;</span>, <span class="type">EQL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comma</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;,&quot;</span>, <span class="type">COMMA</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trueLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;true&quot;</span>, <span class="type">TRUE</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">falseLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;false&quot;</span>, <span class="type">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;var&quot;</span>, <span class="type">VAR</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;val&quot;</span>, <span class="type">VAL</span>)</span><br></pre></td></tr></table></figure><p>这个也非常简单，读取到对应的字符串直接返回对应的token。外面包了positioned以后内部的内容就能够携带行号和列号的信息</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ops</span> </span>= <span class="string">&quot;[+\\-*/%^~!&gt;&lt;]&quot;</span>.r</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  ops ^^ <span class="type">OPERATOR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个通过正则表达式匹配的例子，这里的^数量由三个变成了两个，三个的情况下是左边的条件匹配成功则返回右边的值，而两个的情况下是条件匹配成功后执行右边的函数并且返回其值。</p><p>operator这里是通过正则表达式来进行匹配，ops则是一个正则表达式</p><p>这里可能有一些引起困惑的地方。为什么下面需要返回函数的时候填的是返回的类型？我没有正经学过Scala，用我在其他语言学过的东西来说这大概是因为虽然OPERATOR本身是类型，但在这里是一个值构造器，用另一种表达方式的话就是一个传入OPERATOR所需参数返回一个OPERATOR实例的函数</p><p>这里我可能解释的不是很正确，如有哪里用词/描述不当还请联系我指出</p><h2 id="间隔符与非间隔符"><a href="#间隔符与非间隔符" class="headerlink" title="间隔符与非间隔符"></a>间隔符与非间隔符</h2><p>核心代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allTokens</span></span>: <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">Token</span>]] = &#123;</span><br><span class="line">((rep1sepNoDis(repN(<span class="number">1</span>,notSpacer),spacer.+) ~spacer.*) |</span><br><span class="line"><span class="comment">// BAA is imposible</span></span><br><span class="line">(rep1sepNoDis(spacer.+, repN(<span class="number">1</span>,notSpacer)) ~notSpacer.?)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> list ~ t =&gt;</span><br><span class="line">      list</span><br><span class="line">        .fold(<span class="type">List</span>())(_:::_)</span><br><span class="line">        .concat(t <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(v) =&gt; <span class="type">List</span>(v)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">List</span>()</span><br><span class="line">          <span class="keyword">case</span> _ =&gt; t</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(_ != <span class="type">SPACE</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^^前都是解析的部分，解析部分的～是连接的意思，也就是说前面的解析完会接着解析后面的内容。后面处理的部分只是将每个解析部分生成的输出都连接起来，成为一个List[Token]。由于觉得用不到因此我在这里干掉了SPACE</p><p>其中出现过的一些函数的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">space</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  whiteSpace.+ ^^^ <span class="type">SPACE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notSpacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = keyword | value | eol</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = symbol | operator | eql | space</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keyword</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = stringLiteral | trueLiteral | falseLiteral |</span><br><span class="line">    defStr | endStr | ifStr | thenStr | elsifStr | elseStr | whileStr |</span><br><span class="line">    classStr | superStr | varStr | valStr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbol</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = comma | eol | leftParentTheses | rightParentTheses | leftSquare | rightSquare</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = number | identifier</span><br></pre></td></tr></table></figure><p>这里对我来说是一个比较难写的点，上周在写的时候头痛了好一阵子，想明白逻辑以后再回来看会好很多</p><h3 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h3><p>这里的逻辑是这样的：我们先定义不能作为间隔符的为A（notSpacer），可以作为间隔符的为B（spacer），那么我们需要的是A(B+A)*B*，或者是B+(AB+)*A?</p><p>注：这里的*+?都是正则表达式的语义</p><h3 id="拆分逻辑"><a href="#拆分逻辑" class="headerlink" title="拆分逻辑"></a>拆分逻辑</h3><p>关于为什么要这么设定，我们先从B开始。</p><ol><li><p>可以看到B包含了一些运算符，空格，一些标点符号，这些本身是和任何字符相连都是无歧义的（目前来说B中的内容是无歧义的），那么它们连续存在依然不会产生歧义。B本身是要存在的，因此这里可以推导出B+</p></li><li><p>而A中的内容，比如说两个keyword之间一定要有空格，不然会被识别成一个identifier了，比如说传递参数的时候需要逗号分开（symbol），那么A是不可能连续存在的，因此这里可以推导出A</p></li><li><p>由于我们需要A和B间隔放置，我首先想到的是rep1sep(A, B+)，而由于A和B都可能在第一个，因此有了rep1sep(A, B+) | rep1sep(B+, A)。（repsep举个例子，repsep(str, ‘,’)，对应的就是str, str, str这种以，分割的）但是repsep会扔掉B，因此我从rep1sep抄了一份修改了一下，变成了不扔掉B的版本</p><p>以下rep1sepNoDis都用rep1sep代替</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sepNoDis</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~ p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y.map(x =&gt; <span class="type">List</span>(x._1.asInstanceOf[<span class="type">T</span>], x._2)).fold(<span class="type">List</span>())(_:::_)&#125;</span><br></pre></td></tr></table></figure><p>原版</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sep</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~&gt; p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y&#125;</span><br></pre></td></tr></table></figure><ol><li>但是只是repsep的做法无法处理AB（会残留一个B未解析），那么很自然的就会想到再后面接一个可选的B，因此就有了rep1sep(A, B+) ~ B?，同理无法处理BA，也就有了 rep1sep(B+, A) ~ A? 组合起来就有了 rep1sep(A, B+) ~ B? | rep1sep(B+, A) ~ A? </li></ol><p>事后回顾思路还算是捋的比较清晰，一直这样写或许也会有利于我之后写代码的时候逻辑梳理的能力。不过当时写的时候真的是整个人都不好了…这块写代码的时候想了半天，写博客尽管逻辑很流畅了但是还是写了很久</p><h3 id="逻辑与实现的一些出入"><a href="#逻辑与实现的一些出入" class="headerlink" title="逻辑与实现的一些出入"></a>逻辑与实现的一些出入</h3><p>拆分完逻辑后将</p><p>rep1sep = rep1sepNoDis</p><p>A = notSpacer</p><p>B = spacer</p><p>代入后，会发现有一些不一样的地方。我在rep1sep的A中做了repN(1, A)的操作。至于为什么这么写，是为了保证A和B哪一个在前哪一个在后都可以使用。一个值和一个List交换顺序还能连接的实现不知道有什么可用的，自己尝试写了一个</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l: <span class="type">List</span>[<span class="type">T</span>], v: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = l:::v::<span class="type">Nil</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](v: <span class="type">T</span>, l: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = v::l</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l1: <span class="type">List</span>[<span class="type">T</span>], l2: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = l1:::l2</span><br></pre></td></tr></table></figure><p>但是和前面的函数组合起来，在处理的时候一些看起来很自然的东西并没有通过类型检查，对于Scala的类型理解不到位也难以解决问题，因此就只好先这个样子。虽然用起了Scala，但是并没有学太多，凭着其他语言的经验直接就来写</p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><p>这么说过于抽象，我们通过看测试来实际理解以下例子。</p><p>之所以要搞得这么复杂，是因为最后一个测试用例的那种情况。对于我之前lexer和parser混在一起写的做法处理这样的情况是非常难的。不过我不敢说已经想全面了，有问题再改吧</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&quot;spacer&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// a is notSpacer, b is spacer</span></span><br><span class="line">it(<span class="string">&quot;AB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>), <span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BAB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; id &quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABABB space and eol&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;def f \n&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>), <span class="type">EOL</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; def f&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;only space&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; &quot;</span>, <span class="type">List</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;local&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> v = <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;a&quot;</span>), <span class="type">EQL</span>, <span class="type">NUMBER</span>(<span class="number">1</span>))</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1 &quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a =1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a=1&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来是想写一些parser的内容的，但是没想到这个token间隔符相关的逻辑就花了我这么久的时间。这块我觉得写的还是相对比较清晰，也算是比较满意，所以本周就先这么结束了。关于token一般来说不会有什么特别的内容了，所以关于解析输入，之后基本上就是parser的内容了。</p><p>这个周我觉得进度比较慢，不会调加上前几天整个人都过于不稳定，回家会花一些时间在刷刷刷上，进而减少了编码的时间，不知道什么时候能做完重写啊…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。&lt;/p&gt;
&lt;h1 id=&quot;重构&quot;&gt;&lt;a href=&quot;#重构&quot; class=&quot;headerlink&quot; title=&quot;重构&quot;&gt;&lt;/a&gt;重构&lt;/h1&gt;&lt;p&gt;vm目前代码很少，做的重构主要是将一些东</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Lexer" scheme="https://fusionbolt.github.io/tags/Lexer/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记10 分支与循环</title>
    <link href="https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/"/>
    <id>https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/</id>
    <published>2022-03-05T03:56:29.000Z</published>
    <updated>2022-03-05T03:58:12.762Z</updated>
    
    <content type="html"><![CDATA[<p>开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来</p><p>本周更新的内容主要是修复之前的问题以及处理了分支循环</p><h1 id="继承与成员变量"><a href="#继承与成员变量" class="headerlink" title="继承与成员变量"></a>继承与成员变量</h1><p>首先是上周遗留的继承的情况下成员变量id会有问题，我们先来看一下成员变量相关的实现</p><ol><li>使用id标明</li><li>运行时存一个hash，按照名字来取</li></ol><p>我选择在添加parent的时候将parent的成员变量添加到当前的instance_vars中。这样需要布局在编译器确定，无法应对动态添加成员变量的情况，不过先不管那些</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_var_keys</span></span></span><br><span class="line">  <span class="variable">@instance_vars</span>.sort_by(&amp;<span class="symbol">:last</span>).map &#123;<span class="params">|k, _|</span>k&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_parents</span><span class="params">(parent_name, parent_table)</span></span></span><br><span class="line">  <span class="variable">@parent</span> = parent_name</span><br><span class="line">  <span class="keyword">unless</span> parent_table.is_a? ClassTable</span><br><span class="line">    raise <span class="string">&quot;parent_table should be a ClassTable&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  parent_table.instance_vars.each <span class="keyword">do</span> <span class="params">|var_name, _|</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">@instance_vars</span>.<span class="keyword">include</span>? var_name</span><br><span class="line">      add_instance_var(var_name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>最近才发现我还没有做分支以及循环的内容</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator"><a href="#translator" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_if</span><span class="params">(node)</span></span></span><br><span class="line">  list = node.stmt_list.map <span class="keyword">do</span> <span class="params">|cond, stmt|</span></span><br><span class="line">    c = visit(cond)</span><br><span class="line">    s = [visit(stmt), JumpAfterIf.new].flatten</span><br><span class="line">    cmp_and_jmp = push_eq_jmp(s.size)</span><br><span class="line">    [c, cmp_and_jmp, s].flatten</span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line">  els = visit(node.else_stmts)</span><br><span class="line">  list = list + els</span><br><span class="line">  list.each_with_index <span class="keyword">do</span> <span class="params">|inst, index|</span></span><br><span class="line">    <span class="keyword">if</span> inst.is_a? JumpAfterIf</span><br><span class="line">      list[index] = RelativeJump.new(list.size - index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  list</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_eq_jmp</span><span class="params">(true_branch_size)</span></span></span><br><span class="line">  [Push.new(<span class="number">1</span>), EQ.new, JumpFalse.new(true_branch_size + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每一组（if或者elsif）if条件和stmt进行遍历</p><ol><li><p>生成判断条件的指令</p></li><li><p>生成比较指令</p><p>将判断执行的结果与true进行eq操作，失败则跳转到下一组elsif，也就是true分支之后的第一条指令</p></li><li><p>生成当前组if中对应的true的分支</p><p>最后要添加一个跳转到整个if结束的指令</p></li></ol><h3 id="新指令"><a href="#新指令" class="headerlink" title="新指令"></a>新指令</h3><p>可以看到这里引入了几个新的指令</p><p>JumpAfterIf：用于跳转到if结束语句，提前占好指令位置，最后由RelativeJump代替</p><p>RelativeJump：跳转到一个相对地址</p><p>对于分支来说，判断指令也是需要的，因此还引入了GT，LT，EQ三个指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_op</span><span class="params">(op)</span></span></span><br><span class="line">  <span class="keyword">case</span> op.op</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    LT.new</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    GT.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&#x27;unsupported op&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">While</span> &lt; Struct.<span class="title">new</span>(:<span class="title">cond</span>, :<span class="title">body</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator-1"><a href="#translator-1" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_while</span><span class="params">(node)</span></span></span><br><span class="line">  cond = visit(node.cond)</span><br><span class="line">  body = visit(node.body).flatten</span><br><span class="line">  cmp_and_jmp = push_eq_jmp(body.size + <span class="number">1</span>)</span><br><span class="line">  while_inst = [cond, cmp_and_jmp, body].flatten</span><br><span class="line">  while_inst + [RelativeJump.new(-while_inst.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的内容更简单，相比if来说只需要处理一个分支判断和true的语句，最后加一个回到while开头的跳转即可</p><h1 id="指令的VM实现"><a href="#指令的VM实现" class="headerlink" title="指令的VM实现"></a>指令的VM实现</h1><h2 id="新的pc寻址方式"><a href="#新的pc寻址方式" class="headerlink" title="新的pc寻址方式"></a>新的pc寻址方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span> </span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidVM::<span class="built_in">relative_pc</span>(<span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="built_in">DEBUG_CHECK</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_pc) + offset &lt; <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;invalid pc, pc:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot;offset:&quot;</span> + std::<span class="built_in">to_string</span>(offset))</span><br><span class="line">    <span class="built_in">set_pc</span>(_pc + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> EQ &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::EQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> GT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::GT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> LT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::LT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里，我把一些binary的op做了一下处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(_opname, _op) \</span></span><br><span class="line"><span class="meta">   case BinaryOp::_opname: \</span></span><br><span class="line"><span class="meta">      push(v1 _op v2);     \</span></span><br><span class="line"><span class="meta">      break;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LT GT, FILO</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">        <span class="built_in">PUSH</span>(Add, +)</span><br><span class="line">        <span class="built_in">PUSH</span>(Sub, -)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mul, *)</span><br><span class="line">        <span class="built_in">PUSH</span>(Div, /)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mod, %)</span><br><span class="line">        <span class="built_in">PUSH</span>(EQ, ==)</span><br><span class="line">        <span class="built_in">PUSH</span>(LT, &lt;)</span><br><span class="line">        <span class="built_in">PUSH</span>(GT, &gt;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PUSH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的点是第一个pop出来的是表达式右侧的变量，因为栈是先进后出的。不仅比较操作需要注意，减法和除法也是如此</p><h2 id="RelativeJump"><a href="#RelativeJump" class="headerlink" title="RelativeJump"></a>RelativeJump</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(constRelativeJump &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JumpFalse"><a href="#JumpFalse" class="headerlink" title="JumpFalse"></a>JumpFalse</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]] <span class="keyword">const</span> JumpFalse &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cond = _eval_stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(cond == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>过于急切的去摸了一点oop的边，甚至连基本的分支跳转之类的都没有做，这么匆匆忙忙是否表示我已经不想做了呢…不管怎么说，这个坑决定开了，不想做也要做下去，做的烂总比什么都没做要强的多（最近几周的内容不论是数量还是质量都开始大幅下降了…</p><p>开始不想接着写当前的了，vm那边我觉得虽然没写多少但已经开始有屎山的倾向了，应该花点时间重新考虑下代码结构以及测试。</p><p>优化以及类型分析之类的我觉得还是换一门静态类型的语言来做。最近也在开始进行编译器重写的工作，好在实际上东西不是很多。重写过后就会从优化以及类型开始做一些工作，而下周开始可能会花更大比例的时间在重写上。尽管东西不多，但由于我对新语言对不熟悉，而且尽可能的改用好的设计，还是要花上一定的时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来&lt;/p&gt;
&lt;p&gt;本周更新的内容主要是修复之前的问题以及处理了分支循环&lt;/p&gt;
&lt;h1 id=&quot;继承与成员变量&quot;&gt;&lt;a href=&quot;#继承与成员变量&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记9 OOP之继承</title>
    <link href="https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/"/>
    <id>https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/</id>
    <published>2022-02-20T04:12:17.000Z</published>
    <updated>2022-02-20T04:54:14.092Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分</p><h1 id="类的符号信息"><a href="#类的符号信息" class="headerlink" title="类的符号信息"></a>类的符号信息</h1><p>对于之前的类表实现是只有方法和成员变量的，而现在在获取符号表信息遍历到class的时候需要再添加一个parent的信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span>, <span class="symbol">:parent</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="VM方法查找"><a href="#VM方法查找" class="headerlink" title="VM方法查找"></a>VM方法查找</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject *obj, <span class="keyword">const</span> string &amp;f, <span class="keyword">bool</span> super)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = super ? <span class="built_in">get_parent_class</span>(obj) : obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">method_search</span>(klass, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> string &amp;klass, <span class="keyword">const</span> string &amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;class_table = global_class_table[klass];</span><br><span class="line">    <span class="keyword">if</span> (class_table._methods.<span class="built_in">contains</span>(f)) &#123;</span><br><span class="line">        <span class="keyword">return</span> class_table._methods[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(class_table._parent.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MethodNotFoundException</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">method_search</span>(class_table._parent, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下之前的实现做一个对比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然多了去父类查找的部分。</p><h1 id="调用父类同名函数"><a href="#调用父类同名函数" class="headerlink" title="调用父类同名函数"></a>调用父类同名函数</h1><p>既然要继承了，那么也一定要涉及到调用父类的同名函数的问题。在上面的method_search的实现中，可以看到从obj查找method的时候有一个叫super的参数。因此如果要调用super的话一定是从父类开始查找，而不是从当前类</p><p>而这个在源代码中是通过一个super方法来实现的，大概是这个样子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span></span><br><span class="line">  <span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="AST定义"><a href="#AST定义" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:args</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="variable">@args</span> = args</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper<span class="subst">#&#123;args_to_s(<span class="variable">@args</span>)&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义"><a href="#VM指令定义" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span> &lt; Struct.<span class="title">new</span>(:<span class="title">argc</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:argc</span> =&gt; <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper <span class="subst">#&#123;argc&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意AST中保存的是实参，而指令中已经提前push好了参数，这里只需要传递一个argc用于寻找参数之前push的this指针就可以了</p><h2 id="ast翻译到vm指令的实现"><a href="#ast翻译到vm指令的实现" class="headerlink" title="ast翻译到vm指令的实现"></a>ast翻译到vm指令的实现</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_invoke_super</span><span class="params">(node)</span></span></span><br><span class="line">  [PushThis.new] + push_args(node.args.map) + [InvokeSuper.new(node.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="vm指令的执行"><a href="#vm指令的执行" class="headerlink" title="vm指令的执行"></a>vm指令的执行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> InvokeSuper &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">begin_call</span>(_eval_stack.<span class="built_in">current_method</span>(), inst.argc, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::begin_call</span><span class="params">(<span class="keyword">const</span> string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f, super);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也非常简单，比起之前的实现，现在begin_call里添加了一个super传递给method_search</p><h1 id="成员变量储存"><a href="#成员变量储存" class="headerlink" title="成员变量储存"></a>成员变量储存</h1><p>既然要继承，那么就要保存父类成员的变量。目前的做法是像ruby一样直接覆盖父类同名变量，因此在创建对象的时候获取整个类继承链中所有变量的集合，然后获取其长度，在创建变量的时候使用这个长度来分配对应的空间。</p><p>这个长度应该是编译期间就算出来的，这里这样写有一种应付的感觉…虽然说这样能够处理动态修改父类定义的方法，但是现在并没有做的那么动态，很多设计还没有敲定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">find_all_var</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> parents = global_class_table[klass]._parent;</span><br><span class="line">    <span class="keyword">auto</span> &amp;vars = global_class_table[klass]._vars;</span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">set</span>(vars.<span class="built_in">begin</span>(), vars.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(parents.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.<span class="built_in">merge</span>(<span class="built_in">find_all_var</span>(parents));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_vars_size</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_all_var</span>(klass).<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写成员变量"><a href="#读写成员变量" class="headerlink" title="读写成员变量"></a>读写成员变量</h1><h2 id="AST定义-1"><a href="#AST定义-1" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:name</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义-1"><a href="#VM指令定义-1" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><p>对应了读和写两条指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;GetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;SetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>id是用于标识是这个对象field域中的对象编号</p><p>我目前是通过固定一个变量在field中的位置来读写变量，这样其实没有任何灵活性可言，无法支持动态定义新的变量。想要更灵活那就得存一个hash用名字索引才行，ruby中是这样做的。我这里也没有太想好要怎么样做，只能先做着，可能做下去以后再看就会有来新的看法。</p><p>写博客的时候意识到了存在一个很大的bug，就是我没有处理继承成员时的id…所以说关于id的方面就不要作为参考实现了，写下来只是作为一个出错记录。</p><h2 id="翻译过程"><a href="#翻译过程" class="headerlink" title="翻译过程"></a>翻译过程</h2><p>常规的读会直接翻译成对应的vm指令，从class表中获取要读的这个对象的编号</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_get_class_member_var</span><span class="params">(node)</span></span></span><br><span class="line">  GetClassMemberVar.new(get_class_var(node))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_class_var</span><span class="params">(var_obj)</span></span></span><br><span class="line">  cur_class_table.instance_vars[var_obj.name]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于成员变量的赋值，则是在assign中，如果被赋值的对象是一个AST::GetClassMemberVar的话，则会转换成一个SetClassMember指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_assign</span><span class="params">(node)</span></span></span><br><span class="line">  value = visit(node.expr)</span><br><span class="line">  <span class="keyword">if</span> value.is_a? Value <span class="keyword">or</span> value.is_a? Ref</span><br><span class="line">    value = push(value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> node.var_obj.is_a? Rc::AST::GetClassMemberVar</span><br><span class="line">    [value, SetClassMemberVar.new(get_class_var(node.var_obj))]</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res = visit(node.var_obj)</span><br><span class="line">    [value, SetLocal.new(res.ref)]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="keyword">if</span> node.is_a? Value</span><br><span class="line">    Push.new(node.value)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? Ref</span><br><span class="line">    GetLocal.new(node.ref)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? GetClassMemberVar</span><br><span class="line">    node</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&quot;Unsupported node type <span class="subst">#&#123;node.<span class="keyword">class</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而push也略有不同，函数的参数都是遍历然后对每一个进行push。在成员变量作为参数传入函数的时候，visit的结果则是一个GetClassMemberVar指令，因此需要添加对应的支持。</p><h2 id="VM实现"><a href="#VM实现" class="headerlink" title="VM实现"></a>VM实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> SetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">set_value</span>(inst.id, _eval_stack.<span class="built_in">pop</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> GetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    _eval_stack.<span class="built_in">push</span>(obj-&gt;<span class="built_in">get_number_field</span>(inst.id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set与get的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span><span class="params">(<span class="keyword">int</span> index, RcObject *value)</span> </span>&#123;</span><br><span class="line">    fields[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    fields[index] = <span class="keyword">reinterpret_cast</span>&lt;RcObject*&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RcObject *<span class="title">get_ptr_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fields[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">get_number_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(fields[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields是<code>std::vector&lt;RcObject*&gt; fields</code> 用于保存所有的成员</p><p>由于stack中取出来的是值，那么我们直接将值转换为指针赋值给成员，如果成员确实是值，那么我们将成员转换为指针存储（这里是一个非常不安全的操作，也许应该添加检查）。取的时候再根据需要取出不同的值</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>多态以及接口这些，现阶段是不需要做的。因为目前偏向于鸭子类型，只要你有同名方法就OK，不需要走什么接口。等到后面加上了各种类型相关的操作再考虑引入这些东西</p><p>关于鸭子类型，wiki是这样写的</p><blockquote><p><strong>鸭子类型</strong>（英语：<strong>duck typing</strong>）在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" >程序设计<i class="fas fa-external-link-alt"></i></a>中是<a class="link"   href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1" >动态类型<i class="fas fa-external-link-alt"></i></a>的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" >方法<i class="fas fa-external-link-alt"></i></a>和属性的集合”决定</p></blockquote><p>实现oop的时候许多地方已经开始和类型系统强相关了。现在许多语言中也可以兼顾动态类型，kotlin和C#都有类似于dynamic class的概念。现在先按照动态类型的实现来做，即便之后要全面切入到静态类型，这些依然可以作为动态类型的类的实现</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>很多地方都不知道该如何设计，同时也有应付了事的成分…目前的开发流程算是一次试水吧，后面的时候我会尽量克制应付了事的冲动，不仅是在代码上，做其他的事情我也是容易有相同的问题。昨天钢琴课老师也说，一定要先着重练好手型再去弹，速度多慢都不要紧，这另一种方面也是一种需要克制住“对手型应付了事”的冲动，克制住去做后面更有意思的事情的冲动。克制这件事不仅牵扯到能否做好，如果不克制可能还会浪费更多的时间，这对于时间本就不充足的我是一个很大的影响，在克制这方面我还是要多下功夫。</p><p>过一段时间可能会迁移到另一门语言上，那个时候可以从头梳理一遍目前所做过的决策，同时对好的进行保留，坏的进行剔除。前面的parser我觉得写的一塌糊涂，而且这几周的内容也能看出来很多地方开始乱搞了，都是没有决定好一个语言的方向，导致一个地方偏向这个样子，另一个地方又会偏向完全相反的样子。</p><p>要着重注意的是，重构是好的，但不要过于依赖重构来保证代码的好设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分&lt;/p&gt;
&lt;h1 id=&quot;类的符号信息&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记8 OOP之成员函数调用</title>
    <link href="https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/"/>
    <id>https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/</id>
    <published>2022-02-12T02:45:49.000Z</published>
    <updated>2022-02-12T03:47:10.851Z</updated>
    
    <content type="html"><![CDATA[<p>本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。</p><h1 id="成员函数调用的过程"><a href="#成员函数调用的过程" class="headerlink" title="成员函数调用的过程"></a>成员函数调用的过程</h1><p>我们先来想一下这个过程大致是怎样的</p><ol><li>被调用对象<br>非静态方法的时候首先成员函数要依赖于一个具体的对象，那么我们则需要在调用之前先将被调用对象的指针push到栈上</li><li>方法查找<br>根据对象的信息找到对应的类表，然后在类表中找到对应方法的地址（牵扯到继承的话也是在这里找父类的方法）</li></ol><h1 id="编译器的实现"><a href="#编译器的实现" class="headerlink" title="编译器的实现"></a>编译器的实现</h1><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>成员函数调用的AST是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMemberAccess</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:instance_name</span>, <span class="symbol">:member_name</span>, <span class="symbol">:args</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实这里当初设计想的是能够同时支持函数和成员变量的调用（也会加上无括号调用），但是我们现在认为它就是一个成员函数调用</p><h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_class_member_access</span><span class="params">(access)</span></span></span><br><span class="line">  argc = access.args.size</span><br><span class="line">  push_this = <span class="keyword">if</span> access.instance_name == <span class="string">&quot;self&quot;</span></span><br><span class="line">    PushThis.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push Ref.new cur_fun_env[access.instance_name].id</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  call = Call.new(access.member_name, argc)</span><br><span class="line">  [push_this] + access.args.map&#123; <span class="params">|arg|</span> push(visit(arg))&#125; + [call]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  [PushThis.new] + fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(fun_call.name, fun_call.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>再对比看一下旧的fun_call</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(<span class="variable">@cur_class_name</span>, fun_call.name)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>没什么可讲的，非常直观</p><h1 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h1><h2 id="call的实现思路"><a href="#call的实现思路" class="headerlink" title="call的实现思路"></a>call的实现思路</h2><p>之前的call的参数是一个类和一个函数名，完全可以说是用于静态函数调用的做法。（关于静态函数调用的实现我们之后再考虑）</p><p>上面提到非静态方法需要依赖于具体对象，因此我们需要先将被调用对象的指针push到栈上。而类信息可以从对象上获取，因此不需要call参数中的类型名。而获取指针则需要知道有多少个参数，因此我们需要传递进去参数的数量。这个做法也可以处理变长参数的情况</p><p>传递参数数量在ruby中也是类似的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0004</span> opt_mult &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;[CcCr]</span><br></pre></td></tr></table></figure><p>写到这里的时候我突然想到了一个问题，为什么要先push被调用对象指针？顾思考了一下，如果在push完所有参数之后再push被调用对象指针则前面的参数无法直接作用于被调用函数中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f);</span><br><span class="line">    <span class="keyword">if</span>(fun.begin == UndefinedAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        fun.begin = <span class="built_in">load_method</span>(obj-&gt;<span class="built_in">klass</span>(), f, fun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc + <span class="number">1</span>, obj);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    <span class="built_in">set_pc</span>(fun.begin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXEC_LOG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; new PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot; ret pc:&quot;</span></span><br><span class="line">        + std::<span class="built_in">to_string</span>(_eval_stack.<span class="built_in">current_frame</span>()-&gt;<span class="built_in">ret_addr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很直观，先获取被调用对象，之后找到函数，开始处理调用栈，除了获取调用对象的部分和之前差不多。而栈帧会多保存一个当前的obj。在这里我新记录了调用栈的深度，便于调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">size_t</span> argc, <span class="keyword">size_t</span> locals, <span class="keyword">size_t</span> ret_addr, RcObject *this_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.set stack base</span></span><br><span class="line">    <span class="keyword">auto</span> *base = <span class="built_in">get_args_begin</span>(argc);</span><br><span class="line">    <span class="comment">// 2.alloc local var space</span></span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(base, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(locals));</span><br><span class="line">    <span class="comment">// 3.create new stack frame</span></span><br><span class="line">    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr, this_ptr);</span><br><span class="line">    <span class="comment">// 4.increase depth</span></span><br><span class="line">    ++_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set_pc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了一个控制pc是否递增的成员，pc跳转的时候不应当继续递增pc，所以在各种跳转指令中都会直接使用set_pc</p><p>而递增的逻辑也相应的发生了变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_pc_need_incr)</span><br><span class="line">    &#123;</span><br><span class="line">        ++_pc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _pc_need_incr = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。&lt;/p&gt;
&lt;h1 id=&quot;成员函数调用的过程&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记7 GC也没有那么可怕 其一</title>
    <link href="https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/"/>
    <id>https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/</id>
    <published>2022-02-06T04:36:30.000Z</published>
    <updated>2022-02-12T03:46:28.889Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。</p><p>由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说，<del>可以等到下周养肥再一起看</del></p><p>本周从质和量来说都无法令人满意，状态比较差要写不下去了，但是起码比咕了强</p><h1 id="GC的对象表示"><a href="#GC的对象表示" class="headerlink" title="GC的对象表示"></a>GC的对象表示</h1><p>对象被保存在内存中，而对象则分为<strong>头</strong>和<strong>域</strong>两部分。</p><p>其中头被用于标识对象信息，比如说类型，以及gc的tag信息，利用tag信息来判断当前对象的状态</p><p>域则是能够被编程语言访问到的部分。域很显然可能是一个值，也可能是一个指向对象的指针</p><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>让我们看一下Ruby的RObject的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Basic part, including flags and class. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span> <span class="title">basic</span>;</span></span><br><span class="line">    <span class="comment">/** Object&#x27;s specific fields. */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> numiv;</span><br><span class="line">            VALUE *ivptr;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">st_table</span> *<span class="title">iv_index_tbl</span>;</span></span><br><span class="line">        &#125; heap;</span><br><span class="line">        VALUE ary[ROBJECT_EMBED_LEN_MAX];</span><br><span class="line">    &#125; as;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不需要关心过多的细节，可以看到很明显是分为了头和域两部分。</p><p>让我们再来看一下头部 RBasic</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct</span></span><br><span class="line"><span class="function"><span class="title">RUBY_ALIGNAS</span><span class="params">(SIZEOF_VALUE)</span></span></span><br><span class="line"><span class="function">RBasic </span>&#123;</span><br><span class="line">    VALUE flags;</span><br><span class="line">    <span class="keyword">const</span> VALUE klass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，一个标记和一个类信息。Ruby采用的也是标记算法，这里有flags保存标记信息</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>再来看一下Python的实现。这次我们从头部开始看起</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>Object本质上是对象的头部信息。python是通过引用计数实现的GC，可以看到有一个ob_refcnt，同时还有一个保存Type的对象，</p><p>第一行的_PyObject_HEAD_EXTRA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到这是为了方便测试以及跟踪执行情况而添加的内容</p><p>看一下Python的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>其中的ob_size是用于可变长对象使用的，例如List</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Python是每个对象的头部有一个PyObject的指针，不同的类型是基于这个扩展的</p><p>而Ruby是每个对象是一个RObject，对象内部也有一个相同的头部RBasic，而不同的类型都是RObject本身</p><p>虽然实现的方式略有不同，但是本质上还是一样的。而对于GC的实现也是一样，所以我们之后只是大概提一下实现方式的本质</p><h1 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h1><p>在这里只简单谈及标记清除、引用计数以及复制，这三者是最基本的算法，改进版本暂且也不会提及，本周的内容的目的只是希望读者能够对GC有一些了解。其他算法都是从它们衍生出来的本质并没有发生变化（<del>其实主要是因为我只看了这三个</del>）</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除，我个人觉得用追溯更形象一些，因为需要从一些节点开始遍历访问所有的对象，对这些对象设置上tag，之后再对没有打上tag的对象进行回收</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在对象的头部设置一个字段用于标记有几个对象正在应用当前对象，在被创建的时候会设置标记为1，而被一个新的对象引用的时候计数就加1</p><p>当然这个做法存在一个很明显的问题，就是如果两个对象互相保存了对方的引用，那么就会造成循环引用的情况。C++的智能指针也是使用循环计数，因此依然会遇到这样的问题，而在C++中的解决方案是需要使用一个不获取对象所有权的weak_ptr来解决这个问题。</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>对于复制算法来讲，实际上将堆等分为两部分。一部分是正在使用的空间，另一部分是作为复制的临时空间。</p><p>复制算法将所有的活动对象从当前正在使用的空间复制到临时空间，之后直接将两块空间交换，也就是说没被复制的对象直接被销毁了</p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>垃圾回收的算法与实现</p><p>Python源码剖析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。&lt;/p&gt;
&lt;p&gt;由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说</summary>
      
    
    
    
    <category term="GC" scheme="https://fusionbolt.github.io/categories/GC/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>AI Compiler是什么？</title>
    <link href="https://fusionbolt.github.io/2022/02/05/what-is-ai-compiler/"/>
    <id>https://fusionbolt.github.io/2022/02/05/what-is-ai-compiler/</id>
    <published>2022-02-05T02:38:18.000Z</published>
    <updated>2022-02-05T06:00:46.774Z</updated>
    
    <content type="html"><![CDATA[<p>为了让更多人对AI compiler有个了解，在此对这两者的区别和联系做一个科普，也因此本文以科普区别为主，不会深入。这篇文章一直想写，也算是对我去年工作中所学到的一部分东西的总结，但是硬是咕咕咕到了现在，最后选择了假期结束前把这一篇赶出来以提前适应上班状态，避免假期太强的假期综合症。个人水平有限，如有偏颇之处欢迎联系我指正</p><p>本文将从两方面讲述内容，首先是AI compiler是什么，都在做什么，其次是和传统compiler的异同。为了让读者能更好的理解内容，所需的背景知识我会尽可能的在文中做注解</p><h1 id="AI-compiler是做什么的"><a href="#AI-compiler是做什么的" class="headerlink" title="AI compiler是做什么的"></a>AI compiler是做什么的</h1><p>将各种框架训练产生的模型文件进行编译，生成目标平台的代码。从这个角度来看是和传统compiler是非常类似的，但是模型文件更像一个DSL（ldomain-specific language）</p><h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>先从解析输入开始，按照编译的流程来讲解各个阶段的异同。而这些异同大都是由于ai compiler输入的特殊性质导致的</p><h2 id="编译对象"><a href="#编译对象" class="headerlink" title="编译对象"></a>编译对象</h2><p>首先要编译的对象就有很大的不同。传统compiler则是编译的语言源代码，而AI compiler编译的是各种各样的模型，编译对象的不同导致了后面的各种处理大相径庭。</p><p>先来科普一下模型的组成：模型中包含了一个计算图以及各种数据，而计算图又是由许多算子构成的。每一个算子代表了一种计算</p><p>我个人觉得模型也可以算是一种DSL，从模型的输出向上看相当于一个expr，而每个op结点相当于一些特定函数。</p><h2 id="解析输入方式不同"><a href="#解析输入方式不同" class="headerlink" title="解析输入方式不同"></a>解析输入方式不同</h2><p>而传统语言源代码需要经过各种的parse，手写parser更是非常费力不讨好的一件事情，尽管现在的parser generator技术比较成熟，parser写起来依然是非常麻烦的。</p><p>对于AI compiler来说需要支持各种各样的模型的解析。这里不需要写什么复杂的parser了，像onnx会提供一个文件，可以通过protobuf解析这个文件生成对应的解析模型的源代码，直接调用生成的解析模型的源码中的函数即可。由于这个原因，你也不用担心不使用特定的语言进行编写还要自己做解析的工作，极端的讲，哪怕有一天要换语言做你也不需要担心解析的过程。在这个过程中更多的是将模型的数据取出来，放入设计好的IR中。</p><p>但是对于ai compiler来说你需要支持各种模型，如果只是支持某一种格式的模型是远远不会有用户的，这里不像传统compiler只需要支持自己语言的parser就可以了。目前主流的框架大致有三类，pytorch、onnx以及tensorflow，这三类有着各自的模型格式，而三者都有一定的用户群体，框架的支持程度对于用户来讲是一个非常关键的点。</p><h2 id="高层IR设计"><a href="#高层IR设计" class="headerlink" title="高层IR设计"></a>高层IR设计</h2><p>上面提到了ai compiler需要支持多种格式的模型，而不同格式模型的算子定义又是有许多差异。想要做到兼容各种格式的模型又是一个非常麻烦的问题，假设你设计了一套对应了算子的高层IR，可能需要对输入的模型中的算子前后添加一些操作，使其达到等效于你所选择的这个算子的实现。<br>用常规编程语言的例子就是C语言中要做到类似于成员函数调用通常会在这个函数的第一个成员传入结构体的指针。但是实际上麻烦的事情更多，很多算子甚至不能在不同框架转换，有的能转换也非常复杂，而关于这个问题本文就不深入探索了。</p><p>而传统编程语言的高层IR（通常为ast）相对简化很多，高层不需要考虑兼容与转换的问题。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>将输入读取进来后要做的事情当然是优化，编译器不仅要能够正确的生成对应平台的可执行代码，还要尽可能保证性能。</p><p>这个方面可讲的实在太多，不同层面的IR的优化方式又是各不相，而我所知的也比较有限（很多地方没有参与，但是有一些了解，我想做一个简单的科普还是不成问题），就挑ai编译器讲一下通常都有哪些方面的优化（简单提及概念），都是做什么用的，为什么要有这样的优化。</p><h3 id="图优化"><a href="#图优化" class="headerlink" title="图优化"></a>图优化</h3><ol><li>图节点合并：这个想法非常自然，只要减少了节点数量那么计算所需要的时间自然也会减少许多</li><li>更换顺序：有的时候更换节点顺序后一些节点就可以自然的合并</li><li>还有很多优化是基于算子自身定义的，这些在此就不提及了，本质上都是为了减少计算</li></ol><h3 id="fuse"><a href="#fuse" class="headerlink" title="fuse"></a>fuse</h3><p>将多个节点融合到一个子图中，直接影响到后面的tiling、调度、buffer分配，这是比较常见的一个步骤，因为本质上是为优化服务因此放到了这里。</p><h3 id="tiling-：数据切分与重排"><a href="#tiling-：数据切分与重排" class="headerlink" title="tiling ：数据切分与重排"></a>tiling ：数据切分与重排</h3><p>tiling这边我没有实际参与过，所以我只能大概讲一下在编译到ai加速器上的情况下我的理解。</p><p>对于ai加速器来说，通常只会适应某一些满足条件的数据大小的计算，而实际给加速器的数据大小则是各种各样的，因此需要将数据切分到适应加速器的结构。而大部分情况图上的每个节点所需要数据的大小则是已知的，因此可以提前切分好数据进行计算。（也有节点的数据大小不固定的情况，这里暂且不谈）</p><p>对于ai来说计算很多数据都是多维数组，而实际计算很多又是多层循环，常规的数据计算方式相对低效，而许多数据又是编译期间固定的，所以需要重新以一个高效的方式重排数据。</p><p>tiling这个过程可以说是对性能影响最大的部分之一，相信大部分人都看过那个经典的按行遍历与按列遍历二维数组的例子，不仅如此，还会牵扯到计算单元的利用率以及数据传输的带宽利用。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>将计算图序列化，计算出一个合适的算子执行顺序</p><p>如果要涉及多设备还要尽可能做到多设备之间减少依赖，同时要考虑到数据在不同设备之间传输的带宽</p><h3 id="buffer分配"><a href="#buffer分配" class="headerlink" title="buffer分配"></a>buffer分配</h3><p>数据是通常以一个tensor为单位（最简单的说法tensor就是一个多维数组，但是这样并不确切，但是理解这里足以），而一个tensor通常存在一个buffer之中，运算的时候从buffer中取数据</p><p>通过合理的分配方式减少运算中内存的使用，其中牵扯到计算buffer的生命周期，什么时候可以及时释放掉这块buffer，什么时候可以重用已有的buffer等等</p><h2 id="生成代码与运行"><a href="#生成代码与运行" class="headerlink" title="生成代码与运行"></a>生成代码与运行</h2><p>在这方面其实都是差不多的，ai compiler还经常会生成一些ai加速器用的代码。对于ai加速器来说更多是几条配置指令加一条计算指令来执行特定的算子（上面提到的数据切分重排也和这个问题有非常大的联系）</p><p>关于生成产物的运行，和传统compiler相同也是有两类选择</p><ol><li>生成一个直接可以执行的程序</li><li>生成类似于字节码的东西供另一个运行时的程序读取并且执行</li></ol><h2 id="编译时间敏感度"><a href="#编译时间敏感度" class="headerlink" title="编译时间敏感度"></a>编译时间敏感度</h2><p>传统compiler还是对编译时间比较敏感的，因此导致了一些算法必须选择一个较好解，而最优解是需要很长时间的。</p><p>对于ai compiler编译时间的敏感程度相对较小，而且如果开启量化需要跑量化矫正集那根本无法控制时间（也因此需要高性能的evaluator）。而且对目标执行速度要求高，因此有更多的时间去搜索更好的解，<del>相对于炼丹来说这点时间洒洒水啦</del>。</p><h2 id="AI-compiler特有的部分"><a href="#AI-compiler特有的部分" class="headerlink" title="AI compiler特有的部分"></a>AI compiler特有的部分</h2><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>这里的量化并不是指量化交易，而是指一种将浮点数转换为定点数的计算。在ai中通常使用float进行计算，为了缩小数据大小通常会将float量化到int8，而最后还会转换回float输出（这个则是反量化过程）。如果只是做常规的数据类型转换那一定会有很大的精度损失，因此需要各种量化的算法来尽可能减少这一影响。</p><p>而量化通常需要统计数值范围，并且使用这个范围来算出一个适当的量化参数，而这个范围我们需要通过在编译期间实际执行整个模型来得到，这个时候我们就需要一个evaluator来执行。</p><h3 id="evaluator与kernel"><a href="#evaluator与kernel" class="headerlink" title="evaluator与kernel"></a>evaluator与kernel</h3><p>我觉得这里可以视为以模型和参数作为输入的解释器，对于模型来说最小单位是一个算子，那么我们就需要添加每一个算子所对应的实现，又称为kernel。</p><p>而kernels的实现不仅要正确，还要尽可能的高效。原因有如下两条</p><ol><li>这直接影响到开启量化后的编译时间。</li><li>对于ai加速器来说只能够加速特定的算子，而其他算子依然会使用cpu来执行。cpu上的算子执行如果要利用这些kernels的话那它们的性能也是非常重要。</li></ol><p>关于第二条，这只是做法之一，实际上加速器加速不到的算子也有很多的实现方式，在这里只是提及有这种实现方式不进行评价好与坏，所以仅供参考。</p><h1 id="利用传统编译器的技术来做ai-compiler"><a href="#利用传统编译器的技术来做ai-compiler" class="headerlink" title="利用传统编译器的技术来做ai compiler"></a>利用传统编译器的技术来做ai compiler</h1><p>常量折叠、寄存器分配等技术都是可以从传统编译器来借鉴的。</p><p>一个非常典型的利用传统编译器技术的莫过于TVM（最有名的开源ai compiler）。其中的高层IR（Relay）直接利用了lambda calculus</p><blockquote><p>既然我们知道如何做control flow（lambda calculus），为啥不直接用<a class="link"   href="https://www.zhihu.com/search?q=lambda+calculus&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%22875630325%22%7D" >lambda calculus<i class="fas fa-external-link-alt"></i></a>当IR呢？这就是relay了。(当然，传统DL compiler能做的还是一样，但是没啥好讲的（maybe sized tensor？but sized tensor is boring））。<br>选取了lambda calculus为ir以后，由于这上面的研究很多，我们实现需求复杂的任务比其他框架简单得多 - 因为我们只需要照抄经典compiler算法。</p></blockquote><p>原文链接：<a class="link"   href="https://www.zhihu.com/question/331611341/answer/875630325" >https://www.zhihu.com/question/331611341/answer/875630325<i class="fas fa-external-link-alt"></i></a></p><p>不过只是这些当然还不够，需要探索更多专为ai相关的技术才能做好ai compiler。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当了解了一些知识以后，就很难从一个完全不知道的视角去讲述了，所以写完本文我也难以把握哪里是相关知识较少的人看不明白的地方。读者如果能够通过本文了解ai compiler大致是什么样子的话那是再好不过了，如果读完本文对ai compiler产生了兴趣也欢迎进入这个行业和我一起摸爬滚打</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了让更多人对AI compiler有个了解，在此对这两者的区别和联系做一个科普，也因此本文以科普区别为主，不会深入。这篇文章一直想写，也算是对我去年工作中所学到的一部分东西的总结，但是硬是咕咕咕到了现在，最后选择了假期结束前把这一篇赶出来以提前适应上班状态，避免假期太强的</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="AI" scheme="https://fusionbolt.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>论柳比歇夫</title>
    <link href="https://fusionbolt.github.io/2022/02/04/Lyubishchev/"/>
    <id>https://fusionbolt.github.io/2022/02/04/Lyubishchev/</id>
    <published>2022-02-04T03:00:48.000Z</published>
    <updated>2022-02-04T03:51:45.395Z</updated>
    
    <content type="html"><![CDATA[<p>也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解</p><p>大部分人看到标题，一定只有一个问题：<strong>柳比歇夫是谁？</strong></p><p>他是一个大半生都在<strong>支配时间</strong>的人。我想你一定会对支配时间这个词摸不着头脑，还会有人在想时间面前人人平等，时间怎么可能被他支配？</p><p>那么我们先从他的成就谈起吧</p><h1 id="他的成就"><a href="#他的成就" class="headerlink" title="他的成就"></a>他的成就</h1><blockquote><p>前苏联的昆虫学家、哲学家、数学家。毕业于圣彼得堡国立大学，一生发布了70余部学术著作，从分散分析、生物分类学到昆虫学等。业余时间研究地蚤的分类，还写过不少科学回忆录。 各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。</p></blockquote><p>除了这些，数学、历史与诗歌他都十分擅长。毫无疑问，他是一个全才，并且在一生中做出了超乎想象的成就。他是怎么达到这样的成就的呢？</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>早在他28岁的时候他就已经找到了他一生的奋斗的目标：创造生物自然分类法。尽管遭受怀疑他依然开始着手他的任务，并且将一生投身到其中。</p><blockquote><p>他当然相信他能做到，但总是要从另外什么地方再去挖掘一些力量，再去挖掘一些时间。</p></blockquote><p><strong>而为了完成这一切，他选择了“支配时间”</strong></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>完成事情需要时间，这是一个不可避免的内容。而对于时间的使用，很自然会想到利用好各种时间，他自然是做到了，将各种碎片时间利用到了极致。但只是利用碎片时间自然是不足以使他获得如此成就</p><blockquote><p>应当不断挖掘一切时间潜力。明摆着，人不能者是每天工作十四五个小时。应当正确利用工作时间。从时间中去找时间。</p></blockquote><p>接着他就开始了记录时间的生涯。他将自己做得<strong>几乎每件事情</strong>所需要的时间记录下来，进而达到能够<strong>十分清楚地了解自己做每件事情的时间</strong>，在了解自己的时间后进行十分周密的安排（注意，这是在他能够保证利用各种碎片时间的前提下）。</p><p>这些内容我觉得比起我来讲不如来看摘录的原文</p><blockquote><p>计划就是挑选时间、规定节律，使一切都各得其所。头脑清醒的时候应当钻研数学，累了便看书。</p></blockquote><blockquote><p>这个方法之所以能够存在，是依靠经常的计算和检查。没有计算的计划是盲目的计划，就象某些研究所那样，光会做计划，却不去操心这计划能不能完成。</p></blockquote><p>他对于时间的理解是非常深刻的。而最重要的则是他使用了一生来实践这样的方法。</p><p>了解时间记录法后我偶然想到在一本书中看到的话：不是要达到什么目标，而是要形成一个自己想要的系统，目标会自然而然达到。再看柳比歇夫的经历，亦是如此</p><p>而书中也有很多时间相关值得回味的内容，在这里摘录两段</p><blockquote><p>为了节约时间，实干家下了马车坐上火车，下了火车坐上飞机。发明了电报和电话来代替书信，电视代替了剧院，拉链代替了扣子，圆珠笔代替了鹅翎。电梯、计算机、百货公司、电传打字机、电动制刀——这一切发明，都是为了替人节省时间。然而，不知道为什么，人越来越感到时间不够用</p></blockquote><blockquote><p>时间的分配几乎同两千年以前赛纳卡时代一摸一样：“我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事</p></blockquote><h1 id="代价与幸福"><a href="#代价与幸福" class="headerlink" title="代价与幸福"></a>代价与幸福</h1><p>可能很多人会觉得，这样机械式的生活真的快乐幸福吗？这里可以肯定的回答，至少对他来说是这样的。这里我有一个比较奇特的视角来讲，他清晰的明白自己的能力边界，因此他不需要担心时间不足或者担心自己做不到，他不需要焦虑在这种事情上，减少了焦虑并且能够更好的发挥自己的才能。</p><p>而在作者看来他亦是幸福的。在书的一开始，作者就提到</p><blockquote><p>我从中得到的一切，对于我来说，是一个新发现，使我参透了一个人一生的秘密。</p><p>这个秘密是——怎么生活得更好。</p></blockquote><p>但是这一切是有一个前提：他不断的给自己设定更高的要求，并且他有着源源不断的好奇心和求知欲，而这样做正是满足了他的欲望，因此这一切对他来说是十分幸福的。</p><p>在写下前面的部分，回顾文中的内容，在最后也看到了作者持有着同样的态度</p><blockquote><p>只有一个人向自己提出崇高目标时，这个时间统计法才能成立</p></blockquote><h1 id="能力边界与高要求"><a href="#能力边界与高要求" class="headerlink" title="能力边界与高要求"></a>能力边界与高要求</h1><p>他持续对自己高要求，并且在明确自己能力边界的情况下不断在边界中前进</p><blockquote><p> 他不让自己负担过重，力不胜任；他总是循着他能力的边缘前进，他对自己能力的掂量愈来愈精确。这是一条永不停顿的自我认识的道路”“如果每个人都能知道自己能干些什么，那生活会变得多么美好！因为每个人的能力都比他自己感觉到的大得多。他会变得比自己想象的更为勇敢；他会变得更坚韧、更有力，更能适应环境”</p></blockquote><p>还有一段我觉得是非常棒的描述</p><blockquote><p>对于柳比歇夫，任何时候都不能说他已“成为”怎样一个人。他永远正在“逐步成为”怎样一个人。他一直在探索，一直在变化，他总是重新考虑，不断提高对自己和对自己理想的要求</p></blockquote><h1 id="对知识的热爱以及偏离目标"><a href="#对知识的热爱以及偏离目标" class="headerlink" title="对知识的热爱以及偏离目标"></a>对知识的热爱以及偏离目标</h1><p>他学习知识，数学、历史、文学、音乐等等各种方面。</p><p>他不善于克制自己，经常迷上同他完全无关的东西中。他无法抗拒周围环境的诱惑，他无法抗拒那些知识。但是关于这些，作者给出了很明确的观点</p><blockquote><p>“天哪，对于嗜癖和精力分散我们又能知道些什么呢！谁能说清楚“人应当是怎么样的”。我们从何知道人应当是怎么样的呢”</p></blockquote><p>不过有一点要注意，不论怎么样<strong>他最后都能够确保任务的完成</strong>，这也和他对自己能力有着清晰的认识有关。</p><p>而“偏离目标”，也就是学习各种看似不相关的知识实际上也会产生一些意想不到的效果。达芬奇就是一个非常擅长将不同领域的知识融合在一起的人，他的许多创作都是如此。</p><h1 id="关于这本书"><a href="#关于这本书" class="headerlink" title="关于这本书"></a>关于这本书</h1><p>作者在本书的开头就在提到如何吸引读者这一件事情，而毋庸置疑的作者达到了他的目的，不像我后来看的达芬奇传（作者沃尔特 艾萨克森）真的是无聊至极。</p><p>正如作者所期望的那样，每读一点我就更加迫不及待的想要看到后面的内容，作者巧妙的描述出了一个饱满的柳比歇夫的形象。读完这本书后让我产生了更强烈的阅读其他传记的欲望，之后也就顺势读完了乔布斯传。</p><p>读这本书的过程中自己被柳比歇夫所吸引，也许这就是我所理想的样子。他对自我的要求、他的自由、他的幸福、他对自己的严格要求、他不断增长的边界，无一例外充满了魅力。在写到这一段的时候越写下去越发不可收拾，我着了迷、入了魔，那段时间读到相关的部分都会感到非常兴奋。</p><p>我希望这本书给别人的印象不仅仅是只有柳比歇夫的时间统计法，尽管是在读者的角度，我依然想要让其他阅读这本书的人更多的去体会、感受柳比歇夫的各种特质，而并非只是局限于时间统计法，时间统计法本质上是他的特质的衍生产物，是他为了完成自己的目的所选择的一条道路。</p><p>而完美的是作者也将这些特质巧妙的讲了出来，也没有花费太大篇幅去描述时间统计法。我最初也并不知道柳比歇夫是怎么样的人，但至少读完本书之后对他的形象有了一个饱满的认识，尽管这些只是局限于作者所描述的部分。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>整理这篇文章花费的时间比预想的还要多很多，整理的过程中几度想要放弃了，但是整理的时候多少又找回了一些热情，又回想起了很多，最后还是坚持了下来。请原谅我个人能力有限，文中内容简陋，而且内容有所遗忘，无法在这么短的篇幅中将他的魅力讲述到极致，只能提及部分性格特点，而书中所讲述的他更为有趣。<strong>如果你是对自己有要求的人，那么我非常推荐你去读这本书</strong>，去感受他的人生，感受他的精神，也许你会和我一样着迷。</p><p>虽然我做不到柳比歇夫的时间记录法，但是我可以学习他的高要求、不断在自己的边界进步、他对知识的热情，这些也足够我获得很大的成长了。我应该认真思考如何像他一样对自己不断的提出要求并且<strong>达到这些要求，而不只是空谈</strong>，写完这篇文章的今天我该拿出时间好好反思。</p><p>最开始写这些文字的内容是几个月前我刚读完这本书的时候，现在将其整理成文。开头一段现在回头看多少有点怪异，但我最后还是决定保留。不过不论如何，我现在依然很为能看到这本书并且了解这个人而感到幸运。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解&lt;/p&gt;
&lt;p&gt;大部分人看到标题，一定只有一个问题：&lt;strong&gt;柳比歇夫是谁？&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="柳比歇夫" scheme="https://fusionbolt.github.io/tags/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>iPhone Ultra Max(iPad mini)体验</title>
    <link href="https://fusionbolt.github.io/2022/01/30/iPadminiReview/"/>
    <id>https://fusionbolt.github.io/2022/01/30/iPadminiReview/</id>
    <published>2022-01-30T07:53:31.000Z</published>
    <updated>2022-01-30T08:25:39.898Z</updated>
    
    <content type="html"><![CDATA[<p>曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。<del>但iPad mini在我看来就是一个大号手机，某种意义上还是没错</del></p><p>iPad mini也已经入手有半个月了，半个月内重度使用，过了那阵新鲜劲以及各种问题踩坑也踩的差不多了，这个时候写下的体验我觉得应该是相对比较全面的了</p><h1 id="我的痛点"><a href="#我的痛点" class="headerlink" title="我的痛点"></a>我的痛点</h1><p>我觉得iPad mini解决了我目前使用手机的各种痛点。我的iPhone8plus目前有存储不够，电池容量太小，只能单卡而我自己的卡流量又不够。如果只是这些问题可能有人说换新机不就完美解决了？但是换新机也不能解决屏幕太小的问题，想看点文章或者需要跨app处理一些内容iPhone这么小的一个屏幕实在不方便</p><p>周末需要频繁挤地铁，地铁上的时间非常久，没有座位的时候拿iPad Pro非常不方便，即便有座位从包里拿出来也是很麻烦的事情，手机屏幕又太小，iPad mini的大小可以说是完美。</p><p>所以我实质上是将iPad mini当作我的新手机，我的iPhone8plus还能再战好多年。以下体验更多是从手机的视角来看待</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="iPhoneUltraMax.png"                      alt="image-20220130160002912"                ></p><h1 id="实际体验"><a href="#实际体验" class="headerlink" title="实际体验"></a>实际体验</h1><p>首先：不玩手游，所以并不会提到相关的内容，想看手游相关的建议你去看各种评测视频</p><p>重量感觉拿着没有任何压力，只比带着保护套的手机重了几十克。这个大小能够装到兜里，出门的时候看地图也非常方便。受益于大屏幕，看文章非常方便，不知道比iPhone高到哪里去了。</p><p>电量够我出门用一天，再也不用挂着移动电源到处走了。这是我某一周的使用情况，如果开了省电模式一天非常稳妥，更何况我出门的时候电只有80左右</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="battery.png"                      alt="IMG_2136"                ></p><p>出门在外，iPhone直接扔包里，有什么电话或者短信可以直接转接到iPad mini上</p><p>网上所说的什么果冻屏至少我没什么感知，尽管有这也是显示技术不可避免的问题，120刷新率对于iPad mini来说不太可能用上（而且绝大部分情况不需要刷那么快）这一点争议非常大，建议你去实体店体验一下</p><p>曾经我以为iPad正确的解释姿势就是Face ID，但直到出现了疫情…iPhone已经支持戴口罩解锁了，iPad pro什么时候才能用上？指纹解锁在现在这个到处需要戴口罩的情况下还是很棒的（但是我手指各种掉皮就还是白给</p><p>谈一点没什么关联的，直到我用上了iPad mini才发现iPad Pro是多么大，以及各方面是多么好……不论是扬声器还是屏幕刷新率，这些我之前都毫无感觉，真的是没有对比就没有伤害</p><h1 id="不可避免的问题"><a href="#不可避免的问题" class="headerlink" title="不可避免的问题"></a>不可避免的问题</h1><h2 id="极其多余且愚蠢的设计"><a href="#极其多余且愚蠢的设计" class="headerlink" title="极其多余且愚蠢的设计"></a>极其多余且愚蠢的设计</h2><p>这是我一定要着重说的一个问题。</p><p>所谓的智能音量键调整位置，我的感受就是多此一举，用了一周并没有觉得多么方便，反而每次调整音量不仅要想按哪里，在屏幕没锁定旋转的情况下大概率会按反。我听的不同来源的音频声音响度是不同的，如果忘了提前调整音量则需要快速反应按下减音量，而这种设计又会导致你大概率要先思考或者先按错一次才能按到正确的地方，对于耳朵损伤还是非常大的</p><p>因为有Touch ID，开屏的时候会提示按键位置在哪里，这个本身是好事，但是如果屏幕方向是竖直摆放这个提示则会导致无法看到电量，只是想打开屏幕看一下电量的时候非常难受</p><p>上面这两条，我开始怀疑苹果的人机交互工程师有没有真的自己用一下，一家曾经以设计闻名的公司（个人看法）额外添加的这些设计却反而添加了负面体验，这么大的公司应该有合理的流程避免一些问题，尤其是对于apple来说。但是这种不良设计依然出现了，不知道该怎么评价了</p><h2 id="大屏幕"><a href="#大屏幕" class="headerlink" title="大屏幕"></a>大屏幕</h2><p>大屏幕随之而来的就是你在看的东西更容易被其他人看到，对于非常重视隐私的人来说是灾难。另一个就是便携性不可避免的要下降一些，很多场景不能单手握持，但是只是读文章，单手下滑是没问题的，这是必须做出的取舍。还有就是我衣服兜比较浅，总觉得要掉（后来有一天不知道为什么过于大意，在同一个地方摔了两次….），装到裤子兜又麻烦，到了夏天衣物可能更难携带iPad mini</p><p>字体略小，将字体调到了最大还算可以接受（除了一些app字体并没有适配好）</p><p>到户外这个屏幕亮度不够用。这是我个人觉得最难受的</p><p>双手握持打字略微有些头重脚轻的感觉（竖屏），而且有一种要滑出去的趋势。以及键盘还不是完全一样的，需要一点时间适应。但对我来说键盘录入大量内容可能还是偏少数，更多的是用它去阅读</p><h2 id="OS与应用"><a href="#OS与应用" class="headerlink" title="OS与应用"></a>OS与应用</h2><p>iOS应用仍有一些不适配的情况，万幸的是可以手动放大到一个勉强能用的状态。但是更离谱的是支付宝只能登录一个设备，这产品经理是不是张小龙带出来的。当然这种环节不可避免要把微信拉出来挨打，目前iPad版和mac版是冲突的，干脆不用mac上的了，反正我的微信只用来联系家人。除此之外还有qq不能多个iPad上登陆，也有点小烦，等等还有很多类似的问题</p><p>还有一些并非适配问题而是不能用的，比如说健康和Apple Watch的管理，这些还是要依赖于iPhone。以及就是iPad OS诟病已久的没有天气和计算器。以及某些离谱的应用，比如说企业微信第一次登陆还要手机确认……</p><h2 id="代替手机"><a href="#代替手机" class="headerlink" title="代替手机"></a>代替手机</h2><p>由于不能打电话的硬伤，你并不能真的完全离开你的手机。尽管现在的人电话场景是“十个里面九个骚扰电话，还有一个是快递”</p><p>周末坐地铁的时候意识到不能刷nfc，突然想到还可以刷Apple Watch，但我戴在左手刷起来略显别扭。什么，你说扫码？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="nfc.png"                      alt="telegram-cloud-photo-size-5-6278298406799650309-y"                ></p><h2 id="购买相关"><a href="#购买相关" class="headerlink" title="购买相关"></a>购买相关</h2><p>如果去官网购买，很可能需要等待两个月才能到货，这个着实比较离谱了，因此我选择了京东购入，也就错失了刻上iPhone Ultra Max的机会</p><p>本来想要购入一个紫色，但是去实体店查看跟示意图完全是两个样子…如果想要购入我建议你还是去实体店亲自看一下</p><h1 id="我会用它完全代替iPhone吗"><a href="#我会用它完全代替iPhone吗" class="headerlink" title="我会用它完全代替iPhone吗"></a>我会用它完全代替iPhone吗</h1><p>除了初拿到的欣喜，用了一段时间以后发现很多时候还是用手机方便，但是我依然没有后悔买了这个iPad mini，尽管在上面吐槽了它这么多问题，但我对它实在是非常满意（售价除外）。<strong>某种意义上可以说是因为没有竞争对手，我们只能忍受它的所有缺点</strong>。如果你有类似的需求，那非常推荐你。如果没有，那我还是推荐买大屏</p><p>最后加一个小技巧：如果你的iPhone像我一样只是需要维持最低限度功能，你可以在快捷指令里面设置自动化，当断开电源的时候自动开启低电量模式，平常充电超过80%IPhone会自动关闭低电量模式</p><p>本文绝大部分在地铁上一口气用iPad mini写完，再也不想用iPad mini打这么多字了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。&lt;del&gt;但iPad mini在我看来就是一个大号手机，某种意义上还是没错&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;iPad mini也已经入手有半个月了，半个月内重度使用，过了那阵</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="iPadmini" scheme="https://fusionbolt.github.io/tags/iPadmini/"/>
    
    <category term="Apple" scheme="https://fusionbolt.github.io/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记6 OOP其二</title>
    <link href="https://fusionbolt.github.io/2022/01/30/rc-lang-dev-6/"/>
    <id>https://fusionbolt.github.io/2022/01/30/rc-lang-dev-6/</id>
    <published>2022-01-30T05:16:02.000Z</published>
    <updated>2022-01-30T05:16:35.440Z</updated>
    
    <content type="html"><![CDATA[<p>在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看</p><p>在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。</p><p>本周修改的主要方向：所有的函数操作都是基于一个类的（因此函数信息也都会放到类中）</p><p>在功能上要修改的有以下三个方面（测试这里暂且不谈）</p><ol><li>符号表分析</li><li>生成vm指令</li><li>VM运行时解析执行方式</li></ol><p>与此同时还更改了”链接”的方式，所有函数全部在第一次使用时动态加载</p><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以前的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>, :<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">const_table</span>, :<span class="title">class_table</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到将所有信息都集成到一个class_table符号表目前全部依靠一个class_table进行运作，目前的内容也很简单，只是保存instance methods和vars的信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span> = &#123;&#125;</span><br><span class="line">    <span class="variable">@instance_vars</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_method</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_var</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_vars</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种时候需要单独解释类型信息，这就是动态类型的头疼之处，想试试Scala，但是没时间学了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceMethodInfo</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define</span>, :<span class="title">env</span>, :<span class="title">args</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>define在符号分析的时候是ast的结点，而在后面翻译到vm指令的时候</p><p>相比之前取消了offset，因为全要等到运行时加载，这里的offset没有意义了</p><p>而env就是在global_env中被干掉的fun_env，参数信息没什么好说的，目前仅保存名字以及只用于统计数量</p><h2 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a>实际分析</h2><h3 id="class-table的初始化"><a href="#class-table的初始化" class="headerlink" title="class_table的初始化"></a>class_table的初始化</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">  <span class="variable">@define_env</span> = Env.new</span><br><span class="line">  init_class_table</span><br><span class="line">  <span class="variable">@const_table</span> = Set[]</span><br><span class="line">  <span class="variable">@cur_class_name</span> = Rc::Define::GlobalObject</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_class_table</span></span></span><br><span class="line">  <span class="variable">@class_table</span> = Env.new</span><br><span class="line">  <span class="variable">@class_table</span>.define_symbol(Rc::Define::GlobalObject, ClassTable.new)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Rc</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Define</span></span></span><br><span class="line">    GlobalObject = <span class="string">&#x27;Kernel&#x27;</span></span><br><span class="line">    UndefinedMethod = <span class="string">&#x27;Undefined&#x27;</span></span><br><span class="line">    ConstructorMethod = <span class="string">&#x27;initialize&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>塞进去一个默认的全局类，在vm执行的时候也会提到这里</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_class_define</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="comment"># save old</span></span><br><span class="line">  old_class_name = <span class="variable">@cur_class_name</span></span><br><span class="line">  <span class="comment"># make new and update</span></span><br><span class="line">  <span class="variable">@cur_class_name</span> = node.name</span><br><span class="line">  class_table = ClassTable.new</span><br><span class="line">  <span class="comment"># define before visit fun, because of this is a context used for visit fun</span></span><br><span class="line">  <span class="variable">@class_table</span>.define_symbol(node.name, class_table)</span><br><span class="line">  <span class="comment"># visit and add value to class_table</span></span><br><span class="line">  node.fun_list.each &#123;<span class="params">|f|</span> visit(f)&#125;</span><br><span class="line">  node.var_list.each &#123;<span class="params">|v|</span> class_table.add_instance_var(v.name, v.val)&#125;</span><br><span class="line">  <span class="comment"># restore name</span></span><br><span class="line">  <span class="variable">@cur_class_name</span> = old_class_name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>访问到类的时候创建一个类表，之后遍历visit成员的var和method，将这些信息添加到类表中</p><p>method是在visit的内部添加的，这里目前这样做是因为如果是Kernel的method，则不会经过on_class_define，这里应当在前面ast层面就做处理。先记下来以后来修改，目前比较想赶快赶工到能做GC的地方</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="variable">@define_env</span>.define_symbol(node.name, node)</span><br><span class="line">    <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">    <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">    visit(node.stmts)</span><br><span class="line">    <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">  <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">  visit(node.stmts)</span><br><span class="line">  <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line">  cur_class.add_instance_method(node.name, InstanceMethodInfo.new(node, <span class="variable">@cur_fun_sym</span>, node.args))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也没什么可说的，主要还是符号表存储方式的差别导致了这里信息存储的位置不同了</p><h1 id="vm代码生成"><a href="#vm代码生成" class="headerlink" title="vm代码生成"></a>vm代码生成</h1><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>之前的实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(ast, global_env)</span></span></span><br><span class="line">  <span class="variable">@global_env</span> = global_env</span><br><span class="line">  inst = visit(ast).flatten.compact</span><br><span class="line">  inst.each_with_index <span class="keyword">do</span> <span class="params">|ins, index|</span></span><br><span class="line">    <span class="keyword">if</span> ins.is_a? FunLabel</span><br><span class="line">      <span class="variable">@global_env</span>.define_env[ins.name].offset = index</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="variable">@global_env</span>.define_env.reject! <span class="keyword">do</span> <span class="params">|name, table|</span></span><br><span class="line">    name.<span class="keyword">include</span>? <span class="string">&#x27;@&#x27;</span> <span class="keyword">or</span> table.is_a? Rc::AST::Function</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  inst</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在的实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(global_env)</span></span></span><br><span class="line">  global_env.class_table.update_values <span class="keyword">do</span> <span class="params">|class_name, table|</span></span><br><span class="line">    <span class="variable">@cur_class_name</span> = class_name</span><br><span class="line">    table.instance_methods.update_values <span class="keyword">do</span> <span class="params">|f_name, method_info|</span></span><br><span class="line">      <span class="variable">@cur_method_info</span> = method_info</span><br><span class="line">      method_info.define = visit(method_info.define).flatten.compact</span><br><span class="line">      method_info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    table</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  global_env</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_values</span><span class="params">(&amp;block)</span></span></span><br><span class="line">    each <span class="keyword">do</span> <span class="params">|key, value|</span></span><br><span class="line">      <span class="keyword">self</span>[key] = block.call(key, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>尽管都是以一个函数为单位进行visit，但是对于现在的实现来说更大的遍历单位是一个class</p><p>可以看到这里已经不再设置offset了，等到vm执行的时候再生成offset</p><h2 id="on-function"><a href="#on-function" class="headerlink" title="on function"></a>on function</h2><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun</span> = node.name</span><br><span class="line">  <span class="variable">@global_env</span>.define_env[node.name] = Rc::FunTable.new(cur_fun_env, node.args, <span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line">  [FunLabel.new(node.name), <span class="keyword">super</span>(node), Return.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun</span> = node.name</span><br><span class="line">  [FunLabel.new(node.name), <span class="keyword">super</span>(node), Return.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>on_function只会在translate调用，只需要获取编译出的所有指令就可以了，关于表的更新都在translate中做</p><p>此外，获取当前函数的env要修改一下</p><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cur_fun_env</span></span></span><br><span class="line">  <span class="variable">@global_env</span>.fun_env[<span class="variable">@cur_fun</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cur_fun_env</span></span></span><br><span class="line">  <span class="variable">@cur_method_info</span>.env</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>cur_method_info可以在前面的translate中看到不断的更新值</p><h2 id="dump信息"><a href="#dump信息" class="headerlink" title="dump信息"></a>dump信息</h2><p>目前全部dump到了一个文件中</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span></span></span><br><span class="line">    x + y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  var a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span></span><br><span class="line">    var f = Foo.new()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="编译出的文件"><a href="#编译出的文件" class="headerlink" title="编译出的文件"></a>编译出的文件</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Kernel</span><br><span class="line"></span><br><span class="line">main <span class="number">0</span> <span class="number">1</span></span><br><span class="line">FunLabel main</span><br><span class="line">Alloc Foo</span><br><span class="line">Call Foo initialize</span><br><span class="line">SetLocal <span class="number">0</span></span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">Foo <span class="comment"># 类名</span></span><br><span class="line">a <span class="comment"># 成员变量</span></span><br><span class="line">initialize <span class="number">0</span> <span class="number">0</span> <span class="comment"># 成员函数名 args数量 local_var数量</span></span><br><span class="line">FunLabel initialize <span class="comment"># 函数定义</span></span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">add <span class="number">2</span> <span class="number">2</span></span><br><span class="line">FunLabel add</span><br><span class="line">GetLocal <span class="number">0</span></span><br><span class="line">GetLocal <span class="number">1</span></span><br><span class="line">Add</span><br><span class="line">Return</span><br></pre></td></tr></table></figure><p>FunLabel或许也可以删掉了，目前先这样留着吧，说不定debug会用得上</p><p>写到一半才意识到完全可以使用一些现有的格式来做到这件事情，但这也只是临时用的东西，最后一定会转成真正的字节码而不是这种dump，先这样吧，<del>大家千万不要跟我学坏</del></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这个也没什么好讲的，并非重点，相比之前不同也是以类为一个单位。目前是都编译到了一个文件，目前这样就够用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_class_table</span><span class="params">(global_env)</span></span></span><br><span class="line">  global_env.class_table.map <span class="keyword">do</span> <span class="params">|class_name, table|</span></span><br><span class="line">    <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;class_name&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;table.instance_vars.keys.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&#x27; &#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;table.instance_methods.map &#123; <span class="params">|name, info|</span> gen_method(name, info) &#125;</span>.join(&quot;\n&quot;) &#125;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line">  <span class="keyword">end</span>.join(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_method</span><span class="params">(name, method_info)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;name&#125;</span> <span class="subst">#&#123;method_info.args.size&#125;</span> <span class="subst">#&#123;method_info.env.size&#125;</span> <span class="subst">#&#123;method_info.offset&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;method_info.define.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&quot;\n&quot;</span>)&#125;</span></span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h1><h2 id="符号表-1"><a href="#符号表-1" class="headerlink" title="符号表"></a>符号表</h2><p>这里要和ruby的符号表一致。用两种语言做这种时候就很麻烦，要再做一份</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::vector&lt;std::string&gt; _vars;</span><br><span class="line">    SymbolTable&lt;FunInfo&gt; _methods;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> argc;</span><br><span class="line">    <span class="keyword">size_t</span> locals;</span><br><span class="line">    <span class="keyword">size_t</span> begin;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; inst_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过要注意FunInfo中这里要保存起始地址，因为装载以后就会有地址了，默认为0（不可能存在的地址，视为未链接）</p><h2 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h2><p>先这样凑合用好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SymbolTable&lt;ClassInfo&gt; <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">f</span><span class="params">(_path)</span></span>;</span><br><span class="line">    std::string str;</span><br><span class="line">    SymbolTable&lt;ClassInfo&gt; class_table;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(f, str)) &#123;</span><br><span class="line">        <span class="comment">// 1. class name</span></span><br><span class="line">        <span class="keyword">auto</span> class_name = str;</span><br><span class="line">        <span class="comment">// 2. member vars</span></span><br><span class="line">        std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        <span class="keyword">auto</span> member_vars = <span class="built_in">split</span>(str);</span><br><span class="line">        <span class="comment">// 3. functions</span></span><br><span class="line">        std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        SymbolTable&lt;FunInfo&gt; fun_table;</span><br><span class="line">        <span class="keyword">while</span>(!str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 3.1 info</span></span><br><span class="line">            <span class="keyword">auto</span> fun_info = <span class="built_in">split</span>(str);</span><br><span class="line">            <span class="keyword">auto</span> name = fun_info[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">auto</span> args = std::<span class="built_in">stoi</span>(fun_info[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">auto</span> local_vars = std::<span class="built_in">stoi</span>(fun_info[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 3.2 add to class_table</span></span><br><span class="line">            fun_table.<span class="built_in">define</span>(name, <span class="built_in">FunInfo</span>(args, local_vars));</span><br><span class="line">            <span class="comment">// 3.3 define</span></span><br><span class="line">            std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">            <span class="keyword">auto</span> &amp;inst_list = fun_table[name].inst_list;</span><br><span class="line">            <span class="keyword">while</span>(std::<span class="built_in">getline</span>(f, str) &amp;&amp; !str.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> list = <span class="built_in">split</span>(str);</span><br><span class="line">                inst_list.<span class="built_in">push_back</span>(<span class="built_in">get_inst</span>(list));</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ClassInfo <span class="title">class_info</span><span class="params">(member_vars, fun_table)</span></span>;</span><br><span class="line">        class_table.<span class="built_in">define</span>(class_name, class_info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> class_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>由于增加了类相关的内容以及“动态链接”，这里的变化会大得多</p><p>之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_sym_table.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// todo: find definition</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function&quot;</span> + f + <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = _sym_table[f];</span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    _pc = fun.begin;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; klass, <span class="keyword">const</span> std::string&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_sym_table.<span class="built_in">contains</span>(klass) || !_sym_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function&quot;</span> + f + <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = _sym_table[klass]._methods[f];</span><br><span class="line">    <span class="keyword">if</span>(fun.begin == UndefinedAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        fun.begin = <span class="built_in">load_method</span>(fun);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    _pc = fun.begin;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变化主要有两个</p><ol><li>查找被调用函数的方式，需要先查找类表再从中查找到对应函数信息</li><li>加载</li></ol><p>关于加载的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> FunInfo&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. get start</span></span><br><span class="line">    <span class="keyword">auto</span> start = std::max&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_inst_list.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 2. load inst to inst_list</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp;inst : f.inst_list)</span><br><span class="line">    &#123;</span><br><span class="line">        _inst_list.<span class="built_in">push_back</span>(inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的需求来说这些就足够了，因为目前没有牵扯到一些相对寻址的指令。之后加到那些指令的时候再来更新</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>里面目前就这么一行代码，其实也没有太大变化，只是入口需要指定类了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin_call</span>(VMGlobalClass, VMEntryFun);</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>正式开始构造对象以及调用构造函数要等到GC弄出来再写了（尽管编译器这边已经做了，但是VM不做出对应功能毫无意义）。下个周不出意外的话应该要开GC的坑了，尽管放假了，但依然有一堆事情要处理，就像写博客回顾、重构代码一样，我的生活也需要做一些打扫与清理，还有一些需要学习的新知识，所以大概率还是会维持平常的进度。不寻求太大的变化，能维持这样的进度我觉得也不错。</p><p>我觉得这种对比修改前后代码的方式还挺不错的，以后如果再涉及到修改已有设计的地方都会再加一些。</p><p>最近有些疏于测试了..尤其是VM代码一点都没有，下次一定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看&lt;/p&gt;
&lt;p&gt;在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。&lt;/p&gt;
&lt;p&gt;本周修改的主要方向：所有的函数操作都是基于一个类的（因此函</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记5 函数其二&amp;OOP其一</title>
    <link href="https://fusionbolt.github.io/2022/01/23/rc-lang-dev-5/"/>
    <id>https://fusionbolt.github.io/2022/01/23/rc-lang-dev-5/</id>
    <published>2022-01-23T03:28:49.000Z</published>
    <updated>2022-01-30T05:15:56.660Z</updated>
    
    <content type="html"><![CDATA[<p>本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽</p><p>那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。</p><h1 id="函数在VM的实现"><a href="#函数在VM的实现" class="headerlink" title="函数在VM的实现"></a>函数在VM的实现</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前没有提及函数相关的内容在vm是怎么实现的，所以这里首先提及这个话题</p><p>函数的实现无外乎就是调用与返回的情况，这里再多加一个关于getlocal和setlocal以及计算的实现部分。</p><p>先来简单回顾一下我们的栈上的信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">       tmp var</span><br><span class="line">--------------------</span><br><span class="line">      local var           f1</span><br><span class="line">-------------------- </span><br><span class="line">        args</span><br><span class="line">--------------------  ----------------</span><br><span class="line">       tmp var</span><br><span class="line">--------------------</span><br><span class="line">      local var           main</span><br><span class="line">-------------------- </span><br><span class="line">        args</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><p>除了这些再来看一下我们的栈帧</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackFrame</span></span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;StackFrame&gt; _prev;</span><br><span class="line">    char *_base;</span><br><span class="line">    size_t _ret_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于这些成员都是因为什么需要增加的，请回顾上期内容</p><p><a class="link"   href="https://homura.live/2022/01/16/rc-lang-dev-4/" >Rc-lang开发周记4 函数其一 | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ol><li><p>去符号表找符号</p><p>这一步在vm中处理，找到符号的话将信息传递给栈来做第二步</p></li><li><p>栈处理</p></li><li><p>更新pc</p></li></ol><p>着重讲一下栈的处理</p><ol><li><p>设置当前栈帧基址</p><p>由于目前参数是在call之前push的（这个push一定紧接着call），因此需要先将stack_top指针移动到第0个参数的位置，得出基址</p></li><li><p>分配局部变量空间</p><p>根据局部变量的数量再将栈基址向上移动</p></li><li><p>创建新的栈帧</p></li></ol><p>实现代码，都在eval_stack.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">size_t</span> argc, <span class="keyword">size_t</span> locals, <span class="keyword">size_t</span> ret_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.set stack base</span></span><br><span class="line">    <span class="keyword">auto</span> *base = <span class="built_in">get_args_begin</span>(argc);</span><br><span class="line">    <span class="comment">// 2.alloc local var space</span></span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(base, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(locals));</span><br><span class="line">    <span class="comment">// 3.create new stack frame</span></span><br><span class="line">    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_args_begin</span><span class="params">(<span class="keyword">size_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _stack_top - argc * WordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">stack_move</span><span class="params">(<span class="keyword">char</span> *stack_pos, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack_pos + offset * WordLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于WordLength</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> WordLength = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ol><li><p>获取返回值</p><p>由于在函数体内计算的时候最后会将返回值push到栈顶，那么这里需要先pop将值取出来</p></li><li><p>栈帧回退</p></li><li><p>重置pc</p></li><li><p>返回值放到栈顶</p></li></ol><p>这个返回值有点折腾…目前就先这个样子</p><p>这里也是着重讲一下栈帧回退</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">end_call</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret_addr = _frame-&gt;<span class="built_in">ret_addr</span>();</span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(_frame-&gt;<span class="built_in">base</span>(), <span class="number">-1</span>);</span><br><span class="line">    _frame = _frame-&gt;<span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">return</span> ret_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getlocal-setlocal"><a href="#getlocal-setlocal" class="headerlink" title="getlocal/setlocal"></a>getlocal/setlocal</h3><p>就是简单的从当前栈基址添加偏移量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_local</span><span class="params">(<span class="keyword">size_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">get_base_offset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(offset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_local</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *<span class="built_in">get_base_offset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(offset)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_base_offset</span><span class="params">(<span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_offset_pos</span>(_frame-&gt;<span class="built_in">base</span>(), offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">(Callable &amp;&amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_v = <span class="built_in">f</span>(<span class="built_in">pop</span>(), <span class="built_in">pop</span>());</span><br><span class="line">    <span class="built_in">push</span>(new_v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数最基本的功能完成了，那我们该做创建对象相关的部分了。</p><h1 id="从常见的类开始"><a href="#从常见的类开始" class="headerlink" title="从常见的类开始"></a>从常见的类开始</h1><p>我们从一个常见的类的例子开始引入我们的问题</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="variable">@a</span> = a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(b)</span></span></span><br><span class="line"><span class="variable">@a</span> + b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个类很简单，一个成员变量、一个构造函数和一个实例方法。</p><p>在我们想要使用这个类之前，我们需要在编译期间先解析这个类的信息</p><h2 id="解析成员"><a href="#解析成员" class="headerlink" title="解析成员"></a>解析成员</h2><p>创建一个类表。保存了所有定义的类的定义，以及可以作为一个类型查询表。</p><p>这个解析的过程一度想要直接从Ruby抄一套类似的，但是工作量会非常大，因为需要到基类查找方法，牵扯到继承等各种问题</p><p>目前类的ast结构</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDefine</span></span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:define</span>, <span class="symbol">:parent</span>, <span class="symbol">:fun_list</span>, <span class="symbol">:var_list</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个定义中define是之前做的对于现在来说是不必要的内容，但是我目前时间有限不太敢动，怕前面的东西都乱套了，留个todo再说。parent是因为之前ast解释器的部分做了继承，但是目前vm这边还没有开始做，也就先不管它</p><p>对于成员函数全部翻译一遍，重命名一下符号，而对于成员变量，直接将信息添加到对应的表中即可。所以目前ClassTable是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span> = &#123;&#125;</span><br><span class="line">    <span class="variable">@instance_vars</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_method</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_var</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_vars</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>除了解析信息，还需要在运行的时候创建这个类的对象。创建对象则分为两步</p><ol><li>分配内存</li><li>初始化</li></ol><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>关于分配内存我们需要知道</p><ol><li>为了知道所分配空间的大小，首先需要获取类型信息。那么该如何获取类型信息以及类型信息怎么存放，存在哪里</li></ol><p>目前不考虑元编程的地方，所以这些信息都是编译期间可知的。假设要做更多元编程的内容，那么需要将一部分的内容放到运行时处理。按照我的理解来说，到时候将类型信息传递给vm，以及添加一些指令专门用于做元编程（这样指令种类会增加很多）。但这仅限于我粗浅的理解，更详细的还是要等到我做的时候再考虑。</p><ol><li>如何计算空间大小</li></ol><p>这个时候可能会出现一个最简单不过的想法，直接将所有成员大小都加起来不就好了。但是如果这样做，地址无法对齐，在vm那边取是很麻烦的事情。关于对齐暂时也不考虑，目前只考虑数据全为一个字长的整型数字，因此产生的对象也只会有带有这样成员的数字。还有会遇到空对象的情况，没有任何成员函数该怎么办（关于空对象，下文会单独提一下）</p><p>除了基本的空间大小，还需要考虑留有GC信息的头部。这个就牵扯到下一个问题</p><ol><li>数据保存的格式</li></ol><p>GC需要保存哪些对象信息，这些信息又是如何保存的。关于这一点在后面的Ruby的Object实现中会略微提及</p><p>GC相关的更多内容要等到之后实现的时候再更详细的提及了</p><p>关于这里实际上还有更多复杂的话题，比如说递归数据类型，Union等，这些也都以后做的时候再来讨论</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>这里涉及到了一个问题，一个最简单的Foo对象并没有构造函数，那么我们需要先在ast的阶段生成对应的“无参”构造函数。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用这里本质上是一个方法查找机制，目前想先做最简单的，后面按需添加。直接去对应的this指针，找到对应类的信息，然后再从类表中进行查找，还没做实现，大概会到下周的内容中</p><p>同时这个方法也是作为一个成员函数被调用（尽管是外部不可见的），这里就顺便讲调用成员函数的做法</p><p>首先考虑调用成员函数的时候就需要引入this指针了，这个属于固定在栈内的内容，所以我把它放到了栈帧的结构中，而不是栈的实际数据中。</p><h3 id="一些语言this相关"><a href="#一些语言this相关" class="headerlink" title="一些语言this相关"></a>一些语言this相关</h3><p>说到this指针，我想到了两个语言</p><p>第一个是Python，因为Python是需要显式传递self的</p><p>另一个是C#，C#的extension机制大概是这个样子，通过这种方式来给某个类添加类函数，我没有深究过后面的实现机制，但我想大概是解析到这里就给符号表中的这个类添加一个成员函数吧</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SomeClassExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"><span class="keyword">this</span> SomeClass instance, args</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Ruby本身也有一些相似的对象，定义类函数的时候会需要self。不过这里的self的含义变成了这个类，而不是某个实例成员</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">def <span class="keyword">self</span>.f</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="无成员变量类"><a href="#无成员变量类" class="headerlink" title="无成员变量类"></a>无成员变量类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line">    a + b</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种情况最大的问题在于对象空间大小的问题。目前我已知的做法有如下几种</p><p>C++中对于类似的类在实例化的时候会有一个一字节的空间占用，为的是区分地址</p><p>而Rust则有一个叫ZeroSizedTypes的东东，在谷歌搜索的时候搜索到了这样一段代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, size_of::&lt;()&gt;());</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, size_of::&lt;[(); <span class="number">100</span>]&gt;());</span><br><span class="line">   <span class="keyword">let</span> boxed_unit = <span class="built_in">Box</span>::new(());</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, boxed_unit); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：zqliang</span><br><span class="line">链接：https:<span class="comment">//ld246.com/article/1539826769170</span></span><br><span class="line">来源：链滴</span><br><span class="line">协议：CC BY-SA <span class="number">4.0</span> https:<span class="comment">//creativecommons.org/licenses/by-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0x1</span></span><br></pre></td></tr></table></figure><p>可以看到Rust不像C++一样会有一字节的空间占用</p><p>带有GC的语言通常是会有一个header的开销（header用于存储类型以及GC信息），成员域部分会因实际实现不同而不同</p><p>对于Ruby来说Object是这个样子的。因此对象即便为空也会有下面这个union的开销</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span></span> basic;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125; heap; <span class="comment">//省略</span></span><br><span class="line">        Value ary[ROBJECT_EMBED_LEN_MAX];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ruby的类与函数"><a href="#Ruby的类与函数" class="headerlink" title="Ruby的类与函数"></a>Ruby的类与函数</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line">a = S.new()</span><br></pre></td></tr></table></figure><h2 id="成员函数和“普通函数”"><a href="#成员函数和“普通函数”" class="headerlink" title="成员函数和“普通函数”"></a>成员函数和“普通函数”</h2><h3 id="定义对比"><a href="#定义对比" class="headerlink" title="定义对比"></a>定义对比</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f1@&lt;compiled&gt;<span class="symbol">:</span><span class="number">1</span> (<span class="number">1</span>,<span class="number">0</span>)-(<span class="number">3</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (   <span class="number">2</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (   <span class="number">3</span>)[Re]</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:initialize@&lt;compiled&gt;<span class="symbol">:</span><span class="number">5</span> (<span class="number">5</span>,<span class="number">2</span>)-(<span class="number">7</span>,<span class="number">5</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (   <span class="number">6</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (   <span class="number">7</span>)[Re]</span><br></pre></td></tr></table></figure><p>可以看到编译出的函数没什么不同。我想这是因为Ruby的一切皆对象的缘故。哪怕只是一个单独的函数，也是定义在Kernel中，本质上还是一个成员函数。</p><p>而这个initialize也是和普通的成员函数是一致的，特别之处只是会在Object的new中被调用，甚至和普通成员函数一样可以被外部调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f1@&lt;compiled&gt;<span class="symbol">:</span><span class="number">9</span> (<span class="number">9</span>,<span class="number">2</span>)-(<span class="number">11</span>,<span class="number">5</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (  <span class="number">10</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (  <span class="number">11</span>)[Re]</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0011</span> putself                                                          (   <span class="number">9</span>)[Li]</span><br><span class="line"><span class="number">0012</span> opt_send_without_block                 &lt;calldata!<span class="symbol">mid:</span>f1, <span class="symbol">argc:</span><span class="number">0</span>, FCALL<span class="params">|VCALL|</span>ARGS_SIMPLE&gt;</span><br></pre></td></tr></table></figure><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0003</span> putspecialobject                       <span class="number">3</span>                         (   <span class="number">3</span>)[Li]</span><br><span class="line"><span class="number">0005</span> putnil</span><br><span class="line"><span class="number">0006</span> defineclass                            <span class="symbol">:S</span>, &lt;<span class="class"><span class="keyword">class</span>:<span class="title">S</span>&gt;, 0</span></span><br><span class="line"><span class="number">0010</span> pop</span><br></pre></td></tr></table></figure><p>这里可以看到，Ruby中类也是和method一样是通过特殊的vm指令进行动态定义的</p><p>编译出的类定义的内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:&lt;class:S&gt;@&lt;compiled&gt;<span class="symbol">:</span><span class="number">4</span> (<span class="number">4</span>,<span class="number">0</span>)-(<span class="number">12</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> definemethod                           <span class="symbol">:initialize</span>, initialize   (   <span class="number">5</span>)[LiCl]</span><br><span class="line"><span class="number">0003</span> definemethod                           <span class="symbol">:f1</span>, f1                   (   <span class="number">9</span>)[Li]</span><br><span class="line"><span class="number">0006</span> putobject                              <span class="symbol">:f1</span></span><br><span class="line">0008 leave</span><br></pre></td></tr></table></figure><h2 id="调用构造函数的全部流程流程"><a href="#调用构造函数的全部流程流程" class="headerlink" title="调用构造函数的全部流程流程"></a>调用构造函数的全部流程流程</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0016</span> opt_getinlinecache                     <span class="number">25</span>, &lt;<span class="symbol">is:</span><span class="number">0</span>&gt;                (   <span class="number">9</span>)[Li]</span><br><span class="line">0019 putobject                              <span class="literal">true</span></span><br><span class="line"><span class="number">0021</span> getconstant                            <span class="symbol">:S</span></span><br><span class="line"><span class="number">0023</span> opt_setinlinecache                     &lt;<span class="symbol">is:</span><span class="number">0</span>&gt;</span><br><span class="line"><span class="number">0025</span> opt_send_without_block                 &lt;calldata!<span class="symbol">mid:</span>new, <span class="symbol">argc:</span><span class="number">0</span>, ARGS_SIMPLE&gt;</span><br><span class="line"><span class="number">0027</span> dup</span><br><span class="line">0028 setlocal_WC_0                          a@<span class="number">1</span></span><br></pre></td></tr></table></figure><p>除去前面的优化和后面的赋值操作，可以发现new对象的时候实际调用还是在new上而不是所谓的构造函数。可以从这里一定程度的看到Ruby创建对象的实现：Ruby在创建对象的时候是会先调用隐含的new函数（继承自Object），而这个new函数的默认实现会调用allocate，之后调用对应的initialize方法，最后再将new出来的对象返回。关于这个知识点在之前做TypeStruct的时候也提及过，有兴趣的可以去看一下</p><p><a class="link"   href="https://homura.live/2022/01/09/rc-lang-dev-3/" >Rc-lang开发周记3 生成C++代码 | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Ruby原理剖析</p><p>垃圾回收的算法与实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽&lt;/p&gt;
&lt;p&gt;那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记4 函数其一</title>
    <link href="https://fusionbolt.github.io/2022/01/16/rc-lang-dev-4/"/>
    <id>https://fusionbolt.github.io/2022/01/16/rc-lang-dev-4/</id>
    <published>2022-01-16T09:03:13.000Z</published>
    <updated>2022-01-30T05:15:56.660Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。</p><h1 id="函数解析方式"><a href="#函数解析方式" class="headerlink" title="函数解析方式"></a>函数解析方式</h1><p>这里我一开始没想好怎么做的，所以会做的很诡异，最大的原因是静态类型语言和动态类型语言是不同的。由于我只对动态语言有一些了解，这里暂时只提动态语言的一些点</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>手头动态类型语言的资料是相对较多的，而实际看编译出的产物也是相对熟悉一些。</p><p>对于Ruby和Python来说，函数都是动态定义的。因此解析到一个函数的时候会产生一个定义函数的指令</p><p>Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> definemethod     <span class="symbol">:foo</span>, foo      (   <span class="number">1</span>)[Li]</span><br></pre></td></tr></table></figure><p>（后面的1是行号）</p><p>Python</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span>:</span><br><span class="line"><span class="number">0</span> LOAD_CONST    <span class="number">0</span> (code object f)</span><br><span class="line"><span class="number">3</span> MAKE_FUNCTION <span class="number">0</span></span><br><span class="line"><span class="number">6</span> STORE_NAME    <span class="number">0</span> (f)</span><br></pre></td></tr></table></figure><p>而函数本体内容则是创建了一个函数对象并放到了其他的位置，以及地址是重新从0开始的。这个地址应该是相对地址，因为会动态装载</p><p>这两个的源代码不一样的，只是想展示地址都是从0开始。dump出来的内容差异也比较大</p><p>Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line"> a = <span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:foo@&lt;compiled&gt;<span class="symbol">:</span><span class="number">9</span> (<span class="number">9</span>,<span class="number">0</span>)-(<span class="number">11</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line">local table (<span class="symbol">size:</span> <span class="number">1</span>, <span class="symbol">argc:</span> <span class="number">0</span> [<span class="symbol">opts:</span> <span class="number">0</span>, <span class="symbol">rest:</span> -<span class="number">1</span>, <span class="symbol">post:</span> <span class="number">0</span>, <span class="symbol">block:</span> -<span class="number">1</span>, <span class="symbol">kw:</span> -<span class="number">1</span>@-<span class="number">1</span>, <span class="symbol">kwrest:</span> -<span class="number">1</span>])</span><br><span class="line">[ <span class="number">1</span>] a<span class="variable">@0</span></span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">3</span>                         (  <span class="number">10</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> putobject                              <span class="number">2</span></span><br><span class="line"><span class="number">0004</span> opt_mult                               &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;[CcCr]</span><br><span class="line"><span class="number">0006</span> dup</span><br><span class="line"><span class="number">0007</span> setlocal_WC_0                          a<span class="variable">@0</span></span><br><span class="line">0009 leave</span><br></pre></td></tr></table></figure><p>Python（函数体被编译成的内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span>:</span><br><span class="line">print(<span class="string">&quot;Function&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> LOAD_CONST <span class="number">1</span> (“Function”)</span><br><span class="line"><span class="number">3</span> PRINT_ITEM</span><br><span class="line"><span class="number">4</span> PRINT_NEWLINE</span><br><span class="line"><span class="number">5</span> LOAD_CONST <span class="number">0</span> (None)</span><br><span class="line"><span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一开始是想仿照做一个动态的实现，但是后来觉得还是静态的好，导致产生了如下的代码。</p><p>对于一个函数，我生成了一个DefineFun。FunLabel是因为我不知道它们是如何判断函数结尾到哪里的，这属于我当时的一个理解错误，编译的时候函数体的内容会被编译好放到其他位置，而不是说运行时再看到一个函数的标签，再将之后的一段代码跳过。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只展示关键部分</span></span><br><span class="line"><span class="comment"># 错误版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  [DefineFun.new(node.name), <span class="keyword">super</span>(node), Return.new, FunEnd.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>正确的做法应当是在编译的时候就将这些代码单独放到其他位置，运行时再进行装载。</p><h1 id="调用无参函数"><a href="#调用无参函数" class="headerlink" title="调用无参函数"></a>调用无参函数</h1><p>函数调用我们先从简单的无参函数说起</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>那么首先，我们需要考虑到call的target如何来做处理。很自然的会想到target可以使用字符串。</p><p>尽管使用字符串的话会导致指令长度膨胀，解析复杂等。但目前不考虑那些，解析的也是字符串指令，所以先这样</p><h2 id="去哪里找目标函数的信息"><a href="#去哪里找目标函数的信息" class="headerlink" title="去哪里找目标函数的信息"></a>去哪里找目标函数的信息</h2><p>这个自然来说是需要符号表中保存了</p><h3 id="符号表中的函数信息"><a href="#符号表中的函数信息" class="headerlink" title="符号表中的函数信息"></a>符号表中的函数信息</h3><p>对于符号表来说，表中条目需要保存的信息有以下几条</p><ol><li>参数个数（目前全部为无类型，因此返回类型也无需考虑）</li><li>local变量的信息</li><li>函数体的指令地址</li></ol><p>这些<strong>目前</strong>来说都是编译期间可知的，所以也会以字符串的方式dump出来供vm去解析。至于函数体地址的问题牵扯到链接，而目前我们先不需要考虑链接的情况，只需要将生成的符号表中的地址加载进来就好了。</p><h3 id="生成符号表"><a href="#生成符号表" class="headerlink" title="生成符号表"></a>生成符号表</h3><p>由于以上需求，我们在编译的时候需要生成符号表信息</p><p>我们之前设计的全局符号表是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>,:<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>暂时不考虑常量表，我们需要的是剩下两个表的信息。</p><p>生成vm指令这个阶段会将一个全局定义表（define_env，目前仅存其定义），将其定义更改为args以及offset</p><p>offset都是未知的所以先设置为一个未定义值，因为我是通过返回数组并且把数组连接起来的形式，所以这个时候并不知道偏移量。这里用一个数组存放值的做法实在很差劲，但是实在没精力改进了…先能跑吧</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">    ...  </span><br><span class="line">    <span class="variable">@global_env</span>.define_env[node.name] = [node.args, <span class="string">&#x27;undefined&#x27;</span>]</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>重新设置偏移量</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inst.each_with_index <span class="keyword">do</span> <span class="params">|ins, index|</span>  </span><br><span class="line">    <span class="keyword">if</span> ins.is_a? DefineFun    </span><br><span class="line">        <span class="variable">@global_env</span>.define_env[ins.name][<span class="number">1</span>] = index  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而fun_env表，则是保存了每个表的参数以及局部变量的信息。拥有fun_env表和define_env表（这两个表其实应该合并，下次一定…）的信息，我们就能够生成出上面所需的信息了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_sym_table</span><span class="params">(global_env)</span></span>  </span><br><span class="line">    global_env.define_env.map <span class="keyword">do</span> <span class="params">|name, (args, offset)|</span></span><br><span class="line">        <span class="string">&quot;<span class="subst">#&#123;name&#125;</span> <span class="subst">#&#123;args.size&#125;</span> <span class="subst">#&#123;global_env.fun_env[name].size&#125;</span> <span class="subst">#&#123;offset&#125;</span>&quot;</span>  </span><br><span class="line">    <span class="keyword">end</span>.join(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成示例 格式为 函数名，参数个数，local var个数，起始地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi <span class="number">2</span> <span class="number">2</span> <span class="number">0</span>main <span class="number">0</span> <span class="number">1</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>函数符号表中的条目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunInfo</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="built_in">FunInfo</span>(): <span class="built_in">FunInfo</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(<span class="keyword">size_t</span> _argc, <span class="keyword">size_t</span> _locals, <span class="keyword">size_t</span> _begin): <span class="built_in">argc</span>(_argc), <span class="built_in">locals</span>(_locals), <span class="built_in">begin</span>(_begin) &#123;&#125;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(constFunInfo&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(FunInfo&amp;&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    FunInfo&amp;<span class="keyword">operator</span>=(constFunInfo&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    FunInfo&amp;<span class="keyword">operator</span>=(FunInfo&amp;&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    <span class="keyword">size_t</span> argc;    </span><br><span class="line">    <span class="keyword">size_t</span> locals;    </span><br><span class="line">    <span class="keyword">size_t</span> begin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>既然要调用函数，那么就需要调用栈这个东西了</p><p>就目前的需求来说，调用栈中的栈帧需要有以下几种成员</p><ol><li>前一个栈帧（跟踪整个调用链）</li><li>返回的pc地址（函数调用结束后需要返回到调用者）</li><li>当前栈帧在栈中的起始地址（起始地址开始分配局部变量的空间）</li></ol><p>关于多个栈帧之间的存储方式，由于需要频繁添加删除尾部结点，因此选择了链表的方式。如果使用数组的话会牵扯到长度不够再重新分配数组空间的情况</p><p>而实际栈内数据的布局是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------        f1</span><br><span class="line">    local var</span><br><span class="line">----------------  ----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------        main</span><br><span class="line">    local var</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><p>注意这里和实际的栈不同，对于实际的栈来说类似于返回的pc地址，以及前一个栈帧的地址都是保存在栈内的</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>目前的设计是返回值最后放到栈顶，这样返回的时候直接从栈顶取值，之后再恢复栈就可以了</p><h1 id="调用带参数的函数"><a href="#调用带参数的函数" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b)</span></span></span><br><span class="line">    c = a + b</span><br><span class="line">    c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>目前采用的是push的方式直接push参数，这个体现在函数调用的时候编译出的指令上</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">    fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(fun_call.name)]  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>栈内数据排布</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------</span><br><span class="line">    local var           f1</span><br><span class="line">---------------- </span><br><span class="line">      args</span><br><span class="line">----------------  ----------------</span><br><span class="line">     tmp var</span><br><span class="line">----------------</span><br><span class="line">    local var           main</span><br><span class="line">---------------- </span><br><span class="line">      args</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><p>关于参数传递的话题其实还有很多，比如说顺序，变长参数，谁来释放，在之后的内容再一点点补足</p><h1 id="正文无关闲谈"><a href="#正文无关闲谈" class="headerlink" title="正文无关闲谈"></a>正文无关闲谈</h1><p>首先是最重要的一点：本周的内容就充满了各种应付式的内容，这在往期我都是会直接当场修改掉的，但实属有些无力…我在想这样的内容发出来会不会很不负责任，但是如果停更那我所做出的每周更新的承诺这么快就要被打破了，而且以后更容易不遵守了。</p><p>本周的内容相对少的多，最加对于压力的感知更加明显了，尽管我反复将注意力转移到当前做的事情上（每天也会有对应冥想练习），但很多事情依然力不从心。时间安排的太满，我不会的太多，但每一项我都无法舍弃，最后分配到做这个的时间真的不多了，还要一边查看各种实现学习一边写，好多东西都是周日写的时候才学习修改的。学习实现基本上也是靠看书，看前人总结过的内容，对于大型项目实在没有精力去扒。这周还在看Ruby的YJIT的论文，本就不多的时间更没多少了，最后论文也没看多少（就看了几段介绍…），这篇论文读明白后也会再出一篇博客，尽管只看了一点但也让我增加了许多JIT方面的常识</p><p><a class="link"   href="https://dl.acm.org/doi/10.1145/3486606.3486781" >YJIT: a basic block versioning JIT compiler for CRuby<i class="fas fa-external-link-alt"></i></a></p><p>如何能摆脱这种状态，如果读者有经验还请赐教</p><p>如果我是学生的时候就能开始做这件事情就好了..可是没有那么多如果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。&lt;/p&gt;
&lt;h1 id=&quot;函数解析方式&quot;&gt;&lt;a href=&quot;#函数解析方式&quot; class=&quot;headerlink&quot; title=&quot;函数解析方式&quot;&gt;&lt;/a&gt;函数解析方式&lt;/h1&gt;&lt;p&gt;这里我一开始</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记3 生成C++代码</title>
    <link href="https://fusionbolt.github.io/2022/01/09/rc-lang-dev-3/"/>
    <id>https://fusionbolt.github.io/2022/01/09/rc-lang-dev-3/</id>
    <published>2022-01-09T04:00:35.000Z</published>
    <updated>2022-01-30T05:15:56.659Z</updated>
    
    <content type="html"><![CDATA[<p>由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。</p><h1 id="指令定义"><a href="#指令定义" class="headerlink" title="指令定义"></a>指令定义</h1><p>每个指令有一个InstType的枚举字段来标明类型</p><p>所有指令继承自一个VMInst类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMInst</span> &#123;</span></span><br><span class="line">    InstType type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">VMInst</span>(InstType t) : <span class="built_in">type</span>(t) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Addr</span> :</span> VMInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Addr</span>(<span class="keyword">int</span> offset, string seg) : <span class="built_in">VMInst</span>(InstType::Addr), _offset(offset), _seg(seg) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _offset;</span><br><span class="line">    string _seg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-解析"><a href="#C-解析" class="headerlink" title="C++解析"></a>C++解析</h1><p>最主要的问题是要如何让C++解析这边生成的东西。我目前就选用了最简单粗暴的方法，直接生成字符串，用空格分离参数，用换行分离指令</p><h1 id="获取所有指令信息"><a href="#获取所有指令信息" class="headerlink" title="获取所有指令信息"></a>获取所有指令信息</h1><h2 id="获取有哪些指令"><a href="#获取有哪些指令" class="headerlink" title="获取有哪些指令"></a>获取有哪些指令</h2><p>我将所有的指令都放到了Rc::VM::Inst中，通过获取这个module的所有constant，判断哪些是Class</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_classes</span><span class="params">(mod)</span></span></span><br><span class="line">mod.constants.map&#123;<span class="params">|c|</span> mod.const_get(c)&#125;.select&#123;<span class="params">|c|</span> c.is_a? Class&#125;.sort_by&#123; <span class="params">|klass|</span> klass.to_s &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">classes = get_classes(Rc::VM::Inst)</span><br></pre></td></tr></table></figure><p>通过这个代码能够获取到Inst这个模块中的所有指令</p><ol><li>获取每个指令里面是怎么样的</li></ol><p>由于ruby并没有定义成员类型的东西，因此我选择自己造一个指定成员类型的东西</p><p>有两种实现</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="TypeStruct"><a href="#TypeStruct" class="headerlink" title="TypeStruct"></a>TypeStruct</h3><p>第一种是将Struct给包装一层，我给其命名为TypeStruct</p><p><strong>使用方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondJump</span> &lt;</span> TypeStruct.<span class="built_in"><span class="keyword">new</span></span>(:cond, :addr =&gt; :<span class="keyword">int</span>)</span><br><span class="line">  def to_s</span><br><span class="line">    <span class="string">&quot;CondJump #&#123;cond&#125; #&#123;addr&#125;&quot;</span></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>类似于常规的Struct的使用方式，但是输入变成了可以是一个hash</p><p><strong>实现</strong></p><ol><li><p>实现的一个要点在于new返回的东西需要是一个class。那么我们需要知道Ruby中new是怎么运作的</p><p>常规的对象来说，new中会做三件事。class MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = “\n”, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map { |td| td.name }  endend通过allocate分配空间，send initialize方法进行构造对象，最后将obj返回。而在这里只要修改返回的内容即可</p></li><li><p>另一个要点在于需要给返回的class添加一些实例方法</p><p>这里我们需要先理解常规的Struct.new做了什么，在我的理解本质上是返回了一个通过动态添加定义的匿名class，那么我们需要的是给这个匿名class添加一些方法来定义</p><p>那么我们很自然的就会想到将所有传给new的参数转换为每一个成员以及与之相应的类型定义，之后再对其中每一对“成员名⇒类型”定义对应的获取类型的方法</p></li><li><p>保存一个type_map，用于后面获取信息使用</p></li></ol><p>来看一下代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">args_to_hash</span><span class="params">(*args)</span></span></span><br><span class="line">  args.reduce(&#123;&#125;) <span class="keyword">do</span> <span class="params">|sum, arg|</span></span><br><span class="line">    sum.merge(</span><br><span class="line">      <span class="keyword">if</span> arg.is_a? Hash</span><br><span class="line">        arg</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123; arg =&gt; <span class="symbol">:str</span> &#125;</span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeStruct</span></span></span><br><span class="line">  <span class="keyword">include</span> TypeCheck</span><br><span class="line">  def <span class="keyword">self</span>.new(*args, &amp;block)</span><br><span class="line">    <span class="comment"># if don&#x27;t have allocate, will be nil class</span></span><br><span class="line">    obj = allocate</span><br><span class="line">    <span class="comment"># initialize is a private method</span></span><br><span class="line">    <span class="comment"># initialize must be send instead of direct call</span></span><br><span class="line">    obj.send(<span class="symbol">:initialize</span>, *args, &amp;block)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(*args)</span></span></span><br><span class="line">    args = args_to_hash(*args)</span><br><span class="line">    Struct.new(*args.keys).tap <span class="keyword">do</span> <span class="params">|klass|</span></span><br><span class="line">      args.each <span class="keyword">do</span> <span class="params">|attr, type|</span></span><br><span class="line">        check(type)</span><br><span class="line">        <span class="comment"># per class Struct is different</span></span><br><span class="line">        klass.define_method <span class="string">&quot;<span class="subst">#&#123;attr&#125;</span>_t&quot;</span> <span class="keyword">do</span></span><br><span class="line">          type</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  klass.define_method <span class="string">&quot;type_map&quot;</span> <span class="keyword">do</span></span><br><span class="line">        args</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>还有一个点是需要在这里检查type的合法性，这里想过生成类的，但是最后想或许现在没必要，还是先用符号吧。检查相关的代码如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">TypeCheck</span></span></span><br><span class="line">  VALID_TYPE = &#123;<span class="symbol">:int</span> =&gt; <span class="symbol">:int</span>, <span class="symbol">:str</span> =&gt; <span class="symbol">:string</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">invalid?</span><span class="params">(type)</span></span></span><br><span class="line">    VALID_TYPE.keys.<span class="keyword">include</span>? type</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(type)</span></span></span><br><span class="line">    <span class="keyword">unless</span> invalid? type</span><br><span class="line">      raise <span class="string">&quot;invalid type <span class="subst">#&#123;type&#125;</span>, only supported <span class="subst">#&#123;VALID_TYPE.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:check</span>, <span class="symbol">:invalid?</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="attr-type"><a href="#attr-type" class="headerlink" title="attr_type"></a>attr_type</h3><p>第二种是增加了一个像attr_reader一样叫做attr_type的东西，但是这个要依赖于常规的Struct，我还是想要常规Struct内部的东西来避免重复代码。虽然有办法不依赖Struct，但是那样需要在这个attr_type里面引入更多不属于这个函数的功能，于是还是放弃吧</p><p><strong>使用示例</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Push</span> &lt; Struct.<span class="title">new</span>(:<span class="title">value</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:value</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;Push <span class="subst">#&#123;value&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><p>实现的核心原理还是参数转到hash再对每一对值define_method，只是这次我们要直接hack Module。attr_reader等函数也是采用的类似的做法</p><p>type_map的处置有一些不同，type_map需要将成员初始化，所有成员默认str类型，接着需要不断的merge新的参数，这个时候会将type_map中在args出现过的key所关联的值更新，这么解释可能比较复杂，看代码更直接一些</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;.merge(&#123;<span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;)</span><br><span class="line">=&gt; &#123;<span class="symbol">:a=&gt;</span><span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">attr_type</span><span class="params">(*args)</span></span></span><br><span class="line">    args = args_to_hash(*args)</span><br><span class="line">    args.map <span class="keyword">do</span> <span class="params">|attr, type|</span></span><br><span class="line">      TypeCheck::check(type)</span><br><span class="line">      define_method <span class="string">&quot;<span class="subst">#&#123;attr&#125;</span>_t&quot;</span> <span class="keyword">do</span></span><br><span class="line">        type</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="variable">@type_map</span> <span class="params">||</span>= <span class="keyword">self</span>.members.reduce(&#123;&#125;) &#123;<span class="params">|mem|</span> &#123;mem =&gt; <span class="symbol">:str</span>&#125;&#125;</span><br><span class="line">    <span class="variable">@type_map</span>.merge!(args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="二者的选择"><a href="#二者的选择" class="headerlink" title="二者的选择"></a>二者的选择</h3><p>最后的结果嘛…ide分析不出来，不想看到各种报错的红线。遇到需要手动new的时候只能改成第二种了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Untitled.png"                      alt="Untitled"                ></p><p>在获取成员的时候也用了很脏的做法，没找到什么在不new的情况下获取成员的好方法，因此也只有先new再从里面找。</p><h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><h2 id="以前没做的坑"><a href="#以前没做的坑" class="headerlink" title="以前没做的坑"></a>以前没做的坑</h2><p>这里其实做一个dsl来描述然后生成是最好的。在好久之前了解rv的时候我甚至一度想开一个坑，用一个dsl来描述一个isa，之后生成对应的C++的读写代码。最后也是咕咕咕了，后续有时间可以做一下，还是挺有意思的。</p><p>这是一个描述load store的例子。当时做的时候没想到，现在一想其实也可以直接用Struct来描述，采用和我上面一致的方案</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISA.define <span class="symbol">:LOAD</span> <span class="keyword">do</span>  field <span class="symbol">:rd</span>, <span class="number">5</span>  field <span class="symbol">:funct3</span>, <span class="number">3</span>  field <span class="symbol">:rs1</span>, <span class="number">5</span>  field <span class="symbol">:imm</span>, 12endISA::define <span class="symbol">:STORE</span> <span class="keyword">do</span>  field <span class="symbol">:offset_4_0</span>, <span class="number">5</span>  field <span class="symbol">:width</span>, <span class="number">3</span>  field <span class="symbol">:base</span>, <span class="number">5</span>  field <span class="symbol">:src</span>, <span class="number">5</span>  field <span class="symbol">:offset</span>, 5end</span><br></pre></td></tr></table></figure><p>这是一个只做了外观没有做内部实现的例子，<del>属实有点问题，正经人谁会搞出这玩意</del></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace <span class="symbol">:Suica</span> <span class="keyword">do</span>  namespace <span class="symbol">:T</span> <span class="keyword">do</span>    struct <span class="symbol">:F</span> <span class="keyword">do</span>      auto <span class="symbol">:a1</span>      auto <span class="symbol">:a2</span>, <span class="number">1</span>      void <span class="symbol">:f2</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>] <span class="keyword">do</span>      <span class="keyword">end</span>    <span class="keyword">end</span>  endend</span><br></pre></td></tr></table></figure><h2 id="生成的实现"><a href="#生成的实现" class="headerlink" title="生成的实现"></a>生成的实现</h2><p>有点扯远了，我们来看一下实际生成C++代码的部分。</p><p>我们需要生成如下几步</p><ol><li>获取所有指令信息</li><li>include头文件，名称空间等内容</li><li>InstType的enum定义</li><li>所有指令类的定义</li><li>解析输入的部分</li></ol><p>每个部分生成一个源码字符串，最后将这些拼接为一个长的字符串就好了</p><p>捋清这个流程以后就简单贴一下部分代码好了，源码中&lt;&lt;SRC的部分是一个字符串块的开始，SRC是结束，中间的任何字符都会保留，除了#{expr}，这个是将expr to_s以后再嵌入进去</p><h2 id="帮助方法"><a href="#帮助方法" class="headerlink" title="帮助方法"></a>帮助方法</h2><p>这是我自己加给Array的辅助函数，因为经常会有需要遍历array的所有对象做一套统一的操作最后再join连接的情况</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(c = <span class="string">&quot;\n&quot;</span>, &amp;f)</span></span></span><br><span class="line">    map &#123;<span class="params">|a|</span> f[a] &#125;.join(c)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pure_generate</span><span class="params">(&amp;f)</span></span></span><br><span class="line">    map &#123; <span class="params">|a|</span> a.demodulize_class &#125;.generate(&amp;f)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>demodulize_class的话就是简单的将类名去除了module前缀</p><h2 id="获取所有指令信息-1"><a href="#获取所有指令信息-1" class="headerlink" title="获取所有指令信息"></a>获取所有指令信息</h2><p>虽然上面提过，这里再放一下代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_classes</span><span class="params">(mod)</span></span>  </span><br><span class="line">    mod.constants.map&#123;<span class="params">|c|</span> mod.const_get(c)&#125;.select&#123;<span class="params">|c|</span> c.is_a? Class&#125;.sort_by&#123; <span class="params">|klass|</span> klass.to_s &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_header_namespace</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">#include &lt;string&gt;</span></span><br><span class="line"><span class="string">#include &lt;vector&gt;</span></span><br><span class="line"><span class="string">#include &lt;memory&gt;</span></span><br><span class="line"><span class="string">#pragma once</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">using std::string;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="InstType的enum定义"><a href="#InstType的enum定义" class="headerlink" title="InstType的enum定义"></a>InstType的enum定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_enum_inst_type</span><span class="params">(classes)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">enum class InstType &#123;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;classes.pure_generate &#123;<span class="params">|c|</span> <span class="string">&quot;<span class="subst">#&#123;c&#125;</span>,&quot;</span>&#125;</span>&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">InstType</span> &#123;</span></span><br><span class="line">Add,</span><br><span class="line">Label,</span><br><span class="line">SetLocal,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指令类定义"><a href="#指令类定义" class="headerlink" title="指令类定义"></a>指令类定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_class_define</span><span class="params">(klass)</span></span></span><br><span class="line">  class_name = klass.demodulize_class</span><br><span class="line">  member_map = klass.get_member_map</span><br><span class="line">  params = member_map.generate(<span class="string">&#x27;, &#x27;</span>) &#123;<span class="params">|td|</span> gen_class_member(td)&#125;</span><br><span class="line">  init_member = <span class="string">&quot;<span class="subst">#&#123;member_map.keys.generate(<span class="string">&#x27;, &#x27;</span>) &#123;<span class="params">|name|</span> <span class="string">&quot;_<span class="subst">#&#123;name&#125;</span>(<span class="subst">#&#123;name&#125;</span>)&quot;</span>&#125;</span>&#125;&quot;</span></span><br><span class="line">  init_member = <span class="string">&quot;, <span class="subst">#&#123;init_member&#125;</span>&quot;</span> <span class="keyword">unless</span> init_member.empty?</span><br><span class="line">  init_inst = <span class="string">&quot;VMInst(InstType::<span class="subst">#&#123;class_name&#125;</span>)&quot;</span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">struct <span class="subst">#&#123;class_name&#125;</span> : VMInst</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">  <span class="subst">#&#123;class_name&#125;</span>(<span class="subst">#&#123;params&#125;</span>):<span class="subst">#&#123;init_inst&#125;</span><span class="subst">#&#123;init_member&#125;</span> &#123;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;member_map.generate &#123;<span class="params">|mem_ty|</span> <span class="string">&quot;<span class="subst">#&#123;gen_class_member(mem_ty, <span class="string">&#x27;_&#x27;</span>)&#125;</span>;&quot;</span>&#125;</span>&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里可能有一些需要提一下的东西，比如说有一个get_member_map</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_member_map</span></span></span><br><span class="line">    instance = <span class="keyword">self</span>.new</span><br><span class="line">    <span class="comment"># need keep same order</span></span><br><span class="line">    MemberMap.new(instance.try(<span class="symbol">:type_map</span>).or_else&#123;[]&#125;.map <span class="keyword">do</span> <span class="params">|name, type|</span></span><br><span class="line">      TypeDefine.new(name, type)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保持顺序，我选择了用数组来存放。指令最多无外乎一两百条，对于这个数据量不需要太去关心什么高效算法。</p><p>为了有更多的类型信息来帮助写易读和更可用的代码，一个名称类型对也转转换为了一个类型</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeDefine</span> &lt; Struct.<span class="title">new</span>(:<span class="title">name</span>, :<span class="title">type</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而MemberMap是一层包装，内部用typedefine的array存储，但也是可以像hash一样取出所有的key</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberMap</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(type_defines)</span></span></span><br><span class="line">    <span class="variable">@type_defines</span> = type_defines</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(c = <span class="string">&quot;\n&quot;</span>, &amp;f)</span></span></span><br><span class="line">    <span class="variable">@type_defines</span>.generate(c, &amp;f)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">keys</span></span></span><br><span class="line">    <span class="variable">@type_defines</span>.map &#123; <span class="params">|td|</span> td.name &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Label</span> :</span> VMInst</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Label</span>(string name):<span class="built_in">VMInst</span>(InstType::Label), _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_all_parser</span><span class="params">(classes)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">std::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;classes.generate &#123;<span class="params">|x|</span> gen_parser(x)&#125;</span>&#125;</span></span><br><span class="line"><span class="string">throw std::runtime_error(&quot;Unknown inst type&quot; + list[0]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子（这里只放一个示例</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[<span class="number">0</span>] == <span class="string">&quot;Addr&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;Addr&gt;(std::stoi(list[<span class="number">1</span>]), list[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-代码格式"><a href="#C-代码格式" class="headerlink" title="C++代码格式"></a>C++代码格式</h2><p>这里应该提一下，这种生成方式代码格式一定会乱七八糟，所以还应该调用一下clang-format处理一下。但是VM那边的clang-format之类的许多东西还没有加好，之后再做一下吧</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感谢你能看到这里，我再闲谈几句没什么关联的</p><p>这个系列我已经到了四篇，也就是一个月。持续做了这么几次已经可以确定只要不出意外自己就能连载下去，于是之后都会在推特推送我的更新（本周的就先算了，ruby本身所占比例有点大）<a class="link"   href="https://twitter.com/RealAkemiHomura" >RealAkemiHomura’ Twitter<i class="fas fa-external-link-alt"></i></a></p><p>如果对我的日常有兴趣可以点个关注，如果并不在意这个只想看后续的文章，那么可以通过rss订阅，或者每周一查看我的文章，更新一定是在周末</p><p>前面也提到元旦状态差，这些天甚至几次觉得这个系列过于玩具没有意义，想要断更、项目不想做下去了。但我最后还是决定继续更新，不为别的，只因为我还想接着做这个项目，哪怕内容如此简陋，只是一个过于简单的玩具，但我确实从中收获了知识和乐趣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。&lt;/p&gt;
&lt;h1 id=&quot;指令定义&quot;&gt;&lt;a href=&quot;#指令定义&quot; class=&quot;headerlink&quot; title=&quot;指令</summary>
      
    
    
    
    <category term="Ruby" scheme="https://fusionbolt.github.io/categories/Ruby/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="元编程" scheme="https://fusionbolt.github.io/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记2 VM相关</title>
    <link href="https://fusionbolt.github.io/2022/01/02/rc-lang-dev-2/"/>
    <id>https://fusionbolt.github.io/2022/01/02/rc-lang-dev-2/</id>
    <published>2022-01-02T01:37:17.000Z</published>
    <updated>2022-01-30T05:12:32.821Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧</p><p>本周vm的代码都在ir/vm中，translator用于转换，inst是指令定义，vm.rb是入口</p><h1 id="Function转换"><a href="#Function转换" class="headerlink" title="Function转换"></a><strong>Function转换</strong></h1><p>这是我目前的Function的ast定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:args</span>, <span class="symbol">:stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在修改function生成代码的时候发现了一个问题，因为我有默认最后一个值直接返回的设计，所以或许应该在高层添加一个将stmt显式抽出</p><p>return的操作。这个步骤现在看来大概分为简单两步</p><ol><li>消除不可达代码，比如说一个return后面还有好几个值</li><li>消除后就可以放心将最后一个语句的结果转换为一个返回值了</li></ol><p>但是第二步实际实现的时候可能没有这么简单，这里就暂提个思路，以后再回头看这个设计是否有需要</p><h1 id="无意义的tac-to-vm-inst"><a href="#无意义的tac-to-vm-inst" class="headerlink" title="无意义的tac to vm inst"></a><strong>无意义的tac to vm inst</strong></h1><p>之后做了一些将tac转到vm指令。在做这个的过程我才意识到其实不需要转成tac，对于tac和vm指令的表达力应该是同等级的，都比较偏向于中层IR。查看了一下其他语言的做法，Ruby和Java都是从AST转到了字节码</p><p>深入理解Java虚拟机310页：</p><blockquote><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作</p></blockquote><p>Ruby原理剖析36页：</p><blockquote><p>在解析完 词条生成AST之后，Ruby1.9和Ruby2.0继续把代码编译成一系列的底层指令，叫做YARV指令</p></blockquote><p>这里的YARV是Ruby的字节码解释器，而YARV指令自然就是对应的字节码。而Ruby1.9之前是直接解释执行ast的，甚至不会考虑到tac这样的东西</p><h2 id="为什么不需要先转成tac优化后再到vm指令"><a href="#为什么不需要先转成tac优化后再到vm指令" class="headerlink" title="为什么不需要先转成tac优化后再到vm指令"></a><strong>为什么不需要先转成tac优化后再到vm指令</strong></h2><p>关于这一点，我询问了朋友，最后的结论大概有以下两点。如果读者对这方面很了解希望能科普一下</p><ol><li><p>转成tac做优化以后，尤其是部分针对全局的优化会以及其他的变换会剔除掉一些JIT时所需要的信息。</p><p>关于这点我问了很久，我觉得还要尽可能地多做优化再到jit，应该要通过控制不做哪些优化来避免剔除所需信息。因为我对这几个层面所能做的优化了解不深，不知道所能做的优化有哪些差异，也没法举出例子或者说明收益</p><p>后续我又了解了一些信息，发现jit中还有一个名叫的deoptimize技术，这个出现在multi tiered jit中。关于这个的内容在我另一篇博客中</p></li><li><p>如果直接显式执行的是源码而不是字节码，先转成tac做处理再到vm指令会影响到了启动时间</p><p>Ruby是在内部对源码解析之后再由vm来执行。Java可能给大多数人的印象是必须要先编译到字节码，然后再单独加载执行字节码，但调查发现Java9开始可以通过jshell来直接执行。将这个过程封装到一起实际上也不麻烦，只是不需要你显式操作罢了</p></li></ol><p>所以经过了这些结论，前面做的tac到vm指令的就白费了，只能重新写一套从ast生成vm指令代码。生成tac这个过程并没有白费，编写的过程中让我有对这个东西有了更深的理解，以及后续可能会用tac实现优化算法。</p><h1 id="VM简介"><a href="#VM简介" class="headerlink" title="VM简介"></a><strong>VM简介</strong></h1><p>至于VM的实现，很自然的就会选择栈式VM。以学习为目的肯定要做寄存器分配，但是因为后续想做jit，所以寄存器分配就留到那个时候再做，或者说可以再从tac做成aot，反正目前还是以实现学习为目的。</p><p>搞一个VM本质是什么？我觉得本质是对运行时的环境进行处理。那么我们首先要来谈及这个环境都有哪些部分</p><p>我觉得简单可以分为以下两种</p><ol><li>数据（代码与计算的数据）</li><li>当前状态（寄存器与栈帧）</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a><strong>数据</strong></h2><p>数据牵扯到的问题有很多，比如说数据排布、对象布局、地址分配等等。这也是我第一次动手做这些，这里就先从最简单的只有int32做起。如果后面做完善了可以再单独出一期把这些东西串起来（咕咕咕咕咕咕</p><h2 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a><strong>当前状态</strong></h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>寄存器就从目前来说，我们需要一个pc寄存器来表明当前执行到哪条语句了。至于vm那边的实现目前使用一个数组保存，pc保存下数组索引就好</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a><strong>栈帧</strong></h3><p>栈帧根据不同的需求内容也各不相同</p><p>我们来看一下龙书中提到的常见栈帧成员（不论什么书其实大都差不多</p><ol><li>局部变量</li><li>临时变量的位置（牵扯到临时变量？</li><li>机器状态（保存的特殊寄存器值，这个和调用约定也有一定关联。调用约定决定了哪些寄存器是需要保存的，哪些是不需要保存的，关于调用约定更多详情还请自行查询</li><li>rbp指针（用于管理访问链</li><li>指向调用者的地址</li><li>返回值（我选择统一放到一个寄存器中）</li><li>实参</li></ol><p>要注意的是书中提到的基本上是针对非VM的栈帧，VM的栈帧可以根据需求做出不一样的设计，比如说Ruby中采用了双栈的设计，一个调用栈用于管理调用链，一个计算栈用于存放各种变量与计算，而对于非VM栈帧絕大多说都是一个栈（我没听说过有使用双栈的，但是说不定也存在呢）通过栈中保存的rbp寄存器中的值来处理访问链</p><p>就目前从头开始实现而言，我们需要什么再加什么就好了，后续每个东西怎么加，为什么加我都会有一定说明。</p><h1 id="VM指令转换"><a href="#VM指令转换" class="headerlink" title="VM指令转换"></a><strong>VM指令转换</strong></h1><h2 id="计算赋值"><a href="#计算赋值" class="headerlink" title="计算赋值"></a>计算赋值</h2><p>先从普通的运算赋值做起。这里其实有点问题，我还没有处理好单独的语句，所以都放到了一个函数里（写完这篇就去改），以及对于函数定义该如何处理我也没想好。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">  a = <span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在Ruby的虚拟机中扫描到类似的函数定义则是会产生一行调用 <code>definemethod :foo, foo</code></p><p>而foo本身的内容则是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f@&lt;compiled&gt;<span class="symbol">:</span><span class="number">1</span> (<span class="number">1</span>,<span class="number">0</span>)-(<span class="number">3</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line">local table (<span class="symbol">size:</span> <span class="number">1</span>, <span class="symbol">argc:</span> <span class="number">0</span> [<span class="symbol">opts:</span> <span class="number">0</span>, <span class="symbol">rest:</span> -<span class="number">1</span>, <span class="symbol">post:</span> <span class="number">0</span>, <span class="symbol">block:</span> -<span class="number">1</span>, <span class="symbol">kw:</span> -<span class="number">1</span>@-<span class="number">1</span>, <span class="symbol">kwrest:</span> -<span class="number">1</span>])</span><br><span class="line">[ <span class="number">1</span>] a<span class="variable">@0</span></span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">3</span>                         (   <span class="number">2</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> putobject                              <span class="number">2</span></span><br><span class="line"><span class="number">0004</span> opt_mult                               &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;</span><br><span class="line"><span class="number">0006</span> dup</span><br><span class="line"><span class="number">0007</span> setlocal_WC_0                          a<span class="variable">@0</span></span><br><span class="line">0009 leave                                                            (   <span class="number">3</span>)[Re]</span><br></pre></td></tr></table></figure><p>这里出现了一个点，由于函数体中是一个assign，值会pop走，但是这个assign又是作为一个返回值，因此ruby中对结果调用了dup，创建一个重复的值用于返回。在写博客的时候看到Ruby指令的结果刚意识到这个问题，不过这个是属于关于函数体与函数调用相关的内容，这里目前暂不修改。</p><p>作为参考，进行编写测试。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context <span class="string">&#x27;assign&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&#x27;normal expr&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    s = <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">def foo</span></span><br><span class="line"><span class="string">a = 1 * 2</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line">    inst = get_vm_inst(s)</span><br><span class="line">    expect(inst).to eq [Rc::VM::Push.new(<span class="number">1</span>), Push.new(<span class="number">2</span>), Mul.new, SetLocal.new(<span class="number">0</span>), Return.new]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于一个普通的a = 1 * 2，我们期望的行为是将两个参数push到栈上，之后进行mul操作，最后设置本地变量的值</p><h3 id="乘法操作"><a href="#乘法操作" class="headerlink" title="乘法操作"></a>乘法操作</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary</span> <span class="comment"># Rc::AST::Binary</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:op</span>, <span class="symbol">:lhs</span>, <span class="symbol">:rhs</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_binary</span><span class="params">(node)</span></span></span><br><span class="line">  [</span><br><span class="line">    push(visit(node.lhs)),</span><br><span class="line">    push(visit(node.rhs)),</span><br><span class="line">    translate_op(node.op),</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="操作数的处理"><a href="#操作数的处理" class="headerlink" title="操作数的处理"></a>操作数的处理</h3><p>指令操作数目前分了两种，一种是直接可以保存值的，一种是引用某个名字</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">VMInstOperand</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Value</span> &lt; Struct.<span class="title">new</span>(:<span class="title">value</span>)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Ref a exist var</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> &lt; Struct.<span class="title">new</span>(:<span class="title">ref</span>)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="keyword">if</span> node.is_a? Value</span><br><span class="line">      Push.new(node.value)</span><br><span class="line">    <span class="keyword">elsif</span> node.is_a? Ref</span><br><span class="line">      GetLocal.new(node.ref)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      raise <span class="string">&quot;Unsupported node type <span class="subst">#&#123;node.<span class="keyword">class</span>&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两个都是visit结点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_number_constant</span><span class="params">(node)</span></span></span><br><span class="line">  Value.new node.val.to_i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get or Set, so need return a id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_identifier</span><span class="params">(node)</span></span></span><br><span class="line">  Ref.new cur_fun_env[node.name].id</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这么设计的原因是</p><ol><li>针对一个简单的数值我们可以直接将值push到栈上</li><li>针对一个名字我们需要去符号表中找到这个名字所在的位置，再将对应的值push到栈上</li></ol><p>同时也有不同的“push操作”</p><ol><li>针对简单的值直接push</li><li>针对名字我们通过GetLocal来获取（对于vm那边的实现，需要根据局部变量的基址和偏移量以及类型找到对应的值再放上去，但是类型目前不考虑，统一int32）</li></ol><p>这里暂时不考虑访问外部作用域的问题，这会涉及到符号表的访问以及栈的修改两部分内容。</p><p>针对这样的设计，我们需要开始增加栈的功能了</p><ol><li>简单数值的运算，我们需要能将值放上去，再进行运算取出或者留在栈里（这些临时变量）</li></ol><p>因此就有了如下最最最简单的栈</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">  临时变量</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><ol><li><p>我们需要留有局部变量的位置，能够在里面存取数据。临时变量是会随着当前函数结束而销毁，因此我们需要添加临时变量的位置在栈上，栈回退的时候也会直接销毁掉</p><p>由于1需要反复修改栈指针的操作需要所以放在当前栈帧的最顶端比较合适</p></li></ol><p>因此就有了如下最最简单的栈</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">  临时变量</span><br><span class="line">----------</span><br><span class="line">  局部变量</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><h3 id="op处理"><a href="#op处理" class="headerlink" title="op处理"></a>op处理</h3><p>这个没什么好说的，简单从op字符串转换到不同类型的运算指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_op</span><span class="params">(op)</span></span></span><br><span class="line">    <span class="keyword">case</span> op.op</span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;+&#x27;</span></span><br><span class="line">      Add.new</span><br><span class="line"><span class="comment"># ...以下省略</span></span><br></pre></td></tr></table></figure><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a><strong>符号表</strong></h1><p>就之前的代码而言，符号表信息之类的记录的并不够。在实际考虑栈帧以及执行之前我对符号表的认识仅仅停留在作为解释器的env以及他的功能的“概念”上。由于是之前写过的，就直接拿来用了，没有 再来认真反思设计以及其他的问题，回头再重新设计吧，先能用就行</p><p>考虑局部变量如何保存这个问题，引出了我对符号表更多的实际理解，所以还是要自己动手做才能更有助于理解，只是看一些理论讲还是不够，至少对我而言是这样的</p><p>关于扫描分析的代码在analysis/global_env中</p><p>符号表相关的定义在lib/env中</p><h2 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>, :<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>全局表目前保存三个东西</p><ol><li>各种定义（类定义、函数定义等），这个设计是比较早的时候写的，可能并不合适，后续再好好想一下该怎么做</li><li>常量表</li><li>函数的符号表，根据函数名找到对应函数的符号表</li></ol><h2 id="条目"><a href="#条目" class="headerlink" title="条目"></a>条目</h2><p>针对生成VM指令的阶段，需要知道一个临时变量的位置，因此有了这样的一个东西作为符号表的条目。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvItemInfo</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>, :<span class="title">type</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>id的话在一个函数中是自增的，用于GetLocal和SetLocal中计算具体的offset（这个设计对于后续可能不够用，先这样）。类型肯定也是需要的，但是目前并没有考虑类型的问题，就留了这么一个坑在这里</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@define_env</span>.define_symbol(node.name, node)</span><br><span class="line">  <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">  <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">  visit(node.stmts)</span><br><span class="line">  <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li>将函数名字关联到结点</li><li>从每个函数开始分析时初始化各参数的状态</li><li>将参数merge进当前函数的符号表中</li><li>访问函数体</li><li>将函数名关联到对应的符号表</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>今天写的太久有点写不下去了，所以到后面内容比较潦草，还请见谅。（目前以保证更新频率为主）有疑惑的地方可以联系我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧&lt;/p&gt;
&lt;p&gt;本周vm的代码都在i</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>2021年终总结</title>
    <link href="https://fusionbolt.github.io/2021/12/26/summary-2021/"/>
    <id>https://fusionbolt.github.io/2021/12/26/summary-2021/</id>
    <published>2021-12-26T05:49:57.000Z</published>
    <updated>2022-01-30T04:55:03.250Z</updated>
    
    <content type="html"><![CDATA[<p>下周末就是明年了，今年的事情不能拖到明年做，于是趁早把总结赶了出来。2021年对我来说算是各方面变化比较大的一年，还是有不少值得回顾的内容</p><h1 id="专业、工作与学习"><a href="#专业、工作与学习" class="headerlink" title="专业、工作与学习"></a>专业、工作与学习</h1><p>最大的变化莫过于大学毕业成为社畜了，找工作的过程算是十分坎坷，不过好在最终找到了一份合适的工作。工作中也学到了不少东西，自己也有了许多进步。看着自己的改变，看着自己的GitHub，今年总算可以说自己入门编程了。最大的遗憾是这一时间点来得太晚，每天下班回家留给写代码的时间只有一个多小时，如果还是学生的话时间能多太多。今年的习惯养成比较晚，所以只有最后的时间格子是填满的，明年的话会坚持每天下班后写代码，填满小格子</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">今年的Github</center> <p>年初做了一个ast解释器作为毕业设计，随后随着找工作以及各种事情渐渐停止了维护。而年底又开始基于之前的内容添加编译的部分，希望明年能达到自己对于这个项目的初步目标，并且在这个过程中学习到更多编译器相关的知识。同时我开始每周写一篇博客记录本周开发的内容，序言链接在这里</p><p><a class="link"   href="https://homura.live/2021/12/19/rc-lang-dev-preface/" >Rc-lang开发周记 序 | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></p><p>今年开始读一些书，做到了平均一个月读一本专业之外的书，遗憾是读书笔记大都咕咕咕了，不过还有一些自己的思维片段，有时间会整理成文。明年的话会继续维持这个进度，会试着写一些读书笔记<del>（在新建文件了）</del></p><p>尝试入门GTD，但遗憾的是并没有用好，明年还要在这方面继续努力。</p><p>尽管GTD运用不佳，但是年底的时候开始养成了一些习惯，这些习惯能够很大程度的帮助我抵抗自身的“懒惰”。其中一些习惯的养成受到《微习惯》和《原子习惯》这两本书的影响，后者比较推荐，能够涵盖了很多前者的内容。书中提到了一个让我印象深刻的概念：习惯叠加，意思是养成一个习惯之后可以在这个习惯之后接另一个习惯，而且很容易养成，像我现在每天晚上回家的时间都是数个习惯叠加在一起，养成的过程也没有太痛苦。</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><p>由于成为了社畜，最显著的变化就是要自己租房住了。和宿舍生活相比，入睡时间再也不需要受到别人的影响了，同时住的地方肯定是比宿舍要大的，体验好的多</p><p>另一个变化则是有了收入，因此能做的事情变得更多了</p><p>比如说年底入手了种草许久的相机，开始尝试摄影，拍到了一些满意的照片，尽管其中也有许多瑕疵品。希望明年年底的时候能够自己设计出一个相册来展示自己笨拙的作品。</p><p>除了能做的事情变多，同时还需要关心自己的开支情况。今年第一年工作，总之就是疯狂支出，月月实现负收入。买了各种以前就想买的东西，这个状态感觉还会维持一两年。明年开始大概会花很多钱在自己身上，<del>通过氪金变强</del>，存钱感觉比较困难，只能说尽力存一些吧</p><p>年底渐渐开始接触各种各样的新事物，而这些事物又会激发我的各种想法<del>（我逐渐理解一切了）</del>。除了新事物，年底开始叠加了一些习惯使得我越来越忙碌。越来越多的事情我进入了我的生活中，可以说是有些充实，但是充实的不只有要做的事情，焦虑也是一样，对于事情做不完做不好的焦虑又逐步放大了起来，这也是我需要克服的点。</p><p>除此之外，今年也有幸在推特上认识了一些新朋友，对于他们不嫌弃我这件事情深表感激</p><h1 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h1><h2 id="好转"><a href="#好转" class="headerlink" title="好转"></a>好转</h2><p>一个很重点的问题就是自己的身心感受。比起去年或许有了一些好转，在一些事情上情绪波动也没有那么大了，我想这一定和感受到内心的不合理有关。至于治愈之法，上面提到的《神经症与人性的成长》书中也有提到</p><blockquote><p>所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。此地我们同样地要问，病人必须要知道什么才能铲除他的自负系统，以及除去由此所衍生的一切附带影响？我们可以简单地说，他必须晓得我在本书中所提到的每一件事：他对荣誉的探求，他的“要求”，他的冲突，他个人的特别解决法，以及所有这些因素在他的人际关系方面与创造力方面所具有的影响<br>此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互的作用</p></blockquote><p>我的理解是当你彻底理解各个组建之间的联系的时就会慢慢破除。可惜的是这本书我只是年初读过一遍，许多地方理解并不到位。对我现在来说读过一遍的书还是挺难再花时间去读第二遍的，更偏向于去读新的书，但是鉴于这本书的重要性明年一定要再读一遍。</p><p>还有一个想到的好转是破除了一些所谓的“完美主义”的误区。我自己并没有什么完美主义，只是之前会以这个作为幌子，找借口逃避问题罢了。现在一些东西哪怕做的很烂，也会开始行动了，就像这篇总结以及目前正在维护的开发周记一样</p><p>也许是冥想所带来的习惯，我渐渐开始体会自己的不同感受，发现了自己内心空无一物。能够发现这一问题就是一个很大的进步，希望明年能够通过更多的行动给自己的内部逐渐填充些什么</p><h2 id="顽固"><a href="#顽固" class="headerlink" title="顽固"></a>顽固</h2><p>除了好转，自己依然有一些顽固成分无法脱离。比如说仍有许多无法避免也无法与之相处的执念，这对我造成了很严重的负面影响，经常会因此沉溺于痛苦之中</p><p>以及今年还是比较“自闭”，这个好像没什么好办法。所谓的“不适合和别人相处”只是一个逃避问题的幌子罢了，更深的原因是内心里还残留的一些性格扭曲，这个问题比起无力处理更准确地说是我不想处理，也先这样吧</p><p>上面说的内容很大一部分要归咎与身体与睡眠。睡眠这个对我来说是一直无法解决的问题，长期的睡眠质量差导致我很多时候状态并不好，这和我的焦虑、以及焦虑的应对措施都有着联系。</p><p>目前的应对措施是每日冥想加周日的跑步锻炼，这样的运动量是不太够的，但是时间确实不够用以及日常是步行上下班因此削减了运动时间，明年的话准备采取一些新的方案来对抗这些严重的问题。</p><h1 id="这一年"><a href="#这一年" class="headerlink" title="这一年"></a>这一年</h1><p>这么写下来，今年好像做了一些事情却又好像并没有做多少事情。做了一些事情是因为确实有一点成果，比如说读了书，思维发生了转变，专业方面有了进步，养成了一些习惯等；而没有做多少事情是因为这些事情对于一年这个周期来讲并不多，而且大半年里自己的周末时间很明显并没有怎么用好，基本上都是在无意义的消耗时间。</p><p>另外许多事情是年底才开始做，起步比较晚，但是对于明年来说可以开一个好头</p><h1 id="明年愿景"><a href="#明年愿景" class="headerlink" title="明年愿景"></a>明年愿景</h1><p>不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的</p><p>想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升</p><p>想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西</p><p>自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈</p><p>想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等</p><p>明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>自己的年终总结也没什么特别的感受与想法，只是简单地以流水帐的风格写了一下今年的事情，不过这就够了</p><p>比较期待明年的到来<del>（MBP，我的MBP）</del>虽说回首过去与展望未来都会扰乱内心的平静，但我还是按耐不住自己的期待。</p><p>明年一定是更加忙碌的一年，也是自己会有更多<strong>成长</strong>的一年</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下周末就是明年了，今年的事情不能拖到明年做，于是趁早把总结赶了出来。2021年对我来说算是各方面变化比较大的一年，还是有不少值得回顾的内容&lt;/p&gt;
&lt;h1 id=&quot;专业、工作与学习&quot;&gt;&lt;a href=&quot;#专业、工作与学习&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记1 中间代码表示</title>
    <link href="https://fusionbolt.github.io/2021/12/26/rc-lang-dev-1/"/>
    <id>https://fusionbolt.github.io/2021/12/26/rc-lang-dev-1/</id>
    <published>2021-12-26T03:41:17.000Z</published>
    <updated>2022-01-30T04:55:03.248Z</updated>
    
    <content type="html"><![CDATA[<p>本周前面的时间主要选择了重新整理项目结构以及修正了自己滥用require_relative的问题，后面的话则是开始对ast to tac进行测试，尝试通过TDD的方式在开发效率和质量确保找到一个平衡点。</p><p>比起测试，更主要的目的是重新回顾自己tac的设计决策，前面写的时候更多是一时兴起，完全不顾结构与正确性就往下写，比起急急忙忙往后赶进度还是应该将当前的内容做好才行。</p><h1 id="当前的项目结构"><a href="#当前的项目结构" class="headerlink" title="当前的项目结构"></a>当前的项目结构</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.github <span class="comment"># CI 尽管代码不多，但是依然要依靠单元测试和CI保证每次修改的正确性</span></span><br><span class="line">analysis <span class="comment"># 代码分析的内容，目前并没有做过多的内容</span></span><br><span class="line">interface <span class="comment"># 编译器、解释器和REPL的入口</span></span><br><span class="line">compiler <span class="comment"># compiler的实现</span></span><br><span class="line">interpreter <span class="comment"># 解释执行的实现</span></span><br><span class="line">ir <span class="comment"># 多级ir的实现，ast, tac, vm指令</span></span><br><span class="line">lib <span class="comment"># 编译器相关的一些简单的库，比如env, log或者错误处理之类</span></span><br><span class="line">parser</span><br><span class="line">spec <span class="comment"># 专门用于测试</span></span><br></pre></td></tr></table></figure><p>解释执行实现的部分由于其他内容快速修改，暂无法顾及，因此暂时无法正常工作</p><h1 id="Rc-lang的多层IR结构"><a href="#Rc-lang的多层IR结构" class="headerlink" title="Rc-lang的多层IR结构"></a>Rc-lang的多层IR结构</h1><ol><li>高层IR：AST</li><li>中层IR：四元式</li><li>底层IR：VM指令</li></ol><p>本周内容主要以中层IR为主</p><h1 id="中间代码表示"><a href="#中间代码表示" class="headerlink" title="中间代码表示"></a>中间代码表示</h1><p>IR主要分为两类</p><ol><li>线性IR</li><li>图IR</li></ol><p>要注意的是树IR也是一种DAG图，因此也属于图IR，而高层的AST也是属于图IR</p><p>选择IR的时候最主要的一点是我们要用它来做什么、需要什么信息，我想也没有什么绝对的设计正确，只要提供了所需信息，方便后续测试就足够了。在这里对比一下常见的IR实现（以线性IR为主）</p><h2 id="线性IR的概念"><a href="#线性IR的概念" class="headerlink" title="线性IR的概念"></a>线性IR的概念</h2><p>三地址码是指 指令右侧只能有一个运算，不允许出现组合的形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a2 = (b + c) * 4</span><br><span class="line">需要被翻译为</span><br><span class="line">a1 = b + c</span><br><span class="line">a2 = a1 * 4</span><br></pre></td></tr></table></figure><p>龙书中选择了线性IR的方式，使用了传统的三地址码。而虎书采用了树形IR（最后会简单提及）</p><h2 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h2><p>具有四个字段，类似于 op arg1 arg2 result的形式，但是存在一些特例</p><ol><li>op仅需要一个参数</li><li>param的运算不使用args2和result（这里的param是龙书中用于传递函数参数的指令，龙书针对每一个参数产生一个param，仅传递参数也不需要返回值）</li><li>转移指令将跳转地址放入result</li></ol><p>这些特例是针对虎书中的指令，实际可以根据需求进行一些变动</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>这是我的四元式定义 在文件ir/tac/quad.rb中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quad</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:op</span>, <span class="symbol">:result</span>, <span class="symbol">:lhs</span>, <span class="symbol">:rhs</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(op, result, lhs, rhs)</span></span></span><br><span class="line">    <span class="variable">@op</span>, <span class="variable">@result</span>, <span class="variable">@lhs</span>, <span class="variable">@rhs</span> = op, result, lhs, rhs</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;<span class="subst">#&#123;<span class="variable">@result</span>&#125;</span> = <span class="subst">#&#123;<span class="variable">@lhs</span>&#125;</span> <span class="subst">#&#123;<span class="variable">@op</span>&#125;</span> <span class="subst">#&#123;<span class="variable">@rhs</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="variable">@op</span> == other.op &amp;&amp; <span class="variable">@result</span> == other.result &amp;&amp; <span class="variable">@lhs</span> == other.lhs &amp;&amp; <span class="variable">@rhs</span> == other.rhs</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以及我个人觉得没必要全都严格按照这种方式来，还是以自己的需求为准。按照常规的四元式op可以是各种类型的</p><p>比如说我实现的Assign和Call（其他的op目前还没有修改以及做更多测试，本周先介绍这两个最基本的）</p><p>通过类型来获取更多的信息，而不是仅仅通过字符串判别。还可以做到像call一样设置一个别名，能够显得更加直观</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span> &lt; Quad</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(result, lhs)</span></span></span><br><span class="line">    <span class="variable">@op</span> = <span class="string">&#x27;assign&#x27;</span></span><br><span class="line">    <span class="variable">@result</span> = result</span><br><span class="line">    <span class="variable">@lhs</span> = lhs</span><br><span class="line">    <span class="variable">@rhs</span> = EmptyValue.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Call</span> &lt; Quad</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(result, target, args)</span></span></span><br><span class="line">    <span class="variable">@op</span> = <span class="string">&#x27;call&#x27;</span></span><br><span class="line">    <span class="variable">@result</span> = result</span><br><span class="line">    <span class="variable">@lhs</span> = target</span><br><span class="line">    <span class="variable">@rhs</span> = args</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">target</span></span></span><br><span class="line">    <span class="variable">@lhs</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">args</span></span></span><br><span class="line">    <span class="variable">@rhs</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>Assign没什么可说的。但是Call比较特殊</p><p>args并不是只有一个地址，所以Call并不算严格意义上的四元式。上面也提及过龙书中的Call的参数是通过一个param指令传递的，然后单独调用一个call。但就我目前来说这样做比较方便，等到后续做其他功能发现这么做的坏处的时候再修改也不晚</p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p><strong>实现</strong></p><p>转换代码在ir/tac/translator.rb中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assign</span> <span class="comment"># Rc::AST::Assign</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:var_obj</span>, <span class="symbol">:expr</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(var_obj, expr)</span></span></span><br><span class="line">    <span class="variable">@var_obj</span>, <span class="variable">@expr</span> = var_obj, expr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_assign</span><span class="params">(node)</span></span></span><br><span class="line">  name = visit(node.var_obj)</span><br><span class="line">  expr = visit(node.expr)</span><br><span class="line">  Assign.new(name, expr).tap &#123; <span class="params">|assign|</span> <span class="variable">@tac_list</span>.push assign &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>转换ast::assign的时候会将原来的名字作为tac::assign一个目标地址（尽管设计上留有了这个空间，但是目前先不考虑成员变量这种复杂的情况），然后再将表达式返回的内容设置为assign的operand。因此我们需要看一下expr的转换</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Expr</span> <span class="comment"># Rc::AST::Expr</span></span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:expr</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># Rc::AST::Expr -&gt; Operand</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_expr</span><span class="params">(node)</span></span></span><br><span class="line">  expr = visit(node.expr)</span><br><span class="line">  <span class="keyword">if</span> expr.is_a? Operand</span><br><span class="line">    expr</span><br><span class="line">  <span class="keyword">elsif</span> expr.is_a? Quad</span><br><span class="line">    expr.result</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&#x27;unknown expr type&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>存在两种情况</p><ol><li><p>转换为一个operand（比如说常量的情况）</p></li><li><p>转换为了一个quad</p><p>比如说c = a * b，a * b 会先存到一个临时变量再赋值。关于这个，龙书6.1.1中提到了这样的内容</p><blockquote><p>为什么我们需要复制指令？<br>通常，每个子表达式都会有一个它自己的新临时变量来存放运算结果。只有处理赋值运算符=时，我们才知道将把整个表达式的结果赋到哪里，一个代码优化过程将会发现可以发生替换</p></blockquote><p>我没完全理解，也许只有做优化的时候才会明白，就先沿用这样的设计了</p></li></ol><p>quad的时候需要返回对应的临时变量，因为返回值会直接用于assign的operand</p><p><strong>测试</strong></p><p>然后我们再来看一下测试代码 spec/ir/tac_spec.rb</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">context <span class="string">&#x27;assign&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&#x27;succeed&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    s = <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">def f1</span></span><br><span class="line"><span class="string">a = 1</span></span><br><span class="line"><span class="string">b = 2</span></span><br><span class="line"><span class="string">c = a * b</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line">    tac = get_tac(s)</span><br><span class="line">    list = tac.first_fun_tac_list</span><br><span class="line">    expect(list[<span class="number">1</span>]).to eq Assign.new(Name.new(<span class="string">&#x27;a&#x27;</span>), Number.new(<span class="number">1</span>))</span><br><span class="line">    expect(list[<span class="number">2</span>]).to eq Assign.new(Name.new(<span class="string">&#x27;b&#x27;</span>), Number.new(<span class="number">2</span>))</span><br><span class="line">    expect(list[<span class="number">3</span>]).to eq Quad.new(<span class="string">&#x27;*&#x27;</span>, TempName.new(<span class="string">&#x27;0&#x27;</span>), Name.new(<span class="string">&#x27;a&#x27;</span>), Name.new(<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">    expect(list[<span class="number">4</span>]).to eq Assign.new(Name.new(<span class="string">&#x27;c&#x27;</span>), TempName.new(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到有简单的assign, 还有一个表达式的运算。</p><p>表达式的运算转换为了一个quad，并且保存在了临时变量中，最后再将这个临时变量assign给c</p><h2 id="线性IR的存储方式"><a href="#线性IR的存储方式" class="headerlink" title="线性IR的存储方式"></a>线性IR的存储方式</h2><p>对于线性IR来说，保存的方式也是一个比较重要的实现决策，很大程度会影响到后续各种操作。</p><p>而实际实现无外乎数组和链表两种保存方式，在上周做重排if的时候也能看到数组的方式插入删除比较麻烦，而且效率会比较低。数组插入删除的方式也有对应的优化实现，但是对于其他优点目前没什么了解，后续做到优化的时候可能会需要考虑到这些实现方式的差别。</p><p>我当前所有指令都保存在了一个数组，所以上面的四元式并没有指向前后的指令。之所以这么选择是因为当时没考虑太多，很自然的会想到一组指令会存到一个数组中。不过需要时在ast全部转为tac以后再做一下转换即可，需要做其他优化时再添加。当前目的是直接生成下一步的指令，所以现在这样就够了。</p><h2 id="名称与地址"><a href="#名称与地址" class="headerlink" title="名称与地址"></a>名称与地址</h2><p>对于线性ir来说名称和地址是非常重要的事情。名称与地址是对应了三地址码的操作数，可以是常数，可以是一个地址，也可以是一个名字（间接索引到地址）</p><p>所以有了一个operand的定义，在文件ir/tac/operand.rb中</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operand</span></span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="1-名字"><a href="#1-名字" class="headerlink" title="1.名字"></a>1.名字</h3><p>通过名字确定一个地址，实际实现可以通过符号表来索引到对应地址。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Name</span> &lt; Operand</span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="variable">@name</span>.gsub(<span class="regexp">/:/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="variable">@name</span> == other.name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempName</span> &lt; Name</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2.常量"></a>2.常量</h3><p>如果是数字类型的常量可以直接放入，这也符合CPU指令的行为。（bool本质也是数字）</p><p>如果是字符串常量则需要记录到全局的一个表中，本质上我们还是使用字符串的地址。这个表里的东西在后续转vm指令和运行时会放入常量段，由于不会牵扯到改变，因此目前这里采用了一个普通的列表，通过索引来获取地址的方式。这里或许会牵扯到优化的问题，我觉得关于字符串常量这种优化可以放到转入这一步之前，如果遇到其他场合再做修改。</p><p><strong>两种常量的定义</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> &lt; Operand  </span></span><br><span class="line">    <span class="keyword">attr_accessor</span> <span class="symbol">:num</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(num)</span></span>    </span><br><span class="line">        <span class="variable">@num</span> = num  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_s</span>    </span></span><br><span class="line">        <span class="variable">@num</span>.to_s  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span>    </span><br><span class="line">        <span class="variable">@num</span> == other.num  </span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> &lt; Operand</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:addr</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(addr)</span></span></span><br><span class="line">    <span class="variable">@addr</span> = addr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="variable">@addr</span> == other.addr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>常量的转换</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_bool_constant</span><span class="params">(node)</span></span></span><br><span class="line">  Number.new(node.val.to_i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_number_constant</span><span class="params">(node)</span></span></span><br><span class="line">  Number.new(node.val.to_i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_string_constant</span><span class="params">(node)</span></span></span><br><span class="line">  Memory.new(<span class="variable">@const_table</span>.add(node.val))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这里涉及到一个const_table的问题。字符串会放在常量区，因此我选择在这里转换为一个地址。关于Memory或许需要选择段的问题，但是目前还没有遇到需要区分的情况，后续添加其他类型的常量再考虑吧，因此也是先这样。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span> &lt; Operand</span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:addr</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(addr)</span></span></span><br><span class="line">    <span class="variable">@addr</span> = addr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span></span><br><span class="line">    <span class="variable">@addr</span> == other.addr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>常量表</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstTable</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:list</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@list</span> = []</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(constant)</span></span></span><br><span class="line">    i = <span class="variable">@list</span>.index(constant)</span><br><span class="line">i.or_else <span class="keyword">do</span></span><br><span class="line">      <span class="variable">@list</span>.push constant</span><br><span class="line">      <span class="variable">@list</span>.size - <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(symbol, *args)</span></span></span><br><span class="line">    <span class="variable">@list</span>.method(symbol).try &#123; <span class="params">|x|</span> x.call(*args) &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">==</span><span class="params">(other)</span></span></span><br><span class="line">list == <span class="variable">@other</span>.list</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>目前选择了这样简单的形式。没有用Set的原因是难以添加一个成员以后再返回对应的索引，可以作为后续优化的一个点。</p><p>or_else是一个hack, nil的情况会返回block中的代码</p><h3 id="3-临时变量"><a href="#3-临时变量" class="headerlink" title="3.临时变量"></a>3.临时变量</h3><p>临时变量会出现在各种表达式中，前面转换的实现中也能看到相关内容。这里不多赘述</p><h2 id="其他IR形式"><a href="#其他IR形式" class="headerlink" title="其他IR形式"></a>其他IR形式</h2><p>这里对于SSA(Static Single Assign)就暂不提及了，SSA更多的是用于优化方面，目前的目标是生成VM指令并且能在VM上运行，做到SSA的时候会讲的</p><p>其他的形式在这里大概一提，不讲过多细节（写不完了）</p><h3 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h3><p>具有三个字段，类似于op arg1 arg2的形式。和四元式不同，不会显式保存返回结果，而是将每个结果存入列表中，因此三元式对结果的引用也是依靠于位置。很明显，这样就会导致如果添加或者减少指令则会变得很麻烦，因此引入间接三元式（在这里不赘述了，有兴趣自行搜索）</p><p>由于实现比较麻烦，所以我还是选择使用常规四元式</p><h3 id="图IR"><a href="#图IR" class="headerlink" title="图IR"></a>图IR</h3><p>虎书采用了树形IR</p><p>由于我目前选择了线性的方式，暂无这方面的代码，姑且还是提一下虎书中的实现并且贴一下图</p><p>其实也比较接近于tac，只是结构变成了树状，同样会有各种常数，内存操作，调用等等，因为中层IR本质上都是要将AST转换为接近于机器表示，所以不管什么样子最终都是要接近于机器指令。不同的存储方式区别只是做优化的时候不同</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Untitled.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Untitled1.png"                      alt="Untitled"                ></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>tac指令以及对应的operand过于繁琐，测试代码也有待改进，对于Ruby来说这些都可以利用元编程来精简代码，而且可以疯狂造dsl。只是每天的开发时间实在不多，还是以能做出来为最高优先级。</p><p>写了足足快俩小时，有点写的不耐烦了（有点时间焦虑，先以能写完为目标吧…）。写的过程中我会强迫自己反思和改进，上周写的时候最后还发现了一个bug，也算是不亏，下周也会更（在新建文件了，咕咕咕</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://www.zhihu.com/question/33518780/answer/56731699" >https://www.zhihu.com/question/33518780/answer/56731699<i class="fas fa-external-link-alt"></i></a></p><p>编译原理 第六章</p><p>现代编译原理 第七章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周前面的时间主要选择了重新整理项目结构以及修正了自己滥用require_relative的问题，后面的话则是开始对ast to tac进行测试，尝试通过TDD的方式在开发效率和质量确保找到一个平衡点。&lt;/p&gt;
&lt;p&gt;比起测试，更主要的目的是重新回顾自己tac的设计决策，前</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记0 基本块与if重排</title>
    <link href="https://fusionbolt.github.io/2021/12/19/rc-lang-dev-0/"/>
    <id>https://fusionbolt.github.io/2021/12/19/rc-lang-dev-0/</id>
    <published>2021-12-19T14:06:35.000Z</published>
    <updated>2022-01-30T04:55:03.248Z</updated>
    
    <content type="html"><![CDATA[<p>目前的工作重心在于将ast转换为tac指令。</p><p>由于ast的if转成的中间表示的条件跳转是带有两个分支的，因此需要对if后面所跳转到的位置进行重排。</p><p>基本块与重排相关的代码目前在ir/cfg.rb中，ast到tac的代码目前在ir/tac/tac.rb中</p><p>而跳转指令实质上是从一个基本块（BasicBlock）跳转到另一个基本块，因此我们需要先将tac（三地址码）转换成由基本块构成的形式</p><h1 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h1><h2 id="核心性质"><a href="#核心性质" class="headerlink" title="核心性质"></a>核心性质</h2><ol><li>每个基本块是从一个label开始（单一入口点）</li><li>每个基本块是由一个跳转结束（单一结束点）</li></ol><p>每一个基本块是独立的，因为由跳转结束，所以不管怎么更换基本块的位置最后都不会影执行顺序的正确性</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cond, a, b)</span></span></span><br><span class="line">  n = a + b</span><br><span class="line">  <span class="keyword">if</span> cond</span><br><span class="line">    n * <span class="number">2</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n + <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>比如这段代码，就会存在三个基本块</p><ol><li>main开始到if的条件跳转</li><li>true的部分是一个基本块</li><li>false的部分是一个基本块</li></ol><p>2和3：在生成if代码的时候会给true和false的分支各自添加一个label作为跳转目标，而每个分支结束都会跳转到最后结束的分支</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>能够表示程序的控制流。</p><p>目前用于重排if指令，后续代码的优化分析会经常用到。最经典的就是ssa(Static Single Assign)相关操作，需要对控制流进行分析，而转换为cfg的形式本质上只需要对cfg分析就可以了</p><h2 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h2><p>构造算法很简单。从头到尾进行一遍搜索，找到一个label就开始一个基本块，而到了一个跳转就结束一个基本块。</p><p>但是存在两种特殊情况</p><ol><li>当前是label的情况下前一条指令不是jump的话需要手动添加一个jump跳转到当前的label</li><li>当前是jump的情况下如果下一个不是label则需要将下一个指令设置为label</li></ol><p>上核心代码（这里省掉了检查第一个label的代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">tac_list.each_with_index <span class="keyword">do</span> <span class="params">|cur_tac, index|</span></span><br><span class="line">  <span class="keyword">if</span> cur_tac.is_a? TAC::Label</span><br><span class="line">    <span class="comment"># prev is not a jump, maybe need push a jump to this label</span></span><br><span class="line">    <span class="comment"># but when first, not need process</span></span><br><span class="line">    valid_do(tac_list, index - <span class="number">1</span>) <span class="keyword">do</span> <span class="params">|prev_tac|</span></span><br><span class="line">      <span class="keyword">unless</span> prev_tac.is_a? TAC::Jump</span><br><span class="line">        blocks.last.push TAC::DirectJump.new(cur_tac)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    blocks.push BasicBlock.new(cur_tac)</span><br><span class="line">  <span class="keyword">elsif</span> cur_tac.is_a? TAC::Jump</span><br><span class="line">    <span class="comment"># next is not a label, need create a block and push a label to next block</span></span><br><span class="line">    blocks.last.push cur_tac</span><br><span class="line">    valid_do(tac_list, index + <span class="number">1</span>) <span class="keyword">do</span> <span class="params">|next_tac|</span></span><br><span class="line">      <span class="keyword">unless</span> next_tac.is_a? TAC::Label</span><br><span class="line">        blocks.push BasicBlock.new(<span class="string">&quot;TmpLabel<span class="subst">#&#123;tmp_label_count&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="comment"># push a label</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    blocks.last.push cur_tac</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>目前这里的tac采用的是数组而不是链式结构，所以查看前一个以及插入结点略微麻烦（第一次写，所以一开始写的时候没有想到那么多，后续可以考虑换成链式结构方便插入与查找前驱后继）</p><h1 id="重排if"><a href="#重排if" class="headerlink" title="重排if"></a>重排if</h1><p>重排的过程分为三步</p><ol><li>找到所有的路线</li><li>路线排序</li></ol><h2 id="找到所有路线"><a href="#找到所有路线" class="headerlink" title="找到所有路线"></a>找到所有路线</h2><p>这里也是采用相对比较简单粗暴的算法</p><p>类似于dfs的形式，将所有的基本块放入一个队列中，从第一个未标记的开始深度优先遍历，和dfs一样需要标记中途遍历过的结点，但是并不恢复标记。一条路走完后会从队列取出下一个未走过的点作为新的路线的起点。</p><p>从当前的块选择下一个到达块的时候<strong>优先选择false分支</strong>， ****为了后续转到vm指令的时候不需要考虑CondJump false的情况，false直接顺着走就可以了，方便后面的排序</p><p>上代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_all_branches</span><span class="params">(cfg)</span></span></span><br><span class="line">  blocks = cfg.blocks</span><br><span class="line">  tag = Tag.new</span><br><span class="line">  q = blocks</span><br><span class="line">  roads = []</span><br><span class="line">  <span class="comment"># dfs that traverse all nodes</span></span><br><span class="line">  <span class="keyword">until</span> q.empty?</span><br><span class="line">    roads.push search_single_road(q, tag)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  roads.reduce([]) <span class="keyword">do</span> <span class="params">|sum, road|</span></span><br><span class="line">    sum + road.blocks</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_single_road</span><span class="params">(q, tag)</span></span></span><br><span class="line">    t = Road.new</span><br><span class="line">    b = q.shift</span><br><span class="line">    <span class="keyword">until</span> tag.has_marked(b)</span><br><span class="line">      tag.mark(b)</span><br><span class="line">      t.append(b)</span><br><span class="line">      <span class="comment"># find last(false branch)</span></span><br><span class="line">      first_next_b = b.all_next.reverse.find &#123; <span class="params">|next_b|</span> <span class="keyword">not</span> tag.has_marked(next_b) &#125;</span><br><span class="line">      <span class="keyword">if</span> first_next_b.<span class="literal">nil</span>?</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        b = first_next_b</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    t</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>这里有三种情况</p><ol><li>CondJump后面接着的是false的块，则不需要做任何事情</li><li>后面接的是true块，则需要调换顺序，而条件需要设置为相反的</li><li>后面的块和这个CondJump没有关联，那么需要将这个CondJump(cond, label_true, label_false)转换为一个CondJump(cond, label_true, label_false‘)，之后在后面添加一个label_false’以及直接到label_false的跳转指令</li></ol><p>CondJump(cond, label_true, label_false) →</p><p>CondJump(cond, label_true, label_false‘) + label_false’ + Jump(label_false)</p><p>我这里是通过判断块的第一个label来判断是不是对应的块。代码写的比较粗糙</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorder_branches_impl</span><span class="params">(tac_list)</span></span></span><br><span class="line">  tac_list.each_with_index <span class="keyword">do</span> <span class="params">|tac, index|</span></span><br><span class="line">    <span class="keyword">if</span> tac.is_a? TAC::CondJump</span><br><span class="line">      next_tac = tac_list[index + <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">if</span> next_tac == tac.false_addr</span><br><span class="line">        <span class="comment"># is ok</span></span><br><span class="line">      <span class="keyword">elsif</span> next_tac == tac.true_addr</span><br><span class="line">set_not_cond(tac_list, index)</span><br><span class="line">        next_false_tac = tac_list[index + <span class="number">2</span>]</span><br><span class="line">        tac_list[index + <span class="number">1</span>], tac_list[index + <span class="number">2</span>] = next_false_tac, next_tac</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        old_false_branch = tac.false_addr</span><br><span class="line">        new_false_branch = TAC::Label.new(<span class="string">&quot;<span class="subst">#&#123;tac.false_addr.name&#125;</span>f&#x27;&quot;</span>)</span><br><span class="line">        tac.false_addr = new_false_branch</span><br><span class="line">        tac_list.insert(index + <span class="number">1</span>, new_false_branch)</span><br><span class="line">        tac_list.insert(index + <span class="number">2</span>, TAC::DirectJump.new(old_false_branch))</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到这里也是由于使用数组来保存导致插入新指令比较麻烦（下次一定修改为链式，咕咕咕）</p><p>关于更详细的案例可以看对应的测试代码。重排if的测试代码在spec/ir/tac_spec.rb中</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>现代编译原理C语言描述 第七章、第八章</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;目前的工作重心在于将ast转换为tac指令。&lt;/p&gt;
&lt;p&gt;由于ast的if转成的中间表示的条件跳转是带有两个分支的，因此需要对if后面所跳转到的位置进行重排。&lt;/p&gt;
&lt;p&gt;基本块与重排相关的代码目前在ir/cfg.rb中，ast到tac的代码目前在ir/tac/tac.</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记 序</title>
    <link href="https://fusionbolt.github.io/2021/12/19/rc-lang-dev-preface/"/>
    <id>https://fusionbolt.github.io/2021/12/19/rc-lang-dev-preface/</id>
    <published>2021-12-19T14:00:59.000Z</published>
    <updated>2022-01-30T04:55:03.250Z</updated>
    
    <content type="html"><![CDATA[<p>之前毕业设计想尝试设计一门语言并且实现编译器，奈何时间加个人状态不佳只做到了十分简陋的ast解释器，最近又想着转成编译器并且打算认认真真做下去。既然要做那索性把这个过程中重要的部分记录下来，记录的过程能够反思做的内容，回顾有没有隐藏bug，并且能够督促我继续做下去。不过受限于时间精力，恕我不能一口气把以前写的部分的讲解补上，下次一定（咕咕咕）</p><p>Rclang长远的想法是作为一门教学相联系的语言（并不是给刚学编程的人教学的意思），但是那还太遥远，甚至都不知道能不能坚持到那个时候，<strong>现阶段的目标是能够编译正确的代码到VM上正确执行，并且在这个过程中加强自己编程语言、编译器以及VM的基础知识</strong>。所以会有许多为了能跑或者了解相关知识而实现的决策，并且会反复修改很多设计</p><p>本人水平不足，代码赶工情况很明显，因为时间真的不多，每天都要上班，同时每天以及周末还需要去学习其他的东西，也因此博客会粗糙一些（记录下来花费的时间比我预想的要多很多）。一定会有许多地方理解不够或者存在问题，如发现问题或者不合适的地方十分欢迎联系我（低血压人群可放心食用，高血压人群慎追）</p><p>该系列如无特殊情况每周日更新，你可以在这里找到这个系列所有的文章</p><p><a href="https://homura.live/2021/12/19/rc-lang-dev-preface/"><a class="link"   href="https://homura.live/tags/rc-lang/" >标签: rc-lang | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></a></p><p>项目地址：<a class="link"   href="https://github.com/FusionBolt/Rc-lang" >https://github.com/FusionBolt/Rc-lang<i class="fas fa-external-link-alt"></i></a></p><p>我想一定会有人好奇为什么选择Ruby，对我来说Ruby写的很爽很开心，这就够了。能够开心的持续做下去这才是最重要的（不过VM还是要C++受苦就是了…）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前毕业设计想尝试设计一门语言并且实现编译器，奈何时间加个人状态不佳只做到了十分简陋的ast解释器，最近又想着转成编译器并且打算认认真真做下去。既然要做那索性把这个过程中重要的部分记录下来，记录的过程能够反思做的内容，回顾有没有隐藏bug，并且能够督促我继续做下去。不过受限</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>所坚信的事情</title>
    <link href="https://fusionbolt.github.io/2021/08/23/trust_self/"/>
    <id>https://fusionbolt.github.io/2021/08/23/trust_self/</id>
    <published>2021-08-23T11:33:16.000Z</published>
    <updated>2022-01-30T04:55:03.250Z</updated>
    
    <content type="html"><![CDATA[<p>唯有这一点，在我接下来的人生中一定会坚信不疑</p><h1 id="我一定能够做到无限接近理想的自己"><a href="#我一定能够做到无限接近理想的自己" class="headerlink" title="我一定能够做到无限接近理想的自己"></a>我一定能够做到无限接近理想的自己</h1><p>想了很久不知道该用什么词放在最后，聚聚，大佬，诸如此类的词想了很多，但好像并不符合我的心愿。虽然这种说法十分空洞，显得没有目标，但确确实实是我现在的想法，并不想成为别人眼中的谁，而是想要成为自己眼中的谁。理想自我是不可能抵达的，故只有无限接近</p><p>现在理想的自己是什么样子的？我想起码是有坚固的自信，无论何时都能鼓起勇气，能够让自己的朋友会为认识我感到开心，能够专精某些领域。</p><p>为什么要发一篇这样的博客呢？</p><p>乔布斯说过这样一段话</p><blockquote><p>You have to trust in something, your gut, destiny, life, karma, whatever.</p><p>Because believing that dots will connect down the road will give you the confidence to follow your heart even when it leads you off the well-worn path. </p><p>And that will make all the difference.</p></blockquote><p>我选择它作为我一生的信念，同时这也是值得花费一生去做的事情。</p><p>从今天、现在开始，又是新的起点</p><p>希望这能够带给我<strong>信心</strong>与<strong>勇气</strong></p><p>带上一份歪歪扭扭的签名</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="sign.jpg"                                     ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;唯有这一点，在我接下来的人生中一定会坚信不疑&lt;/p&gt;
&lt;h1 id=&quot;我一定能够做到无限接近理想的自己&quot;&gt;&lt;a href=&quot;#我一定能够做到无限接近理想的自己&quot; class=&quot;headerlink&quot; title=&quot;我一定能够做到无限接近理想的自己&quot;&gt;&lt;/a&gt;我一定能够做到无</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>运气</title>
    <link href="https://fusionbolt.github.io/2021/06/12/luck/"/>
    <id>https://fusionbolt.github.io/2021/06/12/luck/</id>
    <published>2021-06-12T02:28:45.000Z</published>
    <updated>2022-01-30T04:55:03.248Z</updated>
    
    <content type="html"><![CDATA[<p>攒了很多文想写，但由于总觉得自己了解的还不够加上生活比较忙碌迟迟没有写，不过哪怕写的再差，月底之前一定会再憋一篇技术文出来。</p><p>最近比较想写运气这个话题的内容。因为各种意义上，我实在是”倒霉”，尤其是最近几个月。比如说前些时间让我很头疼的毕业相关事宜，刚从学校那边上回北京高铁，导员就通知我一个放进档案的表格字写的不合格要我重写，填一些论文以及实习材料的时候都全填完了论文指导老师才说哪里哪里应该怎么写，好多又白费了。</p><p>先别急着关闭博客，我不是来讲我多”倒霉”的。</p><h2 id="倒霉不是倒霉"><a href="#倒霉不是倒霉" class="headerlink" title="倒霉不是倒霉"></a>倒霉不是倒霉</h2><p>我觉得这其中一部分并不是真正随机的事情，它们可以通过人为因素来一定程度的避免，这也是为什么我在前面的倒霉加了双引号表示。比如说要我重写的表格，明知道要放进档案但我还是没花太多精力去一笔一画的写导致字迹略草（虽说比平常的字好很多了），如果我当时再认真点写或许就可以避免这所谓的“倒霉了”。</p><h2 id="为什么要这样区分？"><a href="#为什么要这样区分？" class="headerlink" title="为什么要这样区分？"></a>为什么要这样区分？</h2><p>这些事情中自己总有做的不够好的地方，如果能改正那可以减少下次发生类似事件的概率（@@@：重复同一件事情是无用的，木大木大），进而还能间接减少坏心情</p><p>改变自己的视角，将出现的问题、差错视为一个发现自己问题并且纠正的机会（这是一场「试炼」，我认为这是一场让我战胜过去「试炼」，我接受了，只有在战胜那不成熟的过去后，人才能有所成长…你不也是一样吗？）</p><p>把一切都推脱出去的行为一点也不可爱（划重点）</p><h2 id="误区"><a href="#误区" class="headerlink" title="误区"></a>误区</h2><p>尽管这类事情中很多是个人因素，但不要因此苛责自己，出错这件事情是不可避免的。并不是说因为自己应该做到些什么就把责任全部归咎于自己身上，比如说你在人行道没看路有摩托撞上来了，自己没看路是一方面，但是对方也没有遵守道路行驶规则。</p><p>再重复一次，改变这些看法的本质只是为了改正自己做的不合适的地方，不要因为这个而苛责自己。实际上确实存在容易将责任归于自己身上的人，如果你是这样那希望本文能够让你意识到问题并且开始萌生改变的想法。</p><h2 id="人为防范的例子"><a href="#人为防范的例子" class="headerlink" title="人为防范的例子"></a>人为防范的例子</h2><p>很多人可能都会有到学校/公司之后发现今天晚上会有雨，但是没有带雨伞的经历。其中也有不少认为今天真倒霉，偏偏要下雨了没带伞。但如果你考虑到这种情况还会发生，于是下次又买了一把伞放在学校/公司那就不一样了，不会因为同样的理由被雨淋，减少了觉得“倒霉”的次数，进而心情还会好一些。</p><h2 id="无可奈何的情况"><a href="#无可奈何的情况" class="headerlink" title="无可奈何的情况"></a>无可奈何的情况</h2><p>除了人为可控的情况，当然也有一些不可抗力，比如说抽卡，抽卡，还有抽卡，<del>但你钱砸的够多还是能抽到</del>。这种情况那我只能说平日多扶老奶奶过马路，多关心孤寡推友 <del>比如作者</del></p><p>最后，希望读者能够早日脱离“运气”的陷阱，减少运气对自己的情绪影响以及能够从中学到些什么。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;攒了很多文想写，但由于总觉得自己了解的还不够加上生活比较忙碌迟迟没有写，不过哪怕写的再差，月底之前一定会再憋一篇技术文出来。&lt;/p&gt;
&lt;p&gt;最近比较想写运气这个话题的内容。因为各种意义上，我实在是”倒霉”，尤其是最近几个月。比如说前些时间让我很头疼的毕业相关事宜，刚从学校那</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
</feed>
