<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2022-04-17T06:24:53.375Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rc-lang开发周记15 Rust源码学习之desugar</title>
    <link href="https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/"/>
    <id>https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/</id>
    <published>2022-04-17T06:23:11.000Z</published>
    <updated>2022-04-17T06:24:53.375Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-15/68232005_p0.png"                      alt="68232005_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:68232005</center> <p>这周可以说几乎没写什么代码，都在学习别人的实现。在参考别人的做法之前自己写一版比较合适，这样会对整体有个了解（这样有利于阅读代码），知道哪些地方会有问题，看别人的代码后会发现哪里不一样并且去思考差异。不过我之前已经写过简易的实现了，因此直接来参考Rust的实现了</p><p>本周看的内容一半是desugar，另一半是关于MIR的。讲解的话目前先讲一下desugar的内容，内容相对较少能够一篇讲完。MIR的东西非常多，笔记也没有整理好，之后会单独开启一个源码阅读系列的坑</p><p>在讲之前首先要提的是<strong>为什么要学习他人的实现</strong>。尽管写出来能跑是没有问题的，但是参考这样的项目的过程中能学到他人写代码的方式，学到更多不一样的实现方式</p><h1 id="desugar"><a href="#desugar" class="headerlink" title="desugar"></a>desugar</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>我们现在在使用的编程语言中有一些语法糖，这些语法糖本质上是对一些功能的包装，让我们用的更方便，但是没有做到一些什么没有这个语法糖所做不到的东西。</p><p>这里举一个很直观的例子，ruby中有一个关键字是unless，它的功能是如果false则执行第一个分支，否则执行第二个分支，相当于if !cond</p><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><p>上面也提到了只是包装，那么可能多种不同形式的语法糖都是针对同一种功能，像C语言中的while和for本质都是一个loop（Rust的for并不是，后面会提到这种for的desugar过程）</p><p>desugar的过程是将这些都转换为了更本质的东西，我觉得这属于一种“去重”的过程。还是上面的例子，假设需要对loop做优化，没有desugar的情况下我们需要对while和for两者都进行处理，两者又有轻微的差别，导致实现起来更不方便，每个优化都需要对这些细节做处理，那不如直接全部转换成一种形式来处理处理</p><p>关于Rust的文档中的介绍是这样</p><blockquote><p>This means many structures are removed if they are irrelevant for type analysis or similar syntax agnostic analyses.</p></blockquote><h1 id="Rust的实现"><a href="#Rust的实现" class="headerlink" title="Rust的实现"></a>Rust的实现</h1><p>官方的文档介绍</p><p><a class="link"   href="https://rustc-dev-guide.rust-lang.org/lowering.html" >https://rustc-dev-guide.rust-lang.org/lowering.html<i class="fas fa-external-link-alt"></i></a></p><p>在这里我要给Rust一个好评，开发文档比较详细，而且一些注释也相对容易懂一些。后面的很多东西都会以注释为参考讲了大概做了什么，注意这里<strong>我们的目的并不是搞清楚细节，而是搞清楚都做了什么操作，所以细节部分点到为止</strong>，细节深究下去是无底洞，有兴趣可以去源码处深入看一下</p><p>desugar相关代码不特别说明根目录都是rustc_ast_lowering</p><h2 id="读代码之前需要了解的"><a href="#读代码之前需要了解的" class="headerlink" title="读代码之前需要了解的"></a>读代码之前需要了解的</h2><p>了解了这些能够更容易看明白代码</p><ol><li>各种参数更多是使用ir来标识以及获取的</li><li>span用于记录源码相关信息</li><li>arean.alloc是用于分配构建ir的，看实现的时候不需要在意这里的细节，只需要看传进去的IR</li></ol><h2 id="DesugaringKind"><a href="#DesugaringKind" class="headerlink" title="DesugaringKind"></a>DesugaringKind</h2><p>这个类型在rustc_span/src/hygine.rs中</p><p>实际使用的时候主要用于创建span的时候填入相关信息，因此并没有放到ast_lowering的位置</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DesugaringKind</span></span> &#123;</span><br><span class="line">    <span class="comment">/// We desugar `if c &#123; i &#125; else &#123; e &#125;` to `match $ExprKind::Use(c) &#123; true =&gt; i, _ =&gt; e &#125;`.</span></span><br><span class="line">    <span class="comment">/// However, we do not want to blame `c` for unreachability but rather say that `i`</span></span><br><span class="line">    <span class="comment">/// is unreachable. This desugaring kind allows us to avoid blaming `c`.</span></span><br><span class="line">    <span class="comment">/// This also applies to `while` loops.</span></span><br><span class="line">    CondTemporary,</span><br><span class="line">    QuestionMark,</span><br><span class="line">    TryBlock,</span><br><span class="line">    <span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line">    <span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line">    <span class="comment">/// `impl Trait` with `Foo`.</span></span><br><span class="line">    OpaqueTy,</span><br><span class="line">    Async,</span><br><span class="line">    Await,</span><br><span class="line">    ForLoop,</span><br><span class="line">    LetElse,</span><br><span class="line">    WhileLoop,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不考虑Async和Await，我们来一个个说其他的</p><h2 id="CondTemporary"><a href="#CondTemporary" class="headerlink" title="CondTemporary"></a>CondTemporary</h2><p>这部分都在src/expr.rs中</p><p>我们先来看一下它的调用位置，发现是在manage_let_cond这个函数中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`</span></span><br><span class="line"><span class="comment">// in a temporary block.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">manage_let_cond</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cond: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_let_expr</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt;(expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> expr.kind &#123;</span><br><span class="line">            hir::ExprKind::Binary(_, lhs, rhs) =&gt; has_let_expr(lhs) || has_let_expr(rhs),</span><br><span class="line">            hir::ExprKind::Let(..) =&gt; <span class="literal">true</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> has_let_expr(cond) &#123;</span><br><span class="line">        cond</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reason = DesugaringKind::CondTemporary;</span><br><span class="line">        <span class="keyword">let</span> span_block = <span class="keyword">self</span>.mark_span_with_reason(reason, cond.span, <span class="literal">None</span>);</span><br><span class="line">        <span class="keyword">self</span>.expr_drop_temps(span_block, cond, AttrVec::new())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换条件"><a href="#转换条件" class="headerlink" title="转换条件"></a>转换条件</h3><p>根据函数名和参数我们可以得知这个是处理cond不为let的情况下，既然是cond那么应当会出现在while和if中</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实际查看manage_let_cond的usage也正是如此。这两处的处理都是类似的，因此我选取一段来介绍</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.lower_expr(cond);</span><br><span class="line"><span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br></pre></td></tr></table></figure><p>可以看到十分简单，就是先对cond本身lower，然后再对整个cond lower</p><p>然后我们再回到manage_let_cond的实现中</p><p>根据实现可以看到对expr递归判断，如果包含let则直接返回原始cond，否则进行转换</p><p>span_block是用于记录信息的，关键在expr_drop_temps中</p><h3 id="本质行为"><a href="#本质行为" class="headerlink" title="本质行为"></a>本质行为</h3><p>进入实现可以看到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In terms of drop order, it has the same effect as wrapping `expr` in</span></span><br><span class="line"><span class="comment">/// `&#123; let _t = $expr; _t &#125;` but should provide better compile-time performance.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The drop order can be important in e.g. `if expr &#123; .. &#125;`.</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_drop_temps_mut(span, expr, attrs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps_mut</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.expr(span, hir::ExprKind::DropTemps(expr), attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际做的事情就是转换为了DropTemps这种类型的Expr</p><h2 id="QuestionMark"><a href="#QuestionMark" class="headerlink" title="QuestionMark"></a>QuestionMark</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>QuestionMark是Result为Err或者Option为None的时候直接抛出错误的一种语法糖，摘选一段官方的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">try_to_parse</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="string">&quot;123&quot;</span>.parse()?; <span class="comment">// x = 123</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">i32</span> = <span class="string">&quot;24a&quot;</span>.parse()?; <span class="comment">// returns an Err() immediately</span></span><br><span class="line">    <span class="literal">Ok</span>(x + y)                    <span class="comment">// Doesn&#x27;t run.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = try_to_parse();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, res);</span><br><span class="line"><span class="built_in">assert!</span>(res.is_err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看QuestionMark的usage，找到了lower_expr_try这个函数</p><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>先来看注释，这里的注释可以说是非常清楚了，将一个QuestionMark转换为了一个模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprKind::Try` from: `&lt;expr&gt;?` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// match Try::branch(&lt;expr&gt;) &#123;</span></span><br><span class="line"><span class="comment">///     ControlFlow::Continue(val) =&gt; #[allow(unreachable_code)] val,,</span></span><br><span class="line"><span class="comment">///     ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">///         #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">///         // If there is an enclosing `try &#123;...&#125;`:</span></span><br><span class="line"><span class="comment">///         break &#x27;catch_target Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">///         // Otherwise:</span></span><br><span class="line"><span class="comment">///         return Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, span: Span, sub_expr: &amp;Expr) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt;</span><br></pre></td></tr></table></figure><p>既然是返回了一个match，那么我们先看一下Expr::Match的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A `match` block, with a source that indicates whether or not it is</span></span><br><span class="line"><span class="comment">/// the result of a desugaring, and if so, which kind.</span></span><br><span class="line">Match(&amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;, &amp;<span class="symbol">&#x27;hir</span> [Arm&lt;<span class="symbol">&#x27;hir</span>&gt;], MatchSource)</span><br></pre></td></tr></table></figure><p>根据注释的内容看上去分为三个部分</p><ol><li>Try::branch(<expr>)</li></ol><p>非常直接的操作，直接lower传进来的sub_expr</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Try::branch(&lt;expr&gt;)`</span></span><br><span class="line"><span class="keyword">let</span> scrutinee = &#123;</span><br><span class="line">    <span class="comment">// expand &lt;expr&gt;</span></span><br><span class="line">    <span class="keyword">let</span> sub_expr = <span class="keyword">self</span>.lower_expr_mut(sub_expr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.expr_call_lang_item_fn(</span><br><span class="line">        unstable_span,</span><br><span class="line">        hir::LangItem::TryTraitBranch,</span><br><span class="line">        arena_vec![<span class="keyword">self</span>; sub_expr],</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>ControlFlow::Continue(val)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的arm是构建了hir的Match的Arm参数</p><ol><li>ControlFlow::Break(residual)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和上面差不多，细节都在省略的部分</p><p>在实际的处理中在最前面的有一部分像上面的CondTemporary一样，先创建一个span用于记录源码相关的信息，源码不再赘述</p><p>还会创建一个*<code>#[allow(unreachable_code)]</code>* 供后面的match使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = &#123;</span><br><span class="line">    <span class="comment">// `allow(unreachable_code)`</span></span><br><span class="line">    <span class="keyword">let</span> allow = &#123;</span><br><span class="line">        <span class="keyword">let</span> allow_ident = Ident::new(sym::allow, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_ident = Ident::new(sym::unreachable_code, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_nested = attr::mk_nested_word_item(uc_ident);</span><br><span class="line">        attr::mk_list_item(allow_ident, <span class="built_in">vec!</span>[uc_nested])</span><br><span class="line">    &#125;;</span><br><span class="line">    attr::mk_attr_outer(allow)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> attrs = <span class="built_in">vec!</span>[attr];</span><br></pre></td></tr></table></figure><h2 id="TryBlock"><a href="#TryBlock" class="headerlink" title="TryBlock"></a>TryBlock</h2><p>在lower_expr_try_block中被用到</p><h3 id="做了什么-1"><a href="#做了什么-1" class="headerlink" title="做了什么"></a>做了什么</h3><p>这里的注释解释的比较清楚了，我就不再赘述</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `try &#123; &lt;stmts&gt;; &lt;expr&gt; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(&lt;expr&gt;) &#125;`,</span></span><br><span class="line"><span class="comment">/// `try &#123; &lt;stmts&gt;; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(()) &#125;`</span></span><br><span class="line"><span class="comment">/// and save the block id to use it as a break target for desugaring of the `?` operator.</span></span><br></pre></td></tr></table></figure><p>最终都是转换为一个包含stmts和::std::ops::Try::from_output的block</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们从返回值往上看，可以看到返回了一个Block，Block的第二个参数是Label，这里并不需要因此设置为了None</p><p>那么我们顺着第一个参数block往上看来源，又回到了函数的开始</p><p>和注释所讲的一样，根据是否有一个expr来做两种不同的处理方式，也是比较直观的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, body: &amp;Block) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.with_catch_scope(body.id, |this| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> block = this.lower_block_noalloc(body, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Final expression of the block (if present) or `()` with span at the end of block</span></span><br><span class="line">        <span class="keyword">let</span> (try_span, tail_expr) = <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(expr) = block.expr.take() &#123;</span><br><span class="line">            (</span><br><span class="line">                this.mark_span_with_reason(</span><br><span class="line">                    DesugaringKind::TryBlock,</span><br><span class="line">                    expr.span,</span><br><span class="line">                    this.allow_try_trait.clone(),</span><br><span class="line">                ),</span><br><span class="line">                expr,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> try_span = this.mark_span_with_reason(</span><br><span class="line">                DesugaringKind::TryBlock,</span><br><span class="line">                this.sess.source_map().end_point(body.span),</span><br><span class="line">                this.allow_try_trait.clone(),</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            (try_span, this.expr_unit(try_span))</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ok_wrapped_span =</span><br><span class="line">            this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `::std::ops::Try::from_output($tail_expr)`</span></span><br><span class="line">        block.expr = <span class="literal">Some</span>(this.wrap_in_try_constructor(</span><br><span class="line">            hir::LangItem::TryTraitFromOutput,</span><br><span class="line">            try_span,</span><br><span class="line">            tail_expr,</span><br><span class="line">            ok_wrapped_span,</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        hir::ExprKind::Block(this.arena.alloc(block), <span class="literal">None</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpaqueTy"><a href="#OpaqueTy" class="headerlink" title="OpaqueTy"></a>OpaqueTy</h2><h3 id="OpaqueTy是什么"><a href="#OpaqueTy是什么" class="headerlink" title="OpaqueTy是什么"></a>OpaqueTy是什么</h3><p>OpaqueTy是impl Trait的一种别名，看一下这个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Foo</span></span> = <span class="keyword">impl</span> Bar;</span><br></pre></td></tr></table></figure><p>实际参数使用Foo的时候只能使用Bar中的接口，不论实现了Bar的类型是否实现了其他类型</p><h3 id="lower做了什么"><a href="#lower做了什么" class="headerlink" title="lower做了什么"></a>lower做了什么</h3><p>关于这个lower的操作，在DesugaringKind::OpaqueTy的位置写的非常清楚了，只是做了简单的类型替换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line"><span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line"><span class="comment">/// `impl Trait` with `Foo`.</span></span><br></pre></td></tr></table></figure><h3 id="lower操作"><a href="#lower操作" class="headerlink" title="lower操作"></a>lower操作</h3><p>lower操作在lower_opaque_impl_trait这个函数中(src/lib.rs)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_opaque_impl_trait</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        span: Span,</span><br><span class="line">        fn_def_id: <span class="built_in">Option</span>&lt;LocalDefId&gt;,</span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">        opaque_ty_node_id: NodeId,</span><br><span class="line">        capturable_lifetimes: <span class="built_in">Option</span>&lt;&amp;FxHashSet&lt;hir::LifetimeName&gt;&gt;,</span><br><span class="line">        lower_bounds: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>) -&gt; hir::GenericBounds&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    ) -&gt; hir::TyKind&lt;<span class="symbol">&#x27;hir</span>&gt; </span><br></pre></td></tr></table></figure><p>来看一下返回值的部分，可以看到主要处理分为两部分，一部分是处理ID相关的，另一部分是处理lifetime</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `impl Trait` now just becomes `Foo&lt;&#x27;a, &#x27;b, ..&gt;`.</span></span><br><span class="line">    hir::TyKind::OpaqueDef(hir::ItemId &#123; def_id: opaque_ty_def_id &#125;, lifetimes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也就不展开了，上面的细节很多是关于type相关的，这部分我不了解，内容也比较长。</p><p>lower_opaque_impl_trait这个函数则是被在上面的lower_ty_direct()调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TyKind::ImplTrait(def_node_id, <span class="keyword">ref</span> bounds) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> span = t.span;</span><br><span class="line">  <span class="keyword">match</span> itctx &#123;</span><br><span class="line">      ImplTraitContext::ReturnPositionOpaqueTy &#123; fn_def_id, origin &#125; =&gt; <span class="keyword">self</span></span><br><span class="line">          .lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">Some</span>(fn_def_id),</span><br><span class="line">              origin,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              |this| this.lower_param_bounds(bounds, itctx),</span><br><span class="line">          ),</span><br><span class="line">      ImplTraitContext::TypeAliasesOpaqueTy &#123; <span class="keyword">ref</span> capturable_lifetimes &#125; =&gt; &#123;</span><br><span class="line">          <span class="comment">// Reset capturable lifetimes, any nested impl trait</span></span><br><span class="line">          <span class="comment">// types will inherit lifetimes from this opaque type,</span></span><br><span class="line">          <span class="comment">// so don&#x27;t need to capture them again.</span></span><br><span class="line">          <span class="keyword">let</span> nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy &#123;</span><br><span class="line">              capturable_lifetimes: &amp;<span class="keyword">mut</span> FxHashSet::default(),</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">self</span>.lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              hir::OpaqueTyOrigin::TyAlias,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">Some</span>(capturable_lifetimes),</span><br><span class="line">              |this| this.lower_param_bounds(bounds, nested_itctx),</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这里的TypeKind为ImplTrait且ImplTraitContext为TypeAliasesOpaqueTy或者ReturnPositionOpaqueTy的时候才会做这个desugar操作</p><ul><li><input disabled="" type="checkbox"> 这里我其实不是很明白。。</li></ul><h3 id="ImpltraitContext"><a href="#ImpltraitContext" class="headerlink" title="ImpltraitContext"></a>ImpltraitContext</h3><p>来看一下ImpltraitContext，根据Disallowed注释大意和成员可以得知这个类主要关联了一个位置是否可以使用impl trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,</span></span><br><span class="line"><span class="comment">/// and if so, what meaning it has.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImplTraitContext</span></span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new universal generic parameter.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a fresh universal parameter like `fn foo&lt;T: Debug&gt;(x: T)`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Newly generated parameters should be inserted into the given `Vec`.</span></span><br><span class="line">    Universal(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;hir::GenericParam&lt;<span class="symbol">&#x27;a</span>&gt;&gt;, LocalDefId),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new opaque type.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo() -&gt; impl Debug`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a new opaque type like `type T = impl Debug; fn foo() -&gt; T`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    ReturnPositionOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// `DefId` for the parent function, used to look up necessary</span></span><br><span class="line">        <span class="comment">/// information later.</span></span><br><span class="line">        fn_def_id: LocalDefId,</span><br><span class="line">        <span class="comment">/// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,</span></span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// Impl trait in type aliases.</span></span><br><span class="line">    TypeAliasesOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// Set of lifetimes that this opaque type can capture, if it uses</span></span><br><span class="line">        <span class="comment">/// them. This includes lifetimes bound since we entered this context.</span></span><br><span class="line">        <span class="comment">/// For example:</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">/// type A&lt;&#x27;b&gt; = impl for&lt;&#x27;a&gt; Trait&lt;&#x27;a, Out = impl Sized + &#x27;a&gt;;</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// Here the inner opaque type captures `&#x27;a` because it uses it. It doesn&#x27;t</span></span><br><span class="line">        <span class="comment">/// need to capture `&#x27;b` because it already inherits the lifetime</span></span><br><span class="line">        <span class="comment">/// parameter from `A`.</span></span><br><span class="line">        <span class="comment">// FIXME(impl_trait): but `required_region_bounds` will ICE later</span></span><br><span class="line">        <span class="comment">// anyway.</span></span><br><span class="line">        capturable_lifetimes: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> FxHashSet&lt;hir::LifetimeName&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// `impl Trait` is not accepted in this position.</span></span><br><span class="line">    Disallowed(ImplTraitPosition),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在上面只有ReturnPositionOpaqueTy和TypeAliasesOpaqueTy的情况下可以使用，当然从名字就可以看出来这两种情况就是为了OpaqueTy而设计的</p><h2 id="ForLoop"><a href="#ForLoop" class="headerlink" title="ForLoop"></a>ForLoop</h2><p>调用处的函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_for</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        e: &amp;Expr,</span><br><span class="line">        pat: &amp;Pat,</span><br><span class="line">        head: &amp;Expr,</span><br><span class="line">        body: &amp;Block,</span><br><span class="line">        opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">    ) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>注释写的非常详细了，将一个ForLoop转换为一个iterator操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprForLoop` from: `[opt_ident]: for &lt;pat&gt; in &lt;head&gt; &lt;body&gt;` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">///     let result = match IntoIterator::into_iter(&lt;head&gt;) &#123;</span></span><br><span class="line"><span class="comment">///         mut iter =&gt; &#123;</span></span><br><span class="line"><span class="comment">///             [opt_ident]: loop &#123;</span></span><br><span class="line"><span class="comment">///                 match Iterator::next(&amp;mut iter) &#123;</span></span><br><span class="line"><span class="comment">///                     None =&gt; break,</span></span><br><span class="line"><span class="comment">///                     Some(&lt;pat&gt;) =&gt; &lt;body&gt;,</span></span><br><span class="line"><span class="comment">///                 &#125;;</span></span><br><span class="line"><span class="comment">///             &#125;</span></span><br><span class="line"><span class="comment">///         &#125;</span></span><br><span class="line"><span class="comment">///     &#125;;</span></span><br><span class="line"><span class="comment">///     result</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><p>实现比较长就不贴了，想要了解更详细的可以去源码处查看</p><h2 id="LetElse"><a href="#LetElse" class="headerlink" title="LetElse"></a>LetElse</h2><h3 id="什么情况会转换"><a href="#什么情况会转换" class="headerlink" title="什么情况会转换"></a>什么情况会转换</h3><p>在lower_let_else中被调用，而这个lower_let_else则是在lower_stmts中</p><p>这是lower_stmts中的处理代码，可以看到是InitElse的情况下会进行处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> expr = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> [s, tail @ ..] = ast_stmts &#123;</span><br><span class="line">            <span class="keyword">match</span> s.kind &#123;</span><br><span class="line">                StmtKind::Local(<span class="keyword">ref</span> local) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> hir_id = <span class="keyword">self</span>.lower_node_id(s.id);</span><br><span class="line">                    <span class="keyword">match</span> &amp;local.kind &#123;</span><br><span class="line">                        LocalKind::InitElse(init, els) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">let</span> e = <span class="keyword">self</span>.lower_let_else(hir_id, local, init, els, tail);</span><br><span class="line">                            expr = <span class="literal">Some</span>(e);</span><br><span class="line"><span class="comment">// remaining statements are in let-else expression</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注意这里的break</p><p>来看一下InitElse</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">LocalKind</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// Local declaration with an initializer and an `else` clause.</span></span><br><span class="line"><span class="comment">/// Example: `let Some(x) = y else &#123; return &#125;;`</span></span><br><span class="line">InitElse(P&lt;Expr&gt;, P&lt;Block&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>一开始看到函数签名中的tail产生了一些疑惑，不知道用途是什么。一开始想到的是会往里添加东西，但是一看类型是immutable的（传进来的是一个array的slice），后面看到调用处的break才明白过来，具体用途后面会讲到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> ty = local</span><br><span class="line">      .ty</span><br><span class="line">      .as_ref()</span><br><span class="line">      .map(|t| <span class="keyword">self</span>.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(local.span);</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.mark_span_with_reason(DesugaringKind::LetElse, span, <span class="literal">None</span>);</span><br><span class="line">  <span class="keyword">let</span> init = <span class="keyword">self</span>.lower_expr(init);</span><br><span class="line">  <span class="keyword">let</span> local_hir_id = <span class="keyword">self</span>.lower_node_id(local.id);</span><br><span class="line">  <span class="keyword">self</span>.lower_attrs(local_hir_id, &amp;local.attrs);</span><br><span class="line">  <span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">          hir_id: local_hir_id,</span><br><span class="line">          pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">          ty,</span><br><span class="line">          init,</span><br><span class="line">          span,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(let_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(else_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.arena.alloc(hir::Expr &#123;</span><br><span class="line">      hir_id: stmt_hir_id,</span><br><span class="line">      span,</span><br><span class="line">      kind: hir::ExprKind::If(let_expr, then_expr, <span class="literal">Some</span>(else_expr)),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> !<span class="keyword">self</span>.sess.features_untracked().let_else &#123;</span><br><span class="line">      feature_err(</span><br><span class="line">          &amp;<span class="keyword">self</span>.sess.parse_sess,</span><br><span class="line">          sym::let_else,</span><br><span class="line">          local.span,</span><br><span class="line">          <span class="string">&quot;`let...else` statements are unstable&quot;</span>,</span><br><span class="line">      )</span><br><span class="line">      .emit();</span><br><span class="line">  &#125;</span><br><span class="line">  if_expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从返回值向上看，可以看到if_expr的参数是let_expr, then_expr, else_expr</p><ol><li>let_expr的部分转成了HIR的let</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">        hir_id: local_hir_id,</span><br><span class="line">        pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">        ty,</span><br><span class="line">        init,</span><br><span class="line">        span,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看一下定义和注释</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Represents a `let &lt;pat&gt;[: &lt;ty&gt;] = &lt;expr&gt;` expression (not a Local), occurring in an `if-let` or</span></span><br><span class="line"><span class="comment">/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In an if-let, imagine it as `if (let &lt;pat&gt; = &lt;expr&gt;) &#123; ... &#125;`; in a let-else, it is part of the</span></span><br><span class="line"><span class="comment">/// desugaring to if-let. Only let-else supports the type annotation at present.</span></span><br><span class="line"><span class="meta">#[derive(Debug, HashStable_Generic)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Let</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> hir_id: HirId,</span><br><span class="line">    <span class="keyword">pub</span> span: Span,</span><br><span class="line">    <span class="keyword">pub</span> pat: &amp;<span class="symbol">&#x27;hir</span> Pat&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> ty: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;hir</span> Ty&lt;<span class="symbol">&#x27;hir</span>&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> init: &amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExprKind</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// A `let $pat = $expr` expression.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// These are not `Local` and only occur as expressions.</span></span><br><span class="line">  <span class="comment">/// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.</span></span><br><span class="line">  Let(&amp;<span class="symbol">&#x27;hir</span> Let&lt;<span class="symbol">&#x27;hir</span>&gt;),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>then_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里解答了我对传进来的tail的疑惑。这里的意思是then的话那么会继续lower tail的部分，将这部分插入到then的block中</p><ol><li>else_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里将传进来的els（InitElse的else block）lower到了一个block</p><h3 id="实际做了什么转换"><a href="#实际做了什么转换" class="headerlink" title="实际做了什么转换"></a>实际做了什么转换</h3><p>单个看起来可能不够直观，将三个部分组合起来的话这个逻辑就是</p><p>cond中创建了一个expr bind</p><p>true：将后面的stmts lower到一个新的block中（因此外面需要break）</p><p>false：将els的部分lower到block</p><h3 id="false为什么不lower-tail"><a href="#false为什么不lower-tail" class="headerlink" title="false为什么不lower tail"></a>false为什么不lower tail</h3><p>像我一样不了解这里语法的情况会觉得false的行为很奇怪，false就不走tail了吗</p><p>于是我就写了这样的一个用例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(let_else)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y:<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接报了编译错误，else中的内容是要强制从当前函数返回才行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: `<span class="keyword">else</span>` clause of `<span class="keyword">let</span>...<span class="keyword">else</span>` does not diverge</span><br><span class="line"> --&gt; src/main.rs:<span class="number">4</span>:<span class="number">26</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |       <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">  |  __________________________^</span><br><span class="line"><span class="number">5</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">  | |__________________________^ expected `!`, found `()`</span><br><span class="line">  |</span><br><span class="line">  = note: expected <span class="class"><span class="keyword">type</span> `!`</span></span><br><span class="line"><span class="class">             <span class="title">found</span></span> <span class="class"><span class="keyword">type</span> `()`</span></span><br><span class="line"><span class="class">  = <span class="title">help</span></span>: <span class="keyword">try</span> adding a diverging expression, such <span class="keyword">as</span> `<span class="keyword">return</span>` or `<span class="built_in">panic!</span>(..)`</span><br><span class="line">  = help: ...or <span class="keyword">use</span> `<span class="keyword">match</span>` instead of `<span class="keyword">let</span>...<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `playground` due to previous error</span><br></pre></td></tr></table></figure><h2 id="WhileLoop"><a href="#WhileLoop" class="headerlink" title="WhileLoop"></a>WhileLoop</h2><p>在lower_expr_mut中被调用，在外部创建span信息然后在lower_expr_while_in_loop_scope中实际进行lower</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ExprKind::While(<span class="keyword">ref</span> cond, <span class="keyword">ref</span> body, opt_label) =&gt; &#123;</span><br><span class="line">      <span class="keyword">self</span>.with_loop_scope(e.id, |this| &#123;</span><br><span class="line">          <span class="keyword">let</span> span =</span><br><span class="line">              this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, <span class="literal">None</span>);</span><br><span class="line">          this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="做了什么-2"><a href="#做了什么-2" class="headerlink" title="做了什么"></a>做了什么</h3><p>注释也非常易懂，将一个while转换为一个loop加一个，cond作为一个if，cond为false则break</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We desugar: `&#x27;label: while $cond $body` into:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">// &#x27;label: loop &#123;</span></span><br><span class="line"><span class="comment">//   if &#123; let _t = $cond; _t &#125; &#123;</span></span><br><span class="line"><span class="comment">//     $body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   else &#123;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wrap in a construct equivalent to `&#123; let _t = $cond; _t &#125;`</span></span><br><span class="line"><span class="comment">// to preserve drop semantics since `while $cond &#123; ... &#125;` does not</span></span><br><span class="line"><span class="comment">// let temporaries live outside of `cond`.</span></span><br></pre></td></tr></table></figure><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>实际的实现代码也是非常直接，没什么可讲的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_while_in_loop_scope</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    cond: &amp;Expr,</span><br><span class="line">    body: &amp;Block,</span><br><span class="line">    opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.with_loop_condition_scope(|t| t.lower_expr(cond));</span><br><span class="line">    <span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br><span class="line">    <span class="keyword">let</span> then = <span class="keyword">self</span>.lower_block_expr(body);</span><br><span class="line">    <span class="keyword">let</span> expr_break = <span class="keyword">self</span>.expr_break(span, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> stmt_break = <span class="keyword">self</span>.stmt_expr(span, expr_break);</span><br><span class="line">    <span class="keyword">let</span> else_blk = <span class="keyword">self</span>.block_all(span, arena_vec![<span class="keyword">self</span>; stmt_break], <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> else_expr = <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(else_blk, ThinVec::new()));</span><br><span class="line">    <span class="keyword">let</span> if_kind = hir::ExprKind::If(new_cond, <span class="keyword">self</span>.arena.alloc(then), <span class="literal">Some</span>(else_expr));</span><br><span class="line">    <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.expr(span, if_kind, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_expr(<span class="keyword">self</span>.arena.alloc(if_expr));</span><br><span class="line">    <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(span.with_hi(cond.span.hi()));</span><br><span class="line">    <span class="keyword">let</span> opt_label = <span class="keyword">self</span>.lower_label(opt_label);</span><br><span class="line">    hir::ExprKind::Loop(block, opt_label, hir::LoopSource::While, span)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来以为desugar的东西比较少就想都写完，但是越写发现越多，这还忽略了很多细节上的东西，导致了文章比较长</p><p>在读代码的时候一开始我是没看到DesugaringKind这个类型的，想着既然要lower，那么首先将ast和hir的定义进行比较。由于内容比较多，只选了熟悉的Expr和Stmt进行对比。查看实际有哪些成员发生了变化，之后再去找到实现的位置。查看实现的过程中偶然看到DesugaringKind，之后看的过程就顺畅了许多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-15</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust源码阅读" scheme="https://fusionbolt.github.io/tags/Rust%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="Desugar" scheme="https://fusionbolt.github.io/tags/Desugar/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记14 重构与AST Visitor</title>
    <link href="https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/"/>
    <id>https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/</id>
    <published>2022-04-10T03:22:23.000Z</published>
    <updated>2022-04-10T03:49:21.753Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-14/noire.jpg"                      alt="noire"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">非pixiv作品</center> <p>本周先是解决了上周遗留下来的一个非常头疼的问题，之后重构了Token和AST的定义以及考虑了一下Visitor。之后也编写了建立符号表的代码以及一半转换到vm指令的代码，但是总觉得哪里不太对劲就先停了下来，后续确认无误了再一起拿出来讲。还学习了一些rust的实现方式，关于IR方面有更多了解以后有意向再单独出一篇文章讲解自己的一些了解</p><h1 id="PackratReader"><a href="#PackratReader" class="headerlink" title="PackratReader"></a>PackratReader</h1><p>上周为了解决左递归的语法使用了PackratParser，但是这会引入一个问题，PackratParser会使用PackratReader管理输入，而PackratReader并没有重载toString，因此在<strong>log的时候</strong>都是类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trying class member at scala.util.parsing.combinator.PackratParsers$$anon$1@4d3167f4</span><br></pre></td></tr></table></figure><p>我的解决思路如下</p><p>首先尝试继承并且实现一个自己的PackratReader，因为之前TokenReader就是继承并实现了Reader。但是发现经过了PackratParser的处理后又会变成系统自带的reader</p><p>查看源码发现有这么一段内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rest</span></span>: <span class="type">Reader</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">PackratReader</span>(underlying.rest) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> cache = outer.cache</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> recursionHeads = outer.recursionHeads</span><br><span class="line">  lrStack = outer.lrStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次获取rest的时候都会重新构造一个PackratReader，因此继承这条路行不通。之后我的思路一直在想着如何hack这个类的toString（用ruby的话我一定会这么做的，对于ruby来说这种做法是理所应当的），但是对于Scala来说并没有那么过分的元编程能力（至少我没有搜寻到相关解决方案）。</p><p>反复尝试无果后，只好继续硬调代码了。调试的过程中偶然想到我可以重载log这个函数，前面的思路都是我需要它的字符串，但是我实际的需求是能够log输出正确的信息</p><p>这是我重载以后的行为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>[<span class="type">T</span>](p: <span class="type">Reader</span>[<span class="type">T</span>], n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; !p.atEnd) then p.first::take(p.rest, n - <span class="number">1</span>) <span class="keyword">else</span> <span class="type">Nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reader: <span class="type">PackratReader</span>[<span class="type">Token</span>] =&gt;</span><br><span class="line">      println(<span class="string">s&quot;trying <span class="subst">$&#123;name&#125;</span> at (<span class="subst">$&#123;take(reader, 3).mkString(&quot;, &quot;)&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      println(<span class="string">&quot;trying &quot;</span> + name + <span class="string">&quot; at &quot;</span> + in)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是原本的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  println(<span class="string">&quot;trying &quot;</span>+ name +<span class="string">&quot; at &quot;</span>+ in)</span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>之前的博客也提到过Token的定义不太好，之前思路过于死板，只想着用enum来解决，但是这里可以更灵活的将trait和enum组合起来，可以通过类型更好的区分不同的Token，AST也是如此。以下这是新的定义的部分代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Token</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Literal</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Delimiter</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Ident</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">UPPER_IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Keyword</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="comment">// local</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br></pre></td></tr></table></figure><p>据我所了解rust的trait是不能携带变量的，在这方面上Scala好用的多，不需要再在每个Token里面保存一个position信息</p><p>举一个这样写法实际比较有帮助的例子，比如说我现在Lexer结束获得了一个List[Token]，想要将其中Keyword的部分全部提取出来并且将这些信息传给编辑器插件高亮处理，那么我不需要再费力的去写一个麻烦的逻辑判断是否是Keyword的方法，而是直接匹配类型。再写其他逻辑不仅是麻烦的问题，实际也容易出错，比如说漏掉什么或者多写了什么，而这些东西直接写到类型定义中大大减少了问题的产生</p><p>我没有写过插件，不知道实际是否是需要这样，但是这种想法和思路都是一样的</p><p>实际处理代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokens.filter &#123;</span><br><span class="line">  <span class="keyword">case</span> k: <span class="type">Keyword</span> =&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>大体思路都在Token部分讲的差不多了，这里贴一下部分关键的AST定义就好了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTNode</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">BinaryOp</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Constant</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Ident</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Ident</span>, value: ast.<span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><p>之前写的str与Id的隐式转换函数放到了一个object中，需要的时候直接import这个object中的一个函数或者全部函数，将隐式转换函数都放在一个位置进行管理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitConversions</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToId</span></span>(str: <span class="type">String</span>): <span class="type">Ident</span> = <span class="type">Ident</span>(str)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">IdToStr</span></span>(id: <span class="type">Ident</span>): <span class="type">String</span> = id.str</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">boolToAST</span></span>(b: <span class="type">Boolean</span>): <span class="type">Expr</span>.<span class="type">Bool</span> = <span class="type">Expr</span>.<span class="type">Bool</span>(b)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToAST</span></span>(i: <span class="type">Int</span>): <span class="type">Expr</span>.<span class="type">Number</span> = <span class="type">Expr</span>.<span class="type">Number</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的时候</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast.<span class="type">ImplicitConversions</span>.*</span><br></pre></td></tr></table></figure><h1 id="AST-Visitor"><a href="#AST-Visitor" class="headerlink" title="AST Visitor"></a>AST Visitor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>虽然在公司做的ai compiler的项目里也有visitor，但那终究只是对特殊形式对expr处理的，也可以说是针对一种DSL的，并不能直接套用。之前用ruby写的版本存在很多问题，同时也使用了动态语言才能写出来的方式。</p><p>编写遍历的时候关键在于遍历函数的签名。除了结点本身之外应当传递什么参数？返回值又是怎样的？</p><p>我的思路是先想一下之后的使用场景是怎么样的。能想到的场景大致有这么几种</p><ol><li>ast check</li><li>type infer</li><li>lower</li><li>其他pass</li></ol><p>ast check这个显然是要遍历所有结点</p><p>type infer没有做过，对于实际要怎么做我还没有一个思路</p><p>lower在很多编译器也是作为一种pass存在，而我目前暂时想先作为一个单独的流程存在。</p><p>其他pass只是参与过公司项目，但是传统compiler还没有做过。关于这个我还存有许多问题，比如说都会用到什么样的访问方式？我目前想到的方面是针对表达式或者说某个特定类型的结点进行处理，那么应用的时候是需要做</p><p>最后结论还是去学习一下前人的做法，尝试查看Scala和rust的实现，Scala实现方式过于复杂，因此最终参考的是rust的实现（但Scala但是实现我还是挺感兴趣但，可能会再花一些时间研究一下）</p><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><p>rust中写了一个visitor的trait，其中包含了各种ast中出现的内容：crate，stmt，ident等都有。其中每一个visit_xxx的默认实现都是调用了walk_xxx，而walk是访问当前这个节点的所有成员，因此默认实现的整个逻辑是：先进入visit，visit调用到了walk，walk对每一个节点进行visit，而每个节点的visit又是调用了walk</p><p>从上面提及的函数签名的角度来看，传递了一个所需的ast结点，无返回值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub <span class="class"><span class="keyword">trait</span> <span class="title">Visitor&lt;</span>&#x27;<span class="title">ast&gt;</span></span>: <span class="type">Sized</span> &#123;</span><br><span class="line">...</span><br><span class="line">fn visit_crate(&amp;mut self, krate: &amp;<span class="symbol">&#x27;ast</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_crate(self, krate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn walk_crate&lt;<span class="symbol">&#x27;a</span>, <span class="type">V</span>: <span class="type">Visitor</span>&lt;<span class="symbol">&#x27;a</span>&gt;&gt;(visitor: &amp;mut <span class="type">V</span>, krate: &amp;<span class="symbol">&#x27;a</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_list!(visitor, visit_item, &amp;krate.items);</span><br><span class="line">    walk_list!(visitor, visit_attribute, &amp;krate.attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个小问题我即便在写到这里的时候我还是没能理解，为什么要传一个visitor进来，直接作为trait的成员不就好了吗？rust的高层IR有好几层，起初我以为是为了给其他的ir使用（思考完这个问题我才意识到这是一个不良设计，每一层的东西应当隔离开来），但经过查看每一层但IR都是完全单独的visitor和walk，偶尔使用walk也是在impl ast visitor的时候</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>选取片段</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTVisitor</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">R</span> </span>= <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(modules: <span class="type">Modules</span>): <span class="type">R</span> = visitRecursive(modules)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(module: <span class="type">RcModule</span>): <span class="type">R</span> = visitRecursive(module)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = visitRecursive(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(expr: <span class="type">Expr</span>): <span class="type">R</span> = visitRecursive(expr)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">visitRecursive</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = &#123;</span><br><span class="line">    item <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> method: <span class="type">Item</span>.<span class="type">Method</span> =&gt; visit(method)</span><br><span class="line">      <span class="keyword">case</span> klass: <span class="type">Item</span>.<span class="type">Class</span> =&gt; visit(klass)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;NoneItem&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于返回值的地方我也纠结了一下，虽然留有了一个R的类型，但是没想好之后怎么用。因此就先这样实现吧，之后根据需求再改。在不了解的情况下不应当想着一口气写出合适的实现，而是先从能用开始，再不断修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-14</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="AST" scheme="https://fusionbolt.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记13 另一些Parser</title>
    <link href="https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/"/>
    <id>https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/</id>
    <published>2022-04-04T02:21:54.000Z</published>
    <updated>2022-04-10T03:41:48.893Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-13/52EA4D4A98FF564EE062964187F4D6B0.jpg"                      alt="52EA4D4A98FF564EE062964187F4D6B0"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:40165995</center> <p>本周的内容主要就是添加剩下的一些parser，主要是和类相关的，同时还添加了数组的下标索引。内容稍微少一些，我觉得也没有太多值得讲的，基本上就是确定语法 + 直接写实现。代码写的也不多，花了不少时间在另一篇博客上，同时还要添加测试。到此为止原先的parser支持的差不多了。还增加了类型以及下标索引的内容，同时还有了更合理的测试。今天收下尾差不多可以开始写其他的内容了</p><h1 id="本周出现的所有语法"><a href="#本周出现的所有语法" class="headerlink" title="本周出现的所有语法"></a>本周出现的所有语法</h1><p>首先我们要确定要写出什么样的语法。语法大致先这样，不知道怎么样的语法才是优雅的，先都做出来再说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &lt;</span> Parent <span class="comment">// 继承，类型名必须首字母大写</span></span><br><span class="line">  v1: Fun <span class="comment">// 成员变量</span></span><br><span class="line">  v2: Int = <span class="number">1</span> <span class="comment">// 成员变量默认值</span></span><br><span class="line"></span><br><span class="line">  def update() <span class="comment">// 成员函数</span></span><br><span class="line">@v2 = @v2 + <span class="number">1</span> <span class="comment">// @获取成员变量</span></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def f()</span><br><span class="line">var v = F.<span class="keyword">new</span>() <span class="comment">// Class.new()的形式构建变量。new本质是object基类的方法</span></span><br><span class="line">v.update() <span class="comment">// 调用成员函数</span></span><br><span class="line">  var arr = Array.<span class="keyword">new</span>(<span class="number">2</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 常规的取数组下标</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>其实我有点中意下面这种写法，将vars和methods都限制在一起，但是后面如果类中可以添加新的东西那会麻烦一些，所以这个想法暂时保留</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line">vars:</span><br><span class="line">  v1: <span class="type">Fun</span></span><br><span class="line">  v2: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">methods:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>()</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classDefine</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>.<span class="type">Class</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">CLASS</span> ~&gt; sym ~ (<span class="type">OPERATOR</span>(<span class="string">&quot;&lt;&quot;</span>) ~&gt; sym).?) ~ log(item | field | noneItem)(<span class="string">&quot;class member&quot;</span>).* &lt;~ log(<span class="type">END</span>)(<span class="string">&quot;class end&quot;</span>) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> klass ~ parent ~ defines =&gt;</span><br><span class="line">      <span class="type">Item</span>.<span class="type">Class</span>(klass, parent,</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Field</span>]).map(_.asInstanceOf[<span class="type">Field</span>]),</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]).map(_.asInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noneItem</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  <span class="type">EOL</span> ^^^ <span class="type">Item</span>.<span class="type">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">field</span></span>: <span class="type">Parser</span>[<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">VAR</span> ~&gt; (id &lt;~ <span class="type">COLON</span>) ~ sym ~ (<span class="type">EQL</span> ~&gt; expr).?) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ ty ~ value =&gt; <span class="type">Field</span>(id, <span class="type">Type</span>.<span class="type">Spec</span>(ty), value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  oneline(method | classDefine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h1><p>新增加的ast成员。其中Constant是大写字母开头的名字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line"><span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Constant</span>(id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><h2 id="MethodCall"><a href="#MethodCall" class="headerlink" title="MethodCall"></a>MethodCall</h2><p>调用成员函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memCall</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">MethodCall</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ~ parSround(repsep(termExpr, <span class="type">COMMA</span>)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ id ~ args =&gt; <span class="type">Expr</span>.<span class="type">MethodCall</span>(obj, id, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ name =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(obj, name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selfField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">AT</span> ~&gt; id) ^^ (id =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(<span class="type">Expr</span>.<span class="type">Self</span>, id))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayIndex</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Index</span>] = positioned &#123;</span><br><span class="line">  termExpr ~ squareSround(termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> expr ~ index =&gt; <span class="type">Expr</span>.<span class="type">Index</span>(expr, index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">squareSround</span></span>[<span class="type">T</span>](p: <span class="type">Parser</span>[<span class="type">T</span>]) = <span class="type">LEFT_SQUARE</span> ~&gt; p &lt;~ <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> beginWithTerm: <span class="type">PackratParser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  memCall | memField | arrayIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | selfField | call | beginWithTerm | sym ^^ <span class="type">Expr</span>.<span class="type">Constant</span> | idExpr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了如上几个语法后，语法已经变成了左递归的形式。遇到这种问题一般来说是转成非左递归的语法，因为左递归的情况很容易堆栈溢出，而Scala的parser combaintor提供了记忆化的能力，简单来说就是能够缓存遍历过的情况，第二次递归到某个情况，如果这个情况已经被遍历过那么直接从缓存中取出即可，而不需要再次递归搜索</p><p>想要使用这个功能需要两个步骤</p><ol><li>parser继承自PackratParsers。之前我的parser都是继承自Parsers，而更换成PackratParsers是兼容的，直接修改继承类名即可</li><li>显式指定需要这个功能的parser返回PackratParser</li><li>函数必须改成lazy val</li></ol><p>可以看到上面的beginWithTerm已经修改为了这种形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-13</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>与CI和链接大战三百回合</title>
    <link href="https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/"/>
    <id>https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/</id>
    <published>2022-03-29T15:34:17.000Z</published>
    <updated>2022-04-04T08:48:10.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/solve-ci-and-link/54707001_p0.png"                      alt="54707001_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">攻撃隊、出撃！Vorwärts！ pixiv:54707001</center> <h1 id="噩梦开始的地方"><a href="#噩梦开始的地方" class="headerlink" title="噩梦开始的地方"></a>噩梦开始的地方</h1><p>在C#的CI测试中（目前仅开启了ubuntu）DllImport报错DllNotFoundException。而报错的位置是我对自己搞的一个capi做的C#包装</p><h1 id="本地尝试"><a href="#本地尝试" class="headerlink" title="本地尝试"></a>本地尝试</h1><p>遇到这种问题，我的第一反应还是先在本地的环境确认一下，这样的做法相对来说成本低很多，能够初步确认一些问题（但是由于自己配的环境的影响会导致很多问题无法排查）</p><p>自然本地是失败了，切到了Windows的机器上依然失败，又切到了公司内部的ubuntu服务器（我没有做过什么环境配置，可以认为相对干净一些）依然是失败了</p><h1 id="查看类似的情况"><a href="#查看类似的情况" class="headerlink" title="查看类似的情况"></a>查看类似的情况</h1><p>项目中也有其他使用我们自己做的C#包装的测试，因此我想到了确认一下它的正确性。我使用了自己的分支，而主分支是没有问题的。自己这里确认的过程中还是不够严谨，应该直接查看对应测试成功与失败的用例的执行情况，只是用这样想当然的想法来考虑。</p><h1 id="CI调试神器"><a href="#CI调试神器" class="headerlink" title="CI调试神器"></a>CI调试神器</h1><p>各种尝试无果（忘了做了哪些，总之都没有效果），之后尝试在Windows和mac下进行测试，这两者居然是能通过的。</p><p>一时之间也没能想到有什么决定性的因素，后来想到以前看过本地模拟ci环境的东西，因此去搜索关于ci调试的信息，并且发现了这个神器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">tmate</span> <span class="string">session</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">mxschmitt/action-tmate@v3</span></span><br></pre></td></tr></table></figure><p>只要将这一段加到GitHub action的yaml文件中，即可在执行到这里的时候停住。此时会不断刷新ssh连接的命令。</p><h1 id="进入CI后"><a href="#进入CI后" class="headerlink" title="进入CI后"></a>进入CI后</h1><p>我做的第一时间是检查so本身是否存在问题</p><p>像以往一样写了一个最简单的main.c，之后 <code>gcc main.c -L . llibname</code> 查看报错。</p><p>我一直使用这样的方式来检查实际链接的时候因为哪些符号是undefined导致链接挂掉，简单易实施，久而久之也开始潜意识的认为这样能过链接就没有问题了，还是对链接了解不够。</p><p>这里出现了一个我忽略了的问题，也正是这个问题导致我浪费了大半天时间。因为这个库是我自己写的自己编的，不会依赖于系统库之外的so，<strong>我潜意识认为这里不会出问题，所以我没有使用ldd进行确认链接状态</strong>。</p><h1 id="启动一个裸docker测试"><a href="#启动一个裸docker测试" class="headerlink" title="启动一个裸docker测试"></a>启动一个裸docker测试</h1><p>前面那一步做好也就不会有后面的那么多操作了..总之后面的操作也回顾一下</p><p>为了和跑测试的ci版本一致，启动了一个ubuntu18.04的docker（后面可以看到，幸好我这里选择了一致的版本，不然可能解决问题的时间需要更久…）</p><p>由于是非常干净的镜像，什么都没有，折腾了半天安装所需要的基本组建，开始编译并且执行测试，依然是存在问题。之后也没什么好思路，后来跑了一下上面提及的类似性质的相关测试的正确性，发现docker中也是错的。（这里如果我之前更严谨的确认了可能也会减少一些重复过程）</p><p>之后我就喊实现这块的同事和我一起看问题，切到了主分支测试也不能通过。后来不记得为什么了我随手敲了个ldd看了一下他的so，他看到了错误信息，一提醒我才看到。自己思考问题经常会钻牛角尖，以及经常会忽略掉一些信息，有的时候换个人从旁观者角度来看会好很多，自己想切换到旁观者角度还是有些难。</p><h1 id="GLIBC-x-xx-not-found"><a href="#GLIBC-x-xx-not-found" class="headerlink" title="GLIBC_x.xx not found"></a>GLIBC_x.xx not found</h1><p>看到的错误信息是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBCXX_3.xx&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>由于这是一个非常干净的ubuntu，所以甚至没有这个东西。这个时候我意识到了自己的库在CI中会不会也是类似的原因，我之前是否ldd检查过，检查过的话是否是忽略了这么重要的调试信息？（这个时候由于没有清晰的思路和严谨的做法，开始怀疑之前是否做过这个测试）</p><p>随后意识到在ci中会不会也是类似的问题。于是进入了ci调试器，看到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>测试能通过的so中是没有类似的错误信息。使用<code>strings /usr/lib/x86_64-linux-gnu/libc.so.6</code> 查看其中的glibc版本信息，发现其中并没有我们所需的版本（注意不要去看libc.so，它虽然叫so但不是动态链接库，用file可以看到实际上是一个文本文件）</p><p>这时可以确认问题就在这里了。</p><h1 id="“失误”"><a href="#“失误”" class="headerlink" title="“失误”"></a>“失误”</h1><p>这个时候我觉得离谱的是这个库我是通过github ci编译的，最后ci不能通过，也许还有什么因素应该控制但是我没有做好的。</p><p>本来还想吐槽这个，最后想办法处理GLIBC版本不一致的时候发现自己编的时候用的是ubuntu-latest的ci…而测试的地方是18.04。这一部分是我不知道从哪里直接就拷贝过来的，没有确认是否有问题就进行拷贝（之前也没有遇到过这样的情况，确认可能也不会想到这一点。但是我也确实没有进行过核对）</p><p>同时这次的经历意识到了自己编的库还是应该尽量依赖低版本的glibc</p><h1 id="关于glibc和GLIBC-XX"><a href="#关于glibc和GLIBC-XX" class="headerlink" title="关于glibc和GLIBC_XX"></a>关于glibc和GLIBC_XX</h1><p>这个我整理起来发现东西不少，以及要控制一下文章长度，因此整理到了另一篇博客上</p><p><a class="link"   href="https://homura.live/2022/03/29/glibc-version/" >https://homura.live/2022/03/29/glibc-version/<i class="fas fa-external-link-alt"></i></a></p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ol><li>GLIBC的version版本对应不上（错误的根本原因）</li><li>在写编译的ci的时候没有认真写，而是随便找了一个抄上就完事（错误的产生原因）</li><li>没有一套严谨的确认问题的思路（花费了我大半天的原因）</li></ol><p>太多意想不到的地方出了问题，不论是ldd还是最后发现是系统版本错，也许是自己在这些地方都没有太注意，最后各种小问题堆积太多导致出现了这种坑。</p><h1 id="事后诸葛亮"><a href="#事后诸葛亮" class="headerlink" title="事后诸葛亮"></a><del>事后诸葛亮</del></h1><p>在此写一下理想的解决思路应该是怎么样的</p><ol><li>发现CI出现问题，查看错误是DllNotFoundException</li><li>本地相同系统测试能通过，那么要确认查找的过程没有问题。多半是要排除掉环境变量的影响因素</li><li>确认路径查找是没有问题的以后进入CI环境查看dll的状态<ol><li>ldd查看依赖是否满足（本次错误看到a即可）</li><li>如果依赖满足的则再手动链接查看是否有undefined的符号之类</li></ol></li><li>发现是glibc的问题，确认是否真的找不到版本（这里我真的遇到过（虽然是GLIBCXX）…安了conda以后因为会先找到conda的glibc，而这个版本可能又是不合要求的，然后就会报错了..解决方案是直接修改链接，如果你遇到类似的问题一搜就能搜到解决方案）</li><li>glibc通常和环境有关，真的是没有匹配版本那么要查看环境的不同</li><li>由于是ci环境，那么肯定首先要看ci的yaml文件，对比配置的差异（问题解决）</li></ol><p>先确认第三步其实也可以，最好的情况下我们先去做了第三步是会省了第二步的问题。但我觉得这种dll链接相关的路径查找的问题可能更多一些，总之这些都是需要确认的步骤。</p><p>这个思路是在本地能够通过测试的前提条件下。需要调的这种情况一般是要合并了之类，这种情况肯定是要先在本地做好测试的。没有做好的情况肯定是要先测试的</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>自己经常会遇到这种离谱的问题，然而每个问题看起来再离谱最终都是会找到原因的，而且这个原因往往出现在意想不到的地方。想要减少这种现象的出现，只有明确自己行为的后果，以及不断踩坑的过程中形成一套自己的应对策略。（如果是别人的库那首先要注意的肯定是查看相关位置的源码）</p><p>这些问题的解决方式大多貌似都是口口相传，因此我打算再遇到这样类似的问题就进行一个记录。记录下我的思路，最终是如何解决问题的以及在这个途中有什么错误的想法，尽量避免第二次犯同样的错误，不断反思形成一套自己的解决问题方案，同时又会重新回顾在这之中有什么细节或者知识点是遗漏的。以后会增加更多这样的博客</p><p>遇到这种问题很重要的一点是如果不能调试，那解决问题可能要付出成倍的时间代价。像这个例子如果我不进去ci环境查看，也比较难确定是否真的是版本问题，不断更新ci打log也可以，但是非常非常麻烦且低效。</p><p>后面应该再写一个链接问题定位的博客（写的话大概会说一些自己踩过的坑）。我的思路未必全面，但是一定有着参考价值<del>（下次一定，在新建文件了，难不成我还能咕咕咕吗）</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/solve-ci-and-l</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CI" scheme="https://fusionbolt.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>关于glibc与GLIBC_XX</title>
    <link href="https://fusionbolt.github.io/2022/03/29/glibc-version/"/>
    <id>https://fusionbolt.github.io/2022/03/29/glibc-version/</id>
    <published>2022-03-29T15:33:44.000Z</published>
    <updated>2022-04-04T08:46:53.477Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/glibc-version/67650124_p0.jpg"                      alt="67650124_p0.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">是GLIBC的版本多还是miku的版本多? pixiv:67650124</center> <h1 id="glibc位置"><a href="#glibc位置" class="headerlink" title="glibc位置"></a>glibc位置</h1><p>这个不同系统不一致，linux中比较多的存在于/lib/libc.so.6</p><p>想要查找libc的位置可以通过ldd(linux)/otool(mac)查看依赖于libc.so的库（有的库会静态塞进去，这种的是看不了）</p><p>有的时候ldd看到的错误信息也会包含glibc的路径，这些还是根据不同的情况来查找</p><h1 id="确认当前环境glibc版本信息"><a href="#确认当前环境glibc版本信息" class="headerlink" title="确认当前环境glibc版本信息"></a>确认当前环境glibc版本信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd --version</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, gnu_get_libc_version());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者都可以</p><h1 id="GLIBC-Version兼容性"><a href="#GLIBC-Version兼容性" class="headerlink" title="GLIBC Version兼容性"></a>GLIBC Version兼容性</h1><p>本质上这是一个so的不同版本兼容性问题。通常我们看到的so的版本号是 主版本号.次版本号，比如说2.6。<strong>链接的时候只会进行主版本号的判断</strong>，不同主版本号可能是不兼容的（不管实际如何，我们都应该视为不兼容，链接器也会报错的）。而次版本号保证新版本会兼容旧版本，比如说2.6兼容2.4</p><h1 id="关于自己编译的库"><a href="#关于自己编译的库" class="headerlink" title="关于自己编译的库"></a>关于自己编译的库</h1><h2 id="查看GLIBC的依赖"><a href="#查看GLIBC的依赖" class="headerlink" title="查看GLIBC的依赖"></a>查看GLIBC的依赖</h2><p>简单的命令查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings libxxx.so | grep <span class="string">&quot;^GLIBC&quot;</span></span><br></pre></td></tr></table></figure><p>你会看到多个版本号，由于新版本兼容旧版本，因此其中最新的一个GLIBC版本号是我们所需要的。这时你可能有很多小问号，让我们一个一个的来解决</p><h2 id="自己的库的GLIBC-Version怎么来的？"><a href="#自己的库的GLIBC-Version怎么来的？" class="headerlink" title="自己的库的GLIBC Version怎么来的？"></a>自己的库的GLIBC Version怎么来的？</h2><p>上面也提及了次版本号会高版本兼容低版本，但是如果依赖高版本的却运行于低版本时可能会出现找不到符号的情况，因此引入了<strong>基于符号的版本机制</strong>。即对应符号可以依赖于某个特定的次版本号</p><p>我们从一个例子来将这些串联起来。以下以上面提到过的确认当前环境GLIBC信息的示例代码为例，实际GLIBC版本大概率不会相同，与你的系统环境有关</p><p>首先使用strings查看，可以看到搜到了两个版本</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GLIBC_2</span><span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="type">GLIBC_2</span><span class="number">.34</span></span><br></pre></td></tr></table></figure><p>当然我想你可能已经尝试过前面确认当前版本GLIBC Version的命令，发现这里的符号和当前版本的符号并不相同。我们先讲解这些版本的来源，之后就会明白原因了</p><p>那么为什么会有两个版本呢？两个版本又是怎么来的呢？让我们用nm查看一下其中的符号</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000000000039</span>c r __abi_tag</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">B</span> __bss_start</span><br><span class="line"><span class="number">0000000000004038</span> b completed<span class="number">.0</span></span><br><span class="line">                 w __cxa_finalize<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">0000000000004028</span> <span class="type">D</span> __data_start</span><br><span class="line"><span class="number">0000000000004028</span> <span class="type">W</span> data_start</span><br><span class="line"><span class="number">0000000000001080</span> t deregister_tm_clones</span><br><span class="line"><span class="number">00000000000010</span>f0 t __do_global_dtors_aux</span><br><span class="line"><span class="number">0000000000003</span>df0 d __do_global_dtors_aux_fini_array_entry</span><br><span class="line"><span class="number">0000000000004030</span> <span class="type">D</span> __dso_handle</span><br><span class="line"><span class="number">0000000000003</span>df8 d _DYNAMIC</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">D</span> _edata</span><br><span class="line"><span class="number">0000000000004040</span> <span class="type">B</span> _end</span><br><span class="line"><span class="number">0000000000001170</span> <span class="type">T</span> _fini</span><br><span class="line"><span class="number">0000000000001140</span> t frame_dummy</span><br><span class="line"><span class="number">0000000000003</span>de8 d __frame_dummy_init_array_entry</span><br><span class="line"><span class="number">00000000000020</span>a8 r __FRAME_END__</span><br><span class="line"><span class="number">0000000000004000</span> d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">                 w __gmon_start__</span><br><span class="line"><span class="number">0000000000002008</span> r __GNU_EH_FRAME_HDR</span><br><span class="line">                 <span class="type">U</span> gnu_get_libc_version<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">0000000000001000</span> <span class="type">T</span> _init</span><br><span class="line"><span class="number">0000000000002000</span> <span class="type">R</span> _IO_stdin_used</span><br><span class="line">                 w _ITM_deregisterTMCloneTable</span><br><span class="line">                 w _ITM_registerTMCloneTable</span><br><span class="line">                 <span class="type">U</span> __libc_start_main<span class="meta">@GLIBC</span>_2<span class="number">.34</span></span><br><span class="line"><span class="number">0000000000001149</span> <span class="type">T</span> main</span><br><span class="line">                 <span class="type">U</span> printf<span class="meta">@GLIBC</span>_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"><span class="number">00000000000010</span>b0 t register_tm_clones</span><br><span class="line"><span class="number">0000000000001050</span> <span class="type">T</span> _start</span><br><span class="line"><span class="number">0000000000004038</span> <span class="type">D</span> __TMC_END__</span><br></pre></td></tr></table></figure><p>可以看到 __cxa_finalize, gnu_get_libc_version, printf是基于2.2.5，而__libc_start_main是基于2.34，这正好与我们前面看到的符号相关联。</p><p>看到这里你应该已经明白了，自己的库中GLIBC版本是来源于所使用的符号所标明的版本，因此我们在当前环境编出来的库的依赖版本实际上是当前环境的库中对应符号所依赖的版本号</p><h1 id="libc-so与libc-so-6"><a href="#libc-so与libc-so-6" class="headerlink" title="libc.so与libc.so.6"></a>libc.so与libc.so.6</h1><p>libc.so虽然长得像so，但它并不是，甚至不是一个软链接。内容大致是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* GNU ld script</span><br><span class="line">   Use the shared library, but some functions are only in</span><br><span class="line">   the static library, so try that secondarily.  */</span><br><span class="line">OUTPUT_FORMAT(elf64-x86-64)</span><br><span class="line">GROUP ( /usr/lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /usr/lib/ld-linux-x86-64.so.2 ) )</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>程序员的自我修养：链接、装载与库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/glibc-version/</summary>
      
    
    
    
    <category term="C" scheme="https://fusionbolt.github.io/categories/C/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
  </entry>
  
  <entry>
    <title>我原本计划停下一周，然而...</title>
    <link href="https://fusionbolt.github.io/2022/03/28/rest-for-a-week/"/>
    <id>https://fusionbolt.github.io/2022/03/28/rest-for-a-week/</id>
    <published>2022-03-28T15:59:09.000Z</published>
    <updated>2022-03-28T16:23:12.230Z</updated>
    
    <content type="html"><![CDATA[<p>最近的精神状态愈发差劲，无止境的压力涌入身体，我也没有什么好的排解途径（本文不是讲我状态多差的，但是这些属于所需要了解的上下文，希望不要看到这个就直接关掉了文章）。我觉得不能再这个样子了，因此我想要尝试为期一周的“在家只休息”计划<del>（过于直接的命名）</del></p><h1 id="这周是如何度过的"><a href="#这周是如何度过的" class="headerlink" title="这周是如何度过的"></a>这周是如何度过的</h1><p>计划很美好，现实嘛…大家都懂</p><h3 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h3><p>清理了卧室的垃圾，做了一些轻微的收拾。之后的时间都是习惯性的就要去抓手机，想要放音乐。看到这里，你可以一会尝试一下一段时间什么也不做是怎样的感受。</p><p>停下来什么都不做还是很难，不知所措的时候突然想到一些东西就开始记了下来，最后花了一个小时的时间手写了满满一页纸的想法（这也不算是在休息）。最后也是不知不觉就十二点了，早睡也没能成功</p><h3 id="后面几天"><a href="#后面几天" class="headerlink" title="后面几天"></a>后面几天</h3><p>本周的精神状态极差，回家只想获取简单快速的反馈，因此结果和我预料的也差不多，第二天开始回家只有各种刷视频，以及玩一些游戏。后面几天愈发过分，甚至到了快一点</p><p>周末由于事情比较多导致只有晚上在家，然而周末晚上也没有多少改善</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发现自己现在的情况，所谓的休息在情绪高压下根本就是找理由刷推特和视频，这种休息还不如不休，但是不休息又会持续积累压力和疲劳，那…</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rest-for-a-week/mami.png"                      alt="Untitled"                ></p><p>仔细想想还是应该注重维持我的日常规划的同时在不同任务之间进行轻微的休息，而减少大片的休息时间。这是非常必要的事情，不能一直紧绷着精神。否则就会像我现在这个样子，在状态差到只想刷刷刷以及处理任务之间反复游走，从来没有真正的休息过</p><h1 id="第一天我都写了些啥？"><a href="#第一天我都写了些啥？" class="headerlink" title="第一天我都写了些啥？"></a>第一天我都写了些啥？</h1><p>尽管写满了一页A4纸，在这里只挑出一些提及一下。</p><p>很久没有这样决定不逼着自己做些什么了（但是另一种角度说我还是在逼着自己不做事情，尽管也没能成功。</p><p>回想起以前的各种略悠闲的生活：回想起三年前在家的时候自己买菜做饭自己去海边溜达的日子，回想起在学校和舍友满学校找猫喂猫的日子。我也有那样的时光啊。</p><p>而现在的我显得忙碌与疲劳，不断给自己添加非常多的压力，这给我的第一反应是与之前的生活有着极大的反差。</p><p>但是后来想起现在的我会去买花，会去公园拍照，会去看星星拍星星，会关心云彩是什么样的，这样想下去现在也没有那么枯燥无谓。相比之前能做以及实际去做的事情都多了非常多，感兴趣的事情也多了许多，自己渐渐开始主动接触各种各样的事物，自己不再是只知道上学学习与打游戏的一个人了。</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>休息也不能白休，偶尔也会感受一下，会想一下自己的状态，进而记录了一些想法。</p><h2 id="外界push"><a href="#外界push" class="headerlink" title="外界push"></a>外界push</h2><p>不论因为什么，我目前都是处于一个身体不想做事情的状态（实际表现就是想做什么但并不会去做）。这个现象我一直隐约有所察觉，但是并没有做过多想法，或许是想了也没有用，再怎么想还是会这样。对于现在的话，更多的是将这个东西有意识的提醒自己，这是很重要的问题自然不能忽略</p><p>我有那么多想做的事情，都是觉得有意思想要尝试的东西，最后没有利用时间去做大多是如此。由于总处于疲惫状态，不管学的东西再有意思也不可能在累的时候还想要用力</p><p>关于这个问题，想起了我第一次接触精神药物的时候，当时因为睡眠不好大夫给我开了黛力新，之后的半个月内真的是精神十足，没有觉得累，也不像以往一样什么都不愿做，讨厌的英语材料也能一直在啃（<del>绝不是给我现在回避啃英语找借口</del>），随后一些原因效果都没了，一共也就吃了两个月。那段时间我在看各种书的lab，然而药效小了以后的效率最多只有原来一半，只能硬逼着自己做，逼着自己做也会很快就产生厌烦，完全找不回那半个月的精神劲。如果能持续保持那样的状态那我大概几个月就会产生更为巨大的变化吧，可惜已经一去不复返了</p><p>想要身体去做事情只有通过各种方式进行push，至少对我来说在被轻度push的时候状态基本上都是相对良好（重度可能会增加焦虑），之前也看到类似这样的话</p><blockquote><p>自己一个人努力是难的，需要有人拉你一把</p></blockquote><h2 id="习惯"><a href="#习惯" class="headerlink" title="习惯"></a>习惯</h2><p>然而不是总能有人来帮你，大多数情况需要靠自己。而对自己push对于我这样的情况来说是相对比较困难的，但我之前依然每天都能够坚持做些什么，这完全归功于习惯。</p><p>只要逐渐养成习惯，那么做这些事情所需的阻力逐渐会减小，那么即便是相对疲惫的状态也能够一直做下去。</p><p>关于如何逐渐养成习惯这些，我推荐去阅读《掌控习惯》这本书。这本书最初是由推友在推特推荐给我的，阅读之后觉得收益非常多。虽然只能将书中的少部分内容运用到实际中，但依然促进了我许多改变。</p><p>关于习惯，周六心情不错的时候我一度认为这就是我破局最重要的东西之一。我写下了这样的一段话：我也不需要再担心自己会一直魔怔了，不过那要到何时我就不知道了。魔怔能不能解决我不知道，但是一定会帮助我解决非常多的问题。在这里我想起了上面提到的《掌控习惯》中提及了这样的内容</p><blockquote><p>不是应当达到某个目的，而是要达到某个系统</p></blockquote><p>一旦所需的习惯系统形成了，目的自然而然也就能够达到了</p><h2 id="“应该做的”"><a href="#“应该做的”" class="headerlink" title="“应该做的”"></a>“应该做的”</h2><p>停摆了一个周，很多事情没有去做也没有那么大的影响。（当然不是说我现在所做的事情都是不该做的意思）</p><p>想到了自己时常会被自己心中所谓的“应该做的”事情所限制所约束所浪费时间。之前总是会把很多这样的事情塞给自己，然后就开始拖。拖到最后太多了就狠心全部清空，实际最后也没有太大的影响。</p><p>你有多少事情也是这样？不过想明白自己真正应该做什么绝非易事，生活中的噪音太多了，而且即便没有这些噪音这也是一个非常难的问题。</p><h1 id="这一周我究竟得到了什么"><a href="#这一周我究竟得到了什么" class="headerlink" title="这一周我究竟得到了什么"></a>这一周我究竟得到了什么</h1><p>这一周的时间，我对所处的情况进行了一些思考，得出了一些结论。在写下成文的过程中再一次强化对这些想法的感知，希望能够帮助我强化一些正确的想法在脑中的印象并且更好的去实施提到的应当做的事情。</p><p>意识到了习惯究竟有多么的重要，看到离开了习惯的我是如何打回原形的；意识到了应该什么时候休息，缺乏休息的后果。这些虽然潜意识的有意识到，但是这种事情还是需要从潜意识中提取出来才能真正开始产生一些影响。</p><p>赶往目的地很重要，但是偶尔还是应该停下脚步，看看周边的风景</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的精神状态愈发差劲，无止境的压力涌入身体，我也没有什么好的排解途径（本文不是讲我状态多差的，但是这些属于所需要了解的上下文，希望不要看到这个就直接关掉了文章）。我觉得不能再这个样子了，因此我想要尝试为期一周的“在家只休息”计划&lt;del&gt;（过于直接的命名）&lt;/del&gt;&lt;/</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="Habits" scheme="https://fusionbolt.github.io/tags/Habits/"/>
    
    <category term="Rest" scheme="https://fusionbolt.github.io/tags/Rest/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记12 部分Parser</title>
    <link href="https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/"/>
    <id>https://fusionbolt.github.io/2022/03/20/rc-lang-dev-12/</id>
    <published>2022-03-20T04:16:15.000Z</published>
    <updated>2022-03-20T07:13:24.958Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-12/IMG_2114.JPG"                      alt="IMG_2114"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:95518122</center> <p>本周内容主要就是parser，而ast的内容会穿插其中</p><h1 id="Parser的一些问题"><a href="#Parser的一些问题" class="headerlink" title="Parser的一些问题"></a>Parser的一些问题</h1><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>由于是由换行来分句，我觉得一个头疼的点在于要想清楚哪里要换行，想清楚这个parser都是由什么组成，然后拼接在一起。但是写到这里的时候我才想到如果表达式有多行（这个也是非常常见的情况）就支持不了了…以后再做支持吧，这个或许可以对于表达式单独添加换行的支持。</p><p>我目前的换行策略是统一由stmt以及item吃掉eol，其中的子parser是不会处理eol的。stmt是很自然的，一行是一个stmt，item的话目前则是由函数或者class组成，而函数和class也不需要管理换行统一由item管理</p><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><p>这个问题留到下次再讲<del>（因为我还没写）</del></p><h1 id="关于设计"><a href="#关于设计" class="headerlink" title="关于设计"></a>关于设计</h1><p>在重写的时候发现很多原来的设计并不好，但是又一时不知该如何设计。后面觉得还是先实现一种，先功能完备再来考虑美化语法</p><p>关于具体的设计还是要看parser和ast的实现</p><h1 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(id: <span class="type">Id</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">String</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br></pre></td></tr></table></figure><p>关于Expr, Stmt, Block之间不知道以什么样的形式比较好，就暂且学习了Rust的做法。自己不知道怎么做那去学习一些比较好的语言，这样的想法我觉得应该是没问题的。之前做的时候也是经常会参考Ruby的实现</p><p>关于Expr我就不一个个放parser了，大部分比较简单没有什么可讲的内容。着重讲几个关键的点。代码中出现log的部分可以忽略</p><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><h3 id="ast的变化"><a href="#ast的变化" class="headerlink" title="ast的变化"></a>ast的变化</h3><p>首先ast的定义相比于之前发生了变化</p><p>这是之前if的ast定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>参考了rust中的if而现在转换成了这个样子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br></pre></td></tr></table></figure><p>false_branch可以是一个普通的else，也可以是接的另一个if，也就是将elsif这一语法糖还原为原始的if了，而elsif的if里又是同样的定义</p><p>同时之前的if是一个stmt，而现在的if是expr。返回的是对应分支block的返回值。block是由多个stmt组成，其返回值则是最后一条stmt</p><h3 id="parser"><a href="#parser" class="headerlink" title="parser"></a>parser</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">block</span></span>: <span class="type">Parser</span>[<span class="type">Block</span>] = positioned &#123;</span><br><span class="line">  rep(statement) ^^ (stmts =&gt; <span class="type">Block</span>(stmts))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiLineIf</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">IF</span> ~&gt; expr) ~ block ~ elsif.* ~ (oneline(<span class="type">ELSE</span>) ~&gt; block).? &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ if_branch ~ elsif ~ else_branch</span><br><span class="line">    =&gt; <span class="type">If</span>(cond, if_branch, elsif.foldRight(else_branch.asInstanceOf[<span class="type">Option</span>[<span class="type">Expr</span>]])(</span><br><span class="line">      (next, acc) =&gt; <span class="type">Some</span>(<span class="type">If</span>(next.cond, next.true_branch, acc))))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elsif</span></span>: <span class="type">Parser</span>[<span class="type">If</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">ELSIF</span> ~&gt; termExpr) ~ block ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ branch =&gt; <span class="type">If</span>(cond, branch, <span class="type">None</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到elsif在这里被编译为了if，多个elsif则是被编译为了一个List[If]，在这里通过FoldRight的方式折叠为一个if。以else为初始值，不断的将List最右边的元素设置为下一个if的else</p><p>逻辑展开是这样的</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">C</span>, <span class="type">ELSE</span>: <span class="type">Option</span>[<span class="type">Expr</span>]</span><br><span class="line"><span class="type">A</span> <span class="type">B</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))</span><br><span class="line"><span class="type">A</span> <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>)))</span><br><span class="line"><span class="type">Some</span>(<span class="type">IF</span>(<span class="type">A</span>.cond, <span class="type">A</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">B</span>.cond, <span class="type">B</span>.true_branch, <span class="type">Some</span>(<span class="type">IF</span>(<span class="type">C</span>.cond, <span class="type">C</span>.true_branch, <span class="type">ELSE</span>))))</span><br></pre></td></tr></table></figure><p>代码中出现的asInstanceOf是因为我不知道这里的类型是怎样处理的，索性通过这种方式来回避编译错误。</p><h2 id="termExpr"><a href="#termExpr" class="headerlink" title="termExpr"></a>termExpr</h2><p>termExpr只是为了parser的时候区分各种expr的一种方式，所以ast表示上是和常规的expr是一样的。可以看到term是一些可以用于各种操作符的东西，比如说1 + 1，1是一个term，整个是一个termExpr。后面我们需要将这一系列的term和operator组合成一个expr，因此需要有后面的termToBinary</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">expr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  multiLineIf | termExpr | ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | call | memField | memCall | idExpr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于termsToBinary的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">BinaryTranslator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> opDefaultInfix = <span class="type">HashMap</span>(<span class="string">&quot;+&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;-&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;*&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;/&quot;</span>-&gt;<span class="number">10</span>, <span class="string">&quot;&gt;&quot;</span>-&gt;<span class="number">5</span>, <span class="string">&quot;&lt;&quot;</span>-&gt;<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findMaxInfixIndex</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Int</span> =</span><br><span class="line">    terms</span><br><span class="line">      .zipWithIndex</span><br><span class="line">      .filter((x, _) =&gt; x.isInstanceOf[<span class="type">OPERATOR</span>])</span><br><span class="line">      .map((x, index) =&gt; (x.asInstanceOf[<span class="type">OPERATOR</span>], index))</span><br><span class="line">      .minBy((op, index) =&gt; opDefaultInfix(op.op))._2</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">replaceBinaryOp</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>], index: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Positional</span>] = &#123;</span><br><span class="line">    <span class="keyword">var</span> t = terms(index)</span><br><span class="line">    <span class="keyword">val</span> left = terms.slice(<span class="number">0</span>, index - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> bn = <span class="type">Expr</span>.<span class="type">Binary</span>(</span><br><span class="line">      terms(index).asInstanceOf[<span class="type">OPERATOR</span>].op,</span><br><span class="line">      terms(index - <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>],</span><br><span class="line">      terms(index + <span class="number">1</span>).asInstanceOf[<span class="type">Expr</span>])</span><br><span class="line">    <span class="keyword">val</span> rights = terms.slice(index + <span class="number">2</span>, terms.size)</span><br><span class="line">    left.appended(bn):::(rights)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(term: <span class="type">Expr</span>, terms: <span class="type">List</span>[<span class="type">List</span>[<span class="type">Positional</span>]]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> terms.isEmpty then <span class="keyword">return</span> term</span><br><span class="line">    termsToBinary(term :: terms.flatten)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">termsToBinary</span></span>(terms: <span class="type">List</span>[<span class="type">Positional</span>]): <span class="type">Expr</span> = &#123;</span><br><span class="line">    <span class="keyword">var</span> newTerms = terms</span><br><span class="line">    <span class="keyword">while</span> (newTerms.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> max_index = findMaxInfixIndex(newTerms)</span><br><span class="line">      newTerms = replaceBinaryOp(newTerms, max_index)</span><br><span class="line">    &#125;</span><br><span class="line">    newTerms.head.asInstanceOf[<span class="type">Expr</span>.<span class="type">Binary</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑：</p><ol><li><p>如果只有开头的一个term则返回该term</p><p>否则将开头的和后面的terms组合起来进行处理</p></li><li><p>找到最高优先级的op的位置</p></li><li><p>将该位置以及左右的term组合为一个expr并且替换</p></li><li><p>重复这个过程直至剩下一个term</p></li></ol><p>这里我觉得实现的有点脏…基本上是把我用ruby写的那一套抄过来了，我一时也没想到什么好的方案</p><p>由于要对替换以后的expr再进行组合，这个过程中index会发生变动；如果要将组合后的拿出来，那还要处理哪些是拿出来的哪些是没有拿出来的，这样获取前后的term也会很不方便</p><h1 id="Stmt"><a href="#Stmt" class="headerlink" title="Stmt"></a>Stmt</h1><h2 id="ast-1"><a href="#ast-1" class="headerlink" title="ast"></a>ast</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Id</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Id</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br></pre></td></tr></table></figure><p>这里的while和rust的不太一样，rust的while也是一个expr，尽管能够从理性上认识到这样做是为了返回最后一个block的结果，但我仍然觉得这个做法好奇怪。目前还是先将其作为stmt，以后发现了哪里不合适再进行修正</p><h2 id="parser-1"><a href="#parser-1" class="headerlink" title="parser"></a>parser</h2><p>这边也比较简单。内容不多就直接贴出来了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">local</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">VAR</span> ~&gt; id) ~ (<span class="type">EQL</span> ~&gt; termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Local</span>(id, <span class="type">Type</span>.<span class="type">Nil</span>, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ret</span></span>: <span class="type">Parser</span>[<span class="type">Return</span>] = positioned &#123;</span><br><span class="line">  <span class="type">RETURN</span> ~&gt; termExpr ^^ <span class="type">Return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assign</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">Assign</span>] = positioned &#123;</span><br><span class="line">  (id &lt;~ <span class="type">EQL</span>) ~ termExpr ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ expr =&gt; <span class="type">Stmt</span>.<span class="type">Assign</span>(id, expr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">whileStmt</span></span>: <span class="type">Parser</span>[<span class="type">Stmt</span>.<span class="type">While</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">WHILE</span> ~&gt; parSround(termExpr)) ~ block &lt;~ <span class="type">END</span> ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> cond ~ body =&gt; <span class="type">Stmt</span>.<span class="type">While</span>(cond, body)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果读者能够读到这里（<del>虽然并不会有几个人，其中大概也不会有追更的</del>），那很大概率不嫌弃我的内容，在这里可能要提前和各位说一声对不起，下周很有可能将是我第二次断更。（其实本周也有好几天都没写了…）</p><p>下周工作之外的事情除了最低限度的练琴，我会尽可能的不去做什么事情。眼睛疼（写的现在也在疼），精神极其不稳定（经常不受控制的胡思乱想），这些都是原因。</p><p>我也不想停，重写的进程还是比较慢，我的开发效率又偏低同时又要各种测试确保正确性。我好想赶快把这些基础的迁移完，然后去学习做优化，学习加上类型系统，等等，还想要多学习一些Scala，除此之外有很多创意想要实现还想去学swiftUI</p><p>但是或许此刻再不停就真的要断线了，我需要花时间好好冷静一下，平复情绪，进行休整。我无法努力获得温暖，那就只有努力去平复情绪。面对至今为止最重要也最大的挑战（当前的不良状态），我也应该拿出应有的态度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-12</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记11 重构与Lexer</title>
    <link href="https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/"/>
    <id>https://fusionbolt.github.io/2022/03/13/rc-lang-dev-11/</id>
    <published>2022-03-13T03:08:42.000Z</published>
    <updated>2022-03-13T08:33:02.179Z</updated>
    
    <content type="html"><![CDATA[<p>本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。</p><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>vm目前代码很少，做的重构主要是将一些东西抽象拆分出来</p><p>这是之前vm的成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line"><span class="keyword">size_t</span> _pc = <span class="number">0</span>;</span><br><span class="line">EvalStack _eval_stack;</span><br><span class="line">std::string _cur_fun;</span><br><span class="line"><span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> _pc_need_incr = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">relative_pc</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">size_t</span> <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">EvalStack&amp; <span class="title">eval_stack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _eval_stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string&amp; klass, <span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> FunInfo&amp; f)</span></span>;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">pc_need_incr</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc_need_incr; &#125;</span><br></pre></td></tr></table></figure><h2 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h2><p>首先就是关于pc的部分，零碎的放在了vm的实现中，我们单独将这些实现挑出来作为一个类来实现，因此就有了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM </span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PC</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PC</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">absolute_jump</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">relative_jump</span><span class="params">(<span class="keyword">int</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">size_t</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">current</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">force_need_incr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> _inst_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> _need_increase = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><p>其次是代码段的内容。和代码段相关的虽然只有一个指令的vector和一个load method方法，但是为了组件之间减少耦合、方便测试还是要拆出来（虽然我还没有写更多的测试…）。最后结果是多了一个这样的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> RCVM</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CodeSegment</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> std::string &amp;klass, <span class="keyword">const</span> std::string &amp;name,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> FunInfo &amp;f)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; <span class="built_in">inst_list</span>() <span class="keyword">const</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;VMInst&gt; <span class="title">get_inst</span><span class="params">(<span class="keyword">size_t</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;VMInst&gt; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i) <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; _inst_list;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重构后的成员"><a href="#重构后的成员" class="headerlink" title="重构后的成员"></a>重构后的成员</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VM</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function">PC <span class="title">pc</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _pc; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">EvalStack &amp;<span class="title">eval_stack</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _eval_stack; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super = <span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_call</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">can_stop</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _can_stop; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_can_stop</span><span class="params">()</span> </span>&#123; _can_stop = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">    [[nodiscard]] <span class="function"><span class="keyword">bool</span> <span class="title">out_of_code_segment</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">VMInstVisitor</span>;</span></span><br><span class="line">    std::shared_ptr&lt;VMInstVisitor&gt; _visitor;</span><br><span class="line">    CodeSegment _code_segment;</span><br><span class="line">    EvalStack _eval_stack;</span><br><span class="line">    std::string _cur_fun;</span><br><span class="line">    <span class="keyword">bool</span> _can_stop = <span class="literal">false</span>;</span><br><span class="line">    PC _pc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看上去清爽了许多。目前先改到这里了</p><h1 id="相关前置知识"><a href="#相关前置知识" class="headerlink" title="相关前置知识"></a>相关前置知识</h1><p>之后的内容开始设计lexer和parser。假设读者没有相关知识，我先来大概讲一下编译器从源码生成到ast的流程。</p><ol><li><p>对输入的源码进行分词，生成一系列Token，我们称之为词法分析</p><p>分词是什么呢？说的直白一些就是把字符串划分开，哪一部分是名字，哪一部分又是空格，哪一部分是数字，诸如此类。Token就是表明了这个东西到底是哪种词，如果不明白可以看后面的代码部分。</p></li><li><p>将Token根据特定的规则进行解析，生成抽象语法树，我们称之为语法分析</p></li></ol><p>这些过程的实现方式不外乎两类</p><ol><li>使用生成器进行生成：常见的是Lex（生成词法分析器） + YACC（生成语法分析器）。这些需要自己编写一下规则，喂给生成器进行生成</li><li>自行手写实现：手写的灵活性灵活度是会比生成器要高的，但是相对比较复杂</li></ol><p>关于手写方式有一种叫parser combaintor的技术，能够通过组合不同的函数来实现解析，实现起来自然是比传统的手写方式方便，而我这里选择的也正是这种方案</p><h1 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h1><p>虽说是parser，但是肯定还是要先做分词的。之前的实现中是没有做分词的，很多地方都搞的比较难受。一开始我还疑惑了一会使用parser combaintor是否还要做分词，但是写了一会意识到还是需要，虽然可以直接隐含了分词的部分，但是这样会把两类逻辑全部糊在一起，对于调试、测试都是非常难受的问题，而且对于空格、换行之类的也会非常麻烦。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>先来看一下Token的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Token</span> <span class="keyword">extends</span> <span class="type">Positional</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">OPERATOR</span>(op: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">case</span> <span class="type">EOL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">COMMA</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">EQL</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SPACE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">IF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">THEN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSIF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">ELSE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">WHILE</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">CLASS</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">SUPER</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><p>通过extends Positional进而让Token都携带了位置信息（行号列号）</p><p>这是一份不是很好的定义。写这个的时候来不及改了，下周会改正，但是在这里将这个不太好的范例拿出来讲。我一开始也觉得这样很奇怪，但是也没深入思考有没有什么更好的方式（再一次见到了自己的惰性），对于Token来说这样平着展开也不能说不对，但是可以做得更好</p><p>后来看到Rust中Token的一些地方我才反应过来，还是应该将keyword和一些间隔符单独揪出来，而不是这么完全扁平化。写这篇的时候来不及改了，只能拖到下周再说了</p><h2 id="一些简单的实现"><a href="#一些简单的实现" class="headerlink" title="一些简单的实现"></a>一些简单的实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NoValueToken</span></span>(str: <span class="type">String</span>, token: <span class="type">Token</span>): <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">    str ^^^ token</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eol</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;\n&quot;</span>, <span class="type">EOL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eql</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;=&quot;</span>, <span class="type">EQL</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comma</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;,&quot;</span>, <span class="type">COMMA</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trueLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;true&quot;</span>, <span class="type">TRUE</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">falseLiteral</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;false&quot;</span>, <span class="type">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;var&quot;</span>, <span class="type">VAR</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">valStr</span> </span>= <span class="type">NoValueToken</span>(<span class="string">&quot;val&quot;</span>, <span class="type">VAL</span>)</span><br></pre></td></tr></table></figure><p>这个也非常简单，读取到对应的字符串直接返回对应的token。外面包了positioned以后内部的内容就能够携带行号和列号的信息</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ops</span> </span>= <span class="string">&quot;[+\\-*/%^~!&gt;&lt;]&quot;</span>.r</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operator</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  ops ^^ <span class="type">OPERATOR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个通过正则表达式匹配的例子，这里的^数量由三个变成了两个，三个的情况下是左边的条件匹配成功则返回右边的值，而两个的情况下是条件匹配成功后执行右边的函数并且返回其值。</p><p>operator这里是通过正则表达式来进行匹配，ops则是一个正则表达式</p><p>这里可能有一些引起困惑的地方。为什么下面需要返回函数的时候填的是返回的类型？我没有正经学过Scala，用我在其他语言学过的东西来说这大概是因为虽然OPERATOR本身是类型，但在这里是一个值构造器，用另一种表达方式的话就是一个传入OPERATOR所需参数返回一个OPERATOR实例的函数</p><p>这里我可能解释的不是很正确，如有哪里用词/描述不当还请联系我指出</p><h2 id="间隔符与非间隔符"><a href="#间隔符与非间隔符" class="headerlink" title="间隔符与非间隔符"></a>间隔符与非间隔符</h2><p>核心代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allTokens</span></span>: <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">Token</span>]] = &#123;</span><br><span class="line">((rep1sepNoDis(repN(<span class="number">1</span>,notSpacer),spacer.+) ~spacer.*) |</span><br><span class="line"><span class="comment">// BAA is imposible</span></span><br><span class="line">(rep1sepNoDis(spacer.+, repN(<span class="number">1</span>,notSpacer)) ~notSpacer.?)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> list ~ t =&gt;</span><br><span class="line">      list</span><br><span class="line">        .fold(<span class="type">List</span>())(_:::_)</span><br><span class="line">        .concat(t <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(v) =&gt; <span class="type">List</span>(v)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">List</span>()</span><br><span class="line">          <span class="keyword">case</span> _ =&gt; t</span><br><span class="line">        &#125;)</span><br><span class="line">        .filter(_ != <span class="type">SPACE</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>^^前都是解析的部分，解析部分的～是连接的意思，也就是说前面的解析完会接着解析后面的内容。后面处理的部分只是将每个解析部分生成的输出都连接起来，成为一个List[Token]。由于觉得用不到因此我在这里干掉了SPACE</p><p>其中出现过的一些函数的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">space</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = positioned &#123;</span><br><span class="line">  whiteSpace.+ ^^^ <span class="type">SPACE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">notSpacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = keyword | value | eol</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spacer</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = symbol | operator | eql | space</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keyword</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = stringLiteral | trueLiteral | falseLiteral |</span><br><span class="line">    defStr | endStr | ifStr | thenStr | elsifStr | elseStr | whileStr |</span><br><span class="line">    classStr | superStr | varStr | valStr</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">symbol</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = comma | eol | leftParentTheses | rightParentTheses | leftSquare | rightSquare</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">Parser</span>[<span class="type">Token</span>] = number | identifier</span><br></pre></td></tr></table></figure><p>这里对我来说是一个比较难写的点，上周在写的时候头痛了好一阵子，想明白逻辑以后再回来看会好很多</p><h3 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h3><p>这里的逻辑是这样的：我们先定义不能作为间隔符的为A（notSpacer），可以作为间隔符的为B（spacer），那么我们需要的是A(B+A)*B*，或者是B+(AB+)*A?</p><p>注：这里的*+?都是正则表达式的语义</p><h3 id="拆分逻辑"><a href="#拆分逻辑" class="headerlink" title="拆分逻辑"></a>拆分逻辑</h3><p>关于为什么要这么设定，我们先从B开始。</p><ol><li><p>可以看到B包含了一些运算符，空格，一些标点符号，这些本身是和任何字符相连都是无歧义的（目前来说B中的内容是无歧义的），那么它们连续存在依然不会产生歧义。B本身是要存在的，因此这里可以推导出B+</p></li><li><p>而A中的内容，比如说两个keyword之间一定要有空格，不然会被识别成一个identifier了，比如说传递参数的时候需要逗号分开（symbol），那么A是不可能连续存在的，因此这里可以推导出A</p></li><li><p>由于我们需要A和B间隔放置，我首先想到的是rep1sep(A, B+)，而由于A和B都可能在第一个，因此有了rep1sep(A, B+) | rep1sep(B+, A)。（repsep举个例子，repsep(str, ‘,’)，对应的就是str, str, str这种以，分割的）但是repsep会扔掉B，因此我从rep1sep抄了一份修改了一下，变成了不扔掉B的版本</p><p>以下rep1sepNoDis都用rep1sep代替</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sepNoDis</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~ p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y.map(x =&gt; <span class="type">List</span>(x._1.asInstanceOf[<span class="type">T</span>], x._2)).fold(<span class="type">List</span>())(_:::_)&#125;</span><br></pre></td></tr></table></figure><p>原版</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rep1sep</span></span>[<span class="type">T</span>](p : =&gt; <span class="type">Parser</span>[<span class="type">T</span>], q : =&gt; <span class="type">Parser</span>[<span class="type">Any</span>]): <span class="type">Parser</span>[<span class="type">List</span>[<span class="type">T</span>]] =</span><br><span class="line">    p ~ rep(q ~&gt; p) ^^ &#123;<span class="keyword">case</span> x~y =&gt; x::y&#125;</span><br></pre></td></tr></table></figure><ol><li>但是只是repsep的做法无法处理AB（会残留一个B未解析），那么很自然的就会想到再后面接一个可选的B，因此就有了rep1sep(A, B+) ~ B?，同理无法处理BA，也就有了 rep1sep(B+, A) ~ A? 组合起来就有了 rep1sep(A, B+) ~ B? | rep1sep(B+, A) ~ A? </li></ol><p>事后回顾思路还算是捋的比较清晰，一直这样写或许也会有利于我之后写代码的时候逻辑梳理的能力。不过当时写的时候真的是整个人都不好了…这块写代码的时候想了半天，写博客尽管逻辑很流畅了但是还是写了很久</p><h3 id="逻辑与实现的一些出入"><a href="#逻辑与实现的一些出入" class="headerlink" title="逻辑与实现的一些出入"></a>逻辑与实现的一些出入</h3><p>拆分完逻辑后将</p><p>rep1sep = rep1sepNoDis</p><p>A = notSpacer</p><p>B = spacer</p><p>代入后，会发现有一些不一样的地方。我在rep1sep的A中做了repN(1, A)的操作。至于为什么这么写，是为了保证A和B哪一个在前哪一个在后都可以使用。一个值和一个List交换顺序还能连接的实现不知道有什么可用的，自己尝试写了一个</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l: <span class="type">List</span>[<span class="type">T</span>], v: <span class="type">T</span>): <span class="type">List</span>[<span class="type">T</span>] = l:::v::<span class="type">Nil</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](v: <span class="type">T</span>, l: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = v::l</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span></span>[<span class="type">T</span>](l1: <span class="type">List</span>[<span class="type">T</span>], l2: <span class="type">List</span>[<span class="type">T</span>]): <span class="type">List</span>[<span class="type">T</span>] = l1:::l2</span><br></pre></td></tr></table></figure><p>但是和前面的函数组合起来，在处理的时候一些看起来很自然的东西并没有通过类型检查，对于Scala的类型理解不到位也难以解决问题，因此就只好先这个样子。虽然用起了Scala，但是并没有学太多，凭着其他语言的经验直接就来写</p><h3 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h3><p>这么说过于抽象，我们通过看测试来实际理解以下例子。</p><p>之所以要搞得这么复杂，是因为最后一个测试用例的那种情况。对于我之前lexer和parser混在一起写的做法处理这样的情况是非常难的。不过我不敢说已经想全面了，有问题再改吧</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&quot;spacer&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">// a is notSpacer, b is spacer</span></span><br><span class="line">it(<span class="string">&quot;AB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;id id&quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>), <span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BAB&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; id &quot;</span>, <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;id&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;ABABB space and eol&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot;def f \n&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>), <span class="type">EOL</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;BABA&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; def f&quot;</span>, <span class="type">List</span>(<span class="type">DEF</span>, <span class="type">IDENTIFIER</span>(<span class="string">&quot;f&quot;</span>)))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;only space&quot;</span>) &#123;</span><br><span class="line">    expectSuccess(<span class="string">&quot; &quot;</span>, <span class="type">List</span>())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">&quot;local&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> v = <span class="type">List</span>(<span class="type">IDENTIFIER</span>(<span class="string">&quot;a&quot;</span>), <span class="type">EQL</span>, <span class="type">NUMBER</span>(<span class="number">1</span>))</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a = 1 &quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a =1&quot;</span>, v)</span><br><span class="line">    expectSuccess(<span class="string">&quot;a=1&quot;</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来是想写一些parser的内容的，但是没想到这个token间隔符相关的逻辑就花了我这么久的时间。这块我觉得写的还是相对比较清晰，也算是比较满意，所以本周就先这么结束了。关于token一般来说不会有什么特别的内容了，所以关于解析输入，之后基本上就是parser的内容了。</p><p>这个周我觉得进度比较慢，不会调加上前几天整个人都过于不稳定，回家会花一些时间在刷刷刷上，进而减少了编码的时间，不知道什么时候能做完重写啊…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周一开始重构了一下vm的部分代码，之后基本上都是在用新语言重写parser的部分。&lt;/p&gt;
&lt;h1 id=&quot;重构&quot;&gt;&lt;a href=&quot;#重构&quot; class=&quot;headerlink&quot; title=&quot;重构&quot;&gt;&lt;/a&gt;重构&lt;/h1&gt;&lt;p&gt;vm目前代码很少，做的重构主要是将一些东</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Lexer" scheme="https://fusionbolt.github.io/tags/Lexer/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记10 分支与循环</title>
    <link href="https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/"/>
    <id>https://fusionbolt.github.io/2022/03/05/rc-lang-dev-10/</id>
    <published>2022-03-05T03:56:29.000Z</published>
    <updated>2022-03-05T03:58:12.762Z</updated>
    
    <content type="html"><![CDATA[<p>开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来</p><p>本周更新的内容主要是修复之前的问题以及处理了分支循环</p><h1 id="继承与成员变量"><a href="#继承与成员变量" class="headerlink" title="继承与成员变量"></a>继承与成员变量</h1><p>首先是上周遗留的继承的情况下成员变量id会有问题，我们先来看一下成员变量相关的实现</p><ol><li>使用id标明</li><li>运行时存一个hash，按照名字来取</li></ol><p>我选择在添加parent的时候将parent的成员变量添加到当前的instance_vars中。这样需要布局在编译器确定，无法应对动态添加成员变量的情况，不过先不管那些</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">instance_var_keys</span></span></span><br><span class="line">  <span class="variable">@instance_vars</span>.sort_by(&amp;<span class="symbol">:last</span>).map &#123;<span class="params">|k, _|</span>k&#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_parents</span><span class="params">(parent_name, parent_table)</span></span></span><br><span class="line">  <span class="variable">@parent</span> = parent_name</span><br><span class="line">  <span class="keyword">unless</span> parent_table.is_a? ClassTable</span><br><span class="line">    raise <span class="string">&quot;parent_table should be a ClassTable&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  parent_table.instance_vars.each <span class="keyword">do</span> <span class="params">|var_name, _|</span></span><br><span class="line">    <span class="keyword">unless</span> <span class="variable">@instance_vars</span>.<span class="keyword">include</span>? var_name</span><br><span class="line">      add_instance_var(var_name)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><p>最近才发现我还没有做分支以及循环的内容</p><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">If</span></span></span><br><span class="line"><span class="comment"># stmt_list: [[if_cond, stmt], [elsif_cond, stmt]*]</span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:stmt_list</span>, <span class="symbol">:else_stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator"><a href="#translator" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_if</span><span class="params">(node)</span></span></span><br><span class="line">  list = node.stmt_list.map <span class="keyword">do</span> <span class="params">|cond, stmt|</span></span><br><span class="line">    c = visit(cond)</span><br><span class="line">    s = [visit(stmt), JumpAfterIf.new].flatten</span><br><span class="line">    cmp_and_jmp = push_eq_jmp(s.size)</span><br><span class="line">    [c, cmp_and_jmp, s].flatten</span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line">  els = visit(node.else_stmts)</span><br><span class="line">  list = list + els</span><br><span class="line">  list.each_with_index <span class="keyword">do</span> <span class="params">|inst, index|</span></span><br><span class="line">    <span class="keyword">if</span> inst.is_a? JumpAfterIf</span><br><span class="line">      list[index] = RelativeJump.new(list.size - index + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  list</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push_eq_jmp</span><span class="params">(true_branch_size)</span></span></span><br><span class="line">  [Push.new(<span class="number">1</span>), EQ.new, JumpFalse.new(true_branch_size + <span class="number">1</span>)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>对于每一组（if或者elsif）if条件和stmt进行遍历</p><ol><li><p>生成判断条件的指令</p></li><li><p>生成比较指令</p><p>将判断执行的结果与true进行eq操作，失败则跳转到下一组elsif，也就是true分支之后的第一条指令</p></li><li><p>生成当前组if中对应的true的分支</p><p>最后要添加一个跳转到整个if结束的指令</p></li></ol><h3 id="新指令"><a href="#新指令" class="headerlink" title="新指令"></a>新指令</h3><p>可以看到这里引入了几个新的指令</p><p>JumpAfterIf：用于跳转到if结束语句，提前占好指令位置，最后由RelativeJump代替</p><p>RelativeJump：跳转到一个相对地址</p><p>对于分支来说，判断指令也是需要的，因此还引入了GT，LT，EQ三个指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_op</span><span class="params">(op)</span></span></span><br><span class="line">  <span class="keyword">case</span> op.op</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&lt;&#x27;</span></span><br><span class="line">    LT.new</span><br><span class="line">  <span class="keyword">in</span> <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    GT.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&#x27;unsupported op&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="ast"><a href="#ast" class="headerlink" title="ast"></a>ast</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">While</span> &lt; Struct.<span class="title">new</span>(:<span class="title">cond</span>, :<span class="title">body</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="translator-1"><a href="#translator-1" class="headerlink" title="translator"></a>translator</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_while</span><span class="params">(node)</span></span></span><br><span class="line">  cond = visit(node.cond)</span><br><span class="line">  body = visit(node.body).flatten</span><br><span class="line">  cmp_and_jmp = push_eq_jmp(body.size + <span class="number">1</span>)</span><br><span class="line">  while_inst = [cond, cmp_and_jmp, body].flatten</span><br><span class="line">  while_inst + [RelativeJump.new(-while_inst.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的内容更简单，相比if来说只需要处理一个分支判断和true的语句，最后加一个回到while开头的跳转即可</p><h1 id="指令的VM实现"><a href="#指令的VM实现" class="headerlink" title="指令的VM实现"></a>指令的VM实现</h1><h2 id="新的pc寻址方式"><a href="#新的pc寻址方式" class="headerlink" title="新的pc寻址方式"></a>新的pc寻址方式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span> </span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">voidVM::<span class="built_in">relative_pc</span>(<span class="keyword">int</span> offset) &#123;</span><br><span class="line">    <span class="built_in">DEBUG_CHECK</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_pc) + offset &lt; <span class="number">0</span>,</span><br><span class="line">                <span class="string">&quot;invalid pc, pc:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot;offset:&quot;</span> + std::<span class="built_in">to_string</span>(offset))</span><br><span class="line">    <span class="built_in">set_pc</span>(_pc + offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> EQ &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::EQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> GT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::GT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]]  <span class="keyword">const</span> LT &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _eval_stack.<span class="built_in">exec</span>(BinaryOp::LT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这里，我把一些binary的op做了一下处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">(BinaryOp op)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(_opname, _op) \</span></span><br><span class="line"><span class="meta">   case BinaryOp::_opname: \</span></span><br><span class="line"><span class="meta">      push(v1 _op v2);     \</span></span><br><span class="line"><span class="meta">      break;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// LT GT, FILO</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="built_in">pop</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (op) &#123;</span><br><span class="line">        <span class="built_in">PUSH</span>(Add, +)</span><br><span class="line">        <span class="built_in">PUSH</span>(Sub, -)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mul, *)</span><br><span class="line">        <span class="built_in">PUSH</span>(Div, /)</span><br><span class="line">        <span class="built_in">PUSH</span>(Mod, %)</span><br><span class="line">        <span class="built_in">PUSH</span>(EQ, ==)</span><br><span class="line">        <span class="built_in">PUSH</span>(LT, &lt;)</span><br><span class="line">        <span class="built_in">PUSH</span>(GT, &gt;)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> PUSH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的点是第一个pop出来的是表达式右侧的变量，因为栈是先进后出的。不仅比较操作需要注意，减法和除法也是如此</p><h2 id="RelativeJump"><a href="#RelativeJump" class="headerlink" title="RelativeJump"></a>RelativeJump</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(constRelativeJump &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JumpFalse"><a href="#JumpFalse" class="headerlink" title="JumpFalse"></a>JumpFalse</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">([[maybe_unused]] <span class="keyword">const</span> JumpFalse &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> cond = _eval_stack.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(cond == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _vm.<span class="built_in">relative_pc</span>(inst.offset);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>过于急切的去摸了一点oop的边，甚至连基本的分支跳转之类的都没有做，这么匆匆忙忙是否表示我已经不想做了呢…不管怎么说，这个坑决定开了，不想做也要做下去，做的烂总比什么都没做要强的多（最近几周的内容不论是数量还是质量都开始大幅下降了…</p><p>开始不想接着写当前的了，vm那边我觉得虽然没写多少但已经开始有屎山的倾向了，应该花点时间重新考虑下代码结构以及测试。</p><p>优化以及类型分析之类的我觉得还是换一门静态类型的语言来做。最近也在开始进行编译器重写的工作，好在实际上东西不是很多。重写过后就会从优化以及类型开始做一些工作，而下周开始可能会花更大比例的时间在重写上。尽管东西不多，但由于我对新语言对不熟悉，而且尽可能的改用好的设计，还是要花上一定的时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;开头忏悔，上周因为年会出去玩了三天没写多少东西，加上回来太累了，也就咕了一周，本周会把上周的东西一起写进来&lt;/p&gt;
&lt;p&gt;本周更新的内容主要是修复之前的问题以及处理了分支循环&lt;/p&gt;
&lt;h1 id=&quot;继承与成员变量&quot;&gt;&lt;a href=&quot;#继承与成员变量&quot; class=&quot;he</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记9 OOP之继承</title>
    <link href="https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/"/>
    <id>https://fusionbolt.github.io/2022/02/20/rc-lang-dev-9/</id>
    <published>2022-02-20T04:12:17.000Z</published>
    <updated>2022-02-20T04:54:14.092Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分</p><h1 id="类的符号信息"><a href="#类的符号信息" class="headerlink" title="类的符号信息"></a>类的符号信息</h1><p>对于之前的类表实现是只有方法和成员变量的，而现在在获取符号表信息遍历到class的时候需要再添加一个parent的信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line"><span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span>, <span class="symbol">:parent</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="VM方法查找"><a href="#VM方法查找" class="headerlink" title="VM方法查找"></a>VM方法查找</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject *obj, <span class="keyword">const</span> string &amp;f, <span class="keyword">bool</span> super)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = super ? <span class="built_in">get_parent_class</span>(obj) : obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">method_search</span>(klass, f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> string &amp;klass, <span class="keyword">const</span> string &amp;f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;class_table = global_class_table[klass];</span><br><span class="line">    <span class="keyword">if</span> (class_table._methods.<span class="built_in">contains</span>(f)) &#123;</span><br><span class="line">        <span class="keyword">return</span> class_table._methods[f];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(class_table._parent.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MethodNotFoundException</span>(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">method_search</span>(class_table._parent, f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下之前的实现做一个对比</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然多了去父类查找的部分。</p><h1 id="调用父类同名函数"><a href="#调用父类同名函数" class="headerlink" title="调用父类同名函数"></a>调用父类同名函数</h1><p>既然要继承了，那么也一定要涉及到调用父类的同名函数的问题。在上面的method_search的实现中，可以看到从obj查找method的时候有一个叫super的参数。因此如果要调用super的话一定是从父类开始查找，而不是从当前类</p><p>而这个在源代码中是通过一个super方法来实现的，大概是这个样子</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span></span><br><span class="line">  <span class="keyword">super</span>()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="AST定义"><a href="#AST定义" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:args</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(args)</span></span></span><br><span class="line">    <span class="variable">@args</span> = args</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper<span class="subst">#&#123;args_to_s(<span class="variable">@args</span>)&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义"><a href="#VM指令定义" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InvokeSuper</span> &lt; Struct.<span class="title">new</span>(:<span class="title">argc</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:argc</span> =&gt; <span class="symbol">:int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;InvokeSuper <span class="subst">#&#123;argc&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意AST中保存的是实参，而指令中已经提前push好了参数，这里只需要传递一个argc用于寻找参数之前push的this指针就可以了</p><h2 id="ast翻译到vm指令的实现"><a href="#ast翻译到vm指令的实现" class="headerlink" title="ast翻译到vm指令的实现"></a>ast翻译到vm指令的实现</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_invoke_super</span><span class="params">(node)</span></span></span><br><span class="line">  [PushThis.new] + push_args(node.args.map) + [InvokeSuper.new(node.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="vm指令的执行"><a href="#vm指令的执行" class="headerlink" title="vm指令的执行"></a>vm指令的执行</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> InvokeSuper &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _vm.<span class="built_in">begin_call</span>(_eval_stack.<span class="built_in">current_method</span>(), inst.argc, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">VM::begin_call</span><span class="params">(<span class="keyword">const</span> string &amp;f, <span class="keyword">size_t</span> argc, <span class="keyword">bool</span> super)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f, super);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也非常简单，比起之前的实现，现在begin_call里添加了一个super传递给method_search</p><h1 id="成员变量储存"><a href="#成员变量储存" class="headerlink" title="成员变量储存"></a>成员变量储存</h1><p>既然要继承，那么就要保存父类成员的变量。目前的做法是像ruby一样直接覆盖父类同名变量，因此在创建对象的时候获取整个类继承链中所有变量的集合，然后获取其长度，在创建变量的时候使用这个长度来分配对应的空间。</p><p>这个长度应该是编译期间就算出来的，这里这样写有一种应付的感觉…虽然说这样能够处理动态修改父类定义的方法，但是现在并没有做的那么动态，很多设计还没有敲定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">find_all_var</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> parents = global_class_table[klass]._parent;</span><br><span class="line">    <span class="keyword">auto</span> &amp;vars = global_class_table[klass]._vars;</span><br><span class="line">    <span class="keyword">auto</span> result = std::<span class="built_in">set</span>(vars.<span class="built_in">begin</span>(), vars.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(parents.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        result.<span class="built_in">merge</span>(<span class="built_in">find_all_var</span>(parents));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_vars_size</span><span class="params">(<span class="keyword">const</span> string &amp;klass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find_all_var</span>(klass).<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读写成员变量"><a href="#读写成员变量" class="headerlink" title="读写成员变量"></a>读写成员变量</h1><h2 id="AST定义-1"><a href="#AST定义-1" class="headerlink" title="AST定义"></a>AST定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:name</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="variable">@name</span> = name</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="VM指令定义-1"><a href="#VM指令定义-1" class="headerlink" title="VM指令定义"></a>VM指令定义</h2><p>对应了读和写两条指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;GetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SetClassMemberVar</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:id</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;SetClassMemberVar <span class="subst">#&#123;id&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>id是用于标识是这个对象field域中的对象编号</p><p>我目前是通过固定一个变量在field中的位置来读写变量，这样其实没有任何灵活性可言，无法支持动态定义新的变量。想要更灵活那就得存一个hash用名字索引才行，ruby中是这样做的。我这里也没有太想好要怎么样做，只能先做着，可能做下去以后再看就会有来新的看法。</p><p>写博客的时候意识到了存在一个很大的bug，就是我没有处理继承成员时的id…所以说关于id的方面就不要作为参考实现了，写下来只是作为一个出错记录。</p><h2 id="翻译过程"><a href="#翻译过程" class="headerlink" title="翻译过程"></a>翻译过程</h2><p>常规的读会直接翻译成对应的vm指令，从class表中获取要读的这个对象的编号</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_get_class_member_var</span><span class="params">(node)</span></span></span><br><span class="line">  GetClassMemberVar.new(get_class_var(node))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_class_var</span><span class="params">(var_obj)</span></span></span><br><span class="line">  cur_class_table.instance_vars[var_obj.name]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于成员变量的赋值，则是在assign中，如果被赋值的对象是一个AST::GetClassMemberVar的话，则会转换成一个SetClassMember指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_assign</span><span class="params">(node)</span></span></span><br><span class="line">  value = visit(node.expr)</span><br><span class="line">  <span class="keyword">if</span> value.is_a? Value <span class="keyword">or</span> value.is_a? Ref</span><br><span class="line">    value = push(value)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">if</span> node.var_obj.is_a? Rc::AST::GetClassMemberVar</span><br><span class="line">    [value, SetClassMemberVar.new(get_class_var(node.var_obj))]</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    res = visit(node.var_obj)</span><br><span class="line">    [value, SetLocal.new(res.ref)]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="keyword">if</span> node.is_a? Value</span><br><span class="line">    Push.new(node.value)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? Ref</span><br><span class="line">    GetLocal.new(node.ref)</span><br><span class="line">  <span class="keyword">elsif</span> node.is_a? GetClassMemberVar</span><br><span class="line">    node</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    raise <span class="string">&quot;Unsupported node type <span class="subst">#&#123;node.<span class="keyword">class</span>&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而push也略有不同，函数的参数都是遍历然后对每一个进行push。在成员变量作为参数传入函数的时候，visit的结果则是一个GetClassMemberVar指令，因此需要添加对应的支持。</p><h2 id="VM实现"><a href="#VM实现" class="headerlink" title="VM实现"></a>VM实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> SetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    obj-&gt;<span class="built_in">set_value</span>(inst.id, _eval_stack.<span class="built_in">pop</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">const</span> GetClassMemberVar &amp;inst)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">this_ptr</span>();</span><br><span class="line">    _eval_stack.<span class="built_in">push</span>(obj-&gt;<span class="built_in">get_number_field</span>(inst.id));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set与get的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pointer</span><span class="params">(<span class="keyword">int</span> index, RcObject *value)</span> </span>&#123;</span><br><span class="line">    fields[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    fields[index] = <span class="keyword">reinterpret_cast</span>&lt;RcObject*&gt;(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RcObject *<span class="title">get_ptr_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fields[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int64_t</span> <span class="title">get_number_field</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">int64_t</span>&gt;(fields[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fields是<code>std::vector&lt;RcObject*&gt; fields</code> 用于保存所有的成员</p><p>由于stack中取出来的是值，那么我们直接将值转换为指针赋值给成员，如果成员确实是值，那么我们将成员转换为指针存储（这里是一个非常不安全的操作，也许应该添加检查）。取的时候再根据需要取出不同的值</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>多态以及接口这些，现阶段是不需要做的。因为目前偏向于鸭子类型，只要你有同名方法就OK，不需要走什么接口。等到后面加上了各种类型相关的操作再考虑引入这些东西</p><p>关于鸭子类型，wiki是这样写的</p><blockquote><p><strong>鸭子类型</strong>（英语：<strong>duck typing</strong>）在<a class="link"   href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" >程序设计<i class="fas fa-external-link-alt"></i></a>中是<a class="link"   href="https://zh.wikipedia.org/wiki/%E9%A1%9E%E5%9E%8B%E7%B3%BB%E7%B5%B1" >动态类型<i class="fas fa-external-link-alt"></i></a>的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前<a class="link"   href="https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%95_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)" >方法<i class="fas fa-external-link-alt"></i></a>和属性的集合”决定</p></blockquote><p>实现oop的时候许多地方已经开始和类型系统强相关了。现在许多语言中也可以兼顾动态类型，kotlin和C#都有类似于dynamic class的概念。现在先按照动态类型的实现来做，即便之后要全面切入到静态类型，这些依然可以作为动态类型的类的实现</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>很多地方都不知道该如何设计，同时也有应付了事的成分…目前的开发流程算是一次试水吧，后面的时候我会尽量克制应付了事的冲动，不仅是在代码上，做其他的事情我也是容易有相同的问题。昨天钢琴课老师也说，一定要先着重练好手型再去弹，速度多慢都不要紧，这另一种方面也是一种需要克制住“对手型应付了事”的冲动，克制住去做后面更有意思的事情的冲动。克制这件事不仅牵扯到能否做好，如果不克制可能还会浪费更多的时间，这对于时间本就不充足的我是一个很大的影响，在克制这方面我还是要多下功夫。</p><p>过一段时间可能会迁移到另一门语言上，那个时候可以从头梳理一遍目前所做过的决策，同时对好的进行保留，坏的进行剔除。前面的parser我觉得写的一塌糊涂，而且这几周的内容也能看出来很多地方开始乱搞了，都是没有决定好一个语言的方向，导致一个地方偏向这个样子，另一个地方又会偏向完全相反的样子。</p><p>要着重注意的是，重构是好的，但不要过于依赖重构来保证代码的好设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是做了一些继承相关的实现工作，把项目文件结构好好修了一波，还有就是加了一些测试。本周代码我觉得大多比较简单，很多地方就不过多赘述了。关于parser和ast在之前已经写好了，所以就直接进入代码生成和VM的部分&lt;/p&gt;
&lt;h1 id=&quot;类的符号信息&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记8 OOP之成员函数调用</title>
    <link href="https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/"/>
    <id>https://fusionbolt.github.io/2022/02/12/rc-lang-dev-8/</id>
    <published>2022-02-12T02:45:49.000Z</published>
    <updated>2022-02-12T03:47:10.851Z</updated>
    
    <content type="html"><![CDATA[<p>本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。</p><h1 id="成员函数调用的过程"><a href="#成员函数调用的过程" class="headerlink" title="成员函数调用的过程"></a>成员函数调用的过程</h1><p>我们先来想一下这个过程大致是怎样的</p><ol><li>被调用对象<br>非静态方法的时候首先成员函数要依赖于一个具体的对象，那么我们则需要在调用之前先将被调用对象的指针push到栈上</li><li>方法查找<br>根据对象的信息找到对应的类表，然后在类表中找到对应方法的地址（牵扯到继承的话也是在这里找父类的方法）</li></ol><h1 id="编译器的实现"><a href="#编译器的实现" class="headerlink" title="编译器的实现"></a>编译器的实现</h1><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>成员函数调用的AST是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMemberAccess</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:instance_name</span>, <span class="symbol">:member_name</span>, <span class="symbol">:args</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>其实这里当初设计想的是能够同时支持函数和成员变量的调用（也会加上无括号调用），但是我们现在认为它就是一个成员函数调用</p><h2 id="Translate"><a href="#Translate" class="headerlink" title="Translate"></a>Translate</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_class_member_access</span><span class="params">(access)</span></span></span><br><span class="line">  argc = access.args.size</span><br><span class="line">  push_this = <span class="keyword">if</span> access.instance_name == <span class="string">&quot;self&quot;</span></span><br><span class="line">    PushThis.new</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    push Ref.new cur_fun_env[access.instance_name].id</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  call = Call.new(access.member_name, argc)</span><br><span class="line">  [push_this] + access.args.map&#123; <span class="params">|arg|</span> push(visit(arg))&#125; + [call]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  [PushThis.new] + fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(fun_call.name, fun_call.args.size)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>再对比看一下旧的fun_call</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">  fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(<span class="variable">@cur_class_name</span>, fun_call.name)]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>没什么可讲的，非常直观</p><h1 id="VM的实现"><a href="#VM的实现" class="headerlink" title="VM的实现"></a>VM的实现</h1><h2 id="call的实现思路"><a href="#call的实现思路" class="headerlink" title="call的实现思路"></a>call的实现思路</h2><p>之前的call的参数是一个类和一个函数名，完全可以说是用于静态函数调用的做法。（关于静态函数调用的实现我们之后再考虑）</p><p>上面提到非静态方法需要依赖于具体对象，因此我们需要先将被调用对象的指针push到栈上。而类信息可以从对象上获取，因此不需要call参数中的类型名。而获取指针则需要知道有多少个参数，因此我们需要传递进去参数的数量。这个做法也可以处理变长参数的情况</p><p>传递参数数量在ruby中也是类似的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0004</span> opt_mult &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;[CcCr]</span><br></pre></td></tr></table></figure><p>写到这里的时候我突然想到了一个问题，为什么要先push被调用对象指针？顾思考了一下，如果在push完所有参数之后再push被调用对象指针则前面的参数无法直接作用于被调用函数中。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FunInfo &amp;<span class="title">method_search</span><span class="params">(<span class="keyword">const</span> RcObject * <span class="keyword">const</span> obj, <span class="keyword">const</span> std::string &amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> klass = obj-&gt;<span class="built_in">klass</span>();</span><br><span class="line">    <span class="keyword">if</span>(!global_class_table.<span class="built_in">contains</span>(klass) || !global_class_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function:&quot;</span> + f + <span class="string">&quot; Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> global_class_table[klass]._methods[f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f, <span class="keyword">size_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> *obj = _eval_stack.<span class="built_in">get_object</span>(argc);</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = <span class="built_in">method_search</span>(obj, f);</span><br><span class="line">    <span class="keyword">if</span>(fun.begin == UndefinedAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        fun.begin = <span class="built_in">load_method</span>(obj-&gt;<span class="built_in">klass</span>(), f, fun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc + <span class="number">1</span>, obj);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    <span class="built_in">set_pc</span>(fun.begin);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EXEC_LOG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; new PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc) + <span class="string">&quot; ret pc:&quot;</span></span><br><span class="line">        + std::<span class="built_in">to_string</span>(_eval_stack.<span class="built_in">current_frame</span>()-&gt;<span class="built_in">ret_addr</span>()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也很直观，先获取被调用对象，之后找到函数，开始处理调用栈，除了获取调用对象的部分和之前差不多。而栈帧会多保存一个当前的obj。在这里我新记录了调用栈的深度，便于调试</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">size_t</span> argc, <span class="keyword">size_t</span> locals, <span class="keyword">size_t</span> ret_addr, RcObject *this_ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.set stack base</span></span><br><span class="line">    <span class="keyword">auto</span> *base = <span class="built_in">get_args_begin</span>(argc);</span><br><span class="line">    <span class="comment">// 2.alloc local var space</span></span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(base, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(locals));</span><br><span class="line">    <span class="comment">// 3.create new stack frame</span></span><br><span class="line">    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr, this_ptr);</span><br><span class="line">    <span class="comment">// 4.increase depth</span></span><br><span class="line">    ++_depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于set_pc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_pc</span><span class="params">(<span class="keyword">size_t</span> new_pc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _pc = new_pc;</span><br><span class="line">    _pc_need_incr = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增了一个控制pc是否递增的成员，pc跳转的时候不应当继续递增pc，所以在各种跳转指令中都会直接使用set_pc</p><p>而递增的逻辑也相应的发生了变化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pc_increase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_pc_need_incr)</span><br><span class="line">    &#123;</span><br><span class="line">        ++_pc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        _pc_need_incr = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周做的内容不多，主要都是在做基础的成员调用相关工作（也只处理了成员函数，还没处理成员变量），然后就是修复一些问题添加了一些dump设施（目前做的并不好，等做好了可以单独拿一期讲一下），以及学习了解了一些其他语言相关的知识。&lt;/p&gt;
&lt;h1 id=&quot;成员函数调用的过程&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记7 GC也没有那么可怕 其一</title>
    <link href="https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/"/>
    <id>https://fusionbolt.github.io/2022/02/06/rc-lang-dev-7/</id>
    <published>2022-02-06T04:36:30.000Z</published>
    <updated>2022-02-12T03:46:28.889Z</updated>
    
    <content type="html"><![CDATA[<p>本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。</p><p>由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说，<del>可以等到下周养肥再一起看</del></p><p>本周从质和量来说都无法令人满意，状态比较差要写不下去了，但是起码比咕了强</p><h1 id="GC的对象表示"><a href="#GC的对象表示" class="headerlink" title="GC的对象表示"></a>GC的对象表示</h1><p>对象被保存在内存中，而对象则分为<strong>头</strong>和<strong>域</strong>两部分。</p><p>其中头被用于标识对象信息，比如说类型，以及gc的tag信息，利用tag信息来判断当前对象的状态</p><p>域则是能够被编程语言访问到的部分。域很显然可能是一个值，也可能是一个指向对象的指针</p><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>让我们看一下Ruby的RObject的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Basic part, including flags and class. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span> <span class="title">basic</span>;</span></span><br><span class="line">    <span class="comment">/** Object&#x27;s specific fields. */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> numiv;</span><br><span class="line">            VALUE *ivptr;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">st_table</span> *<span class="title">iv_index_tbl</span>;</span></span><br><span class="line">        &#125; heap;</span><br><span class="line">        VALUE ary[ROBJECT_EMBED_LEN_MAX];</span><br><span class="line">    &#125; as;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不需要关心过多的细节，可以看到很明显是分为了头和域两部分。</p><p>让我们再来看一下头部 RBasic</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct</span></span><br><span class="line"><span class="function"><span class="title">RUBY_ALIGNAS</span><span class="params">(SIZEOF_VALUE)</span></span></span><br><span class="line"><span class="function">RBasic </span>&#123;</span><br><span class="line">    VALUE flags;</span><br><span class="line">    <span class="keyword">const</span> VALUE klass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，一个标记和一个类信息。Ruby采用的也是标记算法，这里有flags保存标记信息</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>再来看一下Python的实现。这次我们从头部开始看起</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    _PyObject_HEAD_EXTRA</span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    PyTypeObject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><p>Object本质上是对象的头部信息。python是通过引用计数实现的GC，可以看到有一个ob_refcnt，同时还有一个保存Type的对象，</p><p>第一行的_PyObject_HEAD_EXTRA</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_TRACE_REFS</span></span><br><span class="line"><span class="comment">/* Define pointers to support a doubly-linked list of all live heap objects. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA            \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_next;           \</span></span><br><span class="line"><span class="meta">    struct _object *_ob_prev;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _PyObject_EXTRA_INIT 0, 0,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_HEAD_EXTRA</span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> _PyObject_EXTRA_INIT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看到这是为了方便测试以及跟踪执行情况而添加的内容</p><p>看一下Python的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject ob_base;</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure><p>其中的ob_size是用于可变长对象使用的，例如List</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Python是每个对象的头部有一个PyObject的指针，不同的类型是基于这个扩展的</p><p>而Ruby是每个对象是一个RObject，对象内部也有一个相同的头部RBasic，而不同的类型都是RObject本身</p><p>虽然实现的方式略有不同，但是本质上还是一样的。而对于GC的实现也是一样，所以我们之后只是大概提一下实现方式的本质</p><h1 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h1><p>在这里只简单谈及标记清除、引用计数以及复制，这三者是最基本的算法，改进版本暂且也不会提及，本周的内容的目的只是希望读者能够对GC有一些了解。其他算法都是从它们衍生出来的本质并没有发生变化（<del>其实主要是因为我只看了这三个</del>）</p><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除，我个人觉得用追溯更形象一些，因为需要从一些节点开始遍历访问所有的对象，对这些对象设置上tag，之后再对没有打上tag的对象进行回收</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在对象的头部设置一个字段用于标记有几个对象正在应用当前对象，在被创建的时候会设置标记为1，而被一个新的对象引用的时候计数就加1</p><p>当然这个做法存在一个很明显的问题，就是如果两个对象互相保存了对方的引用，那么就会造成循环引用的情况。C++的智能指针也是使用循环计数，因此依然会遇到这样的问题，而在C++中的解决方案是需要使用一个不获取对象所有权的weak_ptr来解决这个问题。</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>对于复制算法来讲，实际上将堆等分为两部分。一部分是正在使用的空间，另一部分是作为复制的临时空间。</p><p>复制算法将所有的活动对象从当前正在使用的空间复制到临时空间，之后直接将两块空间交换，也就是说没被复制的对象直接被销毁了</p><h1 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h1><p>垃圾回收的算法与实现</p><p>Python源码剖析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周的内容主要是写了一点点GC，同时做了一些对接GC的改动，之后接入了gtest开始测试。&lt;/p&gt;
&lt;p&gt;由于GC基本的功能还没写完（你这也太慢了），本周将着重介绍一下GC的原理 ，让读者对GC对一些概念之类有个大概的了解，实现的细节以及我在实现中遇到思考的问题留到下周再说</summary>
      
    
    
    
    <category term="GC" scheme="https://fusionbolt.github.io/categories/GC/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>AI Compiler是什么？</title>
    <link href="https://fusionbolt.github.io/2022/02/05/what-is-ai-compiler/"/>
    <id>https://fusionbolt.github.io/2022/02/05/what-is-ai-compiler/</id>
    <published>2022-02-05T02:38:18.000Z</published>
    <updated>2022-02-05T06:00:46.774Z</updated>
    
    <content type="html"><![CDATA[<p>为了让更多人对AI compiler有个了解，在此对这两者的区别和联系做一个科普，也因此本文以科普区别为主，不会深入。这篇文章一直想写，也算是对我去年工作中所学到的一部分东西的总结，但是硬是咕咕咕到了现在，最后选择了假期结束前把这一篇赶出来以提前适应上班状态，避免假期太强的假期综合症。个人水平有限，如有偏颇之处欢迎联系我指正</p><p>本文将从两方面讲述内容，首先是AI compiler是什么，都在做什么，其次是和传统compiler的异同。为了让读者能更好的理解内容，所需的背景知识我会尽可能的在文中做注解</p><h1 id="AI-compiler是做什么的"><a href="#AI-compiler是做什么的" class="headerlink" title="AI compiler是做什么的"></a>AI compiler是做什么的</h1><p>将各种框架训练产生的模型文件进行编译，生成目标平台的代码。从这个角度来看是和传统compiler是非常类似的，但是模型文件更像一个DSL（ldomain-specific language）</p><h1 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h1><p>先从解析输入开始，按照编译的流程来讲解各个阶段的异同。而这些异同大都是由于ai compiler输入的特殊性质导致的</p><h2 id="编译对象"><a href="#编译对象" class="headerlink" title="编译对象"></a>编译对象</h2><p>首先要编译的对象就有很大的不同。传统compiler则是编译的语言源代码，而AI compiler编译的是各种各样的模型，编译对象的不同导致了后面的各种处理大相径庭。</p><p>先来科普一下模型的组成：模型中包含了一个计算图以及各种数据，而计算图又是由许多算子构成的。每一个算子代表了一种计算</p><p>我个人觉得模型也可以算是一种DSL，从模型的输出向上看相当于一个expr，而每个op结点相当于一些特定函数。</p><h2 id="解析输入方式不同"><a href="#解析输入方式不同" class="headerlink" title="解析输入方式不同"></a>解析输入方式不同</h2><p>而传统语言源代码需要经过各种的parse，手写parser更是非常费力不讨好的一件事情，尽管现在的parser generator技术比较成熟，parser写起来依然是非常麻烦的。</p><p>对于AI compiler来说需要支持各种各样的模型的解析。这里不需要写什么复杂的parser了，像onnx会提供一个文件，可以通过protobuf解析这个文件生成对应的解析模型的源代码，直接调用生成的解析模型的源码中的函数即可。由于这个原因，你也不用担心不使用特定的语言进行编写还要自己做解析的工作，极端的讲，哪怕有一天要换语言做你也不需要担心解析的过程。在这个过程中更多的是将模型的数据取出来，放入设计好的IR中。</p><p>但是对于ai compiler来说你需要支持各种模型，如果只是支持某一种格式的模型是远远不会有用户的，这里不像传统compiler只需要支持自己语言的parser就可以了。目前主流的框架大致有三类，pytorch、onnx以及tensorflow，这三类有着各自的模型格式，而三者都有一定的用户群体，框架的支持程度对于用户来讲是一个非常关键的点。</p><h2 id="高层IR设计"><a href="#高层IR设计" class="headerlink" title="高层IR设计"></a>高层IR设计</h2><p>上面提到了ai compiler需要支持多种格式的模型，而不同格式模型的算子定义又是有许多差异。想要做到兼容各种格式的模型又是一个非常麻烦的问题，假设你设计了一套对应了算子的高层IR，可能需要对输入的模型中的算子前后添加一些操作，使其达到等效于你所选择的这个算子的实现。<br>用常规编程语言的例子就是C语言中要做到类似于成员函数调用通常会在这个函数的第一个成员传入结构体的指针。但是实际上麻烦的事情更多，很多算子甚至不能在不同框架转换，有的能转换也非常复杂，而关于这个问题本文就不深入探索了。</p><p>而传统编程语言的高层IR（通常为ast）相对简化很多，高层不需要考虑兼容与转换的问题。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>将输入读取进来后要做的事情当然是优化，编译器不仅要能够正确的生成对应平台的可执行代码，还要尽可能保证性能。</p><p>这个方面可讲的实在太多，不同层面的IR的优化方式又是各不相，而我所知的也比较有限（很多地方没有参与，但是有一些了解，我想做一个简单的科普还是不成问题），就挑ai编译器讲一下通常都有哪些方面的优化（简单提及概念），都是做什么用的，为什么要有这样的优化。</p><h3 id="图优化"><a href="#图优化" class="headerlink" title="图优化"></a>图优化</h3><ol><li>图节点合并：这个想法非常自然，只要减少了节点数量那么计算所需要的时间自然也会减少许多</li><li>更换顺序：有的时候更换节点顺序后一些节点就可以自然的合并</li><li>还有很多优化是基于算子自身定义的，这些在此就不提及了，本质上都是为了减少计算</li></ol><h3 id="fuse"><a href="#fuse" class="headerlink" title="fuse"></a>fuse</h3><p>将多个节点融合到一个子图中，直接影响到后面的tiling、调度、buffer分配，这是比较常见的一个步骤，因为本质上是为优化服务因此放到了这里。</p><h3 id="tiling-：数据切分与重排"><a href="#tiling-：数据切分与重排" class="headerlink" title="tiling ：数据切分与重排"></a>tiling ：数据切分与重排</h3><p>tiling这边我没有实际参与过，所以我只能大概讲一下在编译到ai加速器上的情况下我的理解。</p><p>对于ai加速器来说，通常只会适应某一些满足条件的数据大小的计算，而实际给加速器的数据大小则是各种各样的，因此需要将数据切分到适应加速器的结构。而大部分情况图上的每个节点所需要数据的大小则是已知的，因此可以提前切分好数据进行计算。（也有节点的数据大小不固定的情况，这里暂且不谈）</p><p>对于ai来说计算很多数据都是多维数组，而实际计算很多又是多层循环，常规的数据计算方式相对低效，而许多数据又是编译期间固定的，所以需要重新以一个高效的方式重排数据。</p><p>tiling这个过程可以说是对性能影响最大的部分之一，相信大部分人都看过那个经典的按行遍历与按列遍历二维数组的例子，不仅如此，还会牵扯到计算单元的利用率以及数据传输的带宽利用。</p><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>将计算图序列化，计算出一个合适的算子执行顺序</p><p>如果要涉及多设备还要尽可能做到多设备之间减少依赖，同时要考虑到数据在不同设备之间传输的带宽</p><h3 id="buffer分配"><a href="#buffer分配" class="headerlink" title="buffer分配"></a>buffer分配</h3><p>数据是通常以一个tensor为单位（最简单的说法tensor就是一个多维数组，但是这样并不确切，但是理解这里足以），而一个tensor通常存在一个buffer之中，运算的时候从buffer中取数据</p><p>通过合理的分配方式减少运算中内存的使用，其中牵扯到计算buffer的生命周期，什么时候可以及时释放掉这块buffer，什么时候可以重用已有的buffer等等</p><h2 id="生成代码与运行"><a href="#生成代码与运行" class="headerlink" title="生成代码与运行"></a>生成代码与运行</h2><p>在这方面其实都是差不多的，ai compiler还经常会生成一些ai加速器用的代码。对于ai加速器来说更多是几条配置指令加一条计算指令来执行特定的算子（上面提到的数据切分重排也和这个问题有非常大的联系）</p><p>关于生成产物的运行，和传统compiler相同也是有两类选择</p><ol><li>生成一个直接可以执行的程序</li><li>生成类似于字节码的东西供另一个运行时的程序读取并且执行</li></ol><h2 id="编译时间敏感度"><a href="#编译时间敏感度" class="headerlink" title="编译时间敏感度"></a>编译时间敏感度</h2><p>传统compiler还是对编译时间比较敏感的，因此导致了一些算法必须选择一个较好解，而最优解是需要很长时间的。</p><p>对于ai compiler编译时间的敏感程度相对较小，而且如果开启量化需要跑量化矫正集那根本无法控制时间（也因此需要高性能的evaluator）。而且对目标执行速度要求高，因此有更多的时间去搜索更好的解，<del>相对于炼丹来说这点时间洒洒水啦</del>。</p><h2 id="AI-compiler特有的部分"><a href="#AI-compiler特有的部分" class="headerlink" title="AI compiler特有的部分"></a>AI compiler特有的部分</h2><h3 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h3><p>这里的量化并不是指量化交易，而是指一种将浮点数转换为定点数的计算。在ai中通常使用float进行计算，为了缩小数据大小通常会将float量化到int8，而最后还会转换回float输出（这个则是反量化过程）。如果只是做常规的数据类型转换那一定会有很大的精度损失，因此需要各种量化的算法来尽可能减少这一影响。</p><p>而量化通常需要统计数值范围，并且使用这个范围来算出一个适当的量化参数，而这个范围我们需要通过在编译期间实际执行整个模型来得到，这个时候我们就需要一个evaluator来执行。</p><h3 id="evaluator与kernel"><a href="#evaluator与kernel" class="headerlink" title="evaluator与kernel"></a>evaluator与kernel</h3><p>我觉得这里可以视为以模型和参数作为输入的解释器，对于模型来说最小单位是一个算子，那么我们就需要添加每一个算子所对应的实现，又称为kernel。</p><p>而kernels的实现不仅要正确，还要尽可能的高效。原因有如下两条</p><ol><li>这直接影响到开启量化后的编译时间。</li><li>对于ai加速器来说只能够加速特定的算子，而其他算子依然会使用cpu来执行。cpu上的算子执行如果要利用这些kernels的话那它们的性能也是非常重要。</li></ol><p>关于第二条，这只是做法之一，实际上加速器加速不到的算子也有很多的实现方式，在这里只是提及有这种实现方式不进行评价好与坏，所以仅供参考。</p><h1 id="利用传统编译器的技术来做ai-compiler"><a href="#利用传统编译器的技术来做ai-compiler" class="headerlink" title="利用传统编译器的技术来做ai compiler"></a>利用传统编译器的技术来做ai compiler</h1><p>常量折叠、寄存器分配等技术都是可以从传统编译器来借鉴的。</p><p>一个非常典型的利用传统编译器技术的莫过于TVM（最有名的开源ai compiler）。其中的高层IR（Relay）直接利用了lambda calculus</p><blockquote><p>既然我们知道如何做control flow（lambda calculus），为啥不直接用<a class="link"   href="https://www.zhihu.com/search?q=lambda+calculus&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%22875630325%22%7D" >lambda calculus<i class="fas fa-external-link-alt"></i></a>当IR呢？这就是relay了。(当然，传统DL compiler能做的还是一样，但是没啥好讲的（maybe sized tensor？but sized tensor is boring））。<br>选取了lambda calculus为ir以后，由于这上面的研究很多，我们实现需求复杂的任务比其他框架简单得多 - 因为我们只需要照抄经典compiler算法。</p></blockquote><p>原文链接：<a class="link"   href="https://www.zhihu.com/question/331611341/answer/875630325" >https://www.zhihu.com/question/331611341/answer/875630325<i class="fas fa-external-link-alt"></i></a></p><p>不过只是这些当然还不够，需要探索更多专为ai相关的技术才能做好ai compiler。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>当了解了一些知识以后，就很难从一个完全不知道的视角去讲述了，所以写完本文我也难以把握哪里是相关知识较少的人看不明白的地方。读者如果能够通过本文了解ai compiler大致是什么样子的话那是再好不过了，如果读完本文对ai compiler产生了兴趣也欢迎进入这个行业和我一起摸爬滚打</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了让更多人对AI compiler有个了解，在此对这两者的区别和联系做一个科普，也因此本文以科普区别为主，不会深入。这篇文章一直想写，也算是对我去年工作中所学到的一部分东西的总结，但是硬是咕咕咕到了现在，最后选择了假期结束前把这一篇赶出来以提前适应上班状态，避免假期太强的</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="AI" scheme="https://fusionbolt.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>论柳比歇夫</title>
    <link href="https://fusionbolt.github.io/2022/02/04/Lyubishchev/"/>
    <id>https://fusionbolt.github.io/2022/02/04/Lyubishchev/</id>
    <published>2022-02-04T03:00:48.000Z</published>
    <updated>2022-02-04T03:51:45.395Z</updated>
    
    <content type="html"><![CDATA[<p>也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解</p><p>大部分人看到标题，一定只有一个问题：<strong>柳比歇夫是谁？</strong></p><p>他是一个大半生都在<strong>支配时间</strong>的人。我想你一定会对支配时间这个词摸不着头脑，还会有人在想时间面前人人平等，时间怎么可能被他支配？</p><p>那么我们先从他的成就谈起吧</p><h1 id="他的成就"><a href="#他的成就" class="headerlink" title="他的成就"></a>他的成就</h1><blockquote><p>前苏联的昆虫学家、哲学家、数学家。毕业于圣彼得堡国立大学，一生发布了70余部学术著作，从分散分析、生物分类学到昆虫学等。业余时间研究地蚤的分类，还写过不少科学回忆录。 各种各样的论文和专著，他一共写了五百多印张。五百印张，等于一万二千五百张打字稿。</p></blockquote><p>除了这些，数学、历史与诗歌他都十分擅长。毫无疑问，他是一个全才，并且在一生中做出了超乎想象的成就。他是怎么达到这样的成就的呢？</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>早在他28岁的时候他就已经找到了他一生的奋斗的目标：创造生物自然分类法。尽管遭受怀疑他依然开始着手他的任务，并且将一生投身到其中。</p><blockquote><p>他当然相信他能做到，但总是要从另外什么地方再去挖掘一些力量，再去挖掘一些时间。</p></blockquote><p><strong>而为了完成这一切，他选择了“支配时间”</strong></p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><p>完成事情需要时间，这是一个不可避免的内容。而对于时间的使用，很自然会想到利用好各种时间，他自然是做到了，将各种碎片时间利用到了极致。但只是利用碎片时间自然是不足以使他获得如此成就</p><blockquote><p>应当不断挖掘一切时间潜力。明摆着，人不能者是每天工作十四五个小时。应当正确利用工作时间。从时间中去找时间。</p></blockquote><p>接着他就开始了记录时间的生涯。他将自己做得<strong>几乎每件事情</strong>所需要的时间记录下来，进而达到能够<strong>十分清楚地了解自己做每件事情的时间</strong>，在了解自己的时间后进行十分周密的安排（注意，这是在他能够保证利用各种碎片时间的前提下）。</p><p>这些内容我觉得比起我来讲不如来看摘录的原文</p><blockquote><p>计划就是挑选时间、规定节律，使一切都各得其所。头脑清醒的时候应当钻研数学，累了便看书。</p></blockquote><blockquote><p>这个方法之所以能够存在，是依靠经常的计算和检查。没有计算的计划是盲目的计划，就象某些研究所那样，光会做计划，却不去操心这计划能不能完成。</p></blockquote><p>他对于时间的理解是非常深刻的。而最重要的则是他使用了一生来实践这样的方法。</p><p>了解时间记录法后我偶然想到在一本书中看到的话：不是要达到什么目标，而是要形成一个自己想要的系统，目标会自然而然达到。再看柳比歇夫的经历，亦是如此</p><p>而书中也有很多时间相关值得回味的内容，在这里摘录两段</p><blockquote><p>为了节约时间，实干家下了马车坐上火车，下了火车坐上飞机。发明了电报和电话来代替书信，电视代替了剧院，拉链代替了扣子，圆珠笔代替了鹅翎。电梯、计算机、百货公司、电传打字机、电动制刀——这一切发明，都是为了替人节省时间。然而，不知道为什么，人越来越感到时间不够用</p></blockquote><blockquote><p>时间的分配几乎同两千年以前赛纳卡时代一摸一样：“我们一生的时间，大部分用于错误及种种恶行；很大一部分虚抛浪掷，无所事事。我们整个一生，几乎都没有用来干应当干的事</p></blockquote><h1 id="代价与幸福"><a href="#代价与幸福" class="headerlink" title="代价与幸福"></a>代价与幸福</h1><p>可能很多人会觉得，这样机械式的生活真的快乐幸福吗？这里可以肯定的回答，至少对他来说是这样的。这里我有一个比较奇特的视角来讲，他清晰的明白自己的能力边界，因此他不需要担心时间不足或者担心自己做不到，他不需要焦虑在这种事情上，减少了焦虑并且能够更好的发挥自己的才能。</p><p>而在作者看来他亦是幸福的。在书的一开始，作者就提到</p><blockquote><p>我从中得到的一切，对于我来说，是一个新发现，使我参透了一个人一生的秘密。</p><p>这个秘密是——怎么生活得更好。</p></blockquote><p>但是这一切是有一个前提：他不断的给自己设定更高的要求，并且他有着源源不断的好奇心和求知欲，而这样做正是满足了他的欲望，因此这一切对他来说是十分幸福的。</p><p>在写下前面的部分，回顾文中的内容，在最后也看到了作者持有着同样的态度</p><blockquote><p>只有一个人向自己提出崇高目标时，这个时间统计法才能成立</p></blockquote><h1 id="能力边界与高要求"><a href="#能力边界与高要求" class="headerlink" title="能力边界与高要求"></a>能力边界与高要求</h1><p>他持续对自己高要求，并且在明确自己能力边界的情况下不断在边界中前进</p><blockquote><p> 他不让自己负担过重，力不胜任；他总是循着他能力的边缘前进，他对自己能力的掂量愈来愈精确。这是一条永不停顿的自我认识的道路”“如果每个人都能知道自己能干些什么，那生活会变得多么美好！因为每个人的能力都比他自己感觉到的大得多。他会变得比自己想象的更为勇敢；他会变得更坚韧、更有力，更能适应环境”</p></blockquote><p>还有一段我觉得是非常棒的描述</p><blockquote><p>对于柳比歇夫，任何时候都不能说他已“成为”怎样一个人。他永远正在“逐步成为”怎样一个人。他一直在探索，一直在变化，他总是重新考虑，不断提高对自己和对自己理想的要求</p></blockquote><h1 id="对知识的热爱以及偏离目标"><a href="#对知识的热爱以及偏离目标" class="headerlink" title="对知识的热爱以及偏离目标"></a>对知识的热爱以及偏离目标</h1><p>他学习知识，数学、历史、文学、音乐等等各种方面。</p><p>他不善于克制自己，经常迷上同他完全无关的东西中。他无法抗拒周围环境的诱惑，他无法抗拒那些知识。但是关于这些，作者给出了很明确的观点</p><blockquote><p>“天哪，对于嗜癖和精力分散我们又能知道些什么呢！谁能说清楚“人应当是怎么样的”。我们从何知道人应当是怎么样的呢”</p></blockquote><p>不过有一点要注意，不论怎么样<strong>他最后都能够确保任务的完成</strong>，这也和他对自己能力有着清晰的认识有关。</p><p>而“偏离目标”，也就是学习各种看似不相关的知识实际上也会产生一些意想不到的效果。达芬奇就是一个非常擅长将不同领域的知识融合在一起的人，他的许多创作都是如此。</p><h1 id="关于这本书"><a href="#关于这本书" class="headerlink" title="关于这本书"></a>关于这本书</h1><p>作者在本书的开头就在提到如何吸引读者这一件事情，而毋庸置疑的作者达到了他的目的，不像我后来看的达芬奇传（作者沃尔特 艾萨克森）真的是无聊至极。</p><p>正如作者所期望的那样，每读一点我就更加迫不及待的想要看到后面的内容，作者巧妙的描述出了一个饱满的柳比歇夫的形象。读完这本书后让我产生了更强烈的阅读其他传记的欲望，之后也就顺势读完了乔布斯传。</p><p>读这本书的过程中自己被柳比歇夫所吸引，也许这就是我所理想的样子。他对自我的要求、他的自由、他的幸福、他对自己的严格要求、他不断增长的边界，无一例外充满了魅力。在写到这一段的时候越写下去越发不可收拾，我着了迷、入了魔，那段时间读到相关的部分都会感到非常兴奋。</p><p>我希望这本书给别人的印象不仅仅是只有柳比歇夫的时间统计法，尽管是在读者的角度，我依然想要让其他阅读这本书的人更多的去体会、感受柳比歇夫的各种特质，而并非只是局限于时间统计法，时间统计法本质上是他的特质的衍生产物，是他为了完成自己的目的所选择的一条道路。</p><p>而完美的是作者也将这些特质巧妙的讲了出来，也没有花费太大篇幅去描述时间统计法。我最初也并不知道柳比歇夫是怎么样的人，但至少读完本书之后对他的形象有了一个饱满的认识，尽管这些只是局限于作者所描述的部分。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>整理这篇文章花费的时间比预想的还要多很多，整理的过程中几度想要放弃了，但是整理的时候多少又找回了一些热情，又回想起了很多，最后还是坚持了下来。请原谅我个人能力有限，文中内容简陋，而且内容有所遗忘，无法在这么短的篇幅中将他的魅力讲述到极致，只能提及部分性格特点，而书中所讲述的他更为有趣。<strong>如果你是对自己有要求的人，那么我非常推荐你去读这本书</strong>，去感受他的人生，感受他的精神，也许你会和我一样着迷。</p><p>虽然我做不到柳比歇夫的时间记录法，但是我可以学习他的高要求、不断在自己的边界进步、他对知识的热情，这些也足够我获得很大的成长了。我应该认真思考如何像他一样对自己不断的提出要求并且<strong>达到这些要求，而不只是空谈</strong>，写完这篇文章的今天我该拿出时间好好反思。</p><p>最开始写这些文字的内容是几个月前我刚读完这本书的时候，现在将其整理成文。开头一段现在回头看多少有点怪异，但我最后还是决定保留。不过不论如何，我现在依然很为能看到这本书并且了解这个人而感到幸运。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;也许有小部分人听说过时间记录法，因此也有幸听过柳比歇夫的名字；甚至可能会有那么零星几位十分幸运的人（至少在我看来是幸运的），读过《奇特的一生》这本书并且对他有了一些了解&lt;/p&gt;
&lt;p&gt;大部分人看到标题，一定只有一个问题：&lt;strong&gt;柳比歇夫是谁？&lt;/strong&gt;&lt;/p</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="柳比歇夫" scheme="https://fusionbolt.github.io/tags/%E6%9F%B3%E6%AF%94%E6%AD%87%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>iPhone Ultra Max(iPad mini)体验</title>
    <link href="https://fusionbolt.github.io/2022/01/30/iPadminiReview/"/>
    <id>https://fusionbolt.github.io/2022/01/30/iPadminiReview/</id>
    <published>2022-01-30T07:53:31.000Z</published>
    <updated>2022-01-30T08:25:39.898Z</updated>
    
    <content type="html"><![CDATA[<p>曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。<del>但iPad mini在我看来就是一个大号手机，某种意义上还是没错</del></p><p>iPad mini也已经入手有半个月了，半个月内重度使用，过了那阵新鲜劲以及各种问题踩坑也踩的差不多了，这个时候写下的体验我觉得应该是相对比较全面的了</p><h1 id="我的痛点"><a href="#我的痛点" class="headerlink" title="我的痛点"></a>我的痛点</h1><p>我觉得iPad mini解决了我目前使用手机的各种痛点。我的iPhone8plus目前有存储不够，电池容量太小，只能单卡而我自己的卡流量又不够。如果只是这些问题可能有人说换新机不就完美解决了？但是换新机也不能解决屏幕太小的问题，想看点文章或者需要跨app处理一些内容iPhone这么小的一个屏幕实在不方便</p><p>周末需要频繁挤地铁，地铁上的时间非常久，没有座位的时候拿iPad Pro非常不方便，即便有座位从包里拿出来也是很麻烦的事情，手机屏幕又太小，iPad mini的大小可以说是完美。</p><p>所以我实质上是将iPad mini当作我的新手机，我的iPhone8plus还能再战好多年。以下体验更多是从手机的视角来看待</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="iPhoneUltraMax.png"                      alt="image-20220130160002912"                ></p><h1 id="实际体验"><a href="#实际体验" class="headerlink" title="实际体验"></a>实际体验</h1><p>首先：不玩手游，所以并不会提到相关的内容，想看手游相关的建议你去看各种评测视频</p><p>重量感觉拿着没有任何压力，只比带着保护套的手机重了几十克。这个大小能够装到兜里，出门的时候看地图也非常方便。受益于大屏幕，看文章非常方便，不知道比iPhone高到哪里去了。</p><p>电量够我出门用一天，再也不用挂着移动电源到处走了。这是我某一周的使用情况，如果开了省电模式一天非常稳妥，更何况我出门的时候电只有80左右</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="battery.png"                      alt="IMG_2136"                ></p><p>出门在外，iPhone直接扔包里，有什么电话或者短信可以直接转接到iPad mini上</p><p>网上所说的什么果冻屏至少我没什么感知，尽管有这也是显示技术不可避免的问题，120刷新率对于iPad mini来说不太可能用上（而且绝大部分情况不需要刷那么快）这一点争议非常大，建议你去实体店体验一下</p><p>曾经我以为iPad正确的解释姿势就是Face ID，但直到出现了疫情…iPhone已经支持戴口罩解锁了，iPad pro什么时候才能用上？指纹解锁在现在这个到处需要戴口罩的情况下还是很棒的（但是我手指各种掉皮就还是白给</p><p>谈一点没什么关联的，直到我用上了iPad mini才发现iPad Pro是多么大，以及各方面是多么好……不论是扬声器还是屏幕刷新率，这些我之前都毫无感觉，真的是没有对比就没有伤害</p><h1 id="不可避免的问题"><a href="#不可避免的问题" class="headerlink" title="不可避免的问题"></a>不可避免的问题</h1><h2 id="极其多余且愚蠢的设计"><a href="#极其多余且愚蠢的设计" class="headerlink" title="极其多余且愚蠢的设计"></a>极其多余且愚蠢的设计</h2><p>这是我一定要着重说的一个问题。</p><p>所谓的智能音量键调整位置，我的感受就是多此一举，用了一周并没有觉得多么方便，反而每次调整音量不仅要想按哪里，在屏幕没锁定旋转的情况下大概率会按反。我听的不同来源的音频声音响度是不同的，如果忘了提前调整音量则需要快速反应按下减音量，而这种设计又会导致你大概率要先思考或者先按错一次才能按到正确的地方，对于耳朵损伤还是非常大的</p><p>因为有Touch ID，开屏的时候会提示按键位置在哪里，这个本身是好事，但是如果屏幕方向是竖直摆放这个提示则会导致无法看到电量，只是想打开屏幕看一下电量的时候非常难受</p><p>上面这两条，我开始怀疑苹果的人机交互工程师有没有真的自己用一下，一家曾经以设计闻名的公司（个人看法）额外添加的这些设计却反而添加了负面体验，这么大的公司应该有合理的流程避免一些问题，尤其是对于apple来说。但是这种不良设计依然出现了，不知道该怎么评价了</p><h2 id="大屏幕"><a href="#大屏幕" class="headerlink" title="大屏幕"></a>大屏幕</h2><p>大屏幕随之而来的就是你在看的东西更容易被其他人看到，对于非常重视隐私的人来说是灾难。另一个就是便携性不可避免的要下降一些，很多场景不能单手握持，但是只是读文章，单手下滑是没问题的，这是必须做出的取舍。还有就是我衣服兜比较浅，总觉得要掉（后来有一天不知道为什么过于大意，在同一个地方摔了两次….），装到裤子兜又麻烦，到了夏天衣物可能更难携带iPad mini</p><p>字体略小，将字体调到了最大还算可以接受（除了一些app字体并没有适配好）</p><p>到户外这个屏幕亮度不够用。这是我个人觉得最难受的</p><p>双手握持打字略微有些头重脚轻的感觉（竖屏），而且有一种要滑出去的趋势。以及键盘还不是完全一样的，需要一点时间适应。但对我来说键盘录入大量内容可能还是偏少数，更多的是用它去阅读</p><h2 id="OS与应用"><a href="#OS与应用" class="headerlink" title="OS与应用"></a>OS与应用</h2><p>iOS应用仍有一些不适配的情况，万幸的是可以手动放大到一个勉强能用的状态。但是更离谱的是支付宝只能登录一个设备，这产品经理是不是张小龙带出来的。当然这种环节不可避免要把微信拉出来挨打，目前iPad版和mac版是冲突的，干脆不用mac上的了，反正我的微信只用来联系家人。除此之外还有qq不能多个iPad上登陆，也有点小烦，等等还有很多类似的问题</p><p>还有一些并非适配问题而是不能用的，比如说健康和Apple Watch的管理，这些还是要依赖于iPhone。以及就是iPad OS诟病已久的没有天气和计算器。以及某些离谱的应用，比如说企业微信第一次登陆还要手机确认……</p><h2 id="代替手机"><a href="#代替手机" class="headerlink" title="代替手机"></a>代替手机</h2><p>由于不能打电话的硬伤，你并不能真的完全离开你的手机。尽管现在的人电话场景是“十个里面九个骚扰电话，还有一个是快递”</p><p>周末坐地铁的时候意识到不能刷nfc，突然想到还可以刷Apple Watch，但我戴在左手刷起来略显别扭。什么，你说扫码？</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="nfc.png"                      alt="telegram-cloud-photo-size-5-6278298406799650309-y"                ></p><h2 id="购买相关"><a href="#购买相关" class="headerlink" title="购买相关"></a>购买相关</h2><p>如果去官网购买，很可能需要等待两个月才能到货，这个着实比较离谱了，因此我选择了京东购入，也就错失了刻上iPhone Ultra Max的机会</p><p>本来想要购入一个紫色，但是去实体店查看跟示意图完全是两个样子…如果想要购入我建议你还是去实体店亲自看一下</p><h1 id="我会用它完全代替iPhone吗"><a href="#我会用它完全代替iPhone吗" class="headerlink" title="我会用它完全代替iPhone吗"></a>我会用它完全代替iPhone吗</h1><p>除了初拿到的欣喜，用了一段时间以后发现很多时候还是用手机方便，但是我依然没有后悔买了这个iPad mini，尽管在上面吐槽了它这么多问题，但我对它实在是非常满意（售价除外）。<strong>某种意义上可以说是因为没有竞争对手，我们只能忍受它的所有缺点</strong>。如果你有类似的需求，那非常推荐你。如果没有，那我还是推荐买大屏</p><p>最后加一个小技巧：如果你的iPhone像我一样只是需要维持最低限度功能，你可以在快捷指令里面设置自动化，当断开电源的时候自动开启低电量模式，平常充电超过80%IPhone会自动关闭低电量模式</p><p>本文绝大部分在地铁上一口气用iPad mini写完，再也不想用iPad mini打这么多字了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;曾经我以为，不考虑预算的情况下iPad就应该买最大屏幕的，直到那一天我将iPad mini放入了我的兜里。&lt;del&gt;但iPad mini在我看来就是一个大号手机，某种意义上还是没错&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;iPad mini也已经入手有半个月了，半个月内重度使用，过了那阵</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="iPadmini" scheme="https://fusionbolt.github.io/tags/iPadmini/"/>
    
    <category term="Apple" scheme="https://fusionbolt.github.io/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记6 OOP其二</title>
    <link href="https://fusionbolt.github.io/2022/01/30/rc-lang-dev-6/"/>
    <id>https://fusionbolt.github.io/2022/01/30/rc-lang-dev-6/</id>
    <published>2022-01-30T05:16:02.000Z</published>
    <updated>2022-01-30T05:16:35.440Z</updated>
    
    <content type="html"><![CDATA[<p>在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看</p><p>在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。</p><p>本周修改的主要方向：所有的函数操作都是基于一个类的（因此函数信息也都会放到类中）</p><p>在功能上要修改的有以下三个方面（测试这里暂且不谈）</p><ol><li>符号表分析</li><li>生成vm指令</li><li>VM运行时解析执行方式</li></ol><p>与此同时还更改了”链接”的方式，所有函数全部在第一次使用时动态加载</p><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>以前的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>, :<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">const_table</span>, :<span class="title">class_table</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看到将所有信息都集成到一个class_table符号表目前全部依靠一个class_table进行运作，目前的内容也很简单，只是保存instance methods和vars的信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span> = &#123;&#125;</span><br><span class="line">    <span class="variable">@instance_vars</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_method</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_var</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_vars</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种时候需要单独解释类型信息，这就是动态类型的头疼之处，想试试Scala，但是没时间学了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstanceMethodInfo</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define</span>, :<span class="title">env</span>, :<span class="title">args</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>define在符号分析的时候是ast的结点，而在后面翻译到vm指令的时候</p><p>相比之前取消了offset，因为全要等到运行时加载，这里的offset没有意义了</p><p>而env就是在global_env中被干掉的fun_env，参数信息没什么好说的，目前仅保存名字以及只用于统计数量</p><h2 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a>实际分析</h2><h3 id="class-table的初始化"><a href="#class-table的初始化" class="headerlink" title="class_table的初始化"></a>class_table的初始化</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">  <span class="variable">@define_env</span> = Env.new</span><br><span class="line">  init_class_table</span><br><span class="line">  <span class="variable">@const_table</span> = Set[]</span><br><span class="line">  <span class="variable">@cur_class_name</span> = Rc::Define::GlobalObject</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_class_table</span></span></span><br><span class="line">  <span class="variable">@class_table</span> = Env.new</span><br><span class="line">  <span class="variable">@class_table</span>.define_symbol(Rc::Define::GlobalObject, ClassTable.new)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Rc</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Define</span></span></span><br><span class="line">    GlobalObject = <span class="string">&#x27;Kernel&#x27;</span></span><br><span class="line">    UndefinedMethod = <span class="string">&#x27;Undefined&#x27;</span></span><br><span class="line">    ConstructorMethod = <span class="string">&#x27;initialize&#x27;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>塞进去一个默认的全局类，在vm执行的时候也会提到这里</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_class_define</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="comment"># save old</span></span><br><span class="line">  old_class_name = <span class="variable">@cur_class_name</span></span><br><span class="line">  <span class="comment"># make new and update</span></span><br><span class="line">  <span class="variable">@cur_class_name</span> = node.name</span><br><span class="line">  class_table = ClassTable.new</span><br><span class="line">  <span class="comment"># define before visit fun, because of this is a context used for visit fun</span></span><br><span class="line">  <span class="variable">@class_table</span>.define_symbol(node.name, class_table)</span><br><span class="line">  <span class="comment"># visit and add value to class_table</span></span><br><span class="line">  node.fun_list.each &#123;<span class="params">|f|</span> visit(f)&#125;</span><br><span class="line">  node.var_list.each &#123;<span class="params">|v|</span> class_table.add_instance_var(v.name, v.val)&#125;</span><br><span class="line">  <span class="comment"># restore name</span></span><br><span class="line">  <span class="variable">@cur_class_name</span> = old_class_name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>访问到类的时候创建一个类表，之后遍历visit成员的var和method，将这些信息添加到类表中</p><p>method是在visit的内部添加的，这里目前这样做是因为如果是Kernel的method，则不会经过on_class_define，这里应当在前面ast层面就做处理。先记下来以后来修改，目前比较想赶快赶工到能做GC的地方</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="variable">@define_env</span>.define_symbol(node.name, node)</span><br><span class="line">    <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">    <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">    <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">    visit(node.stmts)</span><br><span class="line">    <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line">  <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">  <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">  visit(node.stmts)</span><br><span class="line">  <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line">  cur_class.add_instance_method(node.name, InstanceMethodInfo.new(node, <span class="variable">@cur_fun_sym</span>, node.args))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>也没什么可说的，主要还是符号表存储方式的差别导致了这里信息存储的位置不同了</p><h1 id="vm代码生成"><a href="#vm代码生成" class="headerlink" title="vm代码生成"></a>vm代码生成</h1><h2 id="translate"><a href="#translate" class="headerlink" title="translate"></a>translate</h2><p>之前的实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(ast, global_env)</span></span></span><br><span class="line">  <span class="variable">@global_env</span> = global_env</span><br><span class="line">  inst = visit(ast).flatten.compact</span><br><span class="line">  inst.each_with_index <span class="keyword">do</span> <span class="params">|ins, index|</span></span><br><span class="line">    <span class="keyword">if</span> ins.is_a? FunLabel</span><br><span class="line">      <span class="variable">@global_env</span>.define_env[ins.name].offset = index</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="variable">@global_env</span>.define_env.reject! <span class="keyword">do</span> <span class="params">|name, table|</span></span><br><span class="line">    name.<span class="keyword">include</span>? <span class="string">&#x27;@&#x27;</span> <span class="keyword">or</span> table.is_a? Rc::AST::Function</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  inst</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在的实现</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(global_env)</span></span></span><br><span class="line">  global_env.class_table.update_values <span class="keyword">do</span> <span class="params">|class_name, table|</span></span><br><span class="line">    <span class="variable">@cur_class_name</span> = class_name</span><br><span class="line">    table.instance_methods.update_values <span class="keyword">do</span> <span class="params">|f_name, method_info|</span></span><br><span class="line">      <span class="variable">@cur_method_info</span> = method_info</span><br><span class="line">      method_info.define = visit(method_info.define).flatten.compact</span><br><span class="line">      method_info</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    table</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  global_env</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hash</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update_values</span><span class="params">(&amp;block)</span></span></span><br><span class="line">    each <span class="keyword">do</span> <span class="params">|key, value|</span></span><br><span class="line">      <span class="keyword">self</span>[key] = block.call(key, value)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>尽管都是以一个函数为单位进行visit，但是对于现在的实现来说更大的遍历单位是一个class</p><p>可以看到这里已经不再设置offset了，等到vm执行的时候再生成offset</p><h2 id="on-function"><a href="#on-function" class="headerlink" title="on function"></a>on function</h2><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun</span> = node.name</span><br><span class="line">  <span class="variable">@global_env</span>.define_env[node.name] = Rc::FunTable.new(cur_fun_env, node.args, <span class="string">&#x27;undefined&#x27;</span>)</span><br><span class="line">  [FunLabel.new(node.name), <span class="keyword">super</span>(node), Return.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@cur_fun</span> = node.name</span><br><span class="line">  [FunLabel.new(node.name), <span class="keyword">super</span>(node), Return.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>on_function只会在translate调用，只需要获取编译出的所有指令就可以了，关于表的更新都在translate中做</p><p>此外，获取当前函数的env要修改一下</p><p>之前</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cur_fun_env</span></span></span><br><span class="line">  <span class="variable">@global_env</span>.fun_env[<span class="variable">@cur_fun</span>]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>现在</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cur_fun_env</span></span></span><br><span class="line">  <span class="variable">@cur_method_info</span>.env</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>cur_method_info可以在前面的translate中看到不断的更新值</p><h2 id="dump信息"><a href="#dump信息" class="headerlink" title="dump信息"></a>dump信息</h2><p>目前全部dump到了一个文件中</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span></span></span><br><span class="line">    x + y</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  var a = <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span></span><br><span class="line">    var f = Foo.new()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="编译出的文件"><a href="#编译出的文件" class="headerlink" title="编译出的文件"></a>编译出的文件</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Kernel</span><br><span class="line"></span><br><span class="line">main <span class="number">0</span> <span class="number">1</span></span><br><span class="line">FunLabel main</span><br><span class="line">Alloc Foo</span><br><span class="line">Call Foo initialize</span><br><span class="line">SetLocal <span class="number">0</span></span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">Foo <span class="comment"># 类名</span></span><br><span class="line">a <span class="comment"># 成员变量</span></span><br><span class="line">initialize <span class="number">0</span> <span class="number">0</span> <span class="comment"># 成员函数名 args数量 local_var数量</span></span><br><span class="line">FunLabel initialize <span class="comment"># 函数定义</span></span><br><span class="line">Return</span><br><span class="line"></span><br><span class="line">add <span class="number">2</span> <span class="number">2</span></span><br><span class="line">FunLabel add</span><br><span class="line">GetLocal <span class="number">0</span></span><br><span class="line">GetLocal <span class="number">1</span></span><br><span class="line">Add</span><br><span class="line">Return</span><br></pre></td></tr></table></figure><p>FunLabel或许也可以删掉了，目前先这样留着吧，说不定debug会用得上</p><p>写到一半才意识到完全可以使用一些现有的格式来做到这件事情，但这也只是临时用的东西，最后一定会转成真正的字节码而不是这种dump，先这样吧，<del>大家千万不要跟我学坏</del></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>这个也没什么好讲的，并非重点，相比之前不同也是以类为一个单位。目前是都编译到了一个文件，目前这样就够用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_class_table</span><span class="params">(global_env)</span></span></span><br><span class="line">  global_env.class_table.map <span class="keyword">do</span> <span class="params">|class_name, table|</span></span><br><span class="line">    <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;class_name&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;table.instance_vars.keys.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&#x27; &#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;table.instance_methods.map &#123; <span class="params">|name, info|</span> gen_method(name, info) &#125;</span>.join(&quot;\n&quot;) &#125;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line">  <span class="keyword">end</span>.join(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_method</span><span class="params">(name, method_info)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;name&#125;</span> <span class="subst">#&#123;method_info.args.size&#125;</span> <span class="subst">#&#123;method_info.env.size&#125;</span> <span class="subst">#&#123;method_info.offset&#125;</span></span></span><br><span class="line"><span class="string"><span class="subst">#&#123;method_info.define.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&quot;\n&quot;</span>)&#125;</span></span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="VM"><a href="#VM" class="headerlink" title="VM"></a>VM</h1><h2 id="符号表-1"><a href="#符号表-1" class="headerlink" title="符号表"></a>符号表</h2><p>这里要和ruby的符号表一致。用两种语言做这种时候就很麻烦，要再做一份</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ClassInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::vector&lt;std::string&gt; _vars;</span><br><span class="line">    SymbolTable&lt;FunInfo&gt; _methods;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> argc;</span><br><span class="line">    <span class="keyword">size_t</span> locals;</span><br><span class="line">    <span class="keyword">size_t</span> begin;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;VMInst&gt;&gt; inst_list;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不过要注意FunInfo中这里要保存起始地址，因为装载以后就会有地址了，默认为0（不可能存在的地址，视为未链接）</p><h2 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h2><p>先这样凑合用好了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SymbolTable&lt;ClassInfo&gt; <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">f</span><span class="params">(_path)</span></span>;</span><br><span class="line">    std::string str;</span><br><span class="line">    SymbolTable&lt;ClassInfo&gt; class_table;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(f, str)) &#123;</span><br><span class="line">        <span class="comment">// 1. class name</span></span><br><span class="line">        <span class="keyword">auto</span> class_name = str;</span><br><span class="line">        <span class="comment">// 2. member vars</span></span><br><span class="line">        std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        <span class="keyword">auto</span> member_vars = <span class="built_in">split</span>(str);</span><br><span class="line">        <span class="comment">// 3. functions</span></span><br><span class="line">        std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        SymbolTable&lt;FunInfo&gt; fun_table;</span><br><span class="line">        <span class="keyword">while</span>(!str.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 3.1 info</span></span><br><span class="line">            <span class="keyword">auto</span> fun_info = <span class="built_in">split</span>(str);</span><br><span class="line">            <span class="keyword">auto</span> name = fun_info[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">auto</span> args = std::<span class="built_in">stoi</span>(fun_info[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">auto</span> local_vars = std::<span class="built_in">stoi</span>(fun_info[<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 3.2 add to class_table</span></span><br><span class="line">            fun_table.<span class="built_in">define</span>(name, <span class="built_in">FunInfo</span>(args, local_vars));</span><br><span class="line">            <span class="comment">// 3.3 define</span></span><br><span class="line">            std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">            <span class="keyword">auto</span> &amp;inst_list = fun_table[name].inst_list;</span><br><span class="line">            <span class="keyword">while</span>(std::<span class="built_in">getline</span>(f, str) &amp;&amp; !str.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> list = <span class="built_in">split</span>(str);</span><br><span class="line">                inst_list.<span class="built_in">push_back</span>(<span class="built_in">get_inst</span>(list));</span><br><span class="line">            &#125;</span><br><span class="line">            std::<span class="built_in">getline</span>(f, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ClassInfo <span class="title">class_info</span><span class="params">(member_vars, fun_table)</span></span>;</span><br><span class="line">        class_table.<span class="built_in">define</span>(class_name, class_info);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> class_table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>由于增加了类相关的内容以及“动态链接”，这里的变化会大得多</p><p>之前</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_sym_table.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// todo: find definition</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function&quot;</span> + f + <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = _sym_table[f];</span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    _pc = fun.begin;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">const</span> std::string&amp; klass, <span class="keyword">const</span> std::string&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_sym_table.<span class="built_in">contains</span>(klass) || !_sym_table[klass]._methods.<span class="built_in">contains</span>(f))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Target Function&quot;</span> + f + <span class="string">&quot;Not Found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> &amp;fun = _sym_table[klass]._methods[f];</span><br><span class="line">    <span class="keyword">if</span>(fun.begin == UndefinedAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        fun.begin = <span class="built_in">load_method</span>(fun);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. stack process</span></span><br><span class="line">    _eval_stack.<span class="built_in">begin_call</span>(fun.argc, fun.locals, _pc);</span><br><span class="line">    <span class="comment">// 2. set pc</span></span><br><span class="line">    _pc = fun.begin;</span><br><span class="line">    <span class="built_in">LOG_DEBUG</span>(<span class="string">&quot;Call &quot;</span> + f + <span class="string">&quot; PC:&quot;</span> + std::<span class="built_in">to_string</span>(_pc))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变化主要有两个</p><ol><li>查找被调用函数的方式，需要先查找类表再从中查找到对应函数信息</li><li>加载</li></ol><p>关于加载的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">load_method</span><span class="params">(<span class="keyword">const</span> FunInfo&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. get start</span></span><br><span class="line">    <span class="keyword">auto</span> start = std::max&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(_inst_list.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 2. load inst to inst_list</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;&amp;inst : f.inst_list)</span><br><span class="line">    &#123;</span><br><span class="line">        _inst_list.<span class="built_in">push_back</span>(inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前的需求来说这些就足够了，因为目前没有牵扯到一些相对寻址的指令。之后加到那些指令的时候再来更新</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>里面目前就这么一行代码，其实也没有太大变化，只是入口需要指定类了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">begin_call</span>(VMGlobalClass, VMEntryFun);</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>正式开始构造对象以及调用构造函数要等到GC弄出来再写了（尽管编译器这边已经做了，但是VM不做出对应功能毫无意义）。下个周不出意外的话应该要开GC的坑了，尽管放假了，但依然有一堆事情要处理，就像写博客回顾、重构代码一样，我的生活也需要做一些打扫与清理，还有一些需要学习的新知识，所以大概率还是会维持平常的进度。不寻求太大的变化，能维持这样的进度我觉得也不错。</p><p>我觉得这种对比修改前后代码的方式还挺不错的，以后如果再涉及到修改已有设计的地方都会再加一些。</p><p>最近有些疏于测试了..尤其是VM代码一点都没有，下次一定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一周的内容中，我们大概介绍了整个流程，以及少数的实现。本周的内容则是聚焦于实现，建议和上周的内容一起来看&lt;/p&gt;
&lt;p&gt;在之前的代码中内容都是偏向于无对象的结构，因此要先改正为适合面向对象的结构。&lt;/p&gt;
&lt;p&gt;本周修改的主要方向：所有的函数操作都是基于一个类的（因此函</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记5 函数其二&amp;OOP其一</title>
    <link href="https://fusionbolt.github.io/2022/01/23/rc-lang-dev-5/"/>
    <id>https://fusionbolt.github.io/2022/01/23/rc-lang-dev-5/</id>
    <published>2022-01-23T03:28:49.000Z</published>
    <updated>2022-01-30T05:15:56.660Z</updated>
    
    <content type="html"><![CDATA[<p>本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽</p><p>那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。</p><h1 id="函数在VM的实现"><a href="#函数在VM的实现" class="headerlink" title="函数在VM的实现"></a>函数在VM的实现</h1><h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><p>之前没有提及函数相关的内容在vm是怎么实现的，所以这里首先提及这个话题</p><p>函数的实现无外乎就是调用与返回的情况，这里再多加一个关于getlocal和setlocal以及计算的实现部分。</p><p>先来简单回顾一下我们的栈上的信息</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">--------------------</span><br><span class="line">       tmp var</span><br><span class="line">--------------------</span><br><span class="line">      local var           f1</span><br><span class="line">-------------------- </span><br><span class="line">        args</span><br><span class="line">--------------------  ----------------</span><br><span class="line">       tmp var</span><br><span class="line">--------------------</span><br><span class="line">      local var           main</span><br><span class="line">-------------------- </span><br><span class="line">        args</span><br><span class="line">--------------------</span><br></pre></td></tr></table></figure><p>除了这些再来看一下我们的栈帧</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackFrame</span></span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;StackFrame&gt; _prev;</span><br><span class="line">    char *_base;</span><br><span class="line">    size_t _ret_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于这些成员都是因为什么需要增加的，请回顾上期内容</p><p><a class="link"   href="https://homura.live/2022/01/16/rc-lang-dev-4/" >Rc-lang开发周记4 函数其一 | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ol><li><p>去符号表找符号</p><p>这一步在vm中处理，找到符号的话将信息传递给栈来做第二步</p></li><li><p>栈处理</p></li><li><p>更新pc</p></li></ol><p>着重讲一下栈的处理</p><ol><li><p>设置当前栈帧基址</p><p>由于目前参数是在call之前push的（这个push一定紧接着call），因此需要先将stack_top指针移动到第0个参数的位置，得出基址</p></li><li><p>分配局部变量空间</p><p>根据局部变量的数量再将栈基址向上移动</p></li><li><p>创建新的栈帧</p></li></ol><p>实现代码，都在eval_stack.h中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">begin_call</span><span class="params">(<span class="keyword">size_t</span> argc, <span class="keyword">size_t</span> locals, <span class="keyword">size_t</span> ret_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1.set stack base</span></span><br><span class="line">    <span class="keyword">auto</span> *base = <span class="built_in">get_args_begin</span>(argc);</span><br><span class="line">    <span class="comment">// 2.alloc local var space</span></span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(base, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(locals));</span><br><span class="line">    <span class="comment">// 3.create new stack frame</span></span><br><span class="line">    _frame = std::make_shared&lt;StackFrame&gt;(_frame, base, ret_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_args_begin</span><span class="params">(<span class="keyword">size_t</span> argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _stack_top - argc * WordLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">stack_move</span><span class="params">(<span class="keyword">char</span> *stack_pos, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> stack_pos + offset * WordLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于WordLength</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">size_t</span> WordLength = <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><ol><li><p>获取返回值</p><p>由于在函数体内计算的时候最后会将返回值push到栈顶，那么这里需要先pop将值取出来</p></li><li><p>栈帧回退</p></li><li><p>重置pc</p></li><li><p>返回值放到栈顶</p></li></ol><p>这个返回值有点折腾…目前就先这个样子</p><p>这里也是着重讲一下栈帧回退</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">end_call</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret_addr = _frame-&gt;<span class="built_in">ret_addr</span>();</span><br><span class="line">    _stack_top = <span class="built_in">stack_move</span>(_frame-&gt;<span class="built_in">base</span>(), <span class="number">-1</span>);</span><br><span class="line">    _frame = _frame-&gt;<span class="built_in">prev</span>();</span><br><span class="line">    <span class="keyword">return</span> ret_addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getlocal-setlocal"><a href="#getlocal-setlocal" class="headerlink" title="getlocal/setlocal"></a>getlocal/setlocal</h3><p>就是简单的从当前栈基址添加偏移量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_local</span><span class="params">(<span class="keyword">size_t</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="built_in">get_base_offset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(offset));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_local</span><span class="params">(<span class="keyword">size_t</span> offset, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *<span class="built_in">get_base_offset</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(offset)) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_base_offset</span><span class="params">(<span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_offset_pos</span>(_frame-&gt;<span class="built_in">base</span>(), offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exec</span><span class="params">(Callable &amp;&amp;f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> new_v = <span class="built_in">f</span>(<span class="built_in">pop</span>(), <span class="built_in">pop</span>());</span><br><span class="line">    <span class="built_in">push</span>(new_v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数最基本的功能完成了，那我们该做创建对象相关的部分了。</p><h1 id="从常见的类开始"><a href="#从常见的类开始" class="headerlink" title="从常见的类开始"></a>从常见的类开始</h1><p>我们从一个常见的类的例子开始引入我们的问题</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(a)</span></span></span><br><span class="line">    <span class="variable">@a</span> = a</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(b)</span></span></span><br><span class="line"><span class="variable">@a</span> + b</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个类很简单，一个成员变量、一个构造函数和一个实例方法。</p><p>在我们想要使用这个类之前，我们需要在编译期间先解析这个类的信息</p><h2 id="解析成员"><a href="#解析成员" class="headerlink" title="解析成员"></a>解析成员</h2><p>创建一个类表。保存了所有定义的类的定义，以及可以作为一个类型查询表。</p><p>这个解析的过程一度想要直接从Ruby抄一套类似的，但是工作量会非常大，因为需要到基类查找方法，牵扯到继承等各种问题</p><p>目前类的ast结构</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDefine</span></span></span><br><span class="line"><span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:define</span>, <span class="symbol">:parent</span>, <span class="symbol">:fun_list</span>, <span class="symbol">:var_list</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个定义中define是之前做的对于现在来说是不必要的内容，但是我目前时间有限不太敢动，怕前面的东西都乱套了，留个todo再说。parent是因为之前ast解释器的部分做了继承，但是目前vm这边还没有开始做，也就先不管它</p><p>对于成员函数全部翻译一遍，重命名一下符号，而对于成员变量，直接将信息添加到对应的表中即可。所以目前ClassTable是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassTable</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:instance_methods</span>, <span class="symbol">:instance_vars</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span> = &#123;&#125;</span><br><span class="line">    <span class="variable">@instance_vars</span> = &#123;&#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_method</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_methods</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add_instance_var</span><span class="params">(name, define)</span></span></span><br><span class="line">    <span class="variable">@instance_vars</span>[name] = define</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>除了解析信息，还需要在运行的时候创建这个类的对象。创建对象则分为两步</p><ol><li>分配内存</li><li>初始化</li></ol><h2 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h2><p>关于分配内存我们需要知道</p><ol><li>为了知道所分配空间的大小，首先需要获取类型信息。那么该如何获取类型信息以及类型信息怎么存放，存在哪里</li></ol><p>目前不考虑元编程的地方，所以这些信息都是编译期间可知的。假设要做更多元编程的内容，那么需要将一部分的内容放到运行时处理。按照我的理解来说，到时候将类型信息传递给vm，以及添加一些指令专门用于做元编程（这样指令种类会增加很多）。但这仅限于我粗浅的理解，更详细的还是要等到我做的时候再考虑。</p><ol><li>如何计算空间大小</li></ol><p>这个时候可能会出现一个最简单不过的想法，直接将所有成员大小都加起来不就好了。但是如果这样做，地址无法对齐，在vm那边取是很麻烦的事情。关于对齐暂时也不考虑，目前只考虑数据全为一个字长的整型数字，因此产生的对象也只会有带有这样成员的数字。还有会遇到空对象的情况，没有任何成员函数该怎么办（关于空对象，下文会单独提一下）</p><p>除了基本的空间大小，还需要考虑留有GC信息的头部。这个就牵扯到下一个问题</p><ol><li>数据保存的格式</li></ol><p>GC需要保存哪些对象信息，这些信息又是如何保存的。关于这一点在后面的Ruby的Object实现中会略微提及</p><p>GC相关的更多内容要等到之后实现的时候再更详细的提及了</p><p>关于这里实际上还有更多复杂的话题，比如说递归数据类型，Union等，这些也都以后做的时候再来讨论</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>这里涉及到了一个问题，一个最简单的Foo对象并没有构造函数，那么我们需要先在ast的阶段生成对应的“无参”构造函数。</p><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>调用这里本质上是一个方法查找机制，目前想先做最简单的，后面按需添加。直接去对应的this指针，找到对应类的信息，然后再从类表中进行查找，还没做实现，大概会到下周的内容中</p><p>同时这个方法也是作为一个成员函数被调用（尽管是外部不可见的），这里就顺便讲调用成员函数的做法</p><p>首先考虑调用成员函数的时候就需要引入this指针了，这个属于固定在栈内的内容，所以我把它放到了栈帧的结构中，而不是栈的实际数据中。</p><h3 id="一些语言this相关"><a href="#一些语言this相关" class="headerlink" title="一些语言this相关"></a>一些语言this相关</h3><p>说到this指针，我想到了两个语言</p><p>第一个是Python，因为Python是需要显式传递self的</p><p>另一个是C#，C#的extension机制大概是这个样子，通过这种方式来给某个类添加类函数，我没有深究过后面的实现机制，但我想大概是解析到这里就给符号表中的这个类添加一个成员函数吧</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SomeClassExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span>(<span class="params"><span class="keyword">this</span> SomeClass instance, args</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>Ruby本身也有一些相似的对象，定义类函数的时候会需要self。不过这里的self的含义变成了这个类，而不是某个实例成员</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line">def <span class="keyword">self</span>.f</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h1><h2 id="无成员变量类"><a href="#无成员变量类" class="headerlink" title="无成员变量类"></a>无成员变量类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Helper</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span></span></span><br><span class="line">    a + b</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种情况最大的问题在于对象空间大小的问题。目前我已知的做法有如下几种</p><p>C++中对于类似的类在实例化的时候会有一个一字节的空间占用，为的是区分地址</p><p>而Rust则有一个叫ZeroSizedTypes的东东，在谷歌搜索的时候搜索到了这样一段代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::mem::size_of;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">main</span></span>() &#123;</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, size_of::&lt;()&gt;());</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, size_of::&lt;[(); <span class="number">100</span>]&gt;());</span><br><span class="line">   <span class="keyword">let</span> boxed_unit = <span class="built_in">Box</span>::new(());</span><br><span class="line">   <span class="built_in">println!</span>(<span class="string">&quot;&#123;:p&#125;&quot;</span>, boxed_unit); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：zqliang</span><br><span class="line">链接：https:<span class="comment">//ld246.com/article/1539826769170</span></span><br><span class="line">来源：链滴</span><br><span class="line">协议：CC BY-SA <span class="number">4.0</span> https:<span class="comment">//creativecommons.org/licenses/by-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0x1</span></span><br></pre></td></tr></table></figure><p>可以看到Rust不像C++一样会有一字节的空间占用</p><p>带有GC的语言通常是会有一个header的开销（header用于存储类型以及GC信息），成员域部分会因实际实现不同而不同</p><p>对于Ruby来说Object是这个样子的。因此对象即便为空也会有下面这个union的开销</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RObject</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBasic</span></span> basic;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> </span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125; heap; <span class="comment">//省略</span></span><br><span class="line">        Value ary[ROBJECT_EMBED_LEN_MAX];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ruby的类与函数"><a href="#Ruby的类与函数" class="headerlink" title="Ruby的类与函数"></a>Ruby的类与函数</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">m = <span class="number">1</span></span><br><span class="line">a = S.new()</span><br></pre></td></tr></table></figure><h2 id="成员函数和“普通函数”"><a href="#成员函数和“普通函数”" class="headerlink" title="成员函数和“普通函数”"></a>成员函数和“普通函数”</h2><h3 id="定义对比"><a href="#定义对比" class="headerlink" title="定义对比"></a>定义对比</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f1@&lt;compiled&gt;<span class="symbol">:</span><span class="number">1</span> (<span class="number">1</span>,<span class="number">0</span>)-(<span class="number">3</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (   <span class="number">2</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (   <span class="number">3</span>)[Re]</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:initialize@&lt;compiled&gt;<span class="symbol">:</span><span class="number">5</span> (<span class="number">5</span>,<span class="number">2</span>)-(<span class="number">7</span>,<span class="number">5</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (   <span class="number">6</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (   <span class="number">7</span>)[Re]</span><br></pre></td></tr></table></figure><p>可以看到编译出的函数没什么不同。我想这是因为Ruby的一切皆对象的缘故。哪怕只是一个单独的函数，也是定义在Kernel中，本质上还是一个成员函数。</p><p>而这个initialize也是和普通的成员函数是一致的，特别之处只是会在Object的new中被调用，甚至和普通成员函数一样可以被外部调用</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f1@&lt;compiled&gt;<span class="symbol">:</span><span class="number">9</span> (<span class="number">9</span>,<span class="number">2</span>)-(<span class="number">11</span>,<span class="number">5</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">9</span>                         (  <span class="number">10</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> leave                                                            (  <span class="number">11</span>)[Re]</span><br></pre></td></tr></table></figure><h3 id="调用方式"><a href="#调用方式" class="headerlink" title="调用方式"></a>调用方式</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0011</span> putself                                                          (   <span class="number">9</span>)[Li]</span><br><span class="line"><span class="number">0012</span> opt_send_without_block                 &lt;calldata!<span class="symbol">mid:</span>f1, <span class="symbol">argc:</span><span class="number">0</span>, FCALL<span class="params">|VCALL|</span>ARGS_SIMPLE&gt;</span><br></pre></td></tr></table></figure><h2 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0003</span> putspecialobject                       <span class="number">3</span>                         (   <span class="number">3</span>)[Li]</span><br><span class="line"><span class="number">0005</span> putnil</span><br><span class="line"><span class="number">0006</span> defineclass                            <span class="symbol">:S</span>, &lt;<span class="class"><span class="keyword">class</span>:<span class="title">S</span>&gt;, 0</span></span><br><span class="line"><span class="number">0010</span> pop</span><br></pre></td></tr></table></figure><p>这里可以看到，Ruby中类也是和method一样是通过特殊的vm指令进行动态定义的</p><p>编译出的类定义的内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:&lt;class:S&gt;@&lt;compiled&gt;<span class="symbol">:</span><span class="number">4</span> (<span class="number">4</span>,<span class="number">0</span>)-(<span class="number">12</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line"><span class="number">0000</span> definemethod                           <span class="symbol">:initialize</span>, initialize   (   <span class="number">5</span>)[LiCl]</span><br><span class="line"><span class="number">0003</span> definemethod                           <span class="symbol">:f1</span>, f1                   (   <span class="number">9</span>)[Li]</span><br><span class="line"><span class="number">0006</span> putobject                              <span class="symbol">:f1</span></span><br><span class="line">0008 leave</span><br></pre></td></tr></table></figure><h2 id="调用构造函数的全部流程流程"><a href="#调用构造函数的全部流程流程" class="headerlink" title="调用构造函数的全部流程流程"></a>调用构造函数的全部流程流程</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0016</span> opt_getinlinecache                     <span class="number">25</span>, &lt;<span class="symbol">is:</span><span class="number">0</span>&gt;                (   <span class="number">9</span>)[Li]</span><br><span class="line">0019 putobject                              <span class="literal">true</span></span><br><span class="line"><span class="number">0021</span> getconstant                            <span class="symbol">:S</span></span><br><span class="line"><span class="number">0023</span> opt_setinlinecache                     &lt;<span class="symbol">is:</span><span class="number">0</span>&gt;</span><br><span class="line"><span class="number">0025</span> opt_send_without_block                 &lt;calldata!<span class="symbol">mid:</span>new, <span class="symbol">argc:</span><span class="number">0</span>, ARGS_SIMPLE&gt;</span><br><span class="line"><span class="number">0027</span> dup</span><br><span class="line">0028 setlocal_WC_0                          a@<span class="number">1</span></span><br></pre></td></tr></table></figure><p>除去前面的优化和后面的赋值操作，可以发现new对象的时候实际调用还是在new上而不是所谓的构造函数。可以从这里一定程度的看到Ruby创建对象的实现：Ruby在创建对象的时候是会先调用隐含的new函数（继承自Object），而这个new函数的默认实现会调用allocate，之后调用对应的initialize方法，最后再将new出来的对象返回。关于这个知识点在之前做TypeStruct的时候也提及过，有兴趣的可以去看一下</p><p><a class="link"   href="https://homura.live/2022/01/09/rc-lang-dev-3/" >Rc-lang开发周记3 生成C++代码 | Homura’s Blog<i class="fas fa-external-link-alt"></i></a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>Ruby原理剖析</p><p>垃圾回收的算法与实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周要做的第一件事情当然是把之前写的脏代码全部干掉！神清气爽&lt;/p&gt;
&lt;p&gt;那么就让我们进入本周的正题。最近几周的代码可能会较少而且内容非常碎片，时间短缺且这块内容跨度非常大，需要参考其他已有实现，再加上第一次做并不熟悉正处于开荒期，更多的是学习于思考相关的知识。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记4 函数其一</title>
    <link href="https://fusionbolt.github.io/2022/01/16/rc-lang-dev-4/"/>
    <id>https://fusionbolt.github.io/2022/01/16/rc-lang-dev-4/</id>
    <published>2022-01-16T09:03:13.000Z</published>
    <updated>2022-01-30T05:15:56.660Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。</p><h1 id="函数解析方式"><a href="#函数解析方式" class="headerlink" title="函数解析方式"></a>函数解析方式</h1><p>这里我一开始没想好怎么做的，所以会做的很诡异，最大的原因是静态类型语言和动态类型语言是不同的。由于我只对动态语言有一些了解，这里暂时只提动态语言的一些点</p><h2 id="动态语言"><a href="#动态语言" class="headerlink" title="动态语言"></a>动态语言</h2><p>手头动态类型语言的资料是相对较多的，而实际看编译出的产物也是相对熟悉一些。</p><p>对于Ruby和Python来说，函数都是动态定义的。因此解析到一个函数的时候会产生一个定义函数的指令</p><p>Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span> definemethod     <span class="symbol">:foo</span>, foo      (   <span class="number">1</span>)[Li]</span><br></pre></td></tr></table></figure><p>（后面的1是行号）</p><p>Python</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span>:</span><br><span class="line"><span class="number">0</span> LOAD_CONST    <span class="number">0</span> (code object f)</span><br><span class="line"><span class="number">3</span> MAKE_FUNCTION <span class="number">0</span></span><br><span class="line"><span class="number">6</span> STORE_NAME    <span class="number">0</span> (f)</span><br></pre></td></tr></table></figure><p>而函数本体内容则是创建了一个函数对象并放到了其他的位置，以及地址是重新从0开始的。这个地址应该是相对地址，因为会动态装载</p><p>这两个的源代码不一样的，只是想展示地址都是从0开始。dump出来的内容差异也比较大</p><p>Ruby</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line"> a = <span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:foo@&lt;compiled&gt;<span class="symbol">:</span><span class="number">9</span> (<span class="number">9</span>,<span class="number">0</span>)-(<span class="number">11</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line">local table (<span class="symbol">size:</span> <span class="number">1</span>, <span class="symbol">argc:</span> <span class="number">0</span> [<span class="symbol">opts:</span> <span class="number">0</span>, <span class="symbol">rest:</span> -<span class="number">1</span>, <span class="symbol">post:</span> <span class="number">0</span>, <span class="symbol">block:</span> -<span class="number">1</span>, <span class="symbol">kw:</span> -<span class="number">1</span>@-<span class="number">1</span>, <span class="symbol">kwrest:</span> -<span class="number">1</span>])</span><br><span class="line">[ <span class="number">1</span>] a<span class="variable">@0</span></span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">3</span>                         (  <span class="number">10</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> putobject                              <span class="number">2</span></span><br><span class="line"><span class="number">0004</span> opt_mult                               &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;[CcCr]</span><br><span class="line"><span class="number">0006</span> dup</span><br><span class="line"><span class="number">0007</span> setlocal_WC_0                          a<span class="variable">@0</span></span><br><span class="line">0009 leave</span><br></pre></td></tr></table></figure><p>Python（函数体被编译成的内容</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span></span>:</span><br><span class="line">print(<span class="string">&quot;Function&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> LOAD_CONST <span class="number">1</span> (“Function”)</span><br><span class="line"><span class="number">3</span> PRINT_ITEM</span><br><span class="line"><span class="number">4</span> PRINT_NEWLINE</span><br><span class="line"><span class="number">5</span> LOAD_CONST <span class="number">0</span> (None)</span><br><span class="line"><span class="number">8</span> RETURN_VALUE</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>一开始是想仿照做一个动态的实现，但是后来觉得还是静态的好，导致产生了如下的代码。</p><p>对于一个函数，我生成了一个DefineFun。FunLabel是因为我不知道它们是如何判断函数结尾到哪里的，这属于我当时的一个理解错误，编译的时候函数体的内容会被编译好放到其他位置，而不是说运行时再看到一个函数的标签，再将之后的一段代码跳过。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只展示关键部分</span></span><br><span class="line"><span class="comment"># 错误版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  [DefineFun.new(node.name), <span class="keyword">super</span>(node), Return.new, FunEnd.new]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>正确的做法应当是在编译的时候就将这些代码单独放到其他位置，运行时再进行装载。</p><h1 id="调用无参函数"><a href="#调用无参函数" class="headerlink" title="调用无参函数"></a>调用无参函数</h1><p>函数调用我们先从简单的无参函数说起</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span></span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>那么首先，我们需要考虑到call的target如何来做处理。很自然的会想到target可以使用字符串。</p><p>尽管使用字符串的话会导致指令长度膨胀，解析复杂等。但目前不考虑那些，解析的也是字符串指令，所以先这样</p><h2 id="去哪里找目标函数的信息"><a href="#去哪里找目标函数的信息" class="headerlink" title="去哪里找目标函数的信息"></a>去哪里找目标函数的信息</h2><p>这个自然来说是需要符号表中保存了</p><h3 id="符号表中的函数信息"><a href="#符号表中的函数信息" class="headerlink" title="符号表中的函数信息"></a>符号表中的函数信息</h3><p>对于符号表来说，表中条目需要保存的信息有以下几条</p><ol><li>参数个数（目前全部为无类型，因此返回类型也无需考虑）</li><li>local变量的信息</li><li>函数体的指令地址</li></ol><p>这些<strong>目前</strong>来说都是编译期间可知的，所以也会以字符串的方式dump出来供vm去解析。至于函数体地址的问题牵扯到链接，而目前我们先不需要考虑链接的情况，只需要将生成的符号表中的地址加载进来就好了。</p><h3 id="生成符号表"><a href="#生成符号表" class="headerlink" title="生成符号表"></a>生成符号表</h3><p>由于以上需求，我们在编译的时候需要生成符号表信息</p><p>我们之前设计的全局符号表是这样的</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>,:<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>暂时不考虑常量表，我们需要的是剩下两个表的信息。</p><p>生成vm指令这个阶段会将一个全局定义表（define_env，目前仅存其定义），将其定义更改为args以及offset</p><p>offset都是未知的所以先设置为一个未定义值，因为我是通过返回数组并且把数组连接起来的形式，所以这个时候并不知道偏移量。这里用一个数组存放值的做法实在很差劲，但是实在没精力改进了…先能跑吧</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">    ...  </span><br><span class="line">    <span class="variable">@global_env</span>.define_env[node.name] = [node.args, <span class="string">&#x27;undefined&#x27;</span>]</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>重新设置偏移量</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inst.each_with_index <span class="keyword">do</span> <span class="params">|ins, index|</span>  </span><br><span class="line">    <span class="keyword">if</span> ins.is_a? DefineFun    </span><br><span class="line">        <span class="variable">@global_env</span>.define_env[ins.name][<span class="number">1</span>] = index  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而fun_env表，则是保存了每个表的参数以及局部变量的信息。拥有fun_env表和define_env表（这两个表其实应该合并，下次一定…）的信息，我们就能够生成出上面所需的信息了</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_sym_table</span><span class="params">(global_env)</span></span>  </span><br><span class="line">    global_env.define_env.map <span class="keyword">do</span> <span class="params">|name, (args, offset)|</span></span><br><span class="line">        <span class="string">&quot;<span class="subst">#&#123;name&#125;</span> <span class="subst">#&#123;args.size&#125;</span> <span class="subst">#&#123;global_env.fun_env[name].size&#125;</span> <span class="subst">#&#123;offset&#125;</span>&quot;</span>  </span><br><span class="line">    <span class="keyword">end</span>.join(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成示例 格式为 函数名，参数个数，local var个数，起始地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multi <span class="number">2</span> <span class="number">2</span> <span class="number">0</span>main <span class="number">0</span> <span class="number">1</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>函数符号表中的条目</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FunInfo</span></span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">    <span class="built_in">FunInfo</span>(): <span class="built_in">FunInfo</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(<span class="keyword">size_t</span> _argc, <span class="keyword">size_t</span> _locals, <span class="keyword">size_t</span> _begin): <span class="built_in">argc</span>(_argc), <span class="built_in">locals</span>(_locals), <span class="built_in">begin</span>(_begin) &#123;&#125;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(constFunInfo&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    <span class="built_in">FunInfo</span>(FunInfo&amp;&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    FunInfo&amp;<span class="keyword">operator</span>=(constFunInfo&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    FunInfo&amp;<span class="keyword">operator</span>=(FunInfo&amp;&amp; other) =<span class="keyword">default</span>;    </span><br><span class="line">    <span class="keyword">size_t</span> argc;    </span><br><span class="line">    <span class="keyword">size_t</span> locals;    </span><br><span class="line">    <span class="keyword">size_t</span> begin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><p>既然要调用函数，那么就需要调用栈这个东西了</p><p>就目前的需求来说，调用栈中的栈帧需要有以下几种成员</p><ol><li>前一个栈帧（跟踪整个调用链）</li><li>返回的pc地址（函数调用结束后需要返回到调用者）</li><li>当前栈帧在栈中的起始地址（起始地址开始分配局部变量的空间）</li></ol><p>关于多个栈帧之间的存储方式，由于需要频繁添加删除尾部结点，因此选择了链表的方式。如果使用数组的话会牵扯到长度不够再重新分配数组空间的情况</p><p>而实际栈内数据的布局是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------        f1</span><br><span class="line">    local var</span><br><span class="line">----------------  ----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------        main</span><br><span class="line">    local var</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><p>注意这里和实际的栈不同，对于实际的栈来说类似于返回的pc地址，以及前一个栈帧的地址都是保存在栈内的</p><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>目前的设计是返回值最后放到栈顶，这样返回的时候直接从栈顶取值，之后再恢复栈就可以了</p><h1 id="调用带参数的函数"><a href="#调用带参数的函数" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h1><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a, b)</span></span></span><br><span class="line">    c = a + b</span><br><span class="line">    c</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>目前采用的是push的方式直接push参数，这个体现在函数调用的时候编译出的指令上</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_fun_call</span><span class="params">(fun_call)</span></span></span><br><span class="line">    fun_call.args.map &#123; <span class="params">|arg|</span> push(visit(arg)) &#125; + [Call.new(fun_call.name)]  </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>栈内数据排布</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">    tmp var</span><br><span class="line">----------------</span><br><span class="line">    local var           f1</span><br><span class="line">---------------- </span><br><span class="line">      args</span><br><span class="line">----------------  ----------------</span><br><span class="line">     tmp var</span><br><span class="line">----------------</span><br><span class="line">    local var           main</span><br><span class="line">---------------- </span><br><span class="line">      args</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure><p>关于参数传递的话题其实还有很多，比如说顺序，变长参数，谁来释放，在之后的内容再一点点补足</p><h1 id="正文无关闲谈"><a href="#正文无关闲谈" class="headerlink" title="正文无关闲谈"></a>正文无关闲谈</h1><p>首先是最重要的一点：本周的内容就充满了各种应付式的内容，这在往期我都是会直接当场修改掉的，但实属有些无力…我在想这样的内容发出来会不会很不负责任，但是如果停更那我所做出的每周更新的承诺这么快就要被打破了，而且以后更容易不遵守了。</p><p>本周的内容相对少的多，最加对于压力的感知更加明显了，尽管我反复将注意力转移到当前做的事情上（每天也会有对应冥想练习），但很多事情依然力不从心。时间安排的太满，我不会的太多，但每一项我都无法舍弃，最后分配到做这个的时间真的不多了，还要一边查看各种实现学习一边写，好多东西都是周日写的时候才学习修改的。学习实现基本上也是靠看书，看前人总结过的内容，对于大型项目实在没有精力去扒。这周还在看Ruby的YJIT的论文，本就不多的时间更没多少了，最后论文也没看多少（就看了几段介绍…），这篇论文读明白后也会再出一篇博客，尽管只看了一点但也让我增加了许多JIT方面的常识</p><p><a class="link"   href="https://dl.acm.org/doi/10.1145/3486606.3486781" >YJIT: a basic block versioning JIT compiler for CRuby<i class="fas fa-external-link-alt"></i></a></p><p>如何能摆脱这种状态，如果读者有经验还请赐教</p><p>如果我是学生的时候就能开始做这件事情就好了..可是没有那么多如果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周主要是修复了之前C++代码生成的一些bug，之后开始搞函数定义与调用的部分。&lt;/p&gt;
&lt;h1 id=&quot;函数解析方式&quot;&gt;&lt;a href=&quot;#函数解析方式&quot; class=&quot;headerlink&quot; title=&quot;函数解析方式&quot;&gt;&lt;/a&gt;函数解析方式&lt;/h1&gt;&lt;p&gt;这里我一开始</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记3 生成C++代码</title>
    <link href="https://fusionbolt.github.io/2022/01/09/rc-lang-dev-3/"/>
    <id>https://fusionbolt.github.io/2022/01/09/rc-lang-dev-3/</id>
    <published>2022-01-09T04:00:35.000Z</published>
    <updated>2022-01-30T05:15:56.659Z</updated>
    
    <content type="html"><![CDATA[<p>由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。</p><h1 id="指令定义"><a href="#指令定义" class="headerlink" title="指令定义"></a>指令定义</h1><p>每个指令有一个InstType的枚举字段来标明类型</p><p>所有指令继承自一个VMInst类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VMInst</span> &#123;</span></span><br><span class="line">    InstType type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">VMInst</span>(InstType t) : <span class="built_in">type</span>(t) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Addr</span> :</span> VMInst &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Addr</span>(<span class="keyword">int</span> offset, string seg) : <span class="built_in">VMInst</span>(InstType::Addr), _offset(offset), _seg(seg) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _offset;</span><br><span class="line">    string _seg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="C-解析"><a href="#C-解析" class="headerlink" title="C++解析"></a>C++解析</h1><p>最主要的问题是要如何让C++解析这边生成的东西。我目前就选用了最简单粗暴的方法，直接生成字符串，用空格分离参数，用换行分离指令</p><h1 id="获取所有指令信息"><a href="#获取所有指令信息" class="headerlink" title="获取所有指令信息"></a>获取所有指令信息</h1><h2 id="获取有哪些指令"><a href="#获取有哪些指令" class="headerlink" title="获取有哪些指令"></a>获取有哪些指令</h2><p>我将所有的指令都放到了Rc::VM::Inst中，通过获取这个module的所有constant，判断哪些是Class</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_classes</span><span class="params">(mod)</span></span></span><br><span class="line">mod.constants.map&#123;<span class="params">|c|</span> mod.const_get(c)&#125;.select&#123;<span class="params">|c|</span> c.is_a? Class&#125;.sort_by&#123; <span class="params">|klass|</span> klass.to_s &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">classes = get_classes(Rc::VM::Inst)</span><br></pre></td></tr></table></figure><p>通过这个代码能够获取到Inst这个模块中的所有指令</p><ol><li>获取每个指令里面是怎么样的</li></ol><p>由于ruby并没有定义成员类型的东西，因此我选择自己造一个指定成员类型的东西</p><p>有两种实现</p><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="TypeStruct"><a href="#TypeStruct" class="headerlink" title="TypeStruct"></a>TypeStruct</h3><p>第一种是将Struct给包装一层，我给其命名为TypeStruct</p><p><strong>使用方式</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CondJump</span> &lt;</span> TypeStruct.<span class="built_in"><span class="keyword">new</span></span>(:cond, :addr =&gt; :<span class="keyword">int</span>)</span><br><span class="line">  def to_s</span><br><span class="line">    <span class="string">&quot;CondJump #&#123;cond&#125; #&#123;addr&#125;&quot;</span></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>类似于常规的Struct的使用方式，但是输入变成了可以是一个hash</p><p><strong>实现</strong></p><ol><li><p>实现的一个要点在于new返回的东西需要是一个class。那么我们需要知道Ruby中new是怎么运作的</p><p>常规的对象来说，new中会做三件事。class MemberMap  def initialize(type_defines)    @type_defines = type_defines  end  def generate(c = “\n”, &amp;f)    @type_defines.generate(c, &amp;f)  end  def keys    @type_defines.map { |td| td.name }  endend通过allocate分配空间，send initialize方法进行构造对象，最后将obj返回。而在这里只要修改返回的内容即可</p></li><li><p>另一个要点在于需要给返回的class添加一些实例方法</p><p>这里我们需要先理解常规的Struct.new做了什么，在我的理解本质上是返回了一个通过动态添加定义的匿名class，那么我们需要的是给这个匿名class添加一些方法来定义</p><p>那么我们很自然的就会想到将所有传给new的参数转换为每一个成员以及与之相应的类型定义，之后再对其中每一对“成员名⇒类型”定义对应的获取类型的方法</p></li><li><p>保存一个type_map，用于后面获取信息使用</p></li></ol><p>来看一下代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">args_to_hash</span><span class="params">(*args)</span></span></span><br><span class="line">  args.reduce(&#123;&#125;) <span class="keyword">do</span> <span class="params">|sum, arg|</span></span><br><span class="line">    sum.merge(</span><br><span class="line">      <span class="keyword">if</span> arg.is_a? Hash</span><br><span class="line">        arg</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123; arg =&gt; <span class="symbol">:str</span> &#125;</span><br><span class="line">      <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeStruct</span></span></span><br><span class="line">  <span class="keyword">include</span> TypeCheck</span><br><span class="line">  def <span class="keyword">self</span>.new(*args, &amp;block)</span><br><span class="line">    <span class="comment"># if don&#x27;t have allocate, will be nil class</span></span><br><span class="line">    obj = allocate</span><br><span class="line">    <span class="comment"># initialize is a private method</span></span><br><span class="line">    <span class="comment"># initialize must be send instead of direct call</span></span><br><span class="line">    obj.send(<span class="symbol">:initialize</span>, *args, &amp;block)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(*args)</span></span></span><br><span class="line">    args = args_to_hash(*args)</span><br><span class="line">    Struct.new(*args.keys).tap <span class="keyword">do</span> <span class="params">|klass|</span></span><br><span class="line">      args.each <span class="keyword">do</span> <span class="params">|attr, type|</span></span><br><span class="line">        check(type)</span><br><span class="line">        <span class="comment"># per class Struct is different</span></span><br><span class="line">        klass.define_method <span class="string">&quot;<span class="subst">#&#123;attr&#125;</span>_t&quot;</span> <span class="keyword">do</span></span><br><span class="line">          type</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  klass.define_method <span class="string">&quot;type_map&quot;</span> <span class="keyword">do</span></span><br><span class="line">        args</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>还有一个点是需要在这里检查type的合法性，这里想过生成类的，但是最后想或许现在没必要，还是先用符号吧。检查相关的代码如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">TypeCheck</span></span></span><br><span class="line">  VALID_TYPE = &#123;<span class="symbol">:int</span> =&gt; <span class="symbol">:int</span>, <span class="symbol">:str</span> =&gt; <span class="symbol">:string</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">invalid?</span><span class="params">(type)</span></span></span><br><span class="line">    VALID_TYPE.keys.<span class="keyword">include</span>? type</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check</span><span class="params">(type)</span></span></span><br><span class="line">    <span class="keyword">unless</span> invalid? type</span><br><span class="line">      raise <span class="string">&quot;invalid type <span class="subst">#&#123;type&#125;</span>, only supported <span class="subst">#&#123;VALID_TYPE.map(&amp;<span class="symbol">:to_s</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  module_function <span class="symbol">:check</span>, <span class="symbol">:invalid?</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="attr-type"><a href="#attr-type" class="headerlink" title="attr_type"></a>attr_type</h3><p>第二种是增加了一个像attr_reader一样叫做attr_type的东西，但是这个要依赖于常规的Struct，我还是想要常规Struct内部的东西来避免重复代码。虽然有办法不依赖Struct，但是那样需要在这个attr_type里面引入更多不属于这个函数的功能，于是还是放弃吧</p><p><strong>使用示例</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Push</span> &lt; Struct.<span class="title">new</span>(:<span class="title">value</span>)</span></span><br><span class="line">  attr_type <span class="symbol">:value</span> =&gt; <span class="symbol">:int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">    <span class="string">&quot;Push <span class="subst">#&#123;value&#125;</span>&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><strong>实现</strong></p><p>实现的核心原理还是参数转到hash再对每一对值define_method，只是这次我们要直接hack Module。attr_reader等函数也是采用的类似的做法</p><p>type_map的处置有一些不同，type_map需要将成员初始化，所有成员默认str类型，接着需要不断的merge新的参数，这个时候会将type_map中在args出现过的key所关联的值更新，这么解释可能比较复杂，看代码更直接一些</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="symbol">:a</span> =&gt; <span class="number">1</span>&#125;.merge(&#123;<span class="symbol">:a</span> =&gt; <span class="number">2</span>&#125;)</span><br><span class="line">=&gt; &#123;<span class="symbol">:a=&gt;</span><span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Module</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">attr_type</span><span class="params">(*args)</span></span></span><br><span class="line">    args = args_to_hash(*args)</span><br><span class="line">    args.map <span class="keyword">do</span> <span class="params">|attr, type|</span></span><br><span class="line">      TypeCheck::check(type)</span><br><span class="line">      define_method <span class="string">&quot;<span class="subst">#&#123;attr&#125;</span>_t&quot;</span> <span class="keyword">do</span></span><br><span class="line">        type</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="variable">@type_map</span> <span class="params">||</span>= <span class="keyword">self</span>.members.reduce(&#123;&#125;) &#123;<span class="params">|mem|</span> &#123;mem =&gt; <span class="symbol">:str</span>&#125;&#125;</span><br><span class="line">    <span class="variable">@type_map</span>.merge!(args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="二者的选择"><a href="#二者的选择" class="headerlink" title="二者的选择"></a>二者的选择</h3><p>最后的结果嘛…ide分析不出来，不想看到各种报错的红线。遇到需要手动new的时候只能改成第二种了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="Untitled.png"                      alt="Untitled"                ></p><p>在获取成员的时候也用了很脏的做法，没找到什么在不new的情况下获取成员的好方法，因此也只有先new再从里面找。</p><h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><h2 id="以前没做的坑"><a href="#以前没做的坑" class="headerlink" title="以前没做的坑"></a>以前没做的坑</h2><p>这里其实做一个dsl来描述然后生成是最好的。在好久之前了解rv的时候我甚至一度想开一个坑，用一个dsl来描述一个isa，之后生成对应的C++的读写代码。最后也是咕咕咕了，后续有时间可以做一下，还是挺有意思的。</p><p>这是一个描述load store的例子。当时做的时候没想到，现在一想其实也可以直接用Struct来描述，采用和我上面一致的方案</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISA.define <span class="symbol">:LOAD</span> <span class="keyword">do</span>  field <span class="symbol">:rd</span>, <span class="number">5</span>  field <span class="symbol">:funct3</span>, <span class="number">3</span>  field <span class="symbol">:rs1</span>, <span class="number">5</span>  field <span class="symbol">:imm</span>, 12endISA::define <span class="symbol">:STORE</span> <span class="keyword">do</span>  field <span class="symbol">:offset_4_0</span>, <span class="number">5</span>  field <span class="symbol">:width</span>, <span class="number">3</span>  field <span class="symbol">:base</span>, <span class="number">5</span>  field <span class="symbol">:src</span>, <span class="number">5</span>  field <span class="symbol">:offset</span>, 5end</span><br></pre></td></tr></table></figure><p>这是一个只做了外观没有做内部实现的例子，<del>属实有点问题，正经人谁会搞出这玩意</del></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace <span class="symbol">:Suica</span> <span class="keyword">do</span>  namespace <span class="symbol">:T</span> <span class="keyword">do</span>    struct <span class="symbol">:F</span> <span class="keyword">do</span>      auto <span class="symbol">:a1</span>      auto <span class="symbol">:a2</span>, <span class="number">1</span>      void <span class="symbol">:f2</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>] <span class="keyword">do</span>      <span class="keyword">end</span>    <span class="keyword">end</span>  endend</span><br></pre></td></tr></table></figure><h2 id="生成的实现"><a href="#生成的实现" class="headerlink" title="生成的实现"></a>生成的实现</h2><p>有点扯远了，我们来看一下实际生成C++代码的部分。</p><p>我们需要生成如下几步</p><ol><li>获取所有指令信息</li><li>include头文件，名称空间等内容</li><li>InstType的enum定义</li><li>所有指令类的定义</li><li>解析输入的部分</li></ol><p>每个部分生成一个源码字符串，最后将这些拼接为一个长的字符串就好了</p><p>捋清这个流程以后就简单贴一下部分代码好了，源码中&lt;&lt;SRC的部分是一个字符串块的开始，SRC是结束，中间的任何字符都会保留，除了#{expr}，这个是将expr to_s以后再嵌入进去</p><h2 id="帮助方法"><a href="#帮助方法" class="headerlink" title="帮助方法"></a>帮助方法</h2><p>这是我自己加给Array的辅助函数，因为经常会有需要遍历array的所有对象做一套统一的操作最后再join连接的情况</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(c = <span class="string">&quot;\n&quot;</span>, &amp;f)</span></span></span><br><span class="line">    map &#123;<span class="params">|a|</span> f[a] &#125;.join(c)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">pure_generate</span><span class="params">(&amp;f)</span></span></span><br><span class="line">    map &#123; <span class="params">|a|</span> a.demodulize_class &#125;.generate(&amp;f)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>demodulize_class的话就是简单的将类名去除了module前缀</p><h2 id="获取所有指令信息-1"><a href="#获取所有指令信息-1" class="headerlink" title="获取所有指令信息"></a>获取所有指令信息</h2><p>虽然上面提过，这里再放一下代码</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_classes</span><span class="params">(mod)</span></span>  </span><br><span class="line">    mod.constants.map&#123;<span class="params">|c|</span> mod.const_get(c)&#125;.select&#123;<span class="params">|c|</span> c.is_a? Class&#125;.sort_by&#123; <span class="params">|klass|</span> klass.to_s &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_header_namespace</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">#include &lt;string&gt;</span></span><br><span class="line"><span class="string">#include &lt;vector&gt;</span></span><br><span class="line"><span class="string">#include &lt;memory&gt;</span></span><br><span class="line"><span class="string">#pragma once</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">using std::string;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="InstType的enum定义"><a href="#InstType的enum定义" class="headerlink" title="InstType的enum定义"></a>InstType的enum定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_enum_inst_type</span><span class="params">(classes)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">enum class InstType &#123;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;classes.pure_generate &#123;<span class="params">|c|</span> <span class="string">&quot;<span class="subst">#&#123;c&#125;</span>,&quot;</span>&#125;</span>&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">InstType</span> &#123;</span></span><br><span class="line">Add,</span><br><span class="line">Label,</span><br><span class="line">SetLocal,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="指令类定义"><a href="#指令类定义" class="headerlink" title="指令类定义"></a>指令类定义</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_class_define</span><span class="params">(klass)</span></span></span><br><span class="line">  class_name = klass.demodulize_class</span><br><span class="line">  member_map = klass.get_member_map</span><br><span class="line">  params = member_map.generate(<span class="string">&#x27;, &#x27;</span>) &#123;<span class="params">|td|</span> gen_class_member(td)&#125;</span><br><span class="line">  init_member = <span class="string">&quot;<span class="subst">#&#123;member_map.keys.generate(<span class="string">&#x27;, &#x27;</span>) &#123;<span class="params">|name|</span> <span class="string">&quot;_<span class="subst">#&#123;name&#125;</span>(<span class="subst">#&#123;name&#125;</span>)&quot;</span>&#125;</span>&#125;&quot;</span></span><br><span class="line">  init_member = <span class="string">&quot;, <span class="subst">#&#123;init_member&#125;</span>&quot;</span> <span class="keyword">unless</span> init_member.empty?</span><br><span class="line">  init_inst = <span class="string">&quot;VMInst(InstType::<span class="subst">#&#123;class_name&#125;</span>)&quot;</span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">struct <span class="subst">#&#123;class_name&#125;</span> : VMInst</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">public:</span></span><br><span class="line"><span class="string">  <span class="subst">#&#123;class_name&#125;</span>(<span class="subst">#&#123;params&#125;</span>):<span class="subst">#&#123;init_inst&#125;</span><span class="subst">#&#123;init_member&#125;</span> &#123;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">private:</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;member_map.generate &#123;<span class="params">|mem_ty|</span> <span class="string">&quot;<span class="subst">#&#123;gen_class_member(mem_ty, <span class="string">&#x27;_&#x27;</span>)&#125;</span>;&quot;</span>&#125;</span>&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里可能有一些需要提一下的东西，比如说有一个get_member_map</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_member_map</span></span></span><br><span class="line">    instance = <span class="keyword">self</span>.new</span><br><span class="line">    <span class="comment"># need keep same order</span></span><br><span class="line">    MemberMap.new(instance.try(<span class="symbol">:type_map</span>).or_else&#123;[]&#125;.map <span class="keyword">do</span> <span class="params">|name, type|</span></span><br><span class="line">      TypeDefine.new(name, type)</span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保持顺序，我选择了用数组来存放。指令最多无外乎一两百条，对于这个数据量不需要太去关心什么高效算法。</p><p>为了有更多的类型信息来帮助写易读和更可用的代码，一个名称类型对也转转换为了一个类型</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TypeDefine</span> &lt; Struct.<span class="title">new</span>(:<span class="title">name</span>, :<span class="title">type</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>而MemberMap是一层包装，内部用typedefine的array存储，但也是可以像hash一样取出所有的key</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemberMap</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(type_defines)</span></span></span><br><span class="line">    <span class="variable">@type_defines</span> = type_defines</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">(c = <span class="string">&quot;\n&quot;</span>, &amp;f)</span></span></span><br><span class="line">    <span class="variable">@type_defines</span>.generate(c, &amp;f)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">keys</span></span></span><br><span class="line">    <span class="variable">@type_defines</span>.map &#123; <span class="params">|td|</span> td.name &#125;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Label</span> :</span> VMInst</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Label</span>(string name):<span class="built_in">VMInst</span>(InstType::Label), _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="解析代码"><a href="#解析代码" class="headerlink" title="解析代码"></a>解析代码</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_all_parser</span><span class="params">(classes)</span></span></span><br><span class="line">  <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">std::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string"><span class="subst">#&#123;classes.generate &#123;<span class="params">|x|</span> gen_parser(x)&#125;</span>&#125;</span></span><br><span class="line"><span class="string">throw std::runtime_error(&quot;Unknown inst type&quot; + list[0]);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>生成的样子（这里只放一个示例</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;VMInst&gt; get_inst(const std::vector&lt;std::string&gt; &amp;list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (list[<span class="number">0</span>] == <span class="string">&quot;Addr&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> std::make_unique&lt;Addr&gt;(std::stoi(list[<span class="number">1</span>]), list[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-代码格式"><a href="#C-代码格式" class="headerlink" title="C++代码格式"></a>C++代码格式</h2><p>这里应该提一下，这种生成方式代码格式一定会乱七八糟，所以还应该调用一下clang-format处理一下。但是VM那边的clang-format之类的许多东西还没有加好，之后再做一下吧</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>感谢你能看到这里，我再闲谈几句没什么关联的</p><p>这个系列我已经到了四篇，也就是一个月。持续做了这么几次已经可以确定只要不出意外自己就能连载下去，于是之后都会在推特推送我的更新（本周的就先算了，ruby本身所占比例有点大）<a class="link"   href="https://twitter.com/RealAkemiHomura" >RealAkemiHomura’ Twitter<i class="fas fa-external-link-alt"></i></a></p><p>如果对我的日常有兴趣可以点个关注，如果并不在意这个只想看后续的文章，那么可以通过rss订阅，或者每周一查看我的文章，更新一定是在周末</p><p>前面也提到元旦状态差，这些天甚至几次觉得这个系列过于玩具没有意义，想要断更、项目不想做下去了。但我最后还是决定继续更新，不为别的，只因为我还想接着做这个项目，哪怕内容如此简陋，只是一个过于简单的玩具，但我确实从中收获了知识和乐趣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;由于元旦第二天开始状态奇差，本周并没有增加太多内容，周记的内容也会相对少一些。以及本周的内容主要在于生成C++的代码，更多的是Ruby的元编程技巧。&lt;/p&gt;
&lt;h1 id=&quot;指令定义&quot;&gt;&lt;a href=&quot;#指令定义&quot; class=&quot;headerlink&quot; title=&quot;指令</summary>
      
    
    
    
    <category term="Ruby" scheme="https://fusionbolt.github.io/categories/Ruby/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="元编程" scheme="https://fusionbolt.github.io/tags/%E5%85%83%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记2 VM相关</title>
    <link href="https://fusionbolt.github.io/2022/01/02/rc-lang-dev-2/"/>
    <id>https://fusionbolt.github.io/2022/01/02/rc-lang-dev-2/</id>
    <published>2022-01-02T01:37:17.000Z</published>
    <updated>2022-01-30T05:12:32.821Z</updated>
    
    <content type="html"><![CDATA[<p>本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧</p><p>本周vm的代码都在ir/vm中，translator用于转换，inst是指令定义，vm.rb是入口</p><h1 id="Function转换"><a href="#Function转换" class="headerlink" title="Function转换"></a><strong>Function转换</strong></h1><p>这是我目前的Function的ast定义</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Function</span></span></span><br><span class="line">    <span class="keyword">attr_reader</span> <span class="symbol">:name</span>, <span class="symbol">:args</span>, <span class="symbol">:stmts</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在修改function生成代码的时候发现了一个问题，因为我有默认最后一个值直接返回的设计，所以或许应该在高层添加一个将stmt显式抽出</p><p>return的操作。这个步骤现在看来大概分为简单两步</p><ol><li>消除不可达代码，比如说一个return后面还有好几个值</li><li>消除后就可以放心将最后一个语句的结果转换为一个返回值了</li></ol><p>但是第二步实际实现的时候可能没有这么简单，这里就暂提个思路，以后再回头看这个设计是否有需要</p><h1 id="无意义的tac-to-vm-inst"><a href="#无意义的tac-to-vm-inst" class="headerlink" title="无意义的tac to vm inst"></a><strong>无意义的tac to vm inst</strong></h1><p>之后做了一些将tac转到vm指令。在做这个的过程我才意识到其实不需要转成tac，对于tac和vm指令的表达力应该是同等级的，都比较偏向于中层IR。查看了一下其他语言的做法，Ruby和Java都是从AST转到了字节码</p><p>深入理解Java虚拟机310页：</p><blockquote><p>字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转换成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作</p></blockquote><p>Ruby原理剖析36页：</p><blockquote><p>在解析完 词条生成AST之后，Ruby1.9和Ruby2.0继续把代码编译成一系列的底层指令，叫做YARV指令</p></blockquote><p>这里的YARV是Ruby的字节码解释器，而YARV指令自然就是对应的字节码。而Ruby1.9之前是直接解释执行ast的，甚至不会考虑到tac这样的东西</p><h2 id="为什么不需要先转成tac优化后再到vm指令"><a href="#为什么不需要先转成tac优化后再到vm指令" class="headerlink" title="为什么不需要先转成tac优化后再到vm指令"></a><strong>为什么不需要先转成tac优化后再到vm指令</strong></h2><p>关于这一点，我询问了朋友，最后的结论大概有以下两点。如果读者对这方面很了解希望能科普一下</p><ol><li><p>转成tac做优化以后，尤其是部分针对全局的优化会以及其他的变换会剔除掉一些JIT时所需要的信息。</p><p>关于这点我问了很久，我觉得还要尽可能地多做优化再到jit，应该要通过控制不做哪些优化来避免剔除所需信息。因为我对这几个层面所能做的优化了解不深，不知道所能做的优化有哪些差异，也没法举出例子或者说明收益</p><p>后续我又了解了一些信息，发现jit中还有一个名叫的deoptimize技术，这个出现在multi tiered jit中。关于这个的内容在我另一篇博客中</p></li><li><p>如果直接显式执行的是源码而不是字节码，先转成tac做处理再到vm指令会影响到了启动时间</p><p>Ruby是在内部对源码解析之后再由vm来执行。Java可能给大多数人的印象是必须要先编译到字节码，然后再单独加载执行字节码，但调查发现Java9开始可以通过jshell来直接执行。将这个过程封装到一起实际上也不麻烦，只是不需要你显式操作罢了</p></li></ol><p>所以经过了这些结论，前面做的tac到vm指令的就白费了，只能重新写一套从ast生成vm指令代码。生成tac这个过程并没有白费，编写的过程中让我有对这个东西有了更深的理解，以及后续可能会用tac实现优化算法。</p><h1 id="VM简介"><a href="#VM简介" class="headerlink" title="VM简介"></a><strong>VM简介</strong></h1><p>至于VM的实现，很自然的就会选择栈式VM。以学习为目的肯定要做寄存器分配，但是因为后续想做jit，所以寄存器分配就留到那个时候再做，或者说可以再从tac做成aot，反正目前还是以实现学习为目的。</p><p>搞一个VM本质是什么？我觉得本质是对运行时的环境进行处理。那么我们首先要来谈及这个环境都有哪些部分</p><p>我觉得简单可以分为以下两种</p><ol><li>数据（代码与计算的数据）</li><li>当前状态（寄存器与栈帧）</li></ol><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a><strong>数据</strong></h2><p>数据牵扯到的问题有很多，比如说数据排布、对象布局、地址分配等等。这也是我第一次动手做这些，这里就先从最简单的只有int32做起。如果后面做完善了可以再单独出一期把这些东西串起来（咕咕咕咕咕咕</p><h2 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a><strong>当前状态</strong></h2><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h3><p>寄存器就从目前来说，我们需要一个pc寄存器来表明当前执行到哪条语句了。至于vm那边的实现目前使用一个数组保存，pc保存下数组索引就好</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a><strong>栈帧</strong></h3><p>栈帧根据不同的需求内容也各不相同</p><p>我们来看一下龙书中提到的常见栈帧成员（不论什么书其实大都差不多</p><ol><li>局部变量</li><li>临时变量的位置（牵扯到临时变量？</li><li>机器状态（保存的特殊寄存器值，这个和调用约定也有一定关联。调用约定决定了哪些寄存器是需要保存的，哪些是不需要保存的，关于调用约定更多详情还请自行查询</li><li>rbp指针（用于管理访问链</li><li>指向调用者的地址</li><li>返回值（我选择统一放到一个寄存器中）</li><li>实参</li></ol><p>要注意的是书中提到的基本上是针对非VM的栈帧，VM的栈帧可以根据需求做出不一样的设计，比如说Ruby中采用了双栈的设计，一个调用栈用于管理调用链，一个计算栈用于存放各种变量与计算，而对于非VM栈帧絕大多说都是一个栈（我没听说过有使用双栈的，但是说不定也存在呢）通过栈中保存的rbp寄存器中的值来处理访问链</p><p>就目前从头开始实现而言，我们需要什么再加什么就好了，后续每个东西怎么加，为什么加我都会有一定说明。</p><h1 id="VM指令转换"><a href="#VM指令转换" class="headerlink" title="VM指令转换"></a><strong>VM指令转换</strong></h1><h2 id="计算赋值"><a href="#计算赋值" class="headerlink" title="计算赋值"></a>计算赋值</h2><p>先从普通的运算赋值做起。这里其实有点问题，我还没有处理好单独的语句，所以都放到了一个函数里（写完这篇就去改），以及对于函数定义该如何处理我也没想好。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span></span></span><br><span class="line">  a = <span class="number">3</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在Ruby的虚拟机中扫描到类似的函数定义则是会产生一行调用 <code>definemethod :foo, foo</code></p><p>而foo本身的内容则是</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">== <span class="symbol">disasm:</span> #&lt;ISeq:f@&lt;compiled&gt;<span class="symbol">:</span><span class="number">1</span> (<span class="number">1</span>,<span class="number">0</span>)-(<span class="number">3</span>,<span class="number">3</span>)&gt; (<span class="symbol">catch:</span> FALSE)</span><br><span class="line">local table (<span class="symbol">size:</span> <span class="number">1</span>, <span class="symbol">argc:</span> <span class="number">0</span> [<span class="symbol">opts:</span> <span class="number">0</span>, <span class="symbol">rest:</span> -<span class="number">1</span>, <span class="symbol">post:</span> <span class="number">0</span>, <span class="symbol">block:</span> -<span class="number">1</span>, <span class="symbol">kw:</span> -<span class="number">1</span>@-<span class="number">1</span>, <span class="symbol">kwrest:</span> -<span class="number">1</span>])</span><br><span class="line">[ <span class="number">1</span>] a<span class="variable">@0</span></span><br><span class="line"><span class="number">0000</span> putobject                              <span class="number">3</span>                         (   <span class="number">2</span>)[LiCa]</span><br><span class="line"><span class="number">0002</span> putobject                              <span class="number">2</span></span><br><span class="line"><span class="number">0004</span> opt_mult                               &lt;calldata!<span class="symbol">mid:</span>*, <span class="symbol">argc:</span><span class="number">1</span>, ARGS_SIMPLE&gt;</span><br><span class="line"><span class="number">0006</span> dup</span><br><span class="line"><span class="number">0007</span> setlocal_WC_0                          a<span class="variable">@0</span></span><br><span class="line">0009 leave                                                            (   <span class="number">3</span>)[Re]</span><br></pre></td></tr></table></figure><p>这里出现了一个点，由于函数体中是一个assign，值会pop走，但是这个assign又是作为一个返回值，因此ruby中对结果调用了dup，创建一个重复的值用于返回。在写博客的时候看到Ruby指令的结果刚意识到这个问题，不过这个是属于关于函数体与函数调用相关的内容，这里目前暂不修改。</p><p>作为参考，进行编写测试。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context <span class="string">&#x27;assign&#x27;</span> <span class="keyword">do</span></span><br><span class="line">  it <span class="string">&#x27;normal expr&#x27;</span> <span class="keyword">do</span></span><br><span class="line">    s = <span class="string">&lt;&lt;SRC</span></span><br><span class="line"><span class="string">def foo</span></span><br><span class="line"><span class="string">a = 1 * 2</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">SRC</span></span><br><span class="line">    inst = get_vm_inst(s)</span><br><span class="line">    expect(inst).to eq [Rc::VM::Push.new(<span class="number">1</span>), Push.new(<span class="number">2</span>), Mul.new, SetLocal.new(<span class="number">0</span>), Return.new]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>对于一个普通的a = 1 * 2，我们期望的行为是将两个参数push到栈上，之后进行mul操作，最后设置本地变量的值</p><h3 id="乘法操作"><a href="#乘法操作" class="headerlink" title="乘法操作"></a>乘法操作</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Binary</span> <span class="comment"># Rc::AST::Binary</span></span></span><br><span class="line">  <span class="keyword">attr_reader</span> <span class="symbol">:op</span>, <span class="symbol">:lhs</span>, <span class="symbol">:rhs</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_binary</span><span class="params">(node)</span></span></span><br><span class="line">  [</span><br><span class="line">    push(visit(node.lhs)),</span><br><span class="line">    push(visit(node.rhs)),</span><br><span class="line">    translate_op(node.op),</span><br><span class="line">  ]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="操作数的处理"><a href="#操作数的处理" class="headerlink" title="操作数的处理"></a>操作数的处理</h3><p>指令操作数目前分了两种，一种是直接可以保存值的，一种是引用某个名字</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">VMInstOperand</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Value</span> &lt; Struct.<span class="title">new</span>(:<span class="title">value</span>)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Ref a exist var</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Ref</span> &lt; Struct.<span class="title">new</span>(:<span class="title">ref</span>)</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(node)</span></span></span><br><span class="line">    <span class="keyword">if</span> node.is_a? Value</span><br><span class="line">      Push.new(node.value)</span><br><span class="line">    <span class="keyword">elsif</span> node.is_a? Ref</span><br><span class="line">      GetLocal.new(node.ref)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      raise <span class="string">&quot;Unsupported node type <span class="subst">#&#123;node.<span class="keyword">class</span>&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两个都是visit结点的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_number_constant</span><span class="params">(node)</span></span></span><br><span class="line">  Value.new node.val.to_i</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get or Set, so need return a id</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_identifier</span><span class="params">(node)</span></span></span><br><span class="line">  Ref.new cur_fun_env[node.name].id</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这么设计的原因是</p><ol><li>针对一个简单的数值我们可以直接将值push到栈上</li><li>针对一个名字我们需要去符号表中找到这个名字所在的位置，再将对应的值push到栈上</li></ol><p>同时也有不同的“push操作”</p><ol><li>针对简单的值直接push</li><li>针对名字我们通过GetLocal来获取（对于vm那边的实现，需要根据局部变量的基址和偏移量以及类型找到对应的值再放上去，但是类型目前不考虑，统一int32）</li></ol><p>这里暂时不考虑访问外部作用域的问题，这会涉及到符号表的访问以及栈的修改两部分内容。</p><p>针对这样的设计，我们需要开始增加栈的功能了</p><ol><li>简单数值的运算，我们需要能将值放上去，再进行运算取出或者留在栈里（这些临时变量）</li></ol><p>因此就有了如下最最最简单的栈</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">  临时变量</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><ol><li><p>我们需要留有局部变量的位置，能够在里面存取数据。临时变量是会随着当前函数结束而销毁，因此我们需要添加临时变量的位置在栈上，栈回退的时候也会直接销毁掉</p><p>由于1需要反复修改栈指针的操作需要所以放在当前栈帧的最顶端比较合适</p></li></ol><p>因此就有了如下最最简单的栈</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------</span><br><span class="line">  临时变量</span><br><span class="line">----------</span><br><span class="line">  局部变量</span><br><span class="line">----------</span><br></pre></td></tr></table></figure><h3 id="op处理"><a href="#op处理" class="headerlink" title="op处理"></a>op处理</h3><p>这个没什么好说的，简单从op字符串转换到不同类型的运算指令</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate_op</span><span class="params">(op)</span></span></span><br><span class="line">    <span class="keyword">case</span> op.op</span><br><span class="line">    <span class="keyword">in</span> <span class="string">&#x27;+&#x27;</span></span><br><span class="line">      Add.new</span><br><span class="line"><span class="comment"># ...以下省略</span></span><br></pre></td></tr></table></figure><h1 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a><strong>符号表</strong></h1><p>就之前的代码而言，符号表信息之类的记录的并不够。在实际考虑栈帧以及执行之前我对符号表的认识仅仅停留在作为解释器的env以及他的功能的“概念”上。由于是之前写过的，就直接拿来用了，没有 再来认真反思设计以及其他的问题，回头再重新设计吧，先能用就行</p><p>考虑局部变量如何保存这个问题，引出了我对符号表更多的实际理解，所以还是要自己动手做才能更有助于理解，只是看一些理论讲还是不够，至少对我而言是这样的</p><p>关于扫描分析的代码在analysis/global_env中</p><p>符号表相关的定义在lib/env中</p><h2 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a>全局表</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalEnv</span> &lt; Struct.<span class="title">new</span>(:<span class="title">define_env</span>, :<span class="title">const_table</span>, :<span class="title">fun_env</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>全局表目前保存三个东西</p><ol><li>各种定义（类定义、函数定义等），这个设计是比较早的时候写的，可能并不合适，后续再好好想一下该怎么做</li><li>常量表</li><li>函数的符号表，根据函数名找到对应函数的符号表</li></ol><h2 id="条目"><a href="#条目" class="headerlink" title="条目"></a>条目</h2><p>针对生成VM指令的阶段，需要知道一个临时变量的位置，因此有了这样的一个东西作为符号表的条目。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvItemInfo</span> &lt; Struct.<span class="title">new</span>(:<span class="title">id</span>, :<span class="title">type</span>)</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>id的话在一个函数中是自增的，用于GetLocal和SetLocal中计算具体的offset（这个设计对于后续可能不够用，先这样）。类型肯定也是需要的，但是目前并没有考虑类型的问题，就留了这么一个坑在这里</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">on_function</span><span class="params">(node)</span></span></span><br><span class="line">  <span class="variable">@define_env</span>.define_symbol(node.name, node)</span><br><span class="line">  <span class="variable">@cur_fun_sym</span> = Env.new</span><br><span class="line">  <span class="variable">@cur_fun_var_id</span> = <span class="number">0</span></span><br><span class="line">  <span class="variable">@cur_fun_sym</span>.merge(node.args.map&#123; <span class="params">|arg|</span> [arg, EnvItemInfo.new(cur_fun_var_id, <span class="string">&#x27;&#x27;</span>)]&#125;.to_h)</span><br><span class="line">  visit(node.stmts)</span><br><span class="line">  <span class="variable">@fun_env</span>[node.name] = <span class="variable">@cur_fun_sym</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li>将函数名字关联到结点</li><li>从每个函数开始分析时初始化各参数的状态</li><li>将参数merge进当前函数的符号表中</li><li>访问函数体</li><li>将函数名关联到对应的符号表</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>今天写的太久有点写不下去了，所以到后面内容比较潦草，还请见谅。（目前以保证更新频率为主）有疑惑的地方可以联系我</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本周主要先对tac的函数进行了简单的测试，以确保能够正确运行我的vm demo，修正了function的一些问题，之后就是处理对vm指令的生成，处理了一下符号相关的信息，还做了一点函数的相关的以及生成C++的解析代码（都没做完，还是下周吧&lt;/p&gt;
&lt;p&gt;本周vm的代码都在i</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="VM" scheme="https://fusionbolt.github.io/categories/VM/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
</feed>
