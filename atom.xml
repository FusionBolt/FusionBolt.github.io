<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2024-06-05T03:38:47.677Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>参加婚礼</title>
    <link href="https://fusionbolt.github.io/2024/05/20/Life/attend-a-wedding/"/>
    <id>https://fusionbolt.github.io/2024/05/20/Life/attend-a-wedding/</id>
    <published>2024-05-20T08:18:50.000Z</published>
    <updated>2024-06-05T03:38:47.677Z</updated>
    
    <content type="html"><![CDATA[<p>昨天我参加了同学的婚礼，他是高中为数不多和我有往来的人，结婚的对象同样也是班里的同学，其实在高中就有在谈恋爱，这么多年来分分合合不知道多少次，现在总算是结了婚。</p><p>为避免和别人说不上话的尴尬，我选择了十一点才到。在外面教堂风格的露天拍摄场地看到了新郎，几位作为伴郎的同学。找熟悉的同学旁边坐下，由于关系还好，实际上没有那么尴尬。这个时间刚开始一波室外拍摄，我也就拿着设备跟着随手拍了几张，同时一边和旁边的同学随便聊了起来。随后有一个新娘抛捧花的环节，我也被旁边的同学喊了过去，很尴尬的是第一次扔的太用力导致无人接到，我去捡起了花并扔了回去，当然最后也没有接到。</p><p>外部的环节结束后，进入内场等待十二点正式开始，也是理所当然的和同学们一桌，一群熟悉又陌生的人们：一起上学生活了三年，但是我却几乎没有融入过。许久未见，大家都聊起了各自形象上的变化，有的人和过去差别不大，有的人则是变化大到难以认出，至于性格上似乎都没有什么太大的差异。在此之后大家不可避免的开始谈论起工作的事情以及下一个结婚的会是谁，其中讨论的对象也包括一些没有来参加的同学。对于这个年纪的人来说这些几乎是不可避免的话题，尤其是对于许久没有联系的人们来说。不过也有从高中开始一直在一起玩，一直到现在的小圈子，包含新郎在内，他们隔三差五的一起出去玩，他们的话题大多则是最近发生的一些事情之类。这样的小圈子对于我来说是一件可以理解但难以想象的事情，过去的不受他人欢迎，现在的主动回避他人，不论哪个状态的我都不可能会有这样的经历，不过这也并非什么必须的事情。有很大一部分时间基本上都是他们在聊，敏感并且自以为是的我开始感到了内心的不适，而这种感受早已有所预料，并且在前一天晚上就梦到了被排斥后在走廊哭的场景，看来在这些方面我还是一如既往啊。内心这样想着，看着周围欢快聊天的同学，心里想着这样欢喜的日子我的心中却还在碎碎念，不愧是我啊。</p><p>之后是常驻婚礼的敬酒环节，不知为何还有家长敬酒，当他的妈妈过来时我还在想到底是男方还是女方家长，而此时阿姨已经认出了我。上一次去他家还是6年前的事情，对于脸盲的我实在是难以记得这么久之前见过几面的人。</p><p>全部结束后，独自在场地旁边的港湾行走着。没想到他也会有这样的一天，但实际上自己过往压根没有预想过这些，那么自己呢，或许自己不会迎来这样的一天吧？</p><p>一边想着这些无聊的事情，一边任由海风吹拂。空气中混杂着海水中的咸味以及路边花朵的香气，而我的思绪也被这难以形容的气息拉回了现实，开始计算着晚上几点回去，以及考虑着回去后依旧摆烂与散漫的生活。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;昨天我参加了同学的婚礼，他是高中为数不多和我有往来的人，结婚的对象同样也是班里的同学，其实在高中就有在谈恋爱，这么多年来分分合合不知道多少次，现在总算是结了婚。&lt;/p&gt;
&lt;p&gt;为避免和别人说不上话的尴尬，我选择了十一点才到。在外面教堂风格的露天拍摄场地看到了新郎，几位作为伴</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>养猫</title>
    <link href="https://fusionbolt.github.io/2024/04/20/Life/keeping-a-cat/"/>
    <id>https://fusionbolt.github.io/2024/04/20/Life/keeping-a-cat/</id>
    <published>2024-04-20T08:17:43.000Z</published>
    <updated>2024-06-16T09:59:14.627Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间我带了一只可爱的猫咪回家，给她起名为露露。由于是妹妹因此想要用甜品来命名，在到处查看甜品的时候看到各种xxx露，又觉得aa的这种名称形式喊起来比较方便，因此起了这样的名字。她到家的第一天有些怕生，几乎不肯出来，出来的时候路过饭碗也不肯吃东西，看她饿了一天实在心疼，拿出准备好的猫条来诱惑一下，而她也是十分配合的狼吞虎咽的把猫条舔了干净，甚至还想继续找我要，在这之后也开始愿意往外走了，并且渐渐熟络了起来。养了没几天，但还是多少有一些自己的感受。</p><h1 id="养猫的问题"><a href="#养猫的问题" class="headerlink" title="养猫的问题"></a><strong>养猫的问题</strong></h1><p>养猫这个事情，某种层面上来讲和买东西有点类似，最兴奋的一定是选好猫到带走猫的那段时间，随后会有所下降。当真正把猫接回家，首先随之而来的是猫最初的冷漠与害怕，不过对此我已有所准备，并没有过于困扰。当猫咪熟悉了周围的环境，开始大胆的在自己的“领地”进行巡视，更多的问题随之而来，有的猫爱咬线，有的跑爱乱跑，经常会给你捣乱，等等各种问题，像我家的猫在喂猫条的那一天晚上就开始跑酷，第二天也是。与幻想的快乐美好不同，猫一定会带来部分让你困扰的问题。</p><p>除此之外还有很多问题，虽然我早有心理准备的，但还是有还有很多问题实际上比预想的更要麻烦。写到这里想起在真正开始养猫之前的一段时间，我开始问自己，为何要去养猫？自己真的能负起责任吗？<br>最初想养猫自然是因为猫咪治愈可爱，但，然后呢？有的人觉得养宠物可以减少孤独，我一开始也多少带有这样的目的，但当我接回来猫两三天后就意识到对我来说并没有因此产生什么变化，我更寻求的是精神上支撑，而不只是住在一起有一个陪伴。当时我问了养猫的朋友，养猫是为了什么，养猫的意义，养猫的想法，有的朋友说我想太多。我确实是一个非常容易多想的人，容易去想最坏的结果，这样的思考方式面对这种事情或许过于沉重了。<br>另外之前也会屡次自我怀疑是否能负起责任，当我之前在猫咖时，看到有些不那么好看的猫不受欢迎，心里想的是外观的歧视，看到有些智力缺陷的人，我开始对未来的生育恐惧，负责这种事情说起来容易，可是做起来却是无比沉重。害怕自己弃养的念头像怨灵一样纠缠着我，后来也是放下了所谓的道德感，“实在不行就找人领养”，这个事情也就到此作罢。</p><p>过年的期间为了等人在猫咖呆了一个多小时，而这段时间内我突然觉得养猫会不会只是在重复的逗猫，喂食，铲屎这个过程？当我说出这个想法的时候，有朋友说去猫咖和自己养猫是完全不一样的。现在看来自己养的话猫和自己会更熟一些，能玩更多的东西，但是似乎仅此而已了，一周或许还不足以让我这种冷漠的人产生太多的感情。</p><p>养猫需要每天花时间跟猫咪互动玩游戏，逗猫，偶尔还要添食铲屎，同时有了猫以后经常也会不由自主的去rua一会猫，这都会付出许多的时间。我在很多时候是一个时间焦虑很严重的人，在我时间不够用的时候会因为花时间去逗猫陪猫而焦虑，这种焦虑则是我自己需要调整的问题。</p><p>现在回看这些问题和想法，大多没有新的答案，或许还需要更长的时间。</p><h1 id="人与猫"><a href="#人与猫" class="headerlink" title="人与猫"></a><strong>人与猫</strong></h1><p>有一天在家晚上打游戏的时候，露露看起来一直很想和我一起玩，我也只能抽空拿逗猫棒陪陪，打起来了就干脆把逗猫棒给她让她自己玩。游戏打的很不顺利，自己的操作很差还被骂了，她由于想玩也总是过来“捣乱”，我很生气。随后想着逗逗猫缓解一下情绪，拿着逗猫棒带她转了几圈，后来她趴在床上我就使劲rua她的肚皮，即便想跑也要按住继续rua，总觉得自己像个恶魔，觉得她是不是会生我气或者怕我。而第二天我怕她捣乱，直接关上了卧室门，让她无法走到我的电脑前，当我打开卧室门的时候，她看起来就没那么高兴的样子，过来“碰瓷“的概率也变低了。此时我的反应居然是想要讨好。</p><p>和猫相处的过程，对我来说完全暴露出了自己和人相处中的许多问题：坏脾气，控制欲，讨好式相处。在这之前我一直觉得自己会非常宠溺猫咪，不会把脾气撒到她身上，但事实完全打了我的脸，我为此感到害怕，自己竟是这样的恶魔。同时又在想今天我对猫咪会这样，那我明天对关系亲密的人也会做出同样的行为，这是让我感到十分恐慌的。可能有人会觉得猫和人又不一样，在我看来尽管猫咪的智商远不如人并且说不了话，但同样都是有一定智能的生物，都有自己的意识，也会有情绪。</p><p>“猫，在我眼里更像是一个玩具，或者取悦自己的工具。”这个说法很容易受到谴责，但我确实有一刹那感受到这种念头。不论怎么说，我已经养了还是会尽可能对猫咪负责，不会放任这样非常有问题的想法主导我的人格，一切明知有问题的做法还是要尽可能的去修正。</p><p>以上这段内容是在刚养猫一周的时候写的，那段时间情绪有点不太稳定，容易焦虑暴躁。在这之后又过了一个周，我的情绪逐渐冷静下来。这一周也有很多变化，比如她开始不再只局限于卧室了，到处乱爬的现象也变多了，中间因为她乱爬管不住一度觉得自己不适合养猫，一度想放弃，但现在还是逐渐适应家里有猫的生活。</p><p>每个人对待猫的方式都各不相同，我也只是一个不具代表性的例子，还是有很多人非常爱猫，细心呵护自家的猫，将猫当作家人一样对待。那么猫眼中的人是什么样的呢？关于这个事情在网上能看到各种各样的猫视频，也能看到各种各样的段子。有的视频里猫化身粘人精，有的视频里猫则是作为逆子给主人找茬。有天天找主人要食的吃货，也会有“我吃饱了，两脚兽滚出我的领地”的段子。有帮忙带孩子的贴心奶妈，也有叼着孩子给主人的猫妈妈。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/keeping-a-cat/Untitled.jpeg"                      alt="Untitled"                ></p><p>这些有趣的视频和段子，也一定程度上显现出猫看待人的方式，以及让我们窥探到人和猫相处的一些关系，至少都是一定程度的和谐共处，尽管有些“逆子”在，但这就像有的人性格比较难亲近一样。在此基础上更进一步的关系，还是要具体到每个铲屎官和猫主子之间的相处。我和我家的猫相处太少，无法得知我在她的眼中是什么样的，需要更多的时间，以及要我更多去观察和思考她的行为。</p><h1 id="决定养猫的心路历程"><a href="#决定养猫的心路历程" class="headerlink" title="决定养猫的心路历程"></a><strong>决定养猫的心路历程</strong></h1><p>从产生养猫的想法到实际养猫，这个过程算是充斥着矛盾和曲折。最早开始云吸猫的时候我觉得还是有机会每天在家办公再考虑养猫，在几个月前产生了来年要自己整租的念头，也因此开始考虑起有什么是和别人合租没法做到的事情，后来自然而然想到了养猫。之后一段时间我开始研究起了猫的品种，养猫所需要购买的东西。过年期间去猫咖等人的时候则是有了前面提到的对能否负责任的怀疑，年后纠结养什么品种，家里收拾好后又为了想要的品种跑了好几家猫舍。在选好猫交好定金后，更戏剧性的是第二天我开始有水痘的症状，最初我以为是过敏，吓得我之后去了医院，最后医生告诉我是水痘，我又不放心顺便做了过敏源检测，在之后的检测结果中确实有轻微的过敏，这让我更加纠结，选好猫以后的我更多的是想要留下她，而不是像之前那样纠结自己是否真的应该养猫。之后去了猫咖试水，没什么症状以后还是将猫接了回家，在这之后但凡皮肤有些瘙痒的症状我就开始担心过敏的问题，即便我平常也会如此。</p><p>虽然很担心，但目前来看还是能接受的。已经养了的猫我还是会好好养下去，这也是一种人生体验。最后再附上几张我家猫的美照。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/keeping-a-cat/IMAGE_2024-05-20_162505.jpg"                      alt="IMAGE 2024-05-20 16:25:05.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/keeping-a-cat/IMAGE_2024-05-20_162518.jpg"                      alt="IMAGE 2024-05-20 16:25:18.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/keeping-a-cat/IMAGE_2024-05-20_162508.jpg"                      alt="IMAGE 2024-05-20 16:25:08.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前段时间我带了一只可爱的猫咪回家，给她起名为露露。由于是妹妹因此想要用甜品来命名，在到处查看甜品的时候看到各种xxx露，又觉得aa的这种名称形式喊起来比较方便，因此起了这样的名字。她到家的第一天有些怕生，几乎不肯出来，出来的时候路过饭碗也不肯吃东西，看她饿了一天实在心疼，拿</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="Cat" scheme="https://fusionbolt.github.io/tags/Cat/"/>
    
  </entry>
  
  <entry>
    <title>从热辣滚烫到励志故事</title>
    <link href="https://fusionbolt.github.io/2024/02/18/Thinking/relaguntang/"/>
    <id>https://fusionbolt.github.io/2024/02/18/Thinking/relaguntang/</id>
    <published>2024-02-18T09:51:51.000Z</published>
    <updated>2024-03-06T09:54:06.855Z</updated>
    
    <content type="html"><![CDATA[<p>回北京之前表姐喊我吃了个饭顺便拉我去看了热辣滚烫，这部电影最近的热度很高，很大一方面是由于贾玲的变化，一年减下一百斤，对于众多需要减肥的人来说这是非常励志的故事。而我对这部电影的评价是这比起电影更像是另一种形式讲述的个人秀，这是一部爆火的电影，但只是普通的励志故事，故事本身并没有觉得有太多过于精彩的。过多的镜头都是主角一人占据大半个屏幕，这种表现方式将观众的注意力集中在这单一人物上，作为对人物没有那么喜欢的观众来说观感是比较差的，这也是让我觉得像是个人秀的一个原因。不过有一个表现形式确实让我觉得眼前一亮，前面省略的片段都在最后以回忆杀的形式穿插展出。</p><p>观影之前已经知道是贾玲减肥瘦下来的结局，在整个观影过程中励志这个词已经占据了我的大脑，也就很自然的开始思考励志这件事情。许多人都喜欢励志的故事，并且想要像每个故事中的主人公一样“咸鱼翻身”。类似励志的故事也有很多，比如小红书上那位改变形象的小艾同学，还有一位从专科读到了博士生的程序员，等等。对于这部电影来说，想必很多人看了电影以后又会重复“这次一定要减肥”的想法，幻想着自己成功的幻影，但几个月过去了，绝大多数人面对的又是原地踏步的现实。</p><p>这类故事，整个过程大多数是需要漫长的时间以及克服重重困难，甚至一直需要违背人类的天性，才可能到达目的地，做到的人少之又少，也因此会被人们所赞叹。在现实中痛苦挣扎着的人们，总需要些什么作为支撑，哪怕是虚无缥缈的幻想。不过即便是空虚的幻想，如果能促进自己前进一厘米，那也没什么不好。</p><p>希望读到这里的你，也有一天成为专属于你自己的励志故事中的主人公。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回北京之前表姐喊我吃了个饭顺便拉我去看了热辣滚烫，这部电影最近的热度很高，很大一方面是由于贾玲的变化，一年减下一百斤，对于众多需要减肥的人来说这是非常励志的故事。而我对这部电影的评价是这比起电影更像是另一种形式讲述的个人秀，这是一部爆火的电影，但只是普通的励志故事，故事本身</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>再读某书的联想</title>
    <link href="https://fusionbolt.github.io/2024/02/16/Thinking/thoughts-inspired-by-a-book/"/>
    <id>https://fusionbolt.github.io/2024/02/16/Thinking/thoughts-inspired-by-a-book/</id>
    <published>2024-02-16T09:51:40.000Z</published>
    <updated>2024-03-06T09:54:44.241Z</updated>
    
    <content type="html"><![CDATA[<p>因为之前的一条推文，我又想起了阿德勒的 被讨厌的勇气 ，上一次看大概还在两年前，当时的我觉得醍醐灌顶，但只是读过书中的内容，自己并没有什么观念上的变化，只对几个少数几个观点有深刻印象。</p><p>现在的我再回头看，依然觉得这些内容很有道理，但发现自己在很多事情上的观念都已经在潜移默化的改变，思考方式已经和书中的内容产生了许多相同之处，然而这个改变并不是读了那本书所直接带来的，而是我持续关注类似的内容，以及数不尽的胡思乱想所堆出来的。</p><p>其中很多结论在其他的地方只是换了个名字，本质上都是相通的，一个方面中真正重要的东西或许都是如此，不论你在哪里总会看到，只是它们换了不同的马甲，而你一开始或许真的无法识别出换了马甲的它们。</p><p>比如说关注当下这件事情，除了这本书外我还有两个印象深刻的事情。第一件事是在欧文亚隆的 成为我自己 这本书中提到这样一句话：过去的回忆和未来的憧憬，只会使人不安。另一件事是在播客中听到的，两个嘉宾在讲述什么时刻最幸福时，其中一个嘉宾提到在村口坐着看着村里的小孩子们到处跑动玩耍，什么都不考虑，只是这样而已，那个时光是非常幸福的。另外还有所谓的专注体验和心流理论，现在看来这一切其实都在指向<strong>关注当下</strong>这个答案。</p><p>看到了自己观念无形中的改变，又联想到自己一直想要知道某个东西到行动或者改变的障碍如何破除，以及学习方面真正跨越从知道公式到实际行动的鸿沟。最近看到了一岁半的外甥，让我联想到了学习数学的过程，从最初的九九乘法表，到后面复杂的积分等计算方式。如果现在的我没有这些，我可能学完公式就直接套公式计算，不会做什么题，整个知识结构非常不稳固，当年学习数学的时候每个过程都有大量的练习，因此产生稳固基础，逐步走向了后面。</p><p>这是一个神经建立连接的过程，对应的神经通路在多次的使用后会更加强大，更容易与更多的内容建立起连接。不论是强化神经通路还是和其他内容产生连接，也都和上面提到的 关注当下 相关内容体验一致。</p><p>这些结论在学习方法的书中或多或少都有所提及，但是如同文章一开始提到的一样，可能只是读完了，并没有让自己在思维方式上产生变化，这篇文章也算是一种和那些内容的连接。</p><p>那么对于之前没有产生改变的我，读完这本书的时候有什么用吗？没用，但又有用。我接触到了这些知识，尽管只记住了一些无关紧要的内容，并且没有发生观念转变，但这是大脑转变过程中的一小步，另外我回顾的时候又联想产生如此多的想法，产生了意想不到的效果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为之前的一条推文，我又想起了阿德勒的 被讨厌的勇气 ，上一次看大概还在两年前，当时的我觉得醍醐灌顶，但只是读过书中的内容，自己并没有什么观念上的变化，只对几个少数几个观点有深刻印象。&lt;/p&gt;
&lt;p&gt;现在的我再回头看，依然觉得这些内容很有道理，但发现自己在很多事情上的观念都</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>2023年终总结</title>
    <link href="https://fusionbolt.github.io/2023/12/31/Summary/summary-2023/"/>
    <id>https://fusionbolt.github.io/2023/12/31/Summary/summary-2023/</id>
    <published>2023-12-31T10:25:06.000Z</published>
    <updated>2024-01-01T10:31:36.404Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉2023年也走到了尽头，按照惯例年底还是要写一篇年终总结。</p><h1 id="去年的目标"><a href="#去年的目标" class="headerlink" title="去年的目标"></a>去年的目标</h1><p>去年的年终总结中列了一大堆“明年的愿景“，而实际做到的，大概只有一半左右。现在回看，目标这种东西应该经常拿出来看才对，我去年只是随意的列下了一些目标，并没有针对目标做一系列切实可行的任务规划，也没有定期回顾。这也算是我的一个老毛病了，我每次定完什么计划都是这样，实属有些困扰。因此觉得没必要详细去在这里再回顾了，在后面涉及相关内容的时候提及一下即可。</p><h1 id="今年"><a href="#今年" class="headerlink" title="今年"></a>今年</h1><p>今年的各方面是相对平淡的一年，过的没有太多的变化，也许是因为彻底适应了北漂的生活。但五月以及最后两个月都是比较差的状态，不论是学习、工作还是生活都过的不太好。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>今年多少学了一些知识，但总觉得这些内容对于一年的跨度来说还是太少了。</p><p>首先是关于博客，本以为今年会比去年有更多的产出，但mold系列结束后来我开始为写博客这件事情产生了很多焦虑，比如说自己的知识掌握的并不全面这样最典型的问题，另外也有周末的时候一直处于什么都不想做的状态，这个也有一定的关系，我没想到最后两个月自己精神上会痛苦成这个样子，果断选择了最懒散的一条路，什么也不做。除此之外还有很多坑没有填，感觉大概率都会淹没在笔记之中。</p><p><a class="link"   href="https://homura.live/2023/11/22/Other/anxiety-of-blogging/" >https://homura.live/2023/11/22/Other/anxiety-of-blogging/<i class="fas fa-external-link-alt"></i></a></p><p>之后是读书方面。今年被黑塞的作品深深吸引住了，尤其是《荒原狼》和《德米安》，最可惜的是我没能为德米安写一篇文章，而《悉达多》则是写了一半就没写下去了。其中我还参与了线下的读书会讨论了其中的两本书，了解到了各种各样的观点。</p><p><a class="link"   href="https://homura.live/2023/07/30/first-look-at-hesse-literature/" >https://homura.live/2023/07/30/first-look-at-hesse-literature/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/05/04/Reading/def-steppenwolr/" >https://homura.live/2023/05/04/Reading/def-steppenwolr/<i class="fas fa-external-link-alt"></i></a></p><p>《红与黑》的故事我觉得也很精彩</p><p><a class="link"   href="https://homura.live/2023/07/30/Reading/the-red-and-black/" >https://homura.live/2023/07/30/Reading/the-red-and-black/<i class="fas fa-external-link-alt"></i></a></p><p>除此之外还有一些其他作品，有一些毛姆的作品，读下去以后不是很有兴趣，但书买都买了，随便读读吧。还有今年开始了读了一点《卡夫卡》相关的作品，不得不说确实难懂，但是有的文章一旦get到了作者的点还算是能够理解，另外内容比较压抑，我倒是挺喜欢这种不那么“积极向上”，揭露黑暗面的内容。除此之外还零零碎碎读了一些，有的有所记录，而有的也只是读完罢了。</p><p><a class="link"   href="https://homura.live/2023/05/03/Reading/thr-outsider-by-albert-camus/" >https://homura.live/2023/05/03/Reading/thr-outsider-by-albert-camus/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/04/18/Reading/Stoner/" >https://homura.live/2023/04/18/Reading/Stoner/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/04/17/Reading/never-let-me-go/" >https://homura.live/2023/04/17/Reading/never-let-me-go/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/04/09/Reading/1984/" >https://homura.live/2023/04/09/Reading/1984/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/02/19/Reading/brave-new-world/" >https://homura.live/2023/02/19/Reading/brave-new-world/<i class="fas fa-external-link-alt"></i></a></p><p>在代码上，今年自己的编程语言略微做了一些更新，很惭愧并没有写多少代码，只是添加了部分小功能，尝试添加了一些分析和优化的部分。另外是为其实现了一个language server，这个过程算是也踩了许多的坑。还读了mold的源码，顺便更新了一系列的博客，对于链接器做的内容有了更多的了解，只是从读到写是质变，目前学的还非常肤浅，希望未来有机会能参与实际工作去强化相关知识。还花了一点时间回顾了半弃坑的os，读了部分xv6的代码，修了部分之前留下的bug。以及大概了解了一下GPU的架构，年底开始看ssa book，整体看起来并没有做多少事情。</p><p>练琴方面今年上半年状态还可以，之前看到推友在推特练琴因此也开始学习这种方式，对于练琴的效率还是有提升的，但是今年最后两个月不论是练琴时长还是效率都比较差劲。音阶已经练到了最后一个，哈农也只差两三个就结束了，其他的练习曲也都或多或少有所进展。学琴快两年，但我依然对音乐一无所知，练琴的时候也总是出现很多各方面音乐基础相关的问题，比如说听不出好坏，节奏有问题等等，不过那得去学音乐基础而不是钢琴演奏了。</p><p>拍照上今年几乎没怎么出门拍，过年回老家，五一去植物园，夏天雨天去了颐和园，国庆节前后出去。尝试投稿几张照片到视觉中国，但是全军覆没。到了八月的时候也没能去拍流星雨，没有比较好的拍摄条件另外自己也没有想方设法去创造这样的条件。</p><p>八月底因为一次经历让我很难过，想要去改变，遂开了一个频道督促自己，虽然有的时候做的很少，但是确实一直持续了，健身环一直持续到了现在，明年也会继续通过这个频道试着去改变自己。</p><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>日常生活几乎没什么变化，依然是工作日上班→下班，周末一天上钢琴课一天宅家，持续这样的循环。周末的心理咨询感觉对自己没有太大帮助，因此在4月就已经停掉了。九月底的旅行，可以算是今年中最特别的事情了，细节都在之前的博客中，无需再进行概述。</p><p><a class="link"   href="https://homura.live/2023/11/05/Life/first-travel/" >https://homura.live/2023/11/05/Life/first-travel/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2023/11/05/Life/travel-meditations/" >https://homura.live/2023/11/05/Life/travel-meditations/<i class="fas fa-external-link-alt"></i></a></p><p>今年的开支上少了非常非常多，根据信用卡的数据来看整体减少了30%多，虽然还没有把最后两三个月的账整理完，但大概支出项目多少心里也有数。现在没有太多购物的需求，支出的大头还是衣食住行这种必须的开销，由于今年没什么消费需求因此衣食住行上不再那么省。最大的开支还要属前面提到的旅行，其中包含节假日所以住宿特别贵。</p><p>其他方面大多都没什么变化，上半年大胆尝试了两次女装出门，不过后来因为颜值焦虑还是决定不再做这样的事情了，尝试化了一次妆但也是因为做的不好就劝退了。</p><h2 id="娱乐"><a href="#娱乐" class="headerlink" title="娱乐"></a>娱乐</h2><p>今年还打了不少的游戏，可能也和这种精神状况有关。艾尔登法环，王国之泪，宝可梦dlc，血源，等等，算下来整体的游戏时间可能也有几百小时了。</p><p>动画也是看了很多，尤其是在周末的时间和状态不好的时间，一不小心就会看上一个小时，甚至几个小时。今年看的非常棒的动画，一个是全职猎人，另一个是年底的葬送的芙莉莲。</p><p>虽然娱乐本身并无过错，但算到这里的时候还是会在想如果这些时间自己肯拿去学习会怎么样。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>工作上我自己不太满意，不论是工作的内容，还是工作时间的我自己。感觉不到什么进步，停滞不前，一切渐渐开始如同《毫无意义的工作》中所言。年底开始寻求新的机会，试着面试了几次，但是发现面试官对简历上的东西有所了解后，最看重的反而是自己side project的部分，从面试中算是对于自己在相关应聘中的竞争力有个初步了解，同时也意识到了这样下去是不行的，明年无论如何都必须做些什么推动这一切。想要工作中继续得到成长，这或许是一个奢侈的欲望，但不论如何我不能这样继续下去了。</p><p>今年有印象的事情大概就这些了吧。</p><h1 id="明年"><a href="#明年" class="headerlink" title="明年"></a>明年</h1><p>明年有一些迫不及待的事情，首当其冲的就是整租的计划，我实在不愿意继续合租下去了，公共区域因为个人细微的习惯不同会有很多问题，另外只租主卧太过于狭窄，等等各种方面的原因。整租随之而来的就是可以养猫，也就有了明年养一只小猫咪的计划，有一只猫咪陪伴着自己或许各方面状态也会好很多。</p><p>鉴于对工作的不满意，加上可能产生的变动，对明年的新工作有所期待，可以学到新的东西，但同时也十分担心能不能找到满意的工作并且顺利入职。</p><p>明年想要打网球，我一直都很喜欢这项运动，只是目前一直住的很偏僻，很难有什么机会，明年的话会更换住所，或许会有一些机会。</p><p>一个很重要的想法是身心精神状态能好一些，不过每年都在想这件事情，每次都没见有什么好转，尤其是今年的状态实在太差了，但我也并不知道该如何能走出来，只能看一步走一步了。</p><p>每年都很渴望亲密关系，每年都很渴望自己能变强，但每年都没有收获。2022是如此，2023是如此，2024或许仍然会如此吧…已经不敢对这些事情产生什么奢望了。</p><p>目前来说真正算得上目标的可能就如下两点</p><ol><li>很想研究卡夫卡的各种作品，甚至包括相关的出版物。我没有想过从他的作品中得到什么经验，只是单纯很喜欢他笔下作品中的“灵魂“，至于那是怎样的我无法用准确的语言描述。</li><li>认真研读ssa book。要想在编译器继续做下去，这是必须要学会的东西，在面试中因此吃了不少亏，虽然年中的时候三分钟热度想要看下去，但一直拖到了年底真正吃亏了才真正开始看起来。</li></ol><p>其他的方面，希望至少维持现状吧。下一年才刚要开始，我依然处于十分迷茫的状态，因此也无法定下更多的事情，但是至少上面的事情没什么好迷茫的，去做就不会后悔。</p><p>今年的内容有些悲观，也许是因为我最近正处于这样的状态，对事物的解读以及所想到的东西都染上了悲观的色彩。</p><p>至于明年，自己将会再次转动命运的齿轮，走向未知的未来。</p><p>如果你感兴趣的是我的年终总结，那么你读到这里就可以结束了。我的年终总结相比他人来说没有那么多华丽的语言和引人共鸣的感悟，有的只是死板又无趣的流水账。很想写点什么，但我却想不出来，写不出来。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2023/729B547A-7686-4750-9A69-517AFE7A1435_1_105_c.jpeg"                      alt="729B547A-7686-4750-9A69-517AFE7A1435_1_105_c.jpeg"                ></p><p>这里开始的内容多半是你不感兴趣的，此时你已经可以视为文章已经结束。思来想去，还是将这部分内容放在一起，不单独列一个文章了。</p><h1 id="今年的我"><a href="#今年的我" class="headerlink" title="今年的我"></a>今年的我</h1><p>对于我来说，每年更重要的可能是自己有什么变化，今年相比去年变差了很多，内容也消极了很多。</p><h2 id="精神重创"><a href="#精神重创" class="headerlink" title="精神重创"></a>精神重创</h2><p>一整年中，绝大多数时光都没给我留下什么印象，但五月前后和十一二月除外。</p><h3 id="亲密关系的不可能"><a href="#亲密关系的不可能" class="headerlink" title="亲密关系的不可能"></a>亲密关系的不可能</h3><p>五月前后的时候，发生了一件稀疏平常的小事，但我“破防”了。推特上被人回复了一条内容，我就不引用原文了，也没有指向原推主的意思，在我这里高度抽象化后的大意是”我<strong>不可能</strong>找到属于自己和异性之间的亲密关系了“。不论是事情本身还是言论本身，对大部分人来说可能都没什么，但对容易胡思乱想且祈求这种亲密关系的我无疑是一个重磅炸弹，在那之后的一个月我都没什么精神。虽说我自己已经能预见自己一个人的未来了，但被人这样说，还是很难以接受。</p><h3 id="能力的不可能"><a href="#能力的不可能" class="headerlink" title="能力的不可能"></a>能力的不可能</h3><p>十一二月的我已经在看就业的市场行情了。断断续续也投了或者面过一些，其中出了很多状况。十一月开始，朋友帮我内推字节，简历给leader看过，但是因为学历被HR拒绝了；内推腾讯出了很多篓子，先是没面试就收到了面试不通过的邮件，之后面试还有一些问题没答好。（当然我并不是目标放在大厂上，只是恰巧有机会就试一下。）其中不论哪一个环节都很让人受折磨，面试失败是再正常不过的事情，只是一些没面就先被刷掉的情况确实让人很受打击。到了十二月，面了另一家公司，一天面完了整个流程，二面答的自认为比较差劲，但是那些内容都相对比较考验实际经验，对于经验缺乏的我来说并不能好好答出来，尽管之后也收到了面试通过的邮件。而在此之后明显是因为我面试的表现不是太好，即便是发邮件询问也很难得到一个稳定的offer，甚至被hr套路了。</p><p>面试出现各种问题也是在所难免，而我痛苦的并非是面试失败，而是在这背后体现出的自身的无能。在这整个相关的过程中我一直在为自己的无能而无奈，气愤，痛苦，也认为自己会永远这样无能下去，<strong>不可能</strong>再发生什么改变。</p><h3 id="希望的扼杀"><a href="#希望的扼杀" class="headerlink" title="希望的扼杀"></a>希望的扼杀</h3><p>所有希望都被扼杀的生活是很可怕的事情，意味着前方再努力也不会有变化，只要有这样想的苗头，为数不多的力量就会都流失了，不论是哪件事情，<strong>问题的来源全被我指向了我自己</strong>，不论是自己学历差，还是自己能力的不足，又或者是自己歪曲的想法。</p><p>这些时间我几乎没法正常跟人聊天，不论看到什么，总会联想到自己哪里做的不好，哪里做的不够，别人能做到我却做不到，诸如此类，甚至会说出一些充满恶意的话。而最痛苦的那一阵时间，甚至会丧失生存的欲望，甚至屡次说出“希望有人来杀了我”之类的话。</p><h2 id="当下的无助、痛苦"><a href="#当下的无助、痛苦" class="headerlink" title="当下的无助、痛苦"></a>当下的无助、痛苦</h2><h3 id="感受不到正面能量"><a href="#感受不到正面能量" class="headerlink" title="感受不到正面能量"></a>感受不到正面能量</h3><p>之前我都没有注意到这个问题，当我思考总结该写什么的时候才逐渐发现。这些内容中几乎没有什么正面的故事，而我这一整年也确实没什么好的经历，最多只有日常偶尔的一些小快乐，但又都像石头扔到大海中一样溅起一些小水花，随后又会被大浪所冲走。</p><p>那么日常生活中的我，其余时间都在什么状态呢？</p><ol><li>专注做什么。包括工作、学习、兴趣爱好、和别人交流等，专注于当下。</li><li>发呆，什么也不考虑，什么也不去做，或者是在想一些不会太痛苦的事情。</li><li>不专注的做事情，此时会有很多的精力分配在对自己当下行为的评判上，也是非常容易痛苦的时候，还是拿上面说的年终总结的例子，如果我非常专注的写，那么也就不会有精力去思考评价自己的内容，也就不会说写的过程还会伴随着巨大的痛苦。</li><li>纯内耗。这种时候已经完全陷入了痛苦的状态。</li></ol><p>即便是专注做事情，做了的事情视为理所当然，没做好的事情就会进行自我责备。没有来自外部的激励，不过即便有我也一样会视为应该得到的。</p><h3 id="人、亲密关系、对立"><a href="#人、亲密关系、对立" class="headerlink" title="人、亲密关系、对立"></a>人、亲密关系、对立</h3><p>今年依然是没有亲密关系的一年，我和别人相处的过程依然十分扭曲，追求亲密关系这种事情我仍然过分的渴求，但仍然不可能得到。和人相处的过程中逐渐意识到自己并没有想象中的那么高尚，不求回报的付出还是做不到，向别人付出的时候还是想要精神层面的回报，没有得到回报的话就会有所畏缩。前几天的我痛苦到了极致，也不知道该寻求什么人的帮助，不过我也很难想象如果有亲密关系我会愿意寻找对方，自己非常害怕继续依赖于某个人，对于我这种不稳定的频率来说，一定会影响到对方。</p><p>另外今年向许多人伸出了自己的刺，戳到了许多人，倒也不是说想要故意刺伤别人，而是我和他人的关系来说很难不刺到别人。我本身精神状态的不稳定，以及不习惯和他人私聊，等等许多方面，一个人呆惯了真的不适应有另一个人和自己的私人时间产生交集，除非是我主动想要和某人建立什么联系，仿佛“舔狗“一般。</p><p>今年约见了许多推友，有的是第一次见，有的甚至第一次认识，有的是认识好久未见过，有的是见过数次，有单独见面，也有见很多人的时候。单独见面的情况下聊天一般没什么问题，但是多人见面的时候依然会有自我回避的毛病，也总会产生自己无法插上话的感觉，自顾自的陷入了自闭的状态。</p><h3 id="极其强烈的虚无感"><a href="#极其强烈的虚无感" class="headerlink" title="极其强烈的虚无感"></a>极其强烈的虚无感</h3><p>从八九月开始这种感觉格外的强烈，也许是因为迷茫，也许是因为状态不好，缺少行动的动力，并且缺少什么正面反馈。</p><p>第一次是在旅行的过程中</p><p><a class="link"   href="https://homura.live/2023/11/05/Life/travel-meditations/#%E6%97%85%E8%A1%8C%E7%BB%93%E6%9D%9F" >https://homura.live/2023/11/05/Life/travel-meditations/#旅行结束<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>在最初提到了旅行前感受到的无意义感，而旅行过程中无意义的感受又数次涌上心头。</p><p>有一次在和朋友一起吃美食的时候，有一个瞬间我感到格外空虚，无意义，只觉得十分美味的食物吃与否在大部分情况似乎没有什么太大的区别，除非肠道细菌反复催促你去吃。而在吃饭时是否进行交流似乎也没有什么区别，除非我感到孤单需要找人讲话。和我一起的人们可能不可能会产生这样的感受，他们很重视美食，而我则是一个对美食不太讲究的人；他们很注重人和人之间的联系，而我却对这件事情过于冷漠，和别人产生联系甚至会觉得是因为自己心血来潮（当然这并不准确）。</p><p>在约见另一个朋友吃饭的时候，突然觉得是否不约见也无所谓，甚至不认识也是无所谓呢？交朋友对于个人社会生存以及社会关系是有益的，但是对于“我自己”呢？我作为一个弱小的个体可能需要这些益处，但作为我自己来说如果没有任何压力的话，会想要远离和人的关系。这和我的童年过往有所关联，现在也就这么延续了下来。</p><p>在旅途的时候，似乎也出现过认为我是否在城市里，在景点里游玩是完全无所谓的事情，我这次出来纯粹只是为了好奇，体验全新的事物罢了。</p><p>现在看来这些全都是为了满足身心的需求。我是一个认同“人生无意义”这个观点的人，既然活着那就遵循“在不会被警察叔叔带走的情况下满足自己”这个规则去行动，去满足自己的需要，另外满足自己的部分欲望，我的行动、想法与解读，现在看来似乎也是满足这一切的。</p><p>旅途中的这份无意义感或许是想要传达给我什么东西，当然也可能是纯粹的无意义，但我可能不得而知了，现在已经结束了旅游，回到了熟悉的日常生活，回到了熟悉家里，等待着我的或许是另一种的无意义感，但这已经是另一份感受了。现在写这篇文章时我仍然会觉得毫无意义，我为什么要开始写呢？也许是想要拙劣的模仿我的一位朋友，但不论如何既然想写了那就写下去吧。</p><p>数量众多的无意义感，我不知道应该如何面对它们，但不论如何它们或许会陪伴我一辈子，或许也不会有任何答案，只是这样存在罢了。</p></blockquote><p>之后这种感受断断续续掺杂在生活中。前两天的我这种感受又强烈到顶点且想要写下些什么，因此有了下面这段内容。</p><blockquote><p>一如既往吃完了晚餐散步，但突然觉得无比虚无，也许是因为最近的工作让人没有干劲，一天天无所事事，也许是因为生活过于无聊，没有什么乐趣，也没有什么正反馈。</p></blockquote><blockquote><p>每天上班等下班，工作日等周末，每个月等着月底的工资，经常想着最近的长假是什么时候，又或者考虑着今年的年终奖怎么样。我们只是度过这些时间，对于工作的人，学生，似乎都是如此，工作的人为了收入，学生为了学业和学位。有的时候只需要度过这段时间，有的时候需要去做些什么，如果只是等待时间流动，是多么痛苦的事情。</p></blockquote><blockquote><p>这让我想起之前看的书里提到的，“人意识到自己能对周围的影响”，而我似乎正属于一种对一切都不会产生任何影响的状态，并且有着极强的挫败感，也没什么兴趣可言。如果我此时不需要工作了，那我会干什么呢，我也不知道，可能还是什么都不想做，只是去浪费时间罢了。这让我想起了自己曾经做过的一个印象深刻的梦：梦到自己死了，死后在一个无底洞中坠落，看不到底和周围，而我只是在一边下落一边感受着自己此时的感受，就这样一直持续下去，不会痛苦，只是存在罢了。</p></blockquote><p>内容算是写了一半，但我也没有想继续写下去的想法了，就这样吧，或许一切都不会有答案。</p><h3 id="药物治疗"><a href="#药物治疗" class="headerlink" title="药物治疗"></a>药物治疗</h3><p>今年从五月份的那次重创后感觉药物已经没法正常发挥效用了。和大夫沟通并调整了药物，从三片文拉法辛到开始加入艾司西太普兰。但是到了年底，在十二月中旬的时候我再次被重创到感觉要承受不下去了，因此减到一片的文拉法辛又加到了两片，甚至大夫还告诉我如果还这样反复的话最好去住院治疗。但我想，即便再怎么依靠药物和住院治疗，我自己的弱小和无助感，所缺乏的亲密关系和情感支撑，都不会有所改变，这对我来说才是最需要解决的，但又是无力解决的。而且一个很重要的问题是对于一个社畜来讲，因为精神疾病住院一个月，从各种方面来讲都不太妙。</p><h3 id="对自我无能的怨恨"><a href="#对自我无能的怨恨" class="headerlink" title="对自我无能的怨恨"></a>对自我无能的怨恨</h3><p>这对我的影响比缺乏亲密关系还要强烈，但或许如果有亲密关系这也能一定程度的缓解。如同之前所说，我对自己的无能十分怨恨，甚至认为不可能改变。</p><p>我对能力追求的来源有两方面，一个是人希望变好的本性，另一个是变强才会更容易被人喜欢被人接受。这都是相对比较正常的，即便是后者也仍然算在正常的界限内。但更病态的想法存在使得我完全成了一个“疯子”，我需要满足自己是完美的这一想象，当现实和想象分裂开，人的自我同时也会被撕裂，进而导致了巨大的痛苦，也因此这种追求不再是一种动力，而是一种毒素。</p><p>现在的我又很难有什么进步，自己对一切事情提不起兴趣，没有行动力，没有目标，自认为需要别人推进一把但似乎也不可能找到这样的人，这些困难也是我无法解决的。这样难以进步的我，与急需前进的我，又产生了不可调和的矛盾，我只能夹在这些问题之中被撕裂，被打碎，却又无能为力。而我在和人交流中的表现，使得目前只能由自己来想办法苟活在这里。</p><p>内心如此破碎的我，很难有什么正常的言行，许多时候需要去抑制，但这终归不是什么办法，而这更加助长了我在人际关系之中对他人的负面影响，<strong>很多行为全都是为了缓解自己的“痛苦”而“迫不得已”</strong>。当我看到自己这样做的同时，又会给自己施加更多的压力，一切都在恶性循环之中。而这些循环，在这一年<strong>没有发生任何质的改变</strong>，没有从任何一层开始瓦解。《神经症与人性的成长》这本书中提到，治疗的方法在于书中所讲所有内容，需要彻底的理解，不是从文字意义上，才能真正解决，或许我还要做更多的努力吧。</p><h2 id="一切一如既往"><a href="#一切一如既往" class="headerlink" title="一切一如既往"></a>一切一如既往</h2><p>我一如既往的无能，缺爱，自卑，懒惰，一如即往的像个孩子，尽管已经25岁了，但某些不好的地方和15岁时为来某样东西大喊大叫的我没什么差别。这么多问题，大多来自同样的根源，一切都是缠绕在一起。尽管近年来外观看起来不同了，但内核仍未发生什么变化。我至今无法抓住那个根源，也无法梳理好这缠绕的一切，总是处于一片混沌之中。不断的重复选择一根藤蔓尝试剪断，但刚开始没多久又选择拿起另一根藤蔓，最后不仅没有一根藤蔓脱离开，反而被我搞的越来越乱。</p><h2 id="对未来的迷茫"><a href="#对未来的迷茫" class="headerlink" title="对未来的迷茫"></a>对未来的迷茫</h2><p>对人生的探索，我越来越迷茫，不知道想做什么，怎么做好，太多的时候处于一种放弃一切的想法。在旅游之后，意识到自己是多么讨厌坐班，但是自己却又没有任何能力不去坐班。不论是足以让我不上班的底气，还是一个人在家的颓废状态，即便我不工作，我也无法好好的。也许现在的我，无法探索到任何答案吧，至少要先破除困境才行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知不觉2023年也走到了尽头，按照惯例年底还是要写一篇年终总结。&lt;/p&gt;
&lt;h1 id=&quot;去年的目标&quot;&gt;&lt;a href=&quot;#去年的目标&quot; class=&quot;headerlink&quot; title=&quot;去年的目标&quot;&gt;&lt;/a&gt;去年的目标&lt;/h1&gt;&lt;p&gt;去年的年终总结中列了一大堆“明年的</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>写博客的焦虑</title>
    <link href="https://fusionbolt.github.io/2023/11/22/Other/anxiety-of-blogging/"/>
    <id>https://fusionbolt.github.io/2023/11/22/Other/anxiety-of-blogging/</id>
    <published>2023-11-22T13:08:47.000Z</published>
    <updated>2023-11-22T13:10:43.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写博客的焦虑"><a href="#写博客的焦虑" class="headerlink" title="写博客的焦虑"></a>写博客的焦虑</h1><p>博客的内容，很大程度会将一个人的许多方面展现出来。而我此时对于博客的焦虑，也是如此。</p><p>事情的起因是这样的，碰巧看到了某个大佬的博客，从2005年就开始更新一直写到了现在，并且每个月都保持非常高的更新频率。这让我被焦虑感熟练地挟持，不敢想象以后还在写的自己，另外自己的更新频率如此低。点开了早期的博客后发现部分文章内容比较少，自己松了一口气，一段时间后理性重新恢复了掌控，纠结这些东西其实是没有必要的。</p><p>当想法产生后没多久我决定将这些内容记录下来，同时也会强迫自己对于这个问题思考下去。</p><p>我的博客有些时间没有常规更新了，最近几个周也恰巧注意到这个问题，甚至这个想法发生的时间点我已经在准备把之前积累的一点点东西整理一下，同时还在考虑一些问题。</p><ol><li>我是负面想法很重的人，在想一些负面的东西要不要写。</li><li>整理博客的时候，一些内容会纠结要不要放上去，有的内容因为比较短，有的内容因为不那么“好”。</li></ol><p>回到正文，我考虑的这些问题，本质上或许都是想要依靠文章数量和文字数量来做一个非常简易的评价。从数量和文字的层面进行评价，或者说好评，就能掩盖住自己对于博客的一些相对负面的评价。包括但不局限于</p><ol><li>自己的想法太少</li><li>觉得自己内容不佳，包括博客用词、排版、以及介绍的方式等。</li><li>觉得自己水平不佳，写的很多东西自己可能不够熟悉甚至会误导别人。</li></ol><p>可能有的人会觉得这是完美主义，但我觉得并非如此，只是在一味地进行批评罢了，如果真的是完美主义那不可能说放任自己写一些只是<strong>看起来好</strong>的文章。</p><p>除此之外，三个月前我还写下了这样的内容一直没有整理</p><blockquote><p>读代码的博客引用源码似乎也没问题。各种博客写到现在感觉慢慢能写点了，我一直没什么意见和想法，也不太能表达这些，所以只会引用源码分析里面怎么做，也不知应该说什么其他的。其他读书的博客，其实也都是强行逼着写，把很多零散的碎片组合起来，所以内容连贯性不强，很难做到一次写一大段内容…<br>也因为这些不足，加上写的时候很没耐心，我的文章里面很容易出现很短的一段。那些能有那么多自己的想法和内容输出的人真的很厉害，而我最多只有把别人的抄过来，读书的博客也很容易写成摘抄，以及总结剧情，很想避开这些，多写点自己的想法，但我真的没东西说，像极了和别人一起的时候没话说的样子<br>刻意去练习又不太好安排，因此一直这样，还是只能多去逼着自己写下对一些事物的看法，得多写一点技术类，读书类之外的内容，比如说对一些事情的看法等，可能这对我来说是相对好做到的，除此之外也不知道还有什么好办法</p></blockquote><p>里面完全都是类似的焦虑。追求写好这件事情我相信是人性使然，也确实需要去思考如何才能写好，但是过于在意这些或许反而会引起更多烦恼。写好技术文是重要的，但去表达自己同样如此，对我这样焦虑的人来说这之间的取舍还是有些困难的。</p><p>说了那么多内容好坏，以及类别的问题，那博客到底要写什么呢？<strong>理性</strong>地说一定是因人而异的，只要是你想要输出的，想要表达的，都可以。但是对我来说，“感性”，又或者在某些方面的缺失，<strong>迫使</strong>我想要写“<strong>好</strong>”文章。好这个字则显得非常宽泛，略微具体点来说就是“内容长”，”看起来高深“，这种看起来好就可以的东西。技术文更需要的是自己去搞明白某个东西而不是长度，思考文则需要的是捋顺自己的思路以及表达出自己，无论哪一类都不应当是为了内容数量而去，更何况有些内容使用过多的文字反而显得更搞不清楚本意。</p><p>对我来说，只要有办法破除掉自身想法的强制性，后面自然就会知道要怎么做了。结论看起来很简单，但距离做到还非常遥远啊，我还远远不够成熟，像一个小孩子一样，期待着有更多的读者，有更多的赞扬，而大佬们的博客是在非常纯粹的分享想法，即便最初的内容也是如此。不知这样的我何时才能达到那样纯粹的输出内容呢？另外对于写好文章这件事情也是一定会有所追求的，我何时才能真正能写出好文章呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;写博客的焦虑&quot;&gt;&lt;a href=&quot;#写博客的焦虑&quot; class=&quot;headerlink&quot; title=&quot;写博客的焦虑&quot;&gt;&lt;/a&gt;写博客的焦虑&lt;/h1&gt;&lt;p&gt;博客的内容，很大程度会将一个人的许多方面展现出来。而我此时对于博客的焦虑，也是如此。&lt;/p&gt;
&lt;p&gt;事情的起</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="Blog" scheme="https://fusionbolt.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>旅行沉思</title>
    <link href="https://fusionbolt.github.io/2023/11/05/Life/travel-meditations/"/>
    <id>https://fusionbolt.github.io/2023/11/05/Life/travel-meditations/</id>
    <published>2023-11-05T09:55:38.000Z</published>
    <updated>2023-11-05T10:00:33.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="出发前"><a href="#出发前" class="headerlink" title="出发前"></a>出发前</h1><p>在九月底，我开启了一场为期半个月的旅行，旅行的路线是从北京出发，途径广州、深圳、上海、杭州，最后再回到北京。作为第一次出门旅行来说算是略有挑战，选择了那么多城市，同时有许多事情会是第一次面对，需要花不少时间去做准备，包括但不局限于行李准备、行程时间、酒店规划，交通方式、景点规划。</p><p>这次旅行算是在很久之前就有了打算，八月底开始匆匆忙忙做准备，周末都会花时间去做一些规划。许多事情没有经验，也浪费了许多时间在一些不必要的事情上，但旅行已经结束的我看来，作为第一次旅行还算成功。我并没有像网上那样做了十分详尽的规划，具体到几点去什么景点玩，只是大概选了一些感兴趣的点，随缘去逛一逛。</p><p>旅行也不必搞的那么紧张，更何况我这次旅行的目的之一是想着去看一下南方的城市。作为一个典型的北方人，就像没看过雪的南方人一样，对那未曾去往且气候相异的城市感到好奇。另外则是想要去见一些未曾见面以及或者是许久未见的朋友。就这两个目的来讲，也算是都圆满了，感受到了南方的气候，尝到了许多美味的食物，还见到了许多的人。</p><p>“将要旅行”这个想法，从开始规划到出发前一直在围绕着我，有对行程的期待，也有对一切能否顺利而感到不安。</p><p>除此之外，出发的前几天还有种难以描述的强烈感受，整个人有些像一个即将迎来假期的孩子。面对临时下发的任务则像是应对期末考试一样紧张，当任务完成时也像一个考完试的孩子一样松了一口气，这个阶段似乎一直在向未来寻求透支些什么给自己。尽管自己明知即便旅行开始，一切也不会有那么强烈的变化，我还是我自己，不会因为这件事情发生而改变。也许我只是想要从当下逃离，将一切托付给未来的自己吧。</p><p>直到出发的前一天晚上，收拾完东西在沉迷游戏的我，想到了明天就要出发这件事情，瞬间萌生了一些无意义感，以下是我发在频道里的原文。</p><blockquote><p>明天出发旅行，晚上玩游戏的时候突然在想，这个超长假期在家打游戏好像也没什么不好的，出去旅行，和人面基，这些事情似乎都没什么意义。刚才洗漱的时候想到了这个问题，因为没坐过飞机，没旅行过，没去过南方那些城市，所以我会选择开启这次旅行，很大程度上有一种想要初次体验的感觉，但是又开始觉得没有这些体验似乎也无妨</p></blockquote><p>这样的无意义感，从这时开始到旅行结束，经常会在各种意想不到的时机出现。每一次出现我自然会关注且记录下来，但这些待后文再提。</p><p>总之在规划的第一天，我出发了，粗心大意的我在到达第一个目的地前不出意料的出了很大的篓子：走错了机场，但好在我担心各种状况所以出门较早，勉强补救了回来，最后算是相对顺利到达了广州。</p><p>以上就是出发之前的我。而在整个旅程中经历的事情，我不打算严格按照时间线和城市串起来讲，某些东西应当被混到一起，不论是为了变得完整，还是为了模糊掉一些会让人感到困扰的细节。只会留下一个流水账的版本，为了那个可能会记得并且会回头看的自己。</p><h1 id="旅途"><a href="#旅途" class="headerlink" title="旅途"></a>旅途</h1><p>在整个旅行的过程中，踏上了自己从未到达的土地，体验到了众多新鲜的事物，了解到了许多地域的差异，一切都很新奇，获取也很有趣。但现在想来似乎并没有跃跃欲试的感觉，只是平稳的按照模棱两可的规划，前往景点观光，约见各种想见的人。</p><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><h3 id="拍摄"><a href="#拍摄" class="headerlink" title="拍摄"></a>拍摄</h3><p>绝大部分的景点本身可能并没有那么吸引我，但是一些景观如果保存在自己的相机之中，则是有一种别样的感觉。实际上也确实拍了很多照片，其中不乏一些自己比较满意的照片，自然也还有一些浪费存储空间的废片。为了拍照片东奔西走，背着沉重的设备，这也使得我旅行的过程十分劳累。以这样的心态进行旅游，似乎我不再是作为游客，而是作为一个兼职摄影师在工作。</p><p>拍照时的我意外的拼命，有时会背着非常沉重的设备在外面到处行动，经常为了夜景晚上十点还在奔波，不知道是什么在驱动着我。我未曾觉得自己有那么热爱这件事情，但是有些像在一些情况下打游戏，也没什么其他特别重要的事情或者说干脆不想做其他事情的时候，即便是游戏中最重复无聊的部分也会一直在玩，像是在重复自己的行为，或者开始了一时半会停不下来。</p><p>拍摄时以及看到成品的兴奋，以及觉得自己拍不出来好照片的痛苦都是切实存在，甚至一度因为后者不想出门拍照。拍照真的是困难的事情，不知道怎么才能拍到满意的照片，拍出来的照片总是有很多缺陷，也缺乏许多创意。有些地方比较容易出片，但又觉得太过于平常，却也不知道怎么拍的更好，虽然觉得拍到了好看的照片但是又不满意。</p><p>不论拍照这个行为本身的心情如何，到了一些绝美的景点还是会不由自主的拿起相机开始拍照。在珠江夜游拍照的时候彻底迷上了夜景，漆黑的夜晚中到处都是炫彩的灯光，照亮了漆黑的江面，照亮了两岸；站在广州塔顶看向周围的风景时，为所能看到的景观而感叹，不由自主的想要记录下眼睛所看到的所有画面，也因此拍了许多全景照片；走到陆家嘴区域的江边，看向对面金碧辉煌的外滩，很难不感叹真是漂亮。</p><p>记录下肉眼所见的美丽事物，这似乎像是我拍照的初衷之一，我也并不很清楚自己是以怎样的心态开始拿起相机拍照，但至少这个念头使得我继续拍照下去。</p><h3 id="熟悉感"><a href="#熟悉感" class="headerlink" title="熟悉感"></a>熟悉感</h3><p>在各地景点之外的地方，或者说在这些城市中穿行的过程中，感受到更多的并不是作为从外地来的游客的那种好奇，而是一种此时我只是在“这里”，而不是我在“这个城市”的感觉。你不会强烈的意识到你到底在哪里，你只知道你在餐馆里吃饭，你在床上睡觉，在前往目的地的交通工具之上。也许你认为这和我的旅行路线有一定关联，全都是相对繁华的城市，但我想即便是在没有那么繁华的偏远地区，也一样很少会产生此时此刻“身在某个城市”的强烈感觉。</p><p>当然也有一些例外的时刻，比如说我在广州一个商场的电梯中，听着周围大爷大妈全在讲粤语的时候，甚至会觉得自己身在国外，或者在最初几天看到许多高耸入云的建筑，会觉得这一定不是在北京，这对限制建筑高度的北京来说算是比较罕见的光景，但看多后也就习惯了这样的建筑。</p><p>对于有的人来说这种熟悉感是坏事，但对我来说或许会使得我更有信心能够走向更远的地方。在一个半月之前我写下了这样的内容，而这次旅行的我也到达了更远的地方。</p><blockquote><p>刚出生，父母的怀里是孩子的整个世界</p><p>当渐渐的能走了，自己的世界逐渐扩大到了家中各个角落</p><p>到了上幼儿园的年龄，我已经能够在村子里到处玩耍</p><p>当我开始上小学，村子外面一公里的世界也已经和我的世界产生了交集</p><p>在6年的时光后升入了初中，我的世界边界已经需要乘坐公交车前往</p><p>高中不再是按区划分学校，我考到了更远的行政区，随之这些区域也划入了我的范围</p><p>大学入学那天，随着火车的行驶，我侵入了临市的领地，在这之后甚至到了距离更远的其它市</p><p>当我就业后，到达了外省，不论是工作还是周末我都行走于这里，相对于家乡来说十分遥远的地方</p><p>终有一天，会走到更远的地方吧。不论是能踩到的路，还是踩不到的路</p></blockquote><h2 id="人"><a href="#人" class="headerlink" title="人"></a>人</h2><p>这次的旅途中见到了非常多的人，都相处的比较愉快。有的已经认识许久，但也有在路边初次接触的陌生人。相比于世间人类的百态来说这些人群只是非常渺小的一部分，但很多也都给我留下了十分深刻的印象。</p><h3 id="旧友"><a href="#旧友" class="headerlink" title="旧友"></a>旧友</h3><p>首先要说的是和一个旧友的事情。到了广州放下行李后就去见他了，我们约在了一个牛肉火锅店，久违的见面，彼此都为对方的变化感到惊讶。他一开始跟我讲了很多其他的事情，比如说什么好吃的，以及之前共同认识的一个朋友来的时候发生的一些故事。我觉得不太对劲，自己变了，在他一开始给我讲其他事情的时候我感到的是诧异，我第一时间想到的总是生活上的破事，比如说对方的工作，生活，现状之类的。但是之后也是不可避免的谈及到了各种生活的问题，他提到要在广州结婚定居，但是房价太高有点顶不住，也不打算要孩子毕竟开销太大。我想也许绝大多数人都不可避免的会经历这样的改变吧。我也这样向他提出了这个问题以及自己的想法，不记得确切的回答了，大致意思也是赞同我的观点。我觉得有些可悲，和别人聊天不是什么有趣的事情，也不是什么梦想与希望，而是残酷的现实，为生存而苦苦挣扎的惨状，到底是哪里出问题了呢？</p><p>另外他谈及了在这个城市的朋友关系，没有什么要好的朋友，而且他觉得自己年纪大了（三十多了）难以和年轻人一起玩。我们是在我老家那边一起玩switch认识的，当时他大概二十七八左右，一群人经常出去玩switch，然后顺便约饭什么的，也比较开心。另外从他的话中我感觉到他比我要想的更加重视和我的这段关系，我有些意外。也许是我对于人过于冷漠，也许是我不敢相信这样的事情会发生在自己的身上。不知不觉间我可能得到了一些漫长的时间中苦苦追求的东西，只是我却无法认出它本来的样子了。他很重视人和人之间的关系，也比较擅长于处理这个。在等电梯的时候他和其他等电梯的人自然的交谈了起来，对于家里人的事情以及类似的人际交往他都做的很好，后来还告诉我出来玩要买什么给家里人之类的。不是那种靠什么技巧，而是完全的真诚、自然的面对他人，接受他人，不像我一样畏畏缩缩，充满自卑与自私，处处躲着别人，也不愿和家里人交流。如果不是一起玩switch认识的，我很难想象这样的我们会有交集。</p><p>最后吃饭买单的时候他还一定要请我，我是真的不好意思让他来，他还是特地打车来这边，同时第二天还陪着我一起，甚至第二天也没能给我买单的机会，说是等他来北京玩再请他，不过北京毕竟没什么好玩的。饭后的散步，讨论到一些生活问题的时候还在想，50岁女性已经到退休年龄，那大部分50左右中年男人都在干什么？他那边的亲戚在开店，但是在我们这个年龄的人看不到社会上大部分这个年龄段的人，保洁也都是一些六七十的老大爷在做。现在想想可能是开店，保安，货车司机，厨师之类，我不太清楚那个年龄段的人，我爸可能也不能作为参考。</p><p>不过这样沉重的话题也只有第一天，第二天他又陪我到处转到处玩，还带我去坐了珠江夜游，一天的话题都比较轻松愉快，从饮食习惯，到在玩的游戏等。美好的时光总是类似的，也就没有什么特别让人印象深刻的地方。</p><h3 id="最早认识的网友"><a href="#最早认识的网友" class="headerlink" title="最早认识的网友"></a>最早认识的网友</h3><p>旅行的过程中，见到了十年前我正式接触网络世界的时候就认识的网友。由于看过照片，<del>甚至照片被他拿去P成了奇怪的样子</del>，他直接一眼认出，我听着熟悉的声音也算是认出了对方。在十年前认识的时候，彼此都不会想到这份关系会维持到现在，并且还会有这样一天在线下见面。晚餐过后便一边聊天一边压马路到了海边，吹着海风，到了很晚才结束这一场面基。</p><p>这种场合必不可少的话题就是感叹时间之快了，毕竟十年的时光一晃而过，都从一个初中生成长到了一个社畜。除此之外聊天的内容上并没有什么特别的，但是见到这样的网友本身是非常有纪念性的事情。</p><h3 id="一位面基过的网友"><a href="#一位面基过的网友" class="headerlink" title="一位面基过的网友"></a>一位面基过的网友</h3><p>由于是工作日，因此约见的过程是直接去往餐厅，他从公司赶过来，吃完晚餐后再回去工作。除了聊了一些网友之间的故事之外，其他的内容都比较现实，以及他考虑这些问题的方面也是如此。这种说法是想要夸奖这位网友，对这些事情考虑周全也是比较难得的，包括但不局限于城市的选择与工作岗位的问题，以及会面临的一些社会现状等。另外和上面提到的那位十年前就认识的网友完全处于社会的两端，这个说法可能不太好，但此时这样形容是相对比较合适的了。这让我产生了一种非常强烈且难以描述的感觉，或许是对立感，或许是割裂感，就好像是看到高楼大厦的旁边还有一栋老旧的平房一样。</p><h3 id="高中同学"><a href="#高中同学" class="headerlink" title="高中同学"></a>高中同学</h3><p>自从高中毕业以来已经7年了，在这段时间内从未见过他，甚至他的微信都是见面前几天找另一个同学要的。我不太会去联系过去的同学，因为在学校的时候里几乎可以说是我做事情最令人讨厌的时候，但我渐渐开始对过去同学经过这么多年对变化感到好奇，另外在过去他还是与我有些交集，并且一定程度上能接受我一些，之前正好得知他在上海，于是顺便尝试约了一次晚餐。</p><p>他表面看起来还是没什么太大变化，以往就显得有些成熟，也许更多的变化在内部。而我自然是完全变了一个人，除了令人诧异的长发外，对方的评价是看起来变得乐观很多。聊天得知厨师的工作还是比较辛苦，每天基本上除了睡觉、通勤就是在工作。他在上海已经当了五年的厨师，学到了许多厨艺，现在也差不多到了回老家的时候了，和我见面的前几天也是刚刚辞职。对于许久未见的同学来讲，聊的内容大多都是工作以及现状之类，不过能够约见到对方我也比较满意了。我对过往的同学多少有那么一些愧疚感，毕竟过去的自己实在是行事恶劣，令人作呕，自然是抢先买了单，算是弥补一些愧疚。</p><h3 id="或许不够熟悉的约见"><a href="#或许不够熟悉的约见" class="headerlink" title="或许不够熟悉的约见"></a>或许不够熟悉的约见</h3><p>从上海走之前，主动约见了一个推特上偶有交集的推友，但这也算是第一次正式聊些什么。一直觉得会是一个值得见一面的人，见面后也不失所望，你要问我为什么这么想，也许是对于发的推文的感觉，我也无法用语言描述。</p><p>除了常规的话题还聊到两个比较特别的内容。一个是关于心理疾病，另一个则是关于困扰的事情。不止一次面基的时候被问你最近有什么烦恼的事情，现在想想之前的回答好像都是说了一半，但我也很难说出更深层困扰我的东西。刚才又想要成为别人，但是回头来想我只能做自己，这对我来说也是非常困扰的事情，但又可以说是表层困扰自己的事情的一部分。也许因为我不懂，现在的我看来这一切是纵横交错的。</p><h3 id="杭州的群体面基"><a href="#杭州的群体面基" class="headerlink" title="杭州的群体面基"></a>杭州的群体面基</h3><p>群体面基是完完全全超出我预料的情况，我原本自然是打算和单个人进行见面。但由于杭州推友线下交流的氛围比较浓厚，不由自主变成了群体见面。</p><p>最初约见了一位推友在周围转转，后来多了一位推友一起吃晚饭，之后理所应当的一起在城市里压马路。变成三个人的情况我是最不适应的，瞬间沉默了起来，直到结束。而第二天也是类似的情况，在和所有人见面的时候我开始沉默了起来。我不是很习惯这么多初次见面的人一起，也并非什么社恐，只是我有些社交障碍，另外这么多人一起的话很难说每个人进行聊些什么。</p><p>在这个过程我发现自己的回避倾向仍然非常强烈，主动选择在群体中处于孤立的位置，主动选择一言不发。不过也算是难得的体验，这样想的话似乎能接受了很多，但也是我永远不会想有第二次的体验了。</p><h3 id="陌生人"><a href="#陌生人" class="headerlink" title="陌生人"></a>陌生人</h3><h4 id="借移动电源的陌生人"><a href="#借移动电源的陌生人" class="headerlink" title="借移动电源的陌生人"></a>借移动电源的陌生人</h4><p>自己下了广州塔坐在座位上找自己的东西时，一个阿姨打上了车但手机没电了，就来找我借移动电源，在对方等车的时候就开始聊了起来。她看到了我背的相机设备后问我是职业摄影师吗，是否接单之类的，听她讲她是和朋友一起来广州塔吃饭，以及找了摄影师帮忙拍她们。还大概问了一些在哪之类的，问我业余有没有接单，我回复工作忙。临走之前推荐了陈家祠作为下一个目标景点，总体来讲是很友善的一位阿姨，感觉也比较有气质。</p><h4 id="摄月"><a href="#摄月" class="headerlink" title="摄月"></a>摄月</h4><p>在上海拍东方明珠的机位等待时，一个路人小哥过来问我在拍什么，后来他告诉我他在小红书上找到这个机位，恰巧在同样的位置。那天天气很差，都以为看不到月亮了，我甚至规划了下一个机位，就顺便和他约好一会去下一个机位（虽然最后恰巧月亮出来了），在下一个机位拍完后加了微信。除了拍月亮几乎没什么其他交流，但也算是一个比较奇特的经历吧。</p><h4 id="高铁上幸福的一家人"><a href="#高铁上幸福的一家人" class="headerlink" title="高铁上幸福的一家人"></a>高铁上幸福的一家人</h4><p>在某趟高铁上，旁边的小孩子一直在折断笔，妈妈对孩子说爸爸赚钱妈妈花钱买的，你可不能浪费啊，之后孩子的父母都笑了。还有一个片段是服务员路过喊着水果冰激凌，妈妈非常迅速地捂住孩子的耳朵，感觉也很有意思。这家人给我的印象是非常幸福，并且也是非常可爱的一家人，属实让人羡慕。</p><h4 id="擦肩而过的人们"><a href="#擦肩而过的人们" class="headerlink" title="擦肩而过的人们"></a>擦肩而过的人们</h4><p>除此之外，还有数不尽的没有直接交集的人：在广州看到了睡在路边的人，深圳看到开摩的的人；在杭州的文化广场，看到了正在直播唱歌的中年阿姨；中秋节在上海的外滩，有行动不便的人，有在和家里通话的人，有结伴而行的情侣，有坚守岗位的交警，有和睦的一家人，有在发小红书的中年大叔。另外和朋友在海底捞吃饭的时候，看到了失恋的人，有陪他来的朋友，还有旁边一脸陪笑的工作人员。但我在想，这些工作人员也是十分辛苦，在工作之余可能也会因生活所困愁眉苦脸，和当时带有笑容工作时完全是两个样子。我会去想象一个人在不同情况下的样子，比如惊喜和遭受痛苦的时候，工作的时候，游玩的时候等。这算是一个比较有趣的事情，我们每个人都会如此，总会身处不同状态，并且展现给人不同的一面，但每一面都是组成个人的一部分，无法一言蔽之。</p><h1 id="旅行结束"><a href="#旅行结束" class="headerlink" title="旅行结束"></a>旅行结束</h1><p>在最初提到了旅行前感受到的无意义感，而旅行过程中无意义的感受又数次涌上心头。</p><p>有一次在和朋友一起吃美食的时候，有一个瞬间我感到格外空虚，无意义，只觉得十分美味的食物吃与否在大部分情况似乎没有什么太大的区别，除非肠道细菌反复催促你去吃。而在吃饭时是否进行交流似乎也没有什么区别，除非我感到孤单需要找人讲话。和我一起的人们可能不可能会产生这样的感受，他们很重视美食，而我则是一个对美食不太讲究的人；他们很注重人和人之间的联系，而我却对这件事情过于冷漠，和别人产生联系甚至会觉得是因为自己心血来潮（当然这并不准确）。</p><p>在约见另一个朋友吃饭的时候，突然觉得是否不约见也无所谓，甚至不认识也是无所谓呢？交朋友对于个人社会生存以及社会关系是有益的，但是对于“我自己”呢？我作为一个弱小的个体可能需要这些益处，但作为我自己来说如果没有任何压力的话，会想要远离和人的关系。这和我的童年过往有所关联，现在也就这么延续了下来。</p><p>在旅途的时候，似乎也出现过认为我是否在城市里，在景点里游玩是完全无所谓的事情，我这次出来纯粹只是为了好奇，体验全新的事物罢了。</p><p>现在看来这些全都是为了满足身心的需求。我是一个认同“人生无意义”这个观点的人，既然活着那就遵循“在不会被警察叔叔带走的情况下满足自己”这个规则去行动，去满足自己的需要，另外满足自己的部分欲望，我的行动、想法与解读，现在看来似乎也是满足这一切的。</p><p>旅途中的这份无意义感或许是想要传达给我什么东西，当然也可能是纯粹的无意义，但我可能不得而知了，现在已经结束了旅游，回到了熟悉的日常生活，回到了熟悉家里，等待着我的或许是另一种的无意义感，但这已经是另一份感受了。现在写这篇文章时我仍然会觉得毫无意义，我为什么要开始写呢？也许是想要拙劣的模仿我的一位朋友，但不论如何既然想写了那就写下去吧。</p><p>数量众多的无意义感，我不知道应该如何面对它们，但不论如何它们或许会陪伴我一辈子，或许也不会有任何答案，只是这样存在罢了。</p><p>除了上面提到的无意义感，我在旅行的过程中还会不断的询问自己，旅行到底是为了什么？现在看来，我在旅行中有着许多新的体验，见到了许多新的人，了解了更多的知识，也拍到了更多照片，这一切都是我的收获，但如果要将这个作为自己的答案，自己并不会感到满意，这些经历虽然看起来是充实的，但同样也是虚无缥缈的，即便不考虑这一点，得到了些什么在我看来更像是旅行的副产物罢了。同样的问题也曾发在自己的频道中，有些网友的回答是开心就好，有些网友的回答是不要注重结果，但对我来说这些同样不是我想追寻的答案，能适用于每个人的标准答案一定是不存在的。</p><p>尽管长达半个月的时间在外游玩而无需考虑任何工作相关的事情，但在整个旅行的过程中我仍然出现了数次使我感到十分痛苦，甚至到完全丧失生存欲望的情绪。这半个月来总是睡不好觉，但先不考虑这件事情，更多的问题在于自己的感受和想法。这某种意义上是一个警示，即便我天天出去玩，不需要工作，我也依然会有许多的痛苦。这看上去有些像废话，这些感受全部都是根源性的问题，不管是否工作人总会感到痛苦的，只是我觉得自己还比较难应对这些，在非常遥远的未来我想要脱离打工人的身份，但在此之前我需要想办法去应对这些，否则这对于工作上的独立来讲，危害还是非常大的。</p><p>当旅途结束，回到了正常的工作日，我变得无比不适应，不过对大部分人来说都很难从十四天完全自由的生活快速适应每天到点上班的生活吧。前面提到我的旅行一半是作为一个入门摄影师在做赚不到钱的工作，这是我不适感很强烈的一个非常重要的原因。</p><p>这对我是一次强烈的冲击，也许未能使得我实际去做些什么，但我的想法已经产生了更多改变。在从杭州返回北京的前一天晚上，我梦到了独自一人踏上了宝可梦训练师的道路，或许这也是我大脑潜意识的想法，想要就此启程，脱离到点上班的生活，只是我现在还未能实现这一切，希望自己终有一天能够实现吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;出发前&quot;&gt;&lt;a href=&quot;#出发前&quot; class=&quot;headerlink&quot; title=&quot;出发前&quot;&gt;&lt;/a&gt;出发前&lt;/h1&gt;&lt;p&gt;在九月底，我开启了一场为期半个月的旅行，旅行的路线是从北京出发，途径广州、深圳、上海、杭州，最后再回到北京。作为第一次出门旅行来说算</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="Travel" scheme="https://fusionbolt.github.io/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>初次旅行</title>
    <link href="https://fusionbolt.github.io/2023/11/05/Life/first-travel/"/>
    <id>https://fusionbolt.github.io/2023/11/05/Life/first-travel/</id>
    <published>2023-11-05T09:53:12.000Z</published>
    <updated>2023-11-05T11:22:47.070Z</updated>
    
    <content type="html"><![CDATA[<p>本文作为流水帐般的游玩记录，多图杀猫。如果你对我旅行前后的想法有兴趣那请访问这篇文章</p><p><a class="link"   href="https://homura.live/2023/11/05/Life/travel-meditations/" >https://homura.live/2023/11/05/Life/travel-meditations/<i class="fas fa-external-link-alt"></i></a></p><h1 id="广州"><a href="#广州" class="headerlink" title="广州"></a>广州</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>在国庆前一周的周六到了机场乘机，这是我第一次坐飞机，刚起飞的时候风景非常的棒。</p><p>飞机起飞后，一开始感到不适，随着飞机的升高与前行，越来越多新奇的光景进入到了我的视野之中，吸引力我的全部注意力。到了云层之上后，则是有些恐高，但景色的期待，促使着我去承受恐惧，注视着这罕见的景色。整个过程我的心情十分多变，等待飞机起飞时的无聊，起飞时看到光景的惊喜，调整机翼的不适，进入云上世界时的惊叹，身居高空的恐惧，全都混杂在了一起。云层上的世界宛如纪录片中的南极大陆，到处都是雪堆，一片雪白，只是不曾见到岿然不动的冰山。而我则乘坐着巨大的铁鸟在这雪地之上翱翔，经过漫长的飞行后终将穿透雪地，到达地下的文明都市。待孩子般的热情散去后，迎来的景象则是漫无止境的雪白，这样的重复终有厌倦之时，这一刻来到的时候按下了世界音频的开关，一切变的那么寂静，飞机的轰鸣声消失的无影无踪。此时再次向窗外看去，在这样宁静又充满了铺天盖地的雪白的世界中前进，显得格外孤寂。</p><p>看了飞机上的视角，我狠狠的种草了无人机，但是国内这个管控不明不白的，尤其是北京根本不能飞，只能打消了念头。</p><p>机上非常豪华的飞机餐，让我产生了所有飞机的午餐都是这样的错觉。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/E15EE019-CD1B-48BE-B793-78A66F38F5DA_1_105_c.jpeg"                      alt="E15EE019-CD1B-48BE-B793-78A66F38F5DA_1_105_c.jpeg"                ></p><p>下午飞机到达了广州</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/606519B7-A9AE-4248-BC89-2D89CAB32275_1_105_c.jpeg"                      alt="606519B7-A9AE-4248-BC89-2D89CAB32275_1_105_c.jpeg"                ></p><p>坐地铁到了酒店附近的站后，发现这里有一条街都是吃喝玩乐，在北京简直不敢想象有这样的地方，我不由得幻想起了住在这样城市的生活，但没多久便被热浪打醒，实在不能接受这里炎热的气候。</p><p>到酒店放下行李后在周围逛了逛，没多久下起了雨，伞放在酒店的我只好匆匆跑回酒店，趴在床上休息等待朋友赶来一起吃晚饭。</p><p>久违的相见，彼此都为对方的差异感到惊讶，晚上吃了陈记顺和的牛肉火锅。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/E35CABAC-E92D-4230-8284-F37F41DF7D15_1_105_c.jpeg"                      alt="E35CABAC-E92D-4230-8284-F37F41DF7D15_1_105_c.jpeg"                ></p><p>随后在周围的地方开始压马路，其中走到一家奶茶店，他强烈建议我尝一下苦瓜柠檬茶</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/E867CA92-7366-4983-AF43-24D79171CC7F_1_105_c.jpeg"                      alt="E867CA92-7366-4983-AF43-24D79171CC7F_1_105_c.jpeg"                ></p><p>虽然初见以为是邪教，但是实际喝了以后并没有想象中的那么苦，柠檬与糖的味道还是主体，加入了一点苦瓜汁，以及苦瓜碎片。之后一路上聊了很多，一直走到了十一点半才散伙，我拖着疲惫的身躯回到了酒店，等我洗漱完要入睡的时候已经是凌晨2点了。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>第二天醒来已经是十一点了，而朋友也是大概这个点醒了联系我，在匆忙洗漱后我就前往午餐的目的地：银记食府。到达后已经到了十二点，到了楼下就听到了楼上排队取号的声音，我匆匆上去取号，发现前面还有90桌，只好在楼下闲转。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled.png"                      alt="Untitled"                ></p><p>等待些许时间后朋友也赶过来了，遂找了家咖啡店坐了一会，饿到不行的我提前点了个样子奇怪的慕斯，但味道还不错。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/C6E82D19-B44D-485D-BC8F-15C5298FD20A_1_105_c.jpeg"                      alt="C6E82D19-B44D-485D-BC8F-15C5298FD20A_1_105_c.jpeg"                ></p><p>等待两个小时以后便是久等的中午的“早茶”。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/37ABAE37-053E-4C0A-9D2B-C6D8A4FA0A31_1_105_c.jpeg"                      alt="37ABAE37-053E-4C0A-9D2B-C6D8A4FA0A31_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/EE262937-D3E5-45C4-9F32-0B1FABF36556_1_105_c.jpeg"                      alt="EE262937-D3E5-45C4-9F32-0B1FABF36556_1_105_c.jpeg"                ></p><p>吃饱后到了上下九步行街，点了现切的果捞，加了酸梅粉。广州这里果捞是真的多，到处都是，不过我们点的这个果捞满多水果感觉都不是很熟，水果的味道一般，猕猴桃又涩又硬，菠萝非常酸，加上我们吃早茶吃的很饱，也就只吃下了一部分。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/81897222-551F-413E-83FF-C5D8AAF5E440_1_105_c.jpeg"                      alt="81897222-551F-413E-83FF-C5D8AAF5E440_1_105_c.jpeg"                ></p><p>随后沿着步行街走，到了永庆坊，逛了粤剧院，走的时候还看到了绿色的kfc</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/5A74FDC3-F812-4386-B806-42BFFE44E2EE_1_105_c.jpeg"                      alt="5A74FDC3-F812-4386-B806-42BFFE44E2EE_1_105_c.jpeg"                ></p><p>到了傍晚我们赶到了珠江夜游的码头周围，找了个星巴克休息了一下，我则是直接趴在桌上睡了一阵。</p><p>即便是晚上广州也是十分炎热，在船顶多少能感受到一些微风，两岸的夜景吸引了我的全部注意力，拿起了相机进行一个疯狂的连拍。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/81D0EF9A-B3B9-4C6F-A958-7143FB348C10_1_105_c.jpeg"                      alt="81D0EF9A-B3B9-4C6F-A958-7143FB348C10_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/3FEBD70D-A8DA-4F89-ABCA-9386243198F5_1_105_c.jpeg"                      alt="3FEBD70D-A8DA-4F89-ABCA-9386243198F5_1_105_c.jpeg"                ></p><p>当经过广州塔的时候，不仅是我，还有许多游客举起了自己的设备连忙拍照。拍广州塔比较头疼的一点是船靠近的时候塔上各种广告，很难拍出一个纯粹的广州塔。</p><p>珠江夜游结束后我们沿着路边压马路边聊天，走到了一个商场附近的时候，朋友因为身体不适要先打车走，而我则是继续走到了一条小吃街，买了一堆小吃后回到了酒店</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/E808EB01-97E6-4A45-8B8E-0F0D677342BF_1_105_c.jpeg"                      alt="E808EB01-97E6-4A45-8B8E-0F0D677342BF_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/7B3F31EF-CB41-4038-BE24-013D17AC68B5_1_105_c.jpeg"                      alt="7B3F31EF-CB41-4038-BE24-013D17AC68B5_1_105_c.jpeg"                ></p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>第三天醒来便前往了石室圣心大教堂 ，只可惜周一并没有开门，在门口拍了照片留个纪念</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/8B0240CE-9CC9-489A-A054-56F2A7D9CBED_1_105_c.jpeg"                      alt="8B0240CE-9CC9-489A-A054-56F2A7D9CBED_1_105_c.jpeg"                ></p><p>之后直接前往一个有名的商场随便转转，拍了几张照片，商场内部的设计还是比较好看的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/3485304D-7B8C-4A85-8353-37FBF0EAA390_1_105_c.jpeg"                      alt="3485304D-7B8C-4A85-8353-37FBF0EAA390_1_105_c.jpeg"                ></p><p>之后准备到楼顶拍照。在坐电梯上楼的时候，周围都是上了年纪的本地人，全程都在用粤语交流，仿佛到了外国一样。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/67883B62-2CB9-4753-AF21-EC3C4683EA65_1_105_c.jpeg"                      alt="67883B62-2CB9-4753-AF21-EC3C4683EA65_1_105_c.jpeg"                ></p><p>中午到了广州塔附近的珠江新城约见了一名网友，下午则是沿着珠江新城走到了海心沙，路上也是边走边拍，可惜并没有收获什么太好看的照片。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled%201.png"                      alt="Untitled"                ></p><p>等到下午五点多和某个知名小波奇约到了饭！也是非常美味的一餐</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/68916131-5158-4D1B-AAA0-C7364DA5F751_1_105_c.jpeg"                      alt="68916131-5158-4D1B-AAA0-C7364DA5F751_1_105_c.jpeg"                ></p><p>随后一起在周围转了转，聊聊天，分别后我便前往了广州塔。到了目的地后，一路上到了室外的观光出，到摩天轮的位置犹豫了半天要不要上去坐，由于比较恐高，纠结再三以后还是放弃了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/D4CDFA5B-F2CC-4BF7-84FC-2DB0B44FBE1A_1_105_c.jpeg"                      alt="D4CDFA5B-F2CC-4BF7-84FC-2DB0B44FBE1A_1_105_c.jpeg"                ></p><p>刚准备好开始拍照，结果遇到雨天，所有游客只能到塔内的观光区。此时的我感到无奈又气愤，心情十分低落，但也没有办法，只能不耐烦的在室内走了一圈又一圈，看着网上的雷电预测，认为还是有机会重新开放。在等待接近两个小时后，雨停了，室外也终于开放了，而我则第一个冲上了最高层的位置。顶上的风比下面坐摩天轮的位置要大许多，仿佛要被吹飞，但此时在拍照面前这些事情都无关紧要了。要做的只有拿出相机咔咔咔一顿狂拍，看到拍到的结果后感叹等待是非常值得的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/AB8ED7C0-C2E7-4007-AE01-17B973B2E2CB_1_105_c.jpeg"                      alt="AB8ED7C0-C2E7-4007-AE01-17B973B2E2CB_1_105_c.jpeg"                ></p><p>最后十分兴奋的拍到了十点多才结束，之后便是赶回酒店的旅程。</p><h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><p>早上略早的爬了起来，在路上看到鲍师傅糕点店便买了一些来品尝味道</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/8A5E4BC9-DB0B-482F-80A6-B1DEA57A684F_1_105_c.jpeg"                      alt="8A5E4BC9-DB0B-482F-80A6-B1DEA57A684F_1_105_c.jpeg"                ></p><p>另外找了一家店买了一些特产食物寄回了家里，最后在回去前找了家肠粉店尝尝味道。味道非常香，但是香油的量也很大，吃多了比较容易腻。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/9A76D528-BFCF-4E61-999F-182290109757_1_105_c.jpeg"                      alt="9A76D528-BFCF-4E61-999F-182290109757_1_105_c.jpeg"                ></p><p>吃饱喝足后便退房前往下一个城市</p><h1 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h1><h2 id="一-1"><a href="#一-1" class="headerlink" title="一"></a>一</h2><p>深圳离着广州非常近，因此很快就到了，列车途中的风光也是非常不错，到处都是翠绿的树林，远比北方来的要好看。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled.jpeg"                      alt="Untitled"                ></p><p>由于坐在了没什么人的车厢，一路上到处换位置隔着列车的窗户拍照。</p><p>到达了酒店附近，这个地铁站的位置非常有意思，叫做翻身，似乎是农民翻身因此起这个名字，在酒店也看到了有趣的牌子</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/7B72F8DB-21C1-46D4-AEBB-3F8F3C97024E_1_105_c.jpeg"                      alt="7B72F8DB-21C1-46D4-AEBB-3F8F3C97024E_1_105_c.jpeg"                ></p><p>纯智能家居的酒店，最初我还有些不习惯喊小爱（Apple生态的Siri我也一直都是禁用的），但是后来忍着羞耻喊了几次，渐渐懒惰成性，开窗开灯全交给小爱解决了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/C3153AAA-E3B9-4B97-9CD5-CF6D36B9B54A_1_105_c.jpeg"                      alt="C3153AAA-E3B9-4B97-9CD5-CF6D36B9B54A_1_105_c.jpeg"                ></p><p>在前往晚上吃饭的店店路上，顺路到了大疆的天空之城逛了一下，拍了一些照片（虽然都是废片）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/702064E4-C0FE-4206-B55E-1B73CBD2711F_1_105_c.jpeg"                      alt="702064E4-C0FE-4206-B55E-1B73CBD2711F_1_105_c.jpeg"                ></p><p>在楼下还有许多在戴着工牌抽烟的员工。拍照的时候还被保安很友好的提醒注意安全，另外提醒我不要拍到产品。</p><p>之后赶往了和朋友约吃饭的位置</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/3339A09A-D659-4272-8F28-DEFEA4F5B043_1_105_c.jpeg"                      alt="3339A09A-D659-4272-8F28-DEFEA4F5B043_1_105_c.jpeg"                ></p><p>在回去之前选择了先到海边玩一会。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/76656214-5C1D-42AE-94AA-34FABC0DA601_1_105_c.jpeg"                      alt="76656214-5C1D-42AE-94AA-34FABC0DA601_1_105_c.jpeg"                ></p><p>买了一杯饮品，坐在海边吹着海风，什么都不做什么都不想，只是看着对岸的风景，非常惬意，有多久没这样放松过了呢？</p><p>还顺路去看了钟书阁，书店内部的装饰十分有特点，也有许多人特地在这边拍照。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/DSCF7965.jpg"                      alt="DSCF7965.jpg"                ></p><h2 id="二-1"><a href="#二-1" class="headerlink" title="二"></a>二</h2><p>第二天略早爬了起来，去了世界之窗。在世界之窗的游玩算是比较快乐的，租借了一辆代步车，在景区到处“飙车”，节省了我的体力，并且吹着迎面而来的风，十分惬意。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/2B43E282-1560-494E-AA3F-75F4D95C7FDB_1_105_c.jpeg"                      alt="2B43E282-1560-494E-AA3F-75F4D95C7FDB_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/F59764DB-C276-4B79-B26B-DC8E28943E2A_1_105_c.jpeg"                      alt="F59764DB-C276-4B79-B26B-DC8E28943E2A_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/C7772C2D-5BBC-4964-A0FE-59CA52F5F64D_1_105_c.jpeg"                      alt="C7772C2D-5BBC-4964-A0FE-59CA52F5F64D_1_105_c.jpeg"                ></p><p><del>天冠山</del></p><p>玩完后回去美美的睡了一个午觉，之后和一个朋友约定了晚上吃饭的时间以及集合地点，而我则是先到了附近去踩点，随后返回地铁站集合，然后打车去了商场，美美的吃了一顿自助，聊了很多</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/812AF339-061D-4629-AB83-CE2943AFD461_1_105_c.jpeg"                      alt="812AF339-061D-4629-AB83-CE2943AFD461_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/72AA8A23-245C-41A7-9089-5C521BB14193_1_105_c.jpeg"                      alt="72AA8A23-245C-41A7-9089-5C521BB14193_1_105_c.jpeg"                ></p><p>在这之后先是一起赶往目标地点去拍照。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/361FEE1C-8F04-440E-B6FD-520DADBE92C0_1_105_c.jpeg"                      alt="361FEE1C-8F04-440E-B6FD-520DADBE92C0_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/5910BC95-5966-42EC-AA5B-94B735DA1F83_1_105_c.jpeg"                      alt="5910BC95-5966-42EC-AA5B-94B735DA1F83_1_105_c.jpeg"                ></p><p>以上两张图中，第一张是我看到的作品，想要进行复刻机位，第二张是我实际拍的效果，虽然和实际的偏差很多，但我个人还是挺满意的，最近比较喜欢这种漆黑的背景加上带有灯光的建筑。随后我们一路压马路，走到了前一天我去的海边，坐在那里无所事事的吹海风，闲聊。</p><h2 id="三-1"><a href="#三-1" class="headerlink" title="三"></a>三</h2><p>第三天早上起来便直接前往机场，在安检的时候还出了点小插曲，告诉我六角扳手不允许带，在我一番劝说的情况下还是允许我带了。没有六角扳手的话晚上的拍摄活动可能就要白给了。</p><p>后来上了飞机，这次的飞机餐远远不如上一次，挑食的我吃了几口就放弃了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/9A42B13C-0A1A-4477-AEFA-B407703E8693_1_105_c.jpeg"                      alt="9A42B13C-0A1A-4477-AEFA-B407703E8693_1_105_c.jpeg"                ></p><h1 id="上海"><a href="#上海" class="headerlink" title="上海"></a>上海</h1><h2 id="一-2"><a href="#一-2" class="headerlink" title="一"></a>一</h2><p>刚下飞机，被上海浦东机场所惊讶到，真的好大，同时由于是假日的前一天，人也开始多了起来。经过非常久的路程后终于到了换乘列车的站台，第一次体验了磁悬浮列车。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/CB97588F-5498-4632-818B-8AFB9BA1D10C_1_105_c.jpeg"                      alt="CB97588F-5498-4632-818B-8AFB9BA1D10C_1_105_c.jpeg"                ></p><p>列车的速度非常快，在路上拍照的时候还没反应过来就已经到了目的地。趁着列车在等其他乘客的时候也是一顿大拍特拍。</p><p>之后换乘地铁期间和上海的一个同事联系，他问道要不要顺路去公司碰个面，我吐槽道：“去公司看你们上班吗？“</p><p>到了酒店收拾了下东西后就匆忙赶往东方明珠了，毕竟是节假日前最后一天，人会少很多，事实上也确实如此。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/33A5EEA1-ECE2-40E0-B6CA-C7543047F275_1_105_c.jpeg"                      alt="33A5EEA1-ECE2-40E0-B6CA-C7543047F275_1_105_c.jpeg"                ></p><p>东方明珠上可怕的悬空走廊，不敢上去走，还有在这里拍视频做俯卧撑的人</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/9A367096-A38E-4C19-8653-62CD14AD2525_1_105_c.jpeg"                      alt="9A367096-A38E-4C19-8653-62CD14AD2525_1_105_c.jpeg"                ></p><p>在东方明珠上选了个机位，大概会有月亮经过某个建筑，但是近日上海的天气真的是非常的差，月亮全部被乌云遮住了，因此只能作罢。</p><p>随后去了楼下的可口可乐欢乐餐厅，这家餐厅非常长，从一头走到另一头要很久，而我恰好被安排在了靠近门口的位置，就十分尴尬。不过真不愧是可口可乐餐厅，可乐非常的冰，喝起来非常的爽快，可以说是很懂了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/67803804-5CA9-467D-B22E-FE4D657047BD_1_105_c.jpeg"                      alt="67803804-5CA9-467D-B22E-FE4D657047BD_1_105_c.jpeg"                ></p><p>吃饱喝足后走到了陆家嘴三件套这里，之前在小红书上看到了这个机位，觉得很有意思想来看看。但是比机位更有意思的是这里充满了来打卡拍照的人，也许是在小红书上实在太火了，大家都来这里拍照了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/DA74CB2A-D9FE-41FF-953E-88344034E743_1_105_c.jpeg"                      alt="DA74CB2A-D9FE-41FF-953E-88344034E743_1_105_c.jpeg"                ></p><p>之后去向了江边，对面就是外滩，金碧辉煌的建筑在漆黑的夜晚中显得格外漂亮，甚至觉得这里看过去的风景比外滩看向陆家嘴更好看。忍不住在这里架起了机器疯狂拍照，期间也有许多人在附近游玩拍照，也顺便帮了许多路人拍合影。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled%201.jpeg"                      alt="Untitled"                ></p><p>拍完大概已经十点半多了，十分疲劳，匆忙打了个车回到了酒店。</p><h2 id="二-2"><a href="#二-2" class="headerlink" title="二"></a>二</h2><p>早上早早起来，到了外滩的位置，但是雾特别大，很难说拍出什么好看的照片，因此选择了直接吃午饭。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/EE5F85B3-8762-47B7-9504-981A48B14397_1_105_c.jpeg"                      alt="EE5F85B3-8762-47B7-9504-981A48B14397_1_105_c.jpeg"                ></p><p>犹豫吃什么的时候看到了蟹黄面的推荐，店铺找了半天。味道还可以，猪排也非常的嫩。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/03576787-06B1-44D2-9CAE-BC8FF302E513_1_105_c.jpeg"                      alt="03576787-06B1-44D2-9CAE-BC8FF302E513_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/B2E9C8CF-EBA7-4640-9C1E-A517609B95E8_1_105_c.jpeg"                      alt="B2E9C8CF-EBA7-4640-9C1E-A517609B95E8_1_105_c.jpeg"                ></p><p>回去休息了好久，顺便找了下机位，四点左右就提前出发踩点。随便拍了些外景，六点多开始拍月亮，但是天气差的缘故一直在担心能不能拍到月亮。在我焦急等待的时候一个小哥来到旁边，问我是在拍什么，向他询问才得知他在小红书上找到这个机位，恰巧在我找到的位置，也就因此一直拍着月亮了。尽管月亮迟迟没有出来，但最后还是拍到了穿过东方明珠的瞬间。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled%202.png"                      alt="Untitled"                ></p><p>由于担心刚天黑的时候看不到月亮，因此还安排了另一个机位，随后我就和这位小哥一同前往准备再拍一波。到了目的地后周围人也是非常多，不过选的位置人相对较少一点，也算比较方便拍照。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/1C2F900C-3B86-466B-BA2C-81C03A43DC6C_1_105_c.jpeg"                      alt="1C2F900C-3B86-466B-BA2C-81C03A43DC6C_1_105_c.jpeg"                ></p><p>拍完月亮后我也挤入了外滩的人群中，准备拍一下带有月亮的陆家嘴夜景。周围大多都是来拍照打卡的旅客，人非常多，还时不时有游客让我帮忙拍照。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/DSCF8722.jpg"                      alt="DSCF8722.jpg"                ></p><p>陆家嘴的夜景，还没修图调整，可以看到雾气还是比较大的</p><p>后来去拍了外白渡桥</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/../../../../Downloads/d7511a47-df89-42e4-8bcb-9ac4a6365c51_Export-7dacecbd-e5df-4c65-9673-3dbc5f452139/%25E5%2588%259D%25E6%25AC%25A1%25E6%2597%2585%25E8%25A1%258C%2520b4f8e8320314407b8816b744e0ac7bbd/%2525E5%2525A4%252596%2525E7%252599%2525BD%2525E6%2525B8%2525A1%2525E6%2525A1%2525A5_-_01.jpg"                      alt="外白渡桥 - 01.jpg"                ></p><p>为了消除掉来往的行人，需要在这里拍多张叠加。等待自动拍照的时候周围有着形形色色的人，有行动不便坐着轮椅的人，有在和家里通话的人，有结伴而行的情侣，有坚守岗位的交警，有和睦的一家人，有发小红书的中年大叔。</p><p>拍完已经十点半了，也没吃晚饭，吃的太贵，后来买了一个小生煎，又坑又不好吃，店家的态度也比较差，吃的也忘了拍照。</p><h2 id="三-2"><a href="#三-2" class="headerlink" title="三"></a>三</h2><p>起床洗漱后就赶往海底捞和网友们面基</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/D82DB44D-AA4A-4738-A93B-3977C6FDDF12_1_105_c.jpeg"                      alt="D82DB44D-AA4A-4738-A93B-3977C6FDDF12_1_105_c.jpeg"                ></p><p>下午则是一波City walk，一起走到了外滩，邮政博物馆，苏州湾，老垃圾桥。途中下起了雨，找了一个商场的奶茶店聊天避雨。</p><p>晚上到了一个商场闲逛，商场里意外的充满了许多二次元元素，还有许多的coser，真不愧是上海啊，之后到了楼顶还看到了晓美焰的cos。</p><p>晚餐吃了生煎</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/B3A28CF8-E3B5-4F58-9877-60C26F9A4002_1_105_c.jpeg"                      alt="B3A28CF8-E3B5-4F58-9877-60C26F9A4002_1_105_c.jpeg"                ></p><p>随后在商场里又转了一圈，面基活动算是结束了。而我则是顺路去豫园转了一圈</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled%203.png"                      alt="Untitled"                ></p><p>冰沙，喝完第二天拉肚子…</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/EF3E35BF-E505-4889-90E4-CA6DBE9B39EB_1_105_c.jpeg"                      alt="EF3E35BF-E505-4889-90E4-CA6DBE9B39EB_1_105_c.jpeg"                ></p><h2 id="四-1"><a href="#四-1" class="headerlink" title="四"></a>四</h2><p>早上睡到了很晚才起，收拾好东西下楼退房已经是11点59了。之后前往新酒店的路上实在饿，路边找了家店吃了点东西，一个小馄饨加一笼烧卖60，这两天都在外滩这附近，之前看到的东西价格都是类似的，以为上海都是这个价格，也就吃了，但事后才知道原来被宰了…</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/9E6941F6-E105-446D-8F84-AB2F13DC3858_1_105_c.jpeg"                      alt="9E6941F6-E105-446D-8F84-AB2F13DC3858_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/D31E6BF8-20C5-4508-8858-79B71EE24F8B_1_105_c.jpeg"                      alt="D31E6BF8-20C5-4508-8858-79B71EE24F8B_1_105_c.jpeg"                ></p><p>酒店</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/F5E46D5C-CD01-42DF-A93C-1498F9E6DCD8_1_105_c.jpeg"                      alt="F5E46D5C-CD01-42DF-A93C-1498F9E6DCD8_1_105_c.jpeg"                ></p><p>下午朋友喊我去卡拉OK，但我实在无法忍受里面的高音量以及接受不了自己唱歌，还是拒绝了。休息了好久，到了外面的世纪公园转了转，散散心还是比较舒服的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/B0C88E33-6A75-41B4-B94E-875CD6E77C2A_1_105_c.jpeg"                      alt="B0C88E33-6A75-41B4-B94E-875CD6E77C2A_1_105_c.jpeg"                ></p><p>傍晚则是赶去和高中同学约了一波饭。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/68F02D47-7184-411C-BB75-3EEABCA34A7F_1_105_c.jpeg"                      alt="68F02D47-7184-411C-BB75-3EEABCA34A7F_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/22777C67-DD9C-4A38-A83F-2BC5BC35F05F_1_105_c.jpeg"                      alt="22777C67-DD9C-4A38-A83F-2BC5BC35F05F_1_105_c.jpeg"                ></p><p>在回去的地铁站到处都是人</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/62E5B530-2D67-4756-97C7-C63920F6CDAB_1_105_c.jpeg"                      alt="62E5B530-2D67-4756-97C7-C63920F6CDAB_1_105_c.jpeg"                ></p><p>由于前两天拍的外滩全景有很多问题，因此决定重新拍，晚上又是去陆家嘴周围的江边一顿忙碌。</p><p>晚上回去后在酒店的浴缸里泡了一阵子，很是惬意。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/67A7D809-3D41-4DB4-94B6-39E5832FAF10_1_105_c.jpeg"                      alt="67A7D809-3D41-4DB4-94B6-39E5832FAF10_1_105_c.jpeg"                ></p><h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><p>这一天起床已经快十二点了，准备去和网友面基吃饭。到了目的地后由于太晚一些吃饭的地方已经暂时关门了，因此走到了略远的一家店，味道还挺不错。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/AF2AE1B7-B340-4E76-B36E-3CFF49B6A63A_1_105_c.jpeg"                      alt="AF2AE1B7-B340-4E76-B36E-3CFF49B6A63A_1_105_c.jpeg"                ></p><p>下午也是City walk，听推友讲了好多有趣的事情，之后到了鸢尾书店，这家书店里有一些奇怪的营销书。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/12951DA2-D883-44B8-AB75-E33937000039_1_105_c.jpeg"                      alt="12951DA2-D883-44B8-AB75-E33937000039_1_105_c.jpeg"                ></p><p>晚上和同事约了饭，是一家越南菜，感觉还可以</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/6CC50083-7408-4D2E-B43D-F710E9170487_1_105_c.jpeg"                      alt="6CC50083-7408-4D2E-B43D-F710E9170487_1_105_c.jpeg"                ></p><h2 id="六"><a href="#六" class="headerlink" title="六"></a>六</h2><p>收拾好东西后出发到火车站，在车站周围的饭馆和一位网友面基，随后则是一起到了火车站。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/8067618C-1CC9-4257-99F5-59027AAF815F_1_105_c.jpeg"                      alt="8067618C-1CC9-4257-99F5-59027AAF815F_1_105_c.jpeg"                ></p><h1 id="杭州"><a href="#杭州" class="headerlink" title="杭州"></a>杭州</h1><h2 id="一-3"><a href="#一-3" class="headerlink" title="一"></a>一</h2><p>下午到了杭州，由于第一次住民宿没有经验，费半天劲才找到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/8B34023F-EF13-4127-BDB9-3F720686CE5A_1_105_c.jpeg"                      alt="8B34023F-EF13-4127-BDB9-3F720686CE5A_1_105_c.jpeg"                ></p><p>之后去和一个网友汇合逛了一圈，不得不说国庆节的杭州人是真的多</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/00F8B6E2-3FCB-4377-90CE-C1AB8A84DB53_1_105_c.jpeg"                      alt="00F8B6E2-3FCB-4377-90CE-C1AB8A84DB53_1_105_c.jpeg"                ></p><p>晚上我们和另一个推友汇合，约了一家餐馆吃饭，感觉菜品口味略咸</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/754FB73D-207F-49FB-829B-6B9057BD50B4_1_105_c.jpeg"                      alt="754FB73D-207F-49FB-829B-6B9057BD50B4_1_105_c.jpeg"                ></p><p>之后三人一起转了好多地方</p><h2 id="二-3"><a href="#二-3" class="headerlink" title="二"></a>二</h2><p>中午起，下午和推友一起逛城市阳台附近，玩了刮刮乐，晚上和一群人面基</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/31F1AA37-CC3E-4062-8ACB-F3839BEDA16E_1_105_c.jpeg"                      alt="31F1AA37-CC3E-4062-8ACB-F3839BEDA16E_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/DB7A1188-1534-4DD9-BAAD-D256AB678E34_1_105_c.jpeg"                      alt="DB7A1188-1534-4DD9-BAAD-D256AB678E34_1_105_c.jpeg"                ></p><p>M属性大爆发！</p><p>散了以后之后去文化中心拍照，但周围的景观灯都已经灭掉了</p><h2 id="三-3"><a href="#三-3" class="headerlink" title="三"></a>三</h2><p>早上四点半起，去拍没人的西湖</p><p>在等待拍照的过程中，周围其实已经有一些来来往往的人了，有的是游客，有的是晨练的大爷大妈</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/Untitled%202.jpeg"                      alt="Untitled"                ></p><p>最后拍出来的效果比较一般。走的时候已经6点左右了，但没想到桥上已经全都是人</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/F4F288B6-88C4-44CA-A590-5C12F8FC7BAA_1_105_c.jpeg"                      alt="F4F288B6-88C4-44CA-A590-5C12F8FC7BAA_1_105_c.jpeg"                ></p><p>随后找了家店吃了点小馄饨，回去继续睡觉了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/311CFEE7-4FDD-4FD6-954D-4A0568DDD5AF_1_105_c.jpeg"                      alt="311CFEE7-4FDD-4FD6-954D-4A0568DDD5AF_1_105_c.jpeg"                ></p><p>中午十二点起，下楼买洗衣液以及买点午饭，回来吃饭，洗衣服，玩switch，看视频，午睡</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/4A04AECA-56F5-4AD4-92A3-0F7E17770DB6_1_105_c.jpeg"                      alt="4A04AECA-56F5-4AD4-92A3-0F7E17770DB6_1_105_c.jpeg"                ></p><p>快黄昏了爬起来去拍钱塘江对面的夜景，这里有一个灯光秀，所以有非常多的人，好在前面有栏杆挡住围观群众，我可以放心的把机器放到前面拍</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/C008E6FD-E018-4894-9948-3DDA9D26508D_1_105_c.jpeg"                      alt="C008E6FD-E018-4894-9948-3DDA9D26508D_1_105_c.jpeg"                ></p><p>晚上拍文化中心的夜景</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/E4CCAF3D-B1C6-4A8F-9E89-37668756B044_1_105_c.jpeg"                      alt="E4CCAF3D-B1C6-4A8F-9E89-37668756B044_1_105_c.jpeg"                ></p><p>回来到夜市逛，钓鱼，买吃的，钓鱼的过程我总觉得自己才是被店家钓到的鱼。旁边一个小哥也是在钓鱼，但是苦于一直没上钩，和他同行的人一直在催促他回去，他想要钓上了再走，但是最后还是被同行者拖走了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/666AEFFF-CFF1-4495-9F74-664DB0317E39_1_105_c.jpeg"                      alt="666AEFFF-CFF1-4495-9F74-664DB0317E39_1_105_c.jpeg"                ></p><h2 id="四-2"><a href="#四-2" class="headerlink" title="四"></a>四</h2><p>起床后收拾东西直接赶往了火车站，吃了碗面</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/first-travel/11F4FB54-03C0-4A59-AF23-976A1BE78D28_1_105_c.jpeg"                      alt="11F4FB54-03C0-4A59-AF23-976A1BE78D28_1_105_c.jpeg"                ></p><p>由于肠胃不舒服也就没有心情写一些游记之类的内容，只好玩了会switch打发时间，直到上车回家，这为期半个月的旅行也就彻底结束了。</p><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>这半个月大部分时间比我预想的要忙碌得多，几乎每天不是在奔波拍照，就是和网友面基，晚上也都是很晚的时候拖着异常疲惫的身躯回到了酒店，很少会有像一开始坐飞机时那种闲情逸致去思考，去用尽心思记录下自己的想法和感受。所以本文的内容几乎是记录了一堆流水账，以及很多都是过后补全的，也导致内容风格十分分裂。但是看着这些照片和行程的记录，仍然有一种旅行的过程历历在目的感觉，这也就足够了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文作为流水帐般的游玩记录，多图杀猫。如果你对我旅行前后的想法有兴趣那请访问这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;link&quot;   href=&quot;https://homura.live/2023/11/05/Life/travel-meditations/&quot; &gt;https</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="Travel" scheme="https://fusionbolt.github.io/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>25</title>
    <link href="https://fusionbolt.github.io/2023/08/23/Life/25/"/>
    <id>https://fusionbolt.github.io/2023/08/23/Life/25/</id>
    <published>2023-08-22T16:00:00.000Z</published>
    <updated>2023-08-22T16:19:15.908Z</updated>
    
    <content type="html"><![CDATA[<p>25在我眼里是一个略微规整的数字，是5的平方，是75的三分之一，是一百的四分之一，乘二就能凑满一个十，同时又是一个奇数。不过对此时的我来说，比起数学上的意义，更重要的是年龄上的意义，大家都开玩笑说到了25就该奔三，现在我也到了这个时候了。</p><p>关于年龄这个事情，我觉得继续持续增长也挺好的，因为年龄增长的同时自己所能做到的事情也更多了，不论是知识，人际关系，还是金钱，不出意外在这个阶段都是处于上升的期间。只是如果带着回忆回到过去，那我很大概率会选择回去的，在过去的25年里，不知道做了多少错误的事情，其中还有一些是不可挽回的，但事已至此，我也不会再去计较那么久远的自己。</p><p>不过比起身体的年龄，人格，精神上的年龄似乎更加重要。在这方面我远比周围人开始成长的要晚，大概在18岁左右才开始从一个听到什么做什么的人，只会听从本能的人，到开始产生想法与思考，渐渐成为了现在这个样子。我不知道该如何客观的评价现在的自己，只是有一点可以肯定的，我在不断的改变，尤其是克服了许多缺点，许多不良想法。前些时间写的自我介绍或许算是自我评价的一部分吧，在这里也不再重复描述现在的自己了</p><p><a class="link"   href="https://homura.live/2023/07/02/Other/dissuasive-self-presentation/" >https://homura.live/2023/07/02/Other/dissuasive-self-presentation/<i class="fas fa-external-link-alt"></i></a></p><p>我承认总体有些偏向负面的评价，不过有一点我还是可以认同自己的，着已经远比最初意识觉醒的自己要好很多。过去对我刚开始产生想法时的不良影响还是很大的，不过这些影响已经随着我的改变逐渐减少，尽量克服也是我在未来要做的工作。</p><p>对于这个年龄有一个比较难绕过去的问题：亲密关系，或者更直接地说是恋爱。正巧昨天是七夕，下班路上看到有人在地铁口卖花，生意也不错，路上也有许多情侣。对于寻求亲密关系的我来说，很难不羡慕。我对爱情的渴求，不仅是因为自己是母单，在我变化的过程中，渐渐觉得情感，甚至是爱情是我特别重视的部分。我喜欢魔法少女小圆中圆焰的爱，喜欢利兹与青鸟中霙与伞哥哥的爱，在我意识到这些之前，就已经被焰这个角色对于圆的炽热爱意所吸引，只是近一两年才真正认识到自己的这部分。焰在叛逆的物语中有一句让我印象深刻的台词：</p><blockquote><p>比希望更炽热，比绝望更深邃的，是爱啊</p></blockquote><p>或许只有接近完美的爱，才能达到这种情感的极致，我甚至觉得这种体验是对于我这样情感匮乏的人是必需品。在过去半年我在推特上发了许多自身对这种情感需求很强烈的内容，不过现在这种事情已经自认无缘了，不太想多挣扎了，现在也已不再去发这些内容，虽然有些遗憾，但是也没办法。</p><p>另外我和众多这个年龄的人一样，对人生感到迷茫。虽然我有在做一些事情，但我不能确定自己喜欢什么，想要做什么，要如何做出选择，等等。也有一些事情确实妨碍了我的探寻，无法治愈的抑郁和焦虑环绕着我，经常因此无法行动，甚至对自己的无能，对自己面对的一切感到绝望，因此我开始有些无法判断自己不做某件事情的原因，到底是因为什么。不过随着我对自身感受更多的关注，逐渐能够意识到一些东西并不是我真正所想的，只是被环境胁迫，被自己胁迫，才不得不做的事情。</p><p>这一切都是在面对抑郁和焦虑中查找资料与自身感受逐渐习得的，我无法等待一切痊愈后再去探寻，因为或许永远无法痊愈，不可能等到准备完全的时刻再上场，准备完全也是不存在的。我只能去试着读书，或者看他人的文章，学习他人的经验。在这个过程中，我看到了自身想法的真相，看到了焦虑小人，抑郁小人后面真正的自己，看到了自己内心更深处的需求，自己用着如何扭曲的形式将这些表现出来，这些表现是如何干扰我去了解自己的。（不论怎么说我还是希望这些疾病从未缠绕过我，即便带给了我部分成长，但在我痊愈之前我很难完全接受）。这个过程，或许也可以被称为追寻自我，喜好、想做的事情，其实都是自我的一部分。</p><p>纵使我再迷茫，在上述的探索过程中我也发现了很多关于自我深处的片段。自己对精神层面的追求，包括但不限于情感、道德与自我的完善。我想沿着这些走下去的话，迟早有一天会破除迷茫吧。而这一切，我认为都是从我决定开始独立思考，开始探寻的时候就埋下了种子，我在思考，形成自己的独立意见，输出观点的过程都是在给种子浇水施肥，直到现在这个时间，总算发了一个小芽。另外这个过程中也有外界的温暖阳光和风吹雨打影响着我。带给我比较大改变的也许是我2021年在推特认识的朋友，和他的交流，和他产生的连接，某种程度上也加快了自己成长的脚步，我也被他所影响，受到他许多帮助，总之十分感谢他。</p><p>在这个过程中除了有这些进展，但还有非常多未能解决的问题缠绕着自身，像前面所提到的抑郁和焦虑，我认为都是自身的这些问题未能解决的结果，不论是缺失的情感，还是自身的种种无能。这都非常困难，这几年的时间，让我把情绪的根源问题规约到了这两者上，只是已不能再继续了。我一直在解决问题的失败中重复，一直在类似的错误中重复，像焰一样徘徊在似乎没有尽头的时间迷宫，但与焰不同的是我连唯一的路标也看不到，了解自我也无法成为解决自身问题这一方面的路标。不知道自己何时才能克服这些，或许要几年，搞不好或许要几十年，或者直到我去世都未能克服未能接受。我总是期待贵人出现，给予我指点。甚至会更不切实际的想在他的帮助下一切就随之解决，但这是不可能的，他人最多给予我一个方向，最终必须要靠我自己亲自解决。</p><p>回首过去的一切，我虽然一直觉得自己运气不好，但其实我走过的路中有许多运气成分，许多地方自己真的很难想象走其他的路会有怎样的后果。过去一直觉得自己招人厌，没有人愿意帮助我，但实际上并不是有贵人指点才叫帮助，我从许多人那里以各种形式得到了帮助，也是对这些人们十分感谢。经历的一切，很难说有什么美好的事情，但已经逝去也就不必再为其痛苦。那未来呢？短期的未来或许仍然会迷茫，但仍会继续寻求自我的完善与修正，寻求自我的协调。我想这是自己在毫无意义的人生中唯一的路标，也是绝对不会错的路标。</p><p>以下是人生故事会环节，我选择将过去用文字简单写下，读者可忽略。</p><p>这种文章也难免回忆过去，那么从头讲起吧。我出生在一个算是贫困的家庭，除了能保证基本的衣食住行，其他都是奢望，大家习以为常的旅游，美食，电影，游戏机等均与我无关。之后就这样普通的上了学，在学校渐渐开始觉得被排挤孤立，当时愚笨的我根本不懂为何，都是些现在看来真的活该的原因。后来到了初中感受更加强烈，毕竟大家心智和身体都在成长，而我成长的只有身体，仍没有意识到原因，理解那些事情，已经是前几年的事情了。不过尽管如此，我也上了一个普通高中，此时也是我黑历史最多，并且最难忘却的时段，要是拿出来讲可能三天也写不完这文章了。同时这是我的第一个人生拐点，不过是往下拐。这个时候因为各种原因，包括家里接入网络，有了山寨智能手机等原因，上课睡觉，不学习，考试成绩渐渐到了底。另外高中不再是按地域划分，遇到的同学也开始不一样，现在回想起来，家境、见识、各方面真的是差的非常多，但对当时的我来说根本不懂这些事情，拿自己跟其他人比的话真的是非常丢人。不过在最后的一年想法开始产生了一些改变，迎来了我的第二个人生拐点，我到现在也没明白为什么那个时候突然就变了。尽管如此，仍然敌不过自身的无能，最后也就“顺其自然”地考上个一个专科。</p><p>后来大一下学期，听到一些同学提到知乎，我好奇的搜了下，没想到让当时的我眼界大开，虽然知乎现在很烂，但是那个时候真的是做到了让我这个井底之蛙看到更广的世界，让我愈发感受到了无能，让自觉有点小聪明的自己感受到强烈的自卑。此时开始我的焦虑就愈发严重，之后很长一段时间内都很容易沉入在类似的焦虑中，并且随着我接触的更多，这种感受越强烈，甚至几次想过“我是不是最初就不应该看到这么广阔的世界，一直当井底之蛙就好了”（不过这种感受这两年已经开始小时了）。随后专科即将毕业，我去考了一个专升本，顺利的续了接近两年学生时光。最后一年其实就开始找工作了，一直不顺利。当初想要去上海的，但是boss上投简历均石沉大海，也就没了希望。之后经过各种离奇的经历，我来到了现在的公司实习，转正，并且工作到现在，很感谢内推我的人，没有这个机会我现在很难说在哪里做什么奇怪的工作。</p><p>这就是我人生前25年的人生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;25在我眼里是一个略微规整的数字，是5的平方，是75的三分之一，是一百的四分之一，乘二就能凑满一个十，同时又是一个奇数。不过对此时的我来说，比起数学上的意义，更重要的是年龄上的意义，大家都开玩笑说到了25就该奔三，现在我也到了这个时候了。&lt;/p&gt;
&lt;p&gt;关于年龄这个事情，我</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
  </entry>
  
  <entry>
    <title>看不见的女性</title>
    <link href="https://fusionbolt.github.io/2023/08/19/Reading/invisible-women/"/>
    <id>https://fusionbolt.github.io/2023/08/19/Reading/invisible-women/</id>
    <published>2023-08-19T11:47:17.000Z</published>
    <updated>2023-08-19T11:48:01.034Z</updated>
    
    <content type="html"><![CDATA[<p>性别对立，是现在非常容易引起争议的话题。女性们普遍处于弱者的位置，当她们开始寻求自己应有的权利，而不是一直像现在这样，争论也就因为各种原因进一步变多了。那么女性的地位具体到底是怎么样的呢？我觉得这本书已经相当清晰的讲述了在世界上女性的现状，虽然因国家会有微小的不同，但是趋势都是一致的，相对于男性来说处于相当不利的位置。</p><p>即便不看书，我们在生活中也能看到许多例子，包括但不仅限于遭受各种方式的暴力，一些行业的就业歧视，另外在国内一些非常传统家庭中女性被长辈们认为不应该多读什么书，早点找个人结婚生子才是正事。这当然是非常扭曲的事情，不论是男性还是女性，都首先是一个人，在这一层面应当是被同样尊重的，<strong>在做到这个前提下</strong>接纳彼此差异，针对不同性别做一些差异化的帮助，因为躯体差异确实存在，并且也不是简单几句话就能概括的。</p><p>躯体的差异这本书中关于寻医问药的部分提及了很多，这也是让我看了感觉最不适的部分。不同性别由于身体结构的影响，同一个药物的反应可能是完全不一样甚至相反的，但药物研发的时候甚至没有针对女性做同样数量的测试，影响到人体健康不认真进行测试是比较危险且对患者不负责任的事情。此外对于患者的诊断都是基于男性为标准，也就是说中提到的“燕特尔综合征”，导致许多女性更难及时得到治疗，甚至本可以规避死亡却因为诊断的问题而无法规避。</p><p>除了寻医问药外，书中还提及了女性在日常生活，职场，所用工具的设计，公共生活，以及遇到灾难时这几种情况下女性的权益无法受到保障。许多问题的核心来源正如书的标题所讲，女性被忽视了，甚至在一些场合还会出现歧视，在招聘的时候都不愿意招聘短期内具有生育可能的员工，生育前后的休息时间让女性难以适应工作的变化。</p><p>此外社会也没有教导人们如何去应对性别的差异，使得很长一段时间内女性处于完全不公的状态。但随着互联网时代信息的快速扩散，这种不公的问题也暴露的越来越多，意识到问题的人能够将自己的想法传达给更多的人，使得目前性别地位开始有所变化。过去人类社会在很多方面几乎忽略了这百分之五十的人类，我想在历史的发展中，这样的忽略会付出许多的代价，女性和男性具有同等程度的思考能力，同时不同性别的人思维方式会有所差异，那么发展的过程中相当于抹杀了那一部分的可能性。但是当这个现状开始改变的时候，这些可能性也就慢慢涌现了出来了，或许使得社会走向不同的道路。</p><p>女性的生活实际上比我所要想的要困难，虽然我这么说，但我并没有仔细考虑过这些问题。作为一个男性能做的，或许就是像我前面所说，在尊重作为人的一面的前提下，接纳彼此的差异，同时认清并且牢记现实中被忽略的这部分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;性别对立，是现在非常容易引起争议的话题。女性们普遍处于弱者的位置，当她们开始寻求自己应有的权利，而不是一直像现在这样，争论也就因为各种原因进一步变多了。那么女性的地位具体到底是怎么样的呢？我觉得这本书已经相当清晰的讲述了在世界上女性的现状，虽然因国家会有微小的不同，但是趋势</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="对立" scheme="https://fusionbolt.github.io/tags/%E5%AF%B9%E7%AB%8B/"/>
    
  </entry>
  
  <entry>
    <title>欲望</title>
    <link href="https://fusionbolt.github.io/2023/08/08/Thinking/desire/"/>
    <id>https://fusionbolt.github.io/2023/08/08/Thinking/desire/</id>
    <published>2023-08-08T14:09:56.000Z</published>
    <updated>2023-08-08T14:10:48.958Z</updated>
    
    <content type="html"><![CDATA[<p>人因欲望而前进，但又经常会因为欲望无法实现，又或者不可能实现而苦恼不已。在《诗人十四个》中有这样的一段话</p><blockquote><p>有追求，就有落空的可能。应对此事只有两种策略：一是通过觉悟认识到追求的虚幻性，从而放下我执；二是用人格和意志的力量勉力支撑，直到人生尽头。</p></blockquote><p>尽管原文是针对个人的追求，针对个人遇到的挫折与苦难，但我觉得针对欲望仍然是如此，同时还认为个人追求其实也是一种个人的欲望。要不放下自己的执念，要不就是像西西弗一样不论是否能到达终点，仍然不断前进。</p><p>此时的我正被欲望所吞噬，不论是想要变好的欲望，还是对于金钱或者爱情，但同时又因为自己无法实现其中任何一者而备受折磨。欲望是带给人前进的动力，但是当看不到前进的路时就会感到无力，但同时如果又无法放下到达目的地的执念，只会有心力被消耗。</p><p>恰巧最近还在看《瓦尔登湖》，就目前所看的部分与欲望十分贴近的观点是“简单的生活，减少被世俗欲望所影响”。在俗世中最容易被提及的则是金钱，而在书中最先提及的部分也是和金钱相关，人们为了金钱付出了太多，但是却放弃了许多其他的东西。之后还提及了和别人的交际，认为和人们相处很快会感到乏味，思索或者劳作的人总会孤独，独处更加有益身心。我却觉得这些观点上有些极端。作者的主要观点我觉得实在表达要直接去做真正要做的，而不是被无关的事情所影响，这样的观点我也是非常认同，基于这个观点上来说，如果人的欲望是发自自己内心的，或许也可以等价为自己想做的事情，那即便为此去做些俗世的追求也并没有什么不好。而对作者来说，脱离世俗是他更好的达成自己欲望的一部分，不论是为了追求更多的知识，与大自然接触，这仍然是他的欲望。</p><p>但发自内心的又是什么呢？这个答案的细节一定是因人而异，但每个人发现的答案一定有类似点，即不受外界环境影响，无论在哪里都会有这样的想法。如果只是人云亦云，我想那无法称之为发自内心，而是作为人群的欲望罢了，不论是名声，财富。但是如果你摆脱了人群仍然想要得到这些，那去追寻我想也无妨。</p><p>欲望，一直都被认为是魔鬼般的存在，但我现在却不这样想了。我现在处于认为人生没有意义的状态，甚至对我来说活着就是尽可能满足自己的欲望，没有欲望的人，很难想象要怎么活下去。但我是一个十分贪婪的人，又不肯放弃哪些欲望，而且自身能力不够又无法抵达，这样的人路在何方呢？或许有朝一日会找到答案吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;人因欲望而前进，但又经常会因为欲望无法实现，又或者不可能实现而苦恼不已。在《诗人十四个》中有这样的一段话&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有追求，就有落空的可能。应对此事只有两种策略：一是通过觉悟认识到追求的虚幻性，从而放下我执；二是用人格和意志的力量勉力支撑，直到</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>时间的洪流</title>
    <link href="https://fusionbolt.github.io/2023/08/06/Thinking/flood-of-time/"/>
    <id>https://fusionbolt.github.io/2023/08/06/Thinking/flood-of-time/</id>
    <published>2023-08-06T11:03:32.000Z</published>
    <updated>2023-08-06T11:04:39.945Z</updated>
    
    <content type="html"><![CDATA[<p>时间，一个再熟悉不过的词语，但是我们对其又非常陌生。</p><p>做什么事情都需要时间，发呆需要时间，写这些内容需要时间，看这些内容也需要时间，即便什么都不做，也需要时间。关于时间的话题也有很多，比如最常听到的珍惜时间，但我不打算讲这些听的耳朵出茧的大道理。</p><p>时间在我眼里是自我的一部分。时间由自我来掌控，同时通过对待时间的态度和方式显现出了一部分的自我。生活中有几句经常能听到的话：没时间啊，有时间就好了；能不上班就好了，那样就有时间做自己的事情了，这样的话本质都是类似的。但绝大部分情况下只是自我欺骗，或者说是某件事情对自己来说并没有那么重要，你的自我控制了你去做其他事情。</p><p>我之前经常会因为时间过的太快而焦虑，进一步观察其实是觉得自己没做什么正经事情，但我也没什么想做的事情，这样的我在回看过去的时间时焦虑感是不可避免的。或许当我找到属于自己在时间这一无尽的洪流中漂流的方式时，能够不再会为了体会到这种被迫漂流的感觉而感到害怕和无助，因为我知道这种漂流方式是自己主动选择的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间，一个再熟悉不过的词语，但是我们对其又非常陌生。&lt;/p&gt;
&lt;p&gt;做什么事情都需要时间，发呆需要时间，写这些内容需要时间，看这些内容也需要时间，即便什么都不做，也需要时间。关于时间的话题也有很多，比如最常听到的珍惜时间，但我不打算讲这些听的耳朵出茧的大道理。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>mold源码阅读十六 回顾整个流程</title>
    <link href="https://fusionbolt.github.io/2023/08/05/mold/mold-16-summary/"/>
    <id>https://fusionbolt.github.io/2023/08/05/mold/mold-16-summary/</id>
    <published>2023-08-05T10:17:42.000Z</published>
    <updated>2023-08-05T10:31:22.234Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-16-summary/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:80173499</center> <h1 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h1><p>在以往十六期的博客中，我们沿着mold中的main函数一路追寻了下去，直到结束。</p><p>首先我们熟悉了<a class="link"   href="https://homura.live/2023/02/12/mold/mold-0/" >文件结构以及项目目录<i class="fas fa-external-link-alt"></i></a>等，<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#read-file" >查看了如何读取不同类型的文件<i class="fas fa-external-link-alt"></i></a>，其中最关键的是<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#ObjectFile" >obj<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/05/mold/mold-2-read-shared-files/" >dso<i class="fas fa-external-link-alt"></i></a>，lto三种，分析了不同类型的差异及其特有的处理方式。同时在查看如何解析elf的过程中了解elf头，了解了<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#InputFile" >mold对象的构造<i class="fas fa-external-link-alt"></i></a>，以及elf中信息查找段、符号等的方式。</p><p>当我们收集齐输入的文件信息后就要开始对这些文件进行处理。首先做的是<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#dso-uniquely" >dso去重，避免多个同名dso导致的错误<i class="fas fa-external-link-alt"></i></a>。接下来是最重要部分：符号信息解析。符号相关的过程有许多包括<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#%E7%AC%A6%E5%8F%B7%E5%86%B3%E8%AE%AE" >符号决议<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/#compute-import-export" >符号的导入导出<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/" >动态链接的符号的版本确定<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/06/19/mold/mold-9-unresolve-symbol/#claim-unresolved-symbols" >处理未解析的符号<i class="fas fa-external-link-alt"></i></a>等等。之后还对<a class="link"   href="https://homura.live/2023/04/16/mold/mold-4-mergeable-section/" >mergeable的段进行合并<i class="fas fa-external-link-alt"></i></a>。</p><p>处理完符号相关的信息后开始<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#create-output-sections" >创建输出文件<i class="fas fa-external-link-alt"></i></a>，准备将许多input section合成一个output section。此时需要对于常见synthetic<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#add-synthetic-symbols" >符号<i class="fas fa-external-link-alt"></i></a>与段的构造，并且将它们放到输出的文件中。在实际输出文件之前还需要确定文件内部布局，主要对<a class="link"   href="https://homura.live/2023/06/24/mold/mold-10-sort-section/" >段排序<i class="fas fa-external-link-alt"></i></a>，其中包括chunks之间排序，以及output section内部保存的input section的顺序。</p><p>当文件布局确定后我们就可以<a class="link"   href="https://homura.live/2023/07/02/mold/mold-11-rel-and-dynsym/" >创建rel相关的段，将符号写入对应的符号表<i class="fas fa-external-link-alt"></i></a>，计算段内的一些信息，对部分<a class="link"   href="https://homura.live/2023/05/20/mold/mold-7-before-create-output-section/#Create-Synthetic-Sections" >synthetic段构造<i class="fas fa-external-link-alt"></i></a>等等。之后<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#compute-section-headers" >更新section对应的shdr<i class="fas fa-external-link-alt"></i></a>，以及<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/" >更新段的虚拟地址<i class="fas fa-external-link-alt"></i></a>，对<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#fix-synthetic-symbols" >synthetic符号的值进行修正<i class="fas fa-external-link-alt"></i></a>等。通过这些操作来确定下文件载入内存中的布局。</p><p>最后再将这些<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#copy-chunks" >拷贝到输出文件<i class="fas fa-external-link-alt"></i></a>中。在拷贝的同时还做了许多操作，比如说段的重定位，填写ehdr以及其他synthetic段中的信息。</p><p>在整个过程中也有许多检查，比如符号重复定义或者未定义。还有许多优化，例如对<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#gc-sections" >section进行标记来回收无用段<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#set-virtual-addresses-by-order" >安排输出段的位置<i class="fas fa-external-link-alt"></i></a>使得相同读写权限的段尽可能在一个页内，<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#icf-sections" >消除重复的ehframe项<i class="fas fa-external-link-alt"></i></a>，段压缩等等。</p><p>以上就是链接器mold的概况。</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>最初会开始看链接器的实现是因为感到好奇，加上之前每次遇到链接相关的问题第一反应是头大，觉得解决不了。后来看到mold这个链接器，其中的代码量还在我能串一遍理解的范畴，因此开始了读代码的过程。读的时候做着记录，后来想着干脆开一个系列博客，我在读的时候经常容易跳过某些细节，写博客的过程中会强制自己对这些细节进行强制思考。</p><p>经过了十六期的文章后，整个mold的链接过程基本上就全部过了一遍，而我对于链接器工作的整个流程有了更详细的认知。以前对于链接的模糊印象就是简单的相似段合并，符号解析（但是不知道符号解析具体是在做什么），生成可执行文件或者library，但现在我对于这些部分有了更多的了解，并且还知道了链接过程不止有这些，还有包括synthetic的符号和段的处理，虚拟地址计算，重定位操作等等。</p><p>除此之外还看到了许多未曾想到的东西，在看到一些处理过程后，对动态链接以及加载的过程也有了更多的了解，还有一些之前从未想过能如何联系到一起的想法，比如说相同attribute的段放在一起，避免单独成页，减少运行时的内存等。</p><p>虽然学到了很多东西但是还是有很多地方其实是一知半解，阅读源码远不如实际写来困难，虽然能够大致讲出整个链接器的结构是怎样的，但是对链接器来说最重要的还是各种边边角角的细节，或者意想不到的东西都会在写的过程中出现。我现在在造各种轮子玩，想自己做出各种东西并且串联起来，或许会有一天也会需要造自己的linker吧。</p><p>在源码通读的过程可能花了过久的时间，有些低效。但很多东西我一开始确实没意识到，很多问题都没有提出，不过查看了前面的这些过程后，现在开始阅读不仅是了解了有什么，还让我能够提出一些问题。</p><p>在博客内容写作的过程也不太熟练，最近也是为自己博客写作感到焦虑。不论是内容详细程度，以及排版，内容划分做的都不太好。在学习的时候看到maskray聚聚的文章，多少受到了一些启发，意识到自己过于注重于原来的代码怎么写，对于代码背后的原理关注的相对较少，这其实才是要学习的本质内容，又不是学习代码技巧。在后面几期也在有意识的进行改正，之后写其他阅读代码的博客时也会继续试着这样来做。</p><p>排版上试了不同的方案，比如说最早是放一段读一段，后来又尝试一次讲完一个流程然后贴整段代码，之后再对其中需要更加深入的细节加入小标题来做。不过感觉怎么都很别扭，markdown似乎没什么办法分成代码和文字两列，最后还是觉得先讲清楚流程再放代码了。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>如果后续勤快的话还会继续更新一些东西，除了这样通读外，还想针对特定主题进行贯穿一遍，而且还有一些没有详细看细节但是比较重要的东西。（总觉得说出这样的话就会懒得更了…）</p><p>比如说各种synthetic的符号更详细的介绍， 梳理做的各种优化，header的生成，为动态链接做的准备（got，plt等），数据压缩与解压，为重定位所做的各种操作，最终产物的地址计算与关联等等，这些其实都还比较模糊，没有一个确切的印象，需要单独串联起来理解整个过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-16-summar</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>初探黑塞文学</title>
    <link href="https://fusionbolt.github.io/2023/07/30/Reading/first-look-at-hesse-literature/"/>
    <id>https://fusionbolt.github.io/2023/07/30/Reading/first-look-at-hesse-literature/</id>
    <published>2023-07-30T12:10:13.000Z</published>
    <updated>2023-07-30T12:10:30.583Z</updated>
    
    <content type="html"><![CDATA[<p>黑塞的作品中我最早有所了解的是《在轮下》，从b站up主黄鸭兄的视频中了解了整个故事，当时觉得从内容到立意都挺有意思。后来看到黄鸭兄视频中提到《荒原狼》的内容，其中魔剧院中从人驯服狼到狼驯服人的场景震撼到了我，因此选择了这本书作为自己接触黑塞文学的开始。书中从开始到结尾都远超预期，处处让我惊叹，剧情本身的安排，对主人公心理的描写，以及最后的魔剧院的部分，全部引诱着我沉迷于黑塞的故事世界，使我对黑塞的作品充满了好感。</p><p>后来想要接触到更多黑塞的作品，看到《悉达多》是其代表作，遂开始读了起来，读完后觉得非常有黑塞的风格，同时开始坚定的认为黑塞的作品就是我想要看到的，黑塞的故事所传达的精神内核就是我想要追寻的。之后朋友回给我的一封邮件中提及到《德米安》，他在大学时也看了许多黑塞的作品，我也不由分说的开始阅读了起来。不出意外，这本书同样也让我感到非常满足。</p><p>黑塞的作品中那种强有力的吸引力到底是什么？对我来说或许是从中表现出的对自我的剖析与追求，对人生的探索，在人群中仍然抱有强烈的自我，等等。词汇匮乏的我难以用一个词语概括这一切，只能粗略的认为它们都属于精神的世界，属于人类的内核，我对这些内容产生的更多是感受，看到相似的内容会觉得“这个东西一定也是属于同一类”。</p><p>看到个别书评提到黑塞的一些书籍都是翻译的功劳之类的，但翻译只是片面的文字描述罢了，而且翻译不论怎么做都要忠实于作者的原意，黑塞的作品中所展现出的灵魂是不会被不同的文字形式所覆写。就像我最初开始接触荒原狼一样，并不是因为文笔是如何的，而是黑塞笔下的故事本身向我伸出了无形的手，而我甘愿被其所拉入黑塞的故事世界。</p><p>不同的人对一本书的评价是不同的，除去每个人角度不同外的原因外，作品的喜好也是因人而异的。对我来说黑塞的作品正是我最喜欢的，同时其传达的内容也是我所追求的。有的人比较喜欢那些比较正面、能鼓励人心的故事，曾看到有人说喜欢西西弗的故事，被其勇气所感染，但我却不会被这种故事所打动。我更喜欢探寻人类的灵魂，或者发掘更多隐藏在故事背后的真相，这样的故事更多是在讲述着什么，而不是着重于赞扬与批判，这种判别是不可避免的，但上升到更显眼的层面似乎就开始有点变质了。</p><p>黑塞的作品还有不少未看，希望这些能给我带来更多的满足与惊喜，也希望能够发现其他笔下故事能带给我类似感受的作家，借此更加深入自我的内核，同时去感受这些作家们的精神世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;黑塞的作品中我最早有所了解的是《在轮下》，从b站up主黄鸭兄的视频中了解了整个故事，当时觉得从内容到立意都挺有意思。后来看到黄鸭兄视频中提到《荒原狼》的内容，其中魔剧院中从人驯服狼到狼驯服人的场景震撼到了我，因此选择了这本书作为自己接触黑塞文学的开始。书中从开始到结尾都远超</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="黑塞" scheme="https://fusionbolt.github.io/tags/%E9%BB%91%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>红与黑</title>
    <link href="https://fusionbolt.github.io/2023/07/30/Reading/the-red-and-black/"/>
    <id>https://fusionbolt.github.io/2023/07/30/Reading/the-red-and-black/</id>
    <published>2023-07-30T06:12:37.000Z</published>
    <updated>2023-07-30T06:13:47.424Z</updated>
    
    <content type="html"><![CDATA[<p>一个穷苦人家的孩子，凭借着自己过人的本领从一个木匠的儿子开始不断向上爬，获取名誉与金钱，但是黑暗一直伴随着他。他在穷苦环境中产生的黑，无论再多名誉与金钱的红都无法掩盖，这是我眼中的红与黑。于连从一个木匠儿子，到市长家的老师，到学院的尖子生，再到侯爵的助手，一路几乎是顺风顺水。一切离不开他的才智，但也和他的性格息息相关，虽然他会自负，虚伪，但他的性格除了穷苦环境中产生的那些黑，但还有正面的红色：忍耐，理智，坚毅。不论好坏全都推动了他顺利前进，但也推动了他走向悲剧。</p><p>在故事结束后作者写下了“献给幸运的少数人”，在我看来是很有吸引力的留言，我想这一定与作者所在的时代背景有关，身处漩涡中的人难以看清漩涡的全貌，那个时代能接触到思想教育的人绝大多数也是受限的，身陷其中的，这样的时代或许很难有作者的知音。</p><p>再来说说这是一个怎样的时代，我对于当时的历史并不了解，但作者的故事中已经完全被那个时代的颜色所填满，其中最显眼混杂在其中的则是出身、权利与地位、金钱这几种妖艳的色彩，之所以妖艳，是因为带来的不仅只有所谓的美好。于连作为一个对此鄙夷的角色，在他攀爬的过程成为了见证者，但他虽然融入上流社会却并没有染上上流社会的恶习，他虽然在获得更高的权利和地位但他所求的事情似乎并不和那些上流社会的人相同。但是纵使他再怎么对此厌恶，他作为个人再怎么厉害，他仍然是一个无力推翻时代洪流的弱小者，他仍然无法抹消出身的卑微。</p><p>对于于连来讲，除了他那隐藏在内心中的黑暗性格外，一直围绕着他的就是他的出身，不只是周围的看法，乃至他自己都一直困在这片思维洼地中。不过这是时代的悲剧，出身至上的时代注定了如此。而他的这个思维也是让他走向悲剧的根源，他对于拉穆尔小姐不断出现的想法还是“他这样出身的人征服了她”。</p><p>可想而知，这样的时代与于连这样的主角搭配，注定了悲剧的发生。但有些意外的是“我们的英雄”最后以这样的形式迎来悲剧的判决。也许此时他已经不再是那个他了，也许他的本性正如此，他选择了枪击报复他其实还爱着的瑞那夫人。更曲折的是拉穆尔小姐明明已经通过权利使得有避免死刑的希望，最后却还是被已经上任、手握权利且曾为瑞那夫人争风吃醋的瓦勒诺确定了死刑，最后还是被他所讨厌的事物所压倒了。</p><p>于连一切变化的开始似乎源于对于瑞那夫人的爱，虽然这份爱源于扭曲的征服欲，但他的人生最终又因为瑞那夫人崩塌，不论是给拉穆尔侯爵的信，还是因为瓦勒诺曾经是情敌，只是他并没有怨恨，反而最后发觉了自己对瑞那夫人的心意。此外与拉穆尔小姐的偷情，也是他最终结局的原因之一，但这些全部起始于他强烈的自尊，以及他无法摆脱自己底层出身这一泥沼，这两段感情的起点都是他认为自己这样的人征服了这么高贵的人。</p><p>现在的时代尽管完全不同，但人们的追求依然没有改变：金钱、地位、阶级等，而人们贪婪，黑暗的本性从未消失，于连一样的人一定存在。如果作者生活在现在的时代，或许也会写出相似内核的故事，从底向上，最后坠落。最后也许是因为犯法，也许是被出卖，我贫瘠的想象力很难想到有什么寓意深刻的结局，这些人们会如何在高空中的钢丝绳上坠落呢，但不论如何一定是会掉下来的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个穷苦人家的孩子，凭借着自己过人的本领从一个木匠的儿子开始不断向上爬，获取名誉与金钱，但是黑暗一直伴随着他。他在穷苦环境中产生的黑，无论再多名誉与金钱的红都无法掩盖，这是我眼中的红与黑。于连从一个木匠儿子，到市长家的老师，到学院的尖子生，再到侯爵的助手，一路几乎是顺风顺水</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="司汤达" scheme="https://fusionbolt.github.io/tags/%E5%8F%B8%E6%B1%A4%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十五 最后的收尾工作</title>
    <link href="https://fusionbolt.github.io/2023/07/29/mold/mold-15-end/"/>
    <id>https://fusionbolt.github.io/2023/07/29/mold/mold-15-end/</id>
    <published>2023-07-29T12:11:48.000Z</published>
    <updated>2023-07-29T12:14:51.438Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-15-end/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:92983280</center> <p>这一期没什么比较硬的重点知识，仅做为补全整个过程来补充，可以轻松愉快的食用。</p><h1 id="write-dependency"><a href="#write-dependency" class="headerlink" title="write dependency"></a>write dependency</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --dependency-file</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.dependency_file.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">write_dependency_file</span>(ctx);</span><br></pre></td></tr></table></figure><p>将所有依赖，也就是链接过程中所有读取的文件，并且写入到文件中。可以用于确认某个文件是否被加入到链接过程中。</p><blockquote><p>–dependency-file=FILE      Write Makefile-style dependency rules to FILE</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write Makefile-style dependency rules to a file specified by</span></span><br><span class="line"><span class="comment">// --dependency-file. This is analogous to the compiler&#x27;s -M flag.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_dependency_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; deps;</span><br><span class="line">  std::unordered_set&lt;std::string&gt; seen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool)</span><br><span class="line">    <span class="keyword">if</span> (!mf-&gt;parent)</span><br><span class="line">      <span class="keyword">if</span> (std::string path = <span class="built_in">path_clean</span>(mf-&gt;name); seen.<span class="built_in">insert</span>(path).second)</span><br><span class="line">        deps.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">  std::ofstream out;</span><br><span class="line">  out.<span class="built_in">open</span>(ctx.arg.dependency_file);</span><br><span class="line">  <span class="keyword">if</span> (out.<span class="built_in">fail</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dependency-file: cannot open &quot;</span> &lt;&lt; ctx.arg.dependency_file</span><br><span class="line">               &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">errno_string</span>();</span><br><span class="line"></span><br><span class="line">  out &lt;&lt; ctx.arg.output &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::string &amp;s : deps)</span><br><span class="line">    out &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string &amp;s : deps)</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">  out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="clean-lto-object"><a href="#clean-lto-object" class="headerlink" title="clean lto object"></a>clean lto object</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.has_lto_object)</span><br><span class="line">  <span class="built_in">lto_cleanup</span>(ctx);</span><br></pre></td></tr></table></figure><p>清理lto相关的文件，lto相关的操作都是类似于插件的形式执行的，以适配不同编译器产生的lto文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lto_cleanup</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;lto_cleanup&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cleanup_hook)</span><br><span class="line">    <span class="built_in">cleanup_hook</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个cleanup_hook也是在前面注册插件的时候要注册的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> PluginStatus <span class="title">register_cleanup_hook</span><span class="params">(CleanupHandler fn)</span> </span>&#123;</span><br><span class="line">  LOG &lt;&lt; <span class="string">&quot;register_cleanup_hook\n&quot;</span>;</span><br><span class="line">  cleanup_hook = fn;</span><br><span class="line">  <span class="keyword">return</span> LDPS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="print-map"><a href="#print-map" class="headerlink" title="print map"></a>print map</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.print_map)</span><br><span class="line">    <span class="built_in">print_map</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>–Map FILE Write map file to a given file</p></blockquote><p>收集信息并建立了section到symbol的map，之后遍历所有的chunk，进行打印。</p><ol><li>首先会打印一行chunk的信息</li><li>如果不是osec那么会继续打印下一个chunk，否则之后会接着打印osec内部的所有members的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::ostream *out = &amp;std::cout;</span><br><span class="line">  std::unique_ptr&lt;std::ofstream&gt; file;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.Map.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    file = <span class="built_in">open_output_file</span>(ctx);</span><br><span class="line">    out = file.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a section-to-symbol map.</span></span><br><span class="line">  Map&lt;E&gt; map = <span class="built_in">get_map</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print a mapfile.</span></span><br><span class="line">  *out &lt;&lt; <span class="string">&quot;               VMA       Size Align Out     In      Symbol\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *osec : ctx.chunks) &#123;</span><br><span class="line">    *out &lt;&lt; std::showbase</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; (u64)osec-&gt;shdr.sh_addr &lt;&lt; std::dec</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">11</span>) &lt;&lt; (u64)osec-&gt;shdr.sh_size</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; (u64)osec-&gt;shdr.sh_addralign</span><br><span class="line">         &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; osec-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (osec-&gt;<span class="built_in">kind</span>() != OUTPUT_SECTION)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::span&lt;InputSection&lt;E&gt; *&gt; members = ((OutputSection&lt;E&gt; *)osec)-&gt;members;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">bufs</span><span class="params">(members.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">      InputSection&lt;E&gt; *mem = members[i];</span><br><span class="line">      std::ostringstream ss;</span><br><span class="line">      opt_demangle = ctx.arg.demangle;</span><br><span class="line">      u64 addr = osec-&gt;shdr.sh_addr + mem-&gt;offset;</span><br><span class="line"></span><br><span class="line">      ss &lt;&lt; std::showbase</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::dec</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">11</span>) &lt;&lt; (u64)mem-&gt;sh_size</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; (<span class="number">1</span> &lt;&lt; (u64)mem-&gt;p2align)</span><br><span class="line">         &lt;&lt; <span class="string">&quot;         &quot;</span> &lt;&lt; *mem &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">typename</span> Map&lt;E&gt;::const_accessor acc;</span><br><span class="line">      <span class="keyword">if</span> (map.<span class="built_in">find</span>(acc, mem))</span><br><span class="line">        <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : acc-&gt;second)</span><br><span class="line">          ss &lt;&lt; std::showbase</span><br><span class="line">             &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; sym-&gt;<span class="built_in">get_addr</span>(ctx) &lt;&lt; std::dec</span><br><span class="line">             &lt;&lt; <span class="string">&quot;          0     0                 &quot;</span></span><br><span class="line">             &lt;&lt; *sym &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      bufs[i] = ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::string &amp;str : bufs)</span><br><span class="line">      *out &lt;&lt; str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Map&lt;E&gt; <span class="title">get_map</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  Map&lt;E&gt; map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file || sym-&gt;<span class="built_in">get_type</span>() == STT_SECTION)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(file == &amp;isec-&gt;file);</span><br><span class="line">        <span class="keyword">typename</span> Map&lt;E&gt;::accessor acc;</span><br><span class="line">        map.<span class="built_in">insert</span>(acc, &#123;isec, &#123;&#125;&#125;);</span><br><span class="line">        acc-&gt;second.<span class="built_in">push_back</span>(sym);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>(map.<span class="built_in">range</span>(), [](<span class="keyword">const</span> <span class="keyword">typename</span> Map&lt;E&gt;::range_type &amp;range) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.<span class="built_in">begin</span>(); it != range.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">      std::vector&lt;Symbol&lt;E&gt; *&gt; &amp;vec = it-&gt;second;</span><br><span class="line">      <span class="built_in">sort</span>(vec, [](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123; <span class="keyword">return</span> a-&gt;value &lt; b-&gt;value; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Show stats numbers</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.stats)</span><br><span class="line">  <span class="built_in">show_stats</span>(ctx);</span><br></pre></td></tr></table></figure><p>在链接的过程中对于许多操作都会使用一个Counter记录数量，比如说符号的个数等，这里就是打印那些记录的信息</p><blockquote><p>–stats                     Print input statistics</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stats</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *obj : ctx.objs) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">defined</span><span class="params">(<span class="string">&quot;defined_syms&quot;</span>)</span></span>;</span><br><span class="line">    defined += obj-&gt;first_global - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">undefined</span><span class="params">(<span class="string">&quot;undefined_syms&quot;</span>)</span></span>;</span><br><span class="line">    undefined += obj-&gt;symbols.<span class="built_in">size</span>() - obj-&gt;first_global;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;sec : obj-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!sec || !sec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> Counter <span class="title">alloc</span><span class="params">(<span class="string">&quot;reloc_alloc&quot;</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> Counter <span class="title">nonalloc</span><span class="params">(<span class="string">&quot;reloc_nonalloc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC)</span><br><span class="line">        alloc += sec-&gt;<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nonalloc += sec-&gt;<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">comdats</span><span class="params">(<span class="string">&quot;comdats&quot;</span>)</span></span>;</span><br><span class="line">    comdats += obj-&gt;comdat_groups.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">removed_comdats</span><span class="params">(<span class="string">&quot;removed_comdat_mem&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : obj-&gt;comdat_groups)</span><br><span class="line">      <span class="keyword">if</span> (ref.group-&gt;owner != obj-&gt;priority)</span><br><span class="line">        removed_comdats += ref.members.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_cies</span><span class="params">(<span class="string">&quot;num_cies&quot;</span>)</span></span>;</span><br><span class="line">    num_cies += obj-&gt;cies.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_unique_cies</span><span class="params">(<span class="string">&quot;num_unique_cies&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : obj-&gt;cies)</span><br><span class="line">      <span class="keyword">if</span> (cie.is_leader)</span><br><span class="line">        num_unique_cies++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_fdes</span><span class="params">(<span class="string">&quot;num_fdes&quot;</span>)</span></span>;</span><br><span class="line">    num_fdes +=  obj-&gt;fdes.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_bytes</span><span class="params">(<span class="string">&quot;total_input_bytes&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool)</span><br><span class="line">    num_bytes += mf-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_input_sections</span><span class="params">(<span class="string">&quot;input_sections&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    num_input_sections += file-&gt;sections.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_output_chunks</span><span class="params">(<span class="string">&quot;output_chunks&quot;</span>, ctx.chunks.size())</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_objs</span><span class="params">(<span class="string">&quot;num_objs&quot;</span>, ctx.objs.size())</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_dsos</span><span class="params">(<span class="string">&quot;num_dsos&quot;</span>, ctx.dsos.size())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">thunk_bytes</span><span class="params">(<span class="string">&quot;thunk_bytes&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">for</span> (std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk : osec-&gt;thunks)</span><br><span class="line">          thunk_bytes += thunk-&gt;<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;sec : ctx.merged_sections)</span><br><span class="line">    sec-&gt;<span class="built_in">print_stats</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter is used to collect statistics numbers.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Counter</span>(std::string_view name, i64 value = <span class="number">0</span>) : <span class="built_in">name</span>(name), <span class="built_in">values</span>(value) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">    instances.<span class="built_in">push_back</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter &amp;<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">      values.<span class="built_in">local</span>()++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter &amp;<span class="keyword">operator</span>+=(<span class="keyword">int</span> delta) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">      values.<span class="built_in">local</span>() += delta;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">i64 <span class="title">get_value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  std::string_view name;</span><br><span class="line">  tbb::enumerable_thread_specific&lt;i64&gt; values;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> std::vector&lt;Counter *&gt; instances;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(instances, [](Counter *a, Counter *b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;<span class="built_in">get_value</span>() &gt; b-&gt;<span class="built_in">get_value</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Counter *c : instances)</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::right &lt;&lt; c-&gt;name</span><br><span class="line">              &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c-&gt;<span class="built_in">get_value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MergedSection&lt;E&gt;::<span class="built_in">print_stats</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  i64 used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; map.nbuckets; i++)</span><br><span class="line">    <span class="keyword">if</span> (map.keys[i])</span><br><span class="line">      used++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="keyword">this</span>-&gt;name</span><br><span class="line">               &lt;&lt; <span class="string">&quot; estimation=&quot;</span> &lt;&lt; estimator.<span class="built_in">get_cardinality</span>()</span><br><span class="line">               &lt;&lt; <span class="string">&quot; actual=&quot;</span> &lt;&lt; used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p>之前在各个过程中都会创建许多timer，在这个过程中把timer收集到的时间信息全部打印出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.perf)</span><br><span class="line">  <span class="built_in">print_timer_records</span>(ctx.timer_records);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_timer_records</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    tbb::concurrent_vector&lt;std::unique_ptr&lt;TimerRecord&gt;&gt; &amp;records)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = records.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    records[i]-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; records.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    TimerRecord &amp;inner = *records[i];</span><br><span class="line">    <span class="keyword">if</span> (inner.parent)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      TimerRecord &amp;outer = *records[j];</span><br><span class="line">      <span class="keyword">if</span> (outer.start &lt;= inner.start &amp;&amp; inner.end &lt;= outer.end) &#123;</span><br><span class="line">        inner.parent = &amp;outer;</span><br><span class="line">        outer.children.<span class="built_in">push_back</span>(&amp;inner);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;     User   System     Real  Name\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;TimerRecord&gt; &amp;rec : records)</span><br><span class="line">    <span class="keyword">if</span> (!rec-&gt;parent)</span><br><span class="line">      <span class="built_in">print_rec</span>(*rec, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="on-complete"><a href="#on-complete" class="headerlink" title="on_complete"></a>on_complete</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (on_complete)</span><br><span class="line">    <span class="built_in">on_complete</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_WIN32) &amp;&amp; !defined(__APPLE__)</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.fork)</span><br><span class="line">    on_complete = fork_child();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为退出一个大量内存占用的程序很慢，因此这里会fork一个子进程来进行实际的清理工作，主进程直接退出，能够提升结束的速度，让用户不可见的清理操作放到后台执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MOLD_X86_64</span></span><br><span class="line"><span class="comment">// Exiting from a program with large memory usage is slow --</span></span><br><span class="line"><span class="comment">// it may take a few hundred milliseconds. To hide the latency,</span></span><br><span class="line"><span class="comment">// we fork a child and let it do the actual linking work.</span></span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">fork_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Parent</span></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">      _exit(<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">      <span class="built_in">raise</span>(<span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Child</span></span><br><span class="line">  <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [=] &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    [[maybe_unused]] <span class="keyword">int</span> n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="on-exit"><a href="#on-exit" class="headerlink" title="on_exit"></a>on_exit</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.quick_exit)</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; &amp;fn : ctx.on_exit)</span><br><span class="line">  <span class="built_in">fn</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="built_in">checkpoint</span>();</span><br></pre></td></tr></table></figure><p>直接exit或者调用exit的清理的函数</p><blockquote><p>–quick-exit Use quick_exit to exit (default)<br>–no-quick-exit</p></blockquote><p>在mold中有的只有一处，在icf_sections中创建的map需要在这里销毁，但是也可能在lto的过程中注册了其他的exit函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since free&#x27;ing the map is slow, postpone it.</span></span><br><span class="line">ctx.on_exit.<span class="built_in">push_back</span>([=] &#123; <span class="keyword">delete</span> map; &#125;);</span><br></pre></td></tr></table></figure><p>最后在返回之前会再调用checkpoint检查是否有错误。</p><p>至此，整个mold的链接过程已经完全结束了。下一期会进行一个总结，并且记录一下一些自己的想法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-15-end/Un</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十四 固定文件layout以及创建输出</title>
    <link href="https://fusionbolt.github.io/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/"/>
    <id>https://fusionbolt.github.io/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/</id>
    <published>2023-07-25T16:07:02.000Z</published>
    <updated>2023-07-29T12:12:18.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mold源码阅读十四-fix-file-layout-and-create-output"><a href="#mold源码阅读十四-fix-file-layout-and-create-output" class="headerlink" title="mold源码阅读十四 fix file layout and create output"></a>mold源码阅读十四 fix file layout and create output</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:92848682</center> <p>上一期主要讲解了shdr计算更新的部分以及osec offset的设置，这期则是做链接最后的工作。上期在对段shrink的时候也提到部分synthetic的符号值还未固定，本期就会从这部分的值提起，之后则是对debug_section进行压缩，同时文件的大小也会产生变化，到了这里整个文件内部的layout以及文件的大小也就固定了。</p><p>接下来就是创建output file，将数据实际拷贝到对应的输出buffer中，实际apply relocate，以及一些其他的操作，此时链接的产物已经完成了。</p><h1 id="fix-synthetic-symbols"><a href="#fix-synthetic-symbols" class="headerlink" title="fix_synthetic_symbols"></a>fix_synthetic_symbols</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set actual addresses to linker-synthesized symbols.</span></span><br><span class="line"><span class="built_in">fix_synthetic_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要的任务是设置synthetic符号的值以及对应的origin。设置值的过程大部分都是设置对应chunk的shdr，origin则是标识符号来源，其他细节暂且不进行介绍，后面会单独一期详细查看所有synthetic的符号以及synthetic的section在整个链接过程中的行为，符号的具体作用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fix_synthetic_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk, i64 bias = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + bias;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> stop = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + chunk-&gt;shdr.sh_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; sections;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;<span class="built_in">kind</span>() != HEADER &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      sections.<span class="built_in">push_back</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;](std::string name) -&gt; Chunk&lt;E&gt; * &#123;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections)</span><br><span class="line">      <span class="keyword">if</span> (chunk-&gt;name == name)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __bss_start</span></span><br><span class="line">  <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.bss&quot;</span>))</span><br><span class="line">    <span class="built_in">start</span>(ctx.__bss_start, chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr &amp;&amp; (ctx.ehdr-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">    ctx.__ehdr_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__ehdr_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">    ctx.__executable_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__executable_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.__dso_handle) &#123;</span><br><span class="line">    ctx.__dso_handle-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__dso_handle-&gt;value = sections[<span class="number">0</span>]-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __rel_iplt_start and __rel_iplt_end. These symbols need to be</span></span><br><span class="line">  <span class="comment">// defined in a statically-linked non-relocatable executable because</span></span><br><span class="line">  <span class="comment">// such executable lacks the .dynamic section and thus there&#x27;s no way</span></span><br><span class="line">  <span class="comment">// to find ifunc relocations other than these symbols.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We don&#x27;t want to set values to these symbols if we are creating a</span></span><br><span class="line">  <span class="comment">// static PIE due to a glibc bug. Static PIE has a dynamic section.</span></span><br><span class="line">  <span class="comment">// If we set values to these symbols in a static PIE, glibc attempts</span></span><br><span class="line">  <span class="comment">// to run ifunc initializers twice, with the second attempt with wrong</span></span><br><span class="line">  <span class="comment">// function addresses, causing a segmentation fault.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn &amp;&amp; ctx.arg.is_static &amp;&amp; !ctx.arg.pie) &#123;</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_start, ctx.reldyn);</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_end, ctx.reldyn);</span><br><span class="line"></span><br><span class="line">    ctx.__rel_iplt_start-&gt;value -=</span><br><span class="line">      <span class="built_in">get_num_irelative_relocs</span>(ctx) * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __&#123;init,fini&#125;_array_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (chunk-&gt;shdr.sh_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SHT_INIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__init_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__init_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_PREINIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__preinit_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__preinit_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_FINI_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__fini_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__fini_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _end, _etext, _edata and the like</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._end, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._etext, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.etext, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != SHT_NOBITS &amp;&amp;</span><br><span class="line">        (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._edata, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.edata, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _DYNAMIC</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._DYNAMIC, ctx.dynamic);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _GLOBAL_OFFSET_TABLE_. I don&#x27;t know why, but for the sake of</span></span><br><span class="line">  <span class="comment">// compatibility with existing code, it must be set to the beginning of</span></span><br><span class="line">  <span class="comment">// .got.plt instead of .got only on i386 and x86-64.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_x86&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">start</span><span class="params">(ctx._GLOBAL_OFFSET_TABLE_, ctx.gotplt)</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">start</span>(ctx._GLOBAL_OFFSET_TABLE_, ctx.got);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _PROCEDURE_LINKAGE_TABLE_. We need this on SPARC.</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._PROCEDURE_LINKAGE_TABLE_, ctx.plt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _TLS_MODULE_BASE_. This symbol is used to obtain the address of</span></span><br><span class="line">  <span class="comment">// the TLS block in the TLSDESC model. I believe GCC and Clang don&#x27;t</span></span><br><span class="line">  <span class="comment">// create a reference to it, but Intel compiler seems to be using</span></span><br><span class="line">  <span class="comment">// this symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx._TLS_MODULE_BASE_) &#123;</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;value = ctx.tls_begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __GNU_EH_FRAME_HDR</span></span><br><span class="line">  <span class="built_in">start</span>(ctx.__GNU_EH_FRAME_HDR, ctx.eh_frame_hdr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RISC-V&#x27;s __global_pointer$</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__global_pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.sdata&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__global_pointer, chunk, <span class="number">0x800</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.__global_pointer-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.__global_pointer-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ARM32&#x27;s __exidx_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__exidx_start) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.ARM.exidx&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__exidx_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__exidx_end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PPC64&#x27;s &quot;.TOC.&quot; symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.TOC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.got&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.toc&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.TOC-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.TOC-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __start_ and __stop_ symbols</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;std::string&gt; name = <span class="built_in">get_start_stop_name</span>(ctx, *chunk)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__start_&quot;</span> + *name)), chunk);</span><br><span class="line">      <span class="built_in">stop</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__stop_&quot;</span> + *name)), chunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.physical_image_base) &#123;</span><br><span class="line">        u64 paddr = <span class="built_in">to_paddr</span>(ctx, chunk-&gt;shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *x = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_start_&quot;</span> + *name));</span><br><span class="line">        x-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        x-&gt;value = paddr;</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *y = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_stop_&quot;</span> + *name));</span><br><span class="line">        y-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        y-&gt;value = paddr + chunk-&gt;shdr.sh_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --defsym=sym=value symbols</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; *sym = ctx.arg.defsyms[i].first;</span><br><span class="line">    std::variant&lt;Symbol&lt;E&gt; *, u64&gt; val = ctx.arg.defsyms[i].second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u64 *addr = std::get_if&lt;u64&gt;(&amp;val)) &#123;</span><br><span class="line">      sym-&gt;origin = <span class="number">0</span>;</span><br><span class="line">      sym-&gt;value = *addr;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; *sym2 = std::get&lt;Symbol&lt;E&gt; *&gt;(val);</span><br><span class="line">    <span class="keyword">if</span> (!sym2-&gt;file) &#123;</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--defsym: undefined symbol: &quot;</span> &lt;&lt; *sym2;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sym-&gt;value = sym2-&gt;value;</span><br><span class="line">    sym-&gt;origin = sym2-&gt;origin;</span><br><span class="line">    sym-&gt;visibility = sym2-&gt;visibility.<span class="built_in">load</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --section-order symbols</span></span><br><span class="line">  <span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">    <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="compress-debug-sections"><a href="#compress-debug-sections" class="headerlink" title="compress_debug_sections"></a>compress_debug_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --compress-debug-sections is given, compress .debug_* sections</span></span><br><span class="line"><span class="comment">// using zlib.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.compress_debug_sections != COMPRESS_NONE)</span><br><span class="line">  filesize = <span class="built_in">compress_debug_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>压缩了所有debug相关的section，由于压缩了section，段的size发生改变，offset也会随之改变，因此之后还需要更新相关表的shdr，最后还会返回新的file size。具体的压缩过程这里就不详细看了。</p><blockquote><p>–compress-debug-sections [none,zlib,zlib-gabi,zstd]<br>                                        Compress .debug_* sections</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">compress_debug_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compress_debug_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;chunk = *ctx.chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((chunk.shdr.sh_flags &amp; SHF_ALLOC) || chunk.shdr.sh_size == <span class="number">0</span> ||</span><br><span class="line">        !chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Chunk&lt;E&gt; *comp = <span class="keyword">new</span> CompressedSection&lt;E&gt;(ctx, chunk);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(comp);</span><br><span class="line">    ctx.chunks[i] = comp;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.shstrtab-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr)</span><br><span class="line">    ctx.ehdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">u8 *<span class="title">get_uncompressed_data</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> uncompressed.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ElfChdr&lt;E&gt; chdr = &#123;&#125;;</span><br><span class="line">  std::unique_ptr&lt;Compressor&gt; compressed;</span><br><span class="line">  std::unique_ptr&lt;u8[]&gt; uncompressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">CompressedSection&lt;E&gt;::<span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>));</span><br><span class="line">  <span class="keyword">this</span>-&gt;name = chunk.name;</span><br><span class="line"></span><br><span class="line">  uncompressed.<span class="built_in">reset</span>(<span class="keyword">new</span> u8[chunk.shdr.sh_size]);</span><br><span class="line">  chunk.<span class="built_in">write_to</span>(ctx, uncompressed.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.compress_debug_sections) &#123;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZLIB:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZLIB;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZlibCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZSTD:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZSTD;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZstdCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chdr.ch_size = chunk.shdr.sh_size;</span><br><span class="line">  chdr.ch_addralign = chunk.shdr.sh_addralign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr = chunk.shdr;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags |= SHF_COMPRESSED;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="built_in"><span class="keyword">sizeof</span></span>(chdr) + compressed-&gt;compressed_size;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shndx = chunk.shndx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We don&#x27;t need to keep the original data unless --gdb-index is given.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.gdb_index)</span><br><span class="line">    uncompressed.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="create-output-file"><a href="#create-output-file" class="headerlink" title="create output file"></a>create output file</h1><p>到这个位置，所有memory以及file中的layout都就固定了，因此开始准备创建输出文件并且将chunks拷贝到output file中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an output file</span></span><br><span class="line">ctx.output_file =</span><br><span class="line">  OutputFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">open</span>(ctx, ctx.arg.output, filesize, <span class="number">0777</span>);</span><br><span class="line">ctx.buf = ctx.output_file-&gt;buf;</span><br></pre></td></tr></table></figure><p>这里的filesize是上一期的set_osec中最后得到的offset（如果经过压缩过debug_section那么就是上面压缩后的filesize），0777则是文件的权限</p><h1 id="copy-chunks"><a href="#copy-chunks" class="headerlink" title="copy chunks"></a>copy chunks</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy input sections to the output file and apply relocations.</span></span><br><span class="line"><span class="built_in">copy_chunks</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里遍历了所有chunk并且每个都拷贝到输出文件中。但是先拷贝了非rel的段，之后才拷贝所有rel段，因为在copy output section的时候会apply relocate，在rel_offset的位置写入数据，而在后面rel段copy_buf的时候还可能向同样的地址写入数据。</p><p>这里会介绍一下一些主要的copy_chunk的实现（RelSection，OutputSection），其他synthetic符号的细节等到之后的文章再看细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy chunks to an output file</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_chunks</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;copy_chunks&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> copy = [&amp;](Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">    std::string name = chunk.name.<span class="built_in">empty</span>() ? <span class="string">&quot;(header)&quot;</span> : std::<span class="built_in">string</span>(chunk.name);</span><br><span class="line">    <span class="function">Timer <span class="title">t2</span><span class="params">(ctx, name, &amp;t)</span></span>;</span><br><span class="line">    chunk.<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For --relocatable and --emit-relocs, we want to copy non-relocation</span></span><br><span class="line">  <span class="comment">// sections first. This is because REL-type relocation sections (as</span></span><br><span class="line">  <span class="comment">// opposed to RELA-type) stores relocation addends to target sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type == (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">report_undef_errors</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">fixup_arm_exidx_section</span><span class="params">(ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rel的查找过程"><a href="#rel的查找过程" class="headerlink" title="rel的查找过程"></a>rel的查找过程</h2><p>不论是否为rel的output section，都需要有一个定位rel具体位置的过程。首先会先找到所在的osec，一个osec由多个输入的isec组成，每个isec根据其offset在osec中定位，找到具体的isec后则是找到相关的所有rel段</p><h2 id="OutputSection"><a href="#OutputSection" class="headerlink" title="OutputSection"></a>OutputSection</h2><p>对nobits的output section写入数据</p><ol><li>拷贝InputSections的内容到output file中<ol><li>copy数据本身</li><li>apply relocate</li></ol></li><li>清理掉trail padding（设置为0）</li><li>处理thunk</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_type != SHT_NOBITS)</span><br><span class="line">    <span class="built_in">write_to</span>(ctx, ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">auto</span> clear = [&amp;](u8 *loc, i64 size) &#123;</span><br><span class="line">    <span class="comment">// As a special case, .init and .fini are filled with NOPs because the</span></span><br><span class="line">    <span class="comment">// runtime executes the sections as if they were a single function.</span></span><br><span class="line">    <span class="comment">// .init and .fini are superceded by .init_array and .fini_array and</span></span><br><span class="line">    <span class="comment">// being actively used only on s390x though.</span></span><br><span class="line">    <span class="keyword">if</span> (is_s390x&lt;E&gt; &amp;&amp; (<span class="keyword">this</span>-&gt;name == <span class="string">&quot;.init&quot;</span> || <span class="keyword">this</span>-&gt;name == <span class="string">&quot;.fini&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; size; i += <span class="number">2</span>)</span><br><span class="line">        *(ub16 *)(loc + i) = <span class="number">0x0700</span>; <span class="comment">// nop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(loc, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="comment">// Copy section contents to an output file</span></span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *members[i];</span><br><span class="line">    isec.<span class="built_in">write_to</span>(ctx, buf + isec.offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear trailing padding</span></span><br><span class="line">    u64 this_end = isec.offset + isec.sh_size;</span><br><span class="line">    u64 next_start = (i == members.<span class="built_in">size</span>() - <span class="number">1</span>) ?</span><br><span class="line">      (u64)<span class="keyword">this</span>-&gt;shdr.sh_size : members[i + <span class="number">1</span>]-&gt;offset;</span><br><span class="line">    <span class="built_in">clear</span>(buf + this_end, next_start - this_end);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(thunks,</span><br><span class="line">                           [&amp;](std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk) &#123;</span><br><span class="line">      thunk-&gt;<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%201.png"                      alt="Untitled"                ></p><p>根据osec→shdr.sh_addr以及isec.offset定位到具体的isec，并对每一个isec进行write_to</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_type == SHT_NOBITS || sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy data</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy_contents_riscv</span>(ctx, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">uncompress_to</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply relocations</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.relocatable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC)</span><br><span class="line">      <span class="built_in">apply_reloc_alloc</span>(ctx, buf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">apply_reloc_nonalloc</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy数据"><a href="#copy数据" class="headerlink" title="copy数据"></a>copy数据</h3><p>针对非压缩的数据则直接copy，对于压缩后的数据则进行解压</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply-reloc-alloc"><a href="#apply-reloc-alloc" class="headerlink" title="apply reloc alloc"></a>apply reloc alloc</h3><p>这个过程也是因架构而异的，下面的代码来自rv</p><p>针对每个rel段的位置填写对应符号的地址，因为ElfRel本身不携带这个信息，对应的参数只有r_offset, r_type, r_sym，rela还会多一个r_addend。但根据rel类型的不同计算的方式也有些许的差异。具体的不同rel的计算方式要参考官方的文档，比如说rv的</p><p><a class="link"   href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc" >https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc<i class="fas fa-external-link-alt"></i></a></p><p>针对每个rel写入的loc的位置如图所示为osec→shdr.sh_addr + isec.offset + r_offset，不过注意这里的r_offset根据架构不同，可能会进行特殊处理，比如说下面rv的实现中有一个rel.r_offset - get_r_delta(i)的过程（之前shrink过程导致这里需要再处理delta的值）</p><p>另外apply_reloc_noalloc的过程也是类似，不再重复展示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%202.png"                      alt="Untitled"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">apply_reloc_alloc</span>(Context&lt;E&gt; &amp;ctx, u8 *base) &#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = <span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *dynrel = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn)</span><br><span class="line">    dynrel = (ElfRel&lt;E&gt; *)(ctx.buf + ctx.reldyn-&gt;shdr.sh_offset +</span><br><span class="line">                           file.reldyn_offset + <span class="keyword">this</span>-&gt;reldyn_offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_r_delta = [&amp;](i64 idx) &#123;</span><br><span class="line">    <span class="keyword">return</span> extra.r_deltas.<span class="built_in">empty</span>() ? <span class="number">0</span> : extra.r_deltas[idx];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel = rels[i];</span><br><span class="line">    <span class="keyword">if</span> (rel.r_type == R_NONE || rel.r_type == R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *file.symbols[rel.r_sym];</span><br><span class="line">    i64 r_offset = rel.r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    i64 removed_bytes = <span class="built_in">get_r_delta</span>(i + <span class="number">1</span>) - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    u8 *loc = base + r_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](i64 val, i64 lo, i64 hi) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; lo || hi &lt;= val)</span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: relocation &quot;</span> &lt;&lt; rel &lt;&lt; <span class="string">&quot; against &quot;</span></span><br><span class="line">                   &lt;&lt; sym &lt;&lt; <span class="string">&quot; out of range: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; is not in [&quot;</span></span><br><span class="line">                   &lt;&lt; lo &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hi &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S   sym.get_addr(ctx)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A   rel.r_addend</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P   (get_addr() + r_offset)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G   (sym.get_got_idx(ctx) * sizeof(Word<span class="meta-string">&lt;E&gt;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOT ctx.got-&gt;shdr.sh_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rel.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32:</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(E::is_64)</span></span></span><br><span class="line"><span class="function">        *<span class="params">(U32&lt;E&gt; *)</span>loc </span>= S + A;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_64:</span><br><span class="line">      <span class="built_in">assert</span>(E::is_64);</span><br><span class="line">      <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">12</span>), <span class="number">1</span> &lt;&lt; <span class="number">12</span>);</span><br><span class="line">      <span class="built_in">write_btype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_JAL: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">20</span>), <span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">write_jtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      u32 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + rel.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; jal</span></span><br><span class="line">        *(ul32 *)loc = (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0b1101111</span>;</span><br><span class="line">        <span class="built_in">write_jtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.j</span></span><br><span class="line">        *(ul16 *)loc = <span class="number">0b101&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.jal</span></span><br><span class="line">        <span class="built_in">assert</span>(!E::is_64);</span><br><span class="line">        *(ul16 *)loc = <span class="number">0b001&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span>);</span><br><span class="line">        u64 val = sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>() ? <span class="number">0</span> : S + A - P;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">        <span class="built_in">write_itype</span>(loc + <span class="number">4</span>, val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = G + GOT + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_gottp_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_tlsgd_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">      <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>()) &#123;</span><br><span class="line">        <span class="comment">// Calling an undefined weak symbol does not make sense.</span></span><br><span class="line">        <span class="comment">// We make such call into an infinite loop. This should</span></span><br><span class="line">        <span class="comment">// help debugging of a faulty program.</span></span><br><span class="line">        *(ul32 *)loc = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(ul32 *)loc = S + A - P;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(x0)` if the address is</span></span><br><span class="line">      <span class="comment">// accessible relative to the zero register. If the upper 20 bits</span></span><br><span class="line">      <span class="comment">// are all zero, the corresponding LUI might have been removed.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">      <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span> || removed_bytes == <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, S + A - ctx.tp_addr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_TPREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(tp)` if the address is</span></span><br><span class="line">      <span class="comment">// directly accessible using tp. tp is x4.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD8:</span><br><span class="line">      loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB8:</span><br><span class="line">      loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ALIGN: &#123;</span><br><span class="line">      <span class="comment">// A R_RISCV_ALIGN is followed by a NOP sequence. We need to remove</span></span><br><span class="line">      <span class="comment">// zero or more bytes so that the instruction after R_RISCV_ALIGN is</span></span><br><span class="line">      <span class="comment">// aligned to a given alignment boundary.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We need to guarantee that the NOP sequence is valid after byte</span></span><br><span class="line">      <span class="comment">// removal (e.g. we can&#x27;t remove the first 2 bytes of a 4-byte NOP).</span></span><br><span class="line">      <span class="comment">// For the sake of simplicity, we always rewrite the entire NOP sequence.</span></span><br><span class="line">      i64 padding_bytes = rel.r_addend - removed_bytes;</span><br><span class="line">      <span class="built_in">assert</span>((padding_bytes &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      i64 i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt;= padding_bytes - <span class="number">4</span>; i += <span class="number">4</span>)</span><br><span class="line">        *(ul32 *)(loc + i) = <span class="number">0x0000&#x27;0013</span>; <span class="comment">// nop</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; padding_bytes)</span><br><span class="line">        *(ul16 *)(loc + i) = <span class="number">0x0001</span>;      <span class="comment">// c.nop</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">8</span>), <span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">      <span class="built_in">write_cbtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_JUMP: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">11</span>), <span class="number">1</span> &lt;&lt; <span class="number">11</span>);</span><br><span class="line">      <span class="built_in">write_cjtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((*loc - (S + A)) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((S + A) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET8:</span><br><span class="line">      *loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32_PCREL:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S:</span><br><span class="line">      <span class="comment">// These relocations are handled in the next loop.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> P</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> G</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GOT</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle PC-relative LO12 relocations. In the above loop, pcrel HI20</span></span><br><span class="line">  <span class="comment">// relocations overwrote instructions with full 32-bit values to allow</span></span><br><span class="line">  <span class="comment">// their corresponding pcrel LO12 relocations to read their values.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S: &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file.symbols[rels[i].r_sym];</span><br><span class="line">      <span class="built_in">assert</span>(sym.<span class="built_in">get_input_section</span>() == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)(base + sym.value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[i].r_type == R_RISCV_PCREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the original instructions pcrel HI20 relocations overwrote.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20: &#123;</span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)loc;</span><br><span class="line">      <span class="built_in">memcpy</span>(loc, contents.<span class="built_in">data</span>() + rels[i].r_offset, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%203.png"                      alt="Untitled"                ></p><p>rel会先计算r_offset，值为对应osec的地址 + isec.offset + r_offset（来自输入的elf文件），r_type则保留，这个计算方式和上面apply_reloc的过程完全一致</p><p>之后的处理过程如下</p><ol><li><p>针对section外的符号直接获取其index，以及addend的信息并且设置值</p></li><li><p>section的符号则获取到对应的osec的shndx，设置addend为对应section的offset + get_addend()。其中get_addend的过程因架构而异。</p><ol><li>针对SectionFragment则符号更改为output_section.shndx，原始符号或许是指向合并为fragment之前，由于已经merge到了一起，因此只能指向fragment所在的osec</li><li>针对普通section则直接设置为对应osec的shndx</li></ol></li><li><p>设置r_addend</p><ol><li><p>rela直接设置前面计算的addend</p></li><li><p>如果是relocatable，那么会根据rel的type在base + rel.r_offset的位置写入addend的值。这个base与上面的r_offset不同，但实际上都是指向最初计算的r_offset的位置，只是这里要写入文件，因此要以文件的buf为起点，而不是0。关于write_addend也是类似于get_addend，</p><p>relocatable的情况最后write_addend的位置，也就是之前apply_reloc_alloc写入信息的位置，针对没有addend的情况只能将信息覆盖到这里</p></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelocSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">auto</span> write = [&amp;](ElfRel&lt;E&gt; &amp;out, InputSection&lt;E&gt; &amp;isec, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;out, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(out));</span><br><span class="line">    out.r_offset = isec.output_section-&gt;shdr.sh_addr + isec.offset + rel.r_offset;</span><br><span class="line">    out.r_type = rel.r_type;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().st_type == STT_SECTION) &#123;</span><br><span class="line">      i64 addend;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">        out.r_sym = frag-&gt;output_section.shndx;</span><br><span class="line">        addend = frag-&gt;offset + sym.value + <span class="built_in">get_addend</span>(isec, rel);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InputSection&lt;E&gt; *target = sym.<span class="built_in">get_input_section</span>();</span><br><span class="line">        OutputSection&lt;E&gt; *osec = target-&gt;output_section;</span><br><span class="line">        out.r_sym = osec-&gt;shndx;</span><br><span class="line">        addend = <span class="built_in">get_addend</span>(isec, rel) + target-&gt;offset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">        out.r_addend = addend;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.relocatable) &#123;</span><br><span class="line">        u8 *base = ctx.buf + isec.output_section-&gt;shdr.sh_offset + isec.offset;</span><br><span class="line">        <span class="built_in">write_addend</span>(base + rel.r_offset, addend, rel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym.sym_idx)</span><br><span class="line">        out.r_sym = sym.<span class="built_in">get_output_sym_idx</span>(ctx);</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">        out.r_addend </span>= rel.r_addend;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)output_section.members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    ElfRel&lt;E&gt; *buf = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset) + offsets[i];</span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *output_section.members[i];</span><br><span class="line">    std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; rels.<span class="built_in">size</span>(); j++)</span><br><span class="line">      <span class="built_in">write</span>(buf[j], isec, rels[j]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 Symbol&lt;E&gt;::<span class="built_in">get_output_sym_idx</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  i64 i = file-&gt;output_sym_indices[sym_idx];</span><br><span class="line">  <span class="built_in">assert</span>(i != <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_local</span>(ctx))</span><br><span class="line">    <span class="keyword">return</span> file-&gt;local_symtab_idx + i;</span><br><span class="line">  <span class="keyword">return</span> file-&gt;global_symtab_idx + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gdb-index"><a href="#gdb-index" class="headerlink" title="gdb_index"></a>gdb_index</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Some part of .gdb_index couldn&#x27;t be computed until other debug</span></span><br><span class="line"><span class="comment">// sections are complete. We have complete debug sections now, so</span></span><br><span class="line"><span class="comment">// write the rest of .gdb_index.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.gdb_index)</span><br><span class="line">  ctx.gdb_index-&gt;<span class="built_in">write_address_areas</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要是gdb_index写入实际地址，因为在这里符号的地址都已经确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GdbIndexSection&lt;E&gt;::<span class="built_in">write_address_areas</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;GdbIndexSection::write_address_areas&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  u8 *base = ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    std::string_view name = chunk-&gt;name;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_info&quot;</span>)</span><br><span class="line">      ctx.debug_info = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_abbrev&quot;</span>)</span><br><span class="line">      ctx.debug_abbrev = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_ranges&quot;</span>)</span><br><span class="line">      ctx.debug_ranges = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_addr&quot;</span>)</span><br><span class="line">      ctx.debug_addr = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_rnglists&quot;</span>)</span><br><span class="line">      ctx.debug_rnglists = chunk;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_info);</span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_abbrev);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">    ul64 start;</span><br><span class="line">    ul64 end;</span><br><span class="line">    ul32 attr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read address ranges from debug sections and copy them to .gdb_index.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;debug_info)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Entry *begin = (Entry *)(base + header.areas_offset + file-&gt;area_offset);</span><br><span class="line">    Entry *e = begin;</span><br><span class="line">    u64 offset = file-&gt;debug_info-&gt;offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;compunits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::vector&lt;u64&gt; addrs = <span class="built_in">read_address_areas</span>(ctx, *file, offset);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; addrs.<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Skip an empty range</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == addrs[j + <span class="number">1</span>])</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gdb crashes if there are entries with address 0.</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(e &lt; begin + file-&gt;num_areas);</span><br><span class="line">        e-&gt;start = addrs[j];</span><br><span class="line">        e-&gt;end = addrs[j + <span class="number">1</span>];</span><br><span class="line">        e-&gt;attr = file-&gt;compunits_idx + i;</span><br><span class="line">        e++;</span><br><span class="line">      &#125;</span><br><span class="line">      offset += file-&gt;compunits[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill trailing null entries with dummy values because gdb</span></span><br><span class="line">    <span class="comment">// crashes if there are entries with address 0.</span></span><br><span class="line">    u64 filler;</span><br><span class="line">    <span class="keyword">if</span> (e == begin)</span><br><span class="line">      filler = ctx.etext-&gt;<span class="built_in">get_addr</span>(ctx) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      filler = e[<span class="number">-1</span>].start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; e &lt; begin + file-&gt;num_areas; e++) &#123;</span><br><span class="line">      e-&gt;start = filler;</span><br><span class="line">      e-&gt;end = filler;</span><br><span class="line">      e-&gt;attr = file-&gt;compunits_idx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-reldyn"><a href="#sort-reldyn" class="headerlink" title="sort reldyn"></a>sort reldyn</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dynamic linker works better with sorted .rela.dyn section,</span></span><br><span class="line"><span class="comment">// so we sort them.</span></span><br><span class="line">ctx.reldyn-&gt;<span class="built_in">sort</span>(ctx);</span><br></pre></td></tr></table></figure><p>对rel段排序，这么做的原理如注释所描述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the reason why we sort dynamic relocations. Quote from</span></span><br><span class="line"><span class="comment">// https://www.airs.com/blog/archives/186:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   The dynamic linker in glibc uses a one element cache when processing</span></span><br><span class="line"><span class="comment">//   relocs: if a relocation refers to the same symbol as the previous</span></span><br><span class="line"><span class="comment">//   relocation, then the dynamic linker reuses the value rather than</span></span><br><span class="line"><span class="comment">//   looking up the symbol again. Thus the dynamic linker gets the best</span></span><br><span class="line"><span class="comment">//   results if the dynamic relocations are sorted so that all dynamic</span></span><br><span class="line"><span class="comment">//   relocations for a given dynamic symbol are adjacent.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   Other than that, the linker sorts together all relative relocations,</span></span><br><span class="line"><span class="comment">//   which don&#x27;t have symbols. Two relative relocations, or two relocations</span></span><br><span class="line"><span class="comment">//   against the same symbol, are sorted by the address in the output</span></span><br><span class="line"><span class="comment">//   file. This tends to optimize paging and caching when there are two</span></span><br><span class="line"><span class="comment">//   references from the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We group IFUNC relocations at the end of .rel.dyn because we want to</span></span><br><span class="line"><span class="comment">// apply all the other relocations before running user-supplied ifunc</span></span><br><span class="line"><span class="comment">// resolver functions.</span></span><br></pre></td></tr></table></figure><p>大意如下：</p><ol><li>glibc的linker有一个cache，如果一个relocation和前面的relocation引用了相同符号，那么会直2接引用值，而不是重新查找。</li><li>linker会将所有没有符号的relative relocation排序，两个relative relocation或者两个针对同一个符号的relocation会按照文件地址排序。存在同一页面的两个引用时可以优化分页和缓存</li></ol><p>对于一个符号有多个relocation的情况，比如说一个全局变量被不同代码段引用多次，那么每个引用都需要生成一个条目。另外没有符号的relative relocation，是指重定位的记录中不包含符号，只包含偏移，比如说基于pc的相对寻址。</p><p>mold在.rel.dyn的末尾对IFUNC重定位进行分组,因为希望在运行用户提供的ifunc解析函数之前应用所有其他重定位。</p><p>排序规则基于如下三个方面</p><ol><li>根据r_type计算的rank</li><li>r_sym：重定位的符号在符号表中的索引</li><li>r_offset：重定位的位置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelDynSection&lt;E&gt;::<span class="built_in">sort</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_dynamic_relocs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *begin = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">  ElfRel&lt;E&gt; *end = (ElfRel&lt;E&gt; *)((u8 *)begin + <span class="keyword">this</span>-&gt;shdr.sh_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_rank = [](u32 r_type) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> E::R_RELATIVE: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> E::R_IRELATIVE: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_sort</span>(begin, end, [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(a.r_type), a.r_sym, a.r_offset) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(b.r_type), b.r_sym, b.r_offset);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="clear-padding"><a href="#clear-padding" class="headerlink" title="clear_padding"></a>clear_padding</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zero-clear paddings between sections</span></span><br><span class="line"><span class="built_in">clear_padding</span>(ctx);</span><br></pre></td></tr></table></figure><p>将bss外的段中所有padding的空间设置为0，上一期只是设置offset来保证padding，但是padding范围内的值是未定的，在osec写到文件后再来将这部分空间置零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         size          padding</span><br><span class="line">  |                     |         |</span><br><span class="line">offset                       next_offset</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_padding</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;clear_padding&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> zero = [&amp;](Chunk&lt;E&gt; *chunk, i64 next_start) &#123;</span><br><span class="line">    i64 pos = chunk-&gt;shdr.sh_offset + chunk-&gt;shdr.sh_size;</span><br><span class="line">    <span class="built_in">memset</span>(ctx.buf + pos, <span class="number">0</span>, next_start - pos);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; chunks = ctx.chunks;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;shdr.sh_type == SHT_NOBITS;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="built_in">zero</span>(chunks[i - <span class="number">1</span>], chunks[i]-&gt;shdr.sh_offset);</span><br><span class="line">  <span class="built_in">zero</span>(chunks.<span class="built_in">back</span>(), ctx.output_file-&gt;filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="buildid"><a href="#buildid" class="headerlink" title="buildid"></a>buildid</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .note.gnu.build-id section contains a cryptographic hash of the</span></span><br><span class="line"><span class="comment">// entire output file. Now that we wrote everything except build-id,</span></span><br><span class="line"><span class="comment">// we can compute it.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.buildid)</span><br><span class="line">  ctx.buildid-&gt;<span class="built_in">write_buildid</span>(ctx);</span><br></pre></td></tr></table></figure><p>计算文件哈希，这对于elf来说并非必要的部分，但是有哈希可以用于校验文件是否完整是否有问题等，无需重新计算。</p><p>实际写入到header后的位置，因此写入地址是shdr.sh_offset + HEADER_SIZE。对于几种实现算法这里不再讨论。</p><blockquote><p>–build-id [none,md5,sha1,sha256,uuid,HEXSTRING]<br>                                     Generate build ID<br>–no-build-id</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildIdSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BuildIdSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.note.gnu.build-id&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_NOTE;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_buildid</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> i64 HEADER_SIZE = <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> BuildIdSection&lt;E&gt;::<span class="built_in">write_buildid</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;build_id&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.build_id.kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HEX:</span><br><span class="line">    <span class="built_in">write_vector</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE,</span><br><span class="line">                 ctx.arg.build_id.value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HASH:</span><br><span class="line">    <span class="comment">// Modern x86 processors have purpose-built instructions to accelerate</span></span><br><span class="line">    <span class="comment">// SHA256 computation, and SHA256 outperforms MD5 on such computers.</span></span><br><span class="line">    <span class="comment">// So, we always compute SHA256 and truncate it if smaller digest was</span></span><br><span class="line">    <span class="comment">// requested.</span></span><br><span class="line">    <span class="built_in">compute_sha256</span>(ctx, <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::UUID: &#123;</span><br><span class="line">    std::array&lt;u8, 16&gt; uuid = <span class="built_in">get_uuid_v4</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE, uuid.<span class="built_in">data</span>(), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="close-file"><a href="#close-file" class="headerlink" title="close file"></a>close file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close the output file. This is the end of the linker&#x27;s main job.</span></span><br><span class="line">ctx.output_file-&gt;<span class="built_in">close</span>(ctx);</span><br></pre></td></tr></table></figure><p>至此文件已经成功输出，只剩下最后的一些收尾工作，就留到下期再讲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mold源码阅读十四-fix-file-layout-and-create-output&quot;&gt;&lt;a href=&quot;#mold源码阅读十四-fix-file-layout-and-create-output&quot; class=&quot;headerlink&quot; title=&quot;mold</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="rel" scheme="https://fusionbolt.github.io/tags/rel/"/>
    
  </entry>
  
  <entry>
    <title>赶雨</title>
    <link href="https://fusionbolt.github.io/2023/07/22/Life/catch-the-rain/"/>
    <id>https://fusionbolt.github.io/2023/07/22/Life/catch-the-rain/</id>
    <published>2023-07-22T09:01:10.000Z</published>
    <updated>2023-07-22T09:02:35.666Z</updated>
    
    <content type="html"><![CDATA[<p>清晨七点四十左右，一如既往的在没睡够的情况下就醒来了，听着窗外激烈的雨声，随机看了下天气预报，多个平台的预告基本上都是十点十一点左右停雨。躺在床上犹豫了一下，随即爬了起来收拾东西去颐和园拍雨中的荷花。洗漱以及略微吃了点东西后开始打滴滴，或许是雨天的缘故没有人接单，还要排队许久，等不下去的我又打开了高德地图，这里有更多的平台可以选，随着不断等待与加价，最终总算打到了车。一出门感受到的是与季节不符的冷风，但急着赶时间也就没有回去加衣服。上车后，看着窗外的雨，心里只有祈祷雨能继续下着，并且能下的大些，但天气并不能如我所愿，到目的地后雨已经很小了。</p><p>下车后，首先映入眼帘的是打翻了的调色盘一般的人群，各种颜色的伞和雨衣密密麻麻的排在一起。今天有许多郊游的学生以及旅游团，不知是否周末的早上都是如此，我还是第一次这么早来北京的景点。入口的里外都是这样满满的人，靠近后只会感到吵闹与拥堵，但不过也没有时间和心思去关注这些，趁着还在下小雨直奔目的地谐趣园。</p><p>此时的谐趣园虽然也有一些零零散散的人，但相对于外面显得格外安静。有不少老法师举着相机在拍荷花，也有用手机在旁边拍摄以及录制视频的人。在寻找机位的时候，还看到有一个摄影师在拍一个看起来六七十的并且穿着旗袍的老奶奶，看起来非常开心。另外还遇到一个老法师来问我关于网上卖照片的事情，他说他的照片总是审核不过，平台说尺寸太小需要更大分辨率等等。之后则是安心的当了一阵老法师，可惜的是雨天换镜头不方便就没带长焦，减少了几分老法师的成分。</p><p>以下分享的照片很多裁剪以及除雾等处理后会更合适，这里就懒得裁了，（别说裁了，我都懒得分类入库了，卡里还有上千张照片），总之不要在意那么多细节</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6940.jpg"                      alt="DSCF6940.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6954.jpg"                      alt="DSCF6954.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6952.jpg"                      alt="DSCF6952.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6948.jpg"                      alt="DSCF6948.jpg"                ></p><p>拍了一阵觉得也没什么可拍的了，便赶向了我最喜欢的一片“秘境”。这里的人总是最少的，以树林为依靠，以湖水为伴，格外有氛围，我喜欢天气凉爽的时候坐在这附近看书，但是人多的时候体验还是比较差的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6964.jpg"                      alt="DSCF6964.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6969.jpg"                      alt="DSCF6969.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6978.jpg"                      alt="DSCF6978.jpg"                ></p><p>喜欢坐在这看书</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6979.jpg"                      alt="DSCF6979.jpg"                ></p><p>在这里拍了一阵，打算到十七孔桥的位置，原路返回的过程中看到了一只猫，偶然拍到了我认为很棒的照片。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6983.jpg"                      alt="DSCF6983.jpg"                ></p><p>之后则是穿越人群，一路走过去。此时没有太多想拍的，因此更多的注意力放到了对周围的环境，对清新空气的感受上。多久没感受到这种雨后的清新空气了呢，虽然前两天也有在下雨，但是却未曾有这样的感受，也许平时一直在紧绷着神经吧。但我也并没有花费更多的注意力在身体和环境交互的感受上，而是继续寻找着下一个拍摄目标，毕竟这才是我今天最初的目的。路途中看到/听到各种各样的人：和旅伴走散了的旅者，生气的斥责孩子的家长，同样目的的老法师，专心解说的导游，等等。</p><p>没多久看到了这样的荷花，但没带长焦只能进行裁剪了，此时的我又萌生了几千块买一个备用机挂长焦的想法，就不用换镜头了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6987.jpg"                      alt="DSCF6987.jpg"                ></p><p>焦段的极限了，需要稍微裁减一下才行，起码旁边两朵花不能在画面里</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6995.jpg"                      alt="DSCF6995.jpg"                ></p><p>远处朦胧的景色，有一种别样的风味</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6990.jpg"                      alt="DSCF6990.jpg"                ></p><p>雨天的佛香阁</p><p>这个时候已经很困了，决定打道回府。看到这里的船还开着，能够避免回头再走一遍，加上从未体验过，选择了付款坐船。由于是雨天的缘故，座位都被雨水浸湿，勉强擦干了坐下。在船上感受到凌烈的“寒风”，但没多久注意力便放到了观看周围的景色上，有没有什么可以拍摄的目标。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7011.jpg"                      alt="DSCF7011.jpg"                ></p><p>路途也不远，没多久也就到了目的地。之后走走停停，看到了一处小的荷花，但是在下一个船坞里。不得已买了船票，但是告诉我不能提前进船坞里面等，而且船来了要立刻坐，不允许等待，结果最后只拍了一张照片，实在是让人很生气。最后到了北宫门的苏州街这里，人还是蛮多的，不论是从上面进入颐和园的人，还是下面在狭窄的道路上观光的人。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7019.jpg"                      alt="DSCF7019.jpg"                ></p><p>费半天劲才拍到的一个荷花</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7027.jpg"                      alt="DSCF7027.jpg"                ></p><p>游船的目的地</p><p>在这附近想拍那种雨滴拉线的效果，奈何雨滴太小了，只有偶尔房檐滴下的大雨滴才能拍出，而这雨滴又没法和荷花拍到一起，最后还是放弃了。</p><p>走之前在这里倒是看到一个小插曲，一个游客问旁边卖伞的人价格，听到价格后回答这个价格美团上都能买到两个了，之后轻微争论了两句觉得不值就走了。在出了北门到了地铁站前，看到几步路就有一个卖伞、雨衣的，不知他们能否卖出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;清晨七点四十左右，一如既往的在没睡够的情况下就醒来了，听着窗外激烈的雨声，随机看了下天气预报，多个平台的预告基本上都是十点十一点左右停雨。躺在床上犹豫了一下，随即爬了起来收拾东西去颐和园拍雨中的荷花。洗漱以及略微吃了点东西后开始打滴滴，或许是雨天的缘故没有人接单，还要排队许</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="颐和园" scheme="https://fusionbolt.github.io/tags/%E9%A2%90%E5%92%8C%E5%9B%AD/"/>
    
    <category term="摄影" scheme="https://fusionbolt.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十三 计算shdr以及osec offset</title>
    <link href="https://fusionbolt.github.io/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/"/>
    <id>https://fusionbolt.github.io/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/</id>
    <published>2023-07-15T12:02:55.000Z</published>
    <updated>2023-07-15T12:04:27.230Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-13-compute-shdr-and-set-osec-offsets/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:94763079</center> <p>本期的内容主要是更新section header以及set output section offsets相关。当这些操作结束后，虚拟地址会固定，因此输出文件的memory layout就固定下来了。</p><h1 id="create-reloc-sections"><a href="#create-reloc-sections" class="headerlink" title="create_reloc_sections"></a>create_reloc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --emit-relocs is given, we&#x27;ll copy relocation sections from input</span></span><br><span class="line"><span class="comment">// files to an output file.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emit_relocs)</span><br><span class="line">  <span class="built_in">create_reloc_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要做了2件事情</p><ol><li>这里将relocation段从input拷贝到output中，即设置所有OutputSection中reloc_sec</li><li>加入到chunks中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_reloc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;create_reloc_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create .rela.* sections</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      osec-&gt;reloc_sec.<span class="built_in">reset</span>(<span class="keyword">new</span> RelocSection&lt;E&gt;(ctx, *osec));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>, end = ctx.chunks.<span class="built_in">size</span>(); i &lt; end; i++)</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      <span class="keyword">if</span> (RelocSection&lt;E&gt; *x = osec-&gt;reloc_sec.<span class="built_in">get</span>())</span><br><span class="line">        ctx.chunks.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelocSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OutputSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  std::vector&lt;i64&gt; offsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中构造rel段的过程主要还是填写shdr的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">RelocSection&lt;E&gt;::<span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec)</span><br><span class="line">  : <span class="built_in">output_section</span>(osec) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rela&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_RELA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rel&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_REL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_INFO_LINK;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_entsize = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute an offset for each input section</span></span><br><span class="line">  offsets.<span class="built_in">resize</span>(osec.members.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scan = [&amp;](<span class="keyword">const</span> tbb::blocked_range&lt;i64&gt; &amp;r, i64 sum, <span class="keyword">bool</span> is_final) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">      InputSection&lt;E&gt; &amp;isec = *osec.members[i];</span><br><span class="line">      <span class="keyword">if</span> (is_final)</span><br><span class="line">        offsets[i] = sum;</span><br><span class="line">      sum += isec.<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  i64 num_entries = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">    tbb::blocked_range&lt;i64&gt;(<span class="number">0</span>, osec.members.<span class="built_in">size</span>()), <span class="number">0</span>, scan, std::<span class="built_in">plus</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = num_entries * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造RelocSection的时候需要计算出rel的数量。每个OutputSection由多个InputSection组成，每个InputSection中又有多个rel段，这里遍历扫描计算出sum的数量。</p><p>这里构造的时候有rel和rela两种情况，它们有如下几种区别</p><ol><li>rel只是简单的保存了需要被resolve的地址</li><li>rela保存了额外信息，其中的a是append。具体什么信息</li></ol><blockquote><p><em>SHT_RELA The section holds relocation entries with explicit addends, such as type</em><br><em>Elf32_Rela for the 32-bit class of object files. An object file may have</em><br><em>multiple relocation sections. See “Relocation’’ below for details.</em></p></blockquote><p>另外RelocSection的shdr flag为SHF_INFO_LINK，意义如下</p><blockquote><p>This section headers sh_info field holds a section header table index.</p></blockquote><p>设置sh_info的过程则是在后续compute_section_headers中</p><h1 id="compute-section-headers"><a href="#compute-section-headers" class="headerlink" title="compute_section_headers"></a>compute_section_headers</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the section header values for all sections.</span></span><br><span class="line"><span class="built_in">compute_section_headers</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要做了这么几件事</p><ol><li>所有输出段更新shdr</li><li>移除所有空的chunk</li><li>重新设置所有chunk的index（因为上面移除了chunk，index发生了改变）</li><li>SymtabShndxSection的处理</li><li>再次更新所有的shdr</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_headers</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update sh_size for each chunk.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove empty chunks.</span></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;<span class="built_in">kind</span>() != OUTPUT_SECTION &amp;&amp; chunk-&gt;shdr.sh_size == <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set section indices.</span></span><br><span class="line">  i64 shndx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (ctx.chunks[i]-&gt;<span class="built_in">kind</span>() != HEADER)</span><br><span class="line">      ctx.chunks[i]-&gt;shndx = shndx++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab &amp;&amp; SHN_LORESERVE &lt;= shndx) &#123;</span><br><span class="line">    SymtabShndxSection&lt;E&gt; *sec = <span class="keyword">new</span> SymtabShndxSection&lt;E&gt;;</span><br><span class="line">    sec-&gt;shndx = shndx++;</span><br><span class="line">    sec-&gt;shdr.sh_link = ctx.symtab-&gt;shndx;</span><br><span class="line">    ctx.symtab_shndx = sec;</span><br><span class="line">    ctx.chunks.<span class="built_in">push_back</span>(sec);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(sec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;shdr.sh_size = shndx * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfShdr&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Some types of section header refer other section by index.</span></span><br><span class="line">  <span class="comment">// Recompute the section header to fill such fields with correct values.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab_shndx) &#123;</span><br><span class="line">    i64 symtab_size = ctx.symtab-&gt;shdr.sh_size / <span class="built_in"><span class="keyword">sizeof</span></span>(ElfSym&lt;E&gt;);</span><br><span class="line">    ctx.symtab_shndx-&gt;shdr.sh_size = symtab_size * <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="update-shdr"><a href="#update-shdr" class="headerlink" title="update_shdr"></a>update_shdr</h2><p>大多数synthetic的chunk都有自己的实现，一些类型的section header通过index引用了其他段，因此需要重新计算shdr中对应字段的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk represents a contiguous region in an output file.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chunk</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说OutputPhdr，在这里就需要update</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputPhdr&lt;E&gt;::<span class="built_in">update_shdr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  phdrs = <span class="built_in">create_phdr</span>(ctx);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = phdrs.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfPhdr&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除空的chunk"><a href="#移除空的chunk" class="headerlink" title="移除空的chunk"></a>移除空的chunk</h2><p>这里选择了空的非OutputSection进行移除，判断是否为OutputSection则是根据ChunkKind</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> HEADER, OUTPUT_SECTION, SYNTHETIC &#125; ChunkKind;</span><br></pre></td></tr></table></figure><p>其中HEADER是用于output的phdr，ehdr，shdr，chunk默认是SYNTHETIC，也就是说相当于最终只是删除一些空的synthetic的段</p><h2 id="重新更新索引"><a href="#重新更新索引" class="headerlink" title="重新更新索引"></a>重新更新索引</h2><p>在普通的根据chunk的序列设置索引后有一个SHN_LORESERVE的判断，和SHN_LORESERVE相关的信息有这些</p><p><a class="link"   href="https://man7.org/linux/man-pages/man5/elf.5.html" >https://man7.org/linux/man-pages/man5/elf.5.html<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">e_shnum</span><br><span class="line">              This member holds the number of entries in the section</span><br><span class="line">              header table.  Thus the product of e_shent size and e_shnum</span><br><span class="line">              gives the section header table&#x27;s size in bytes.  If a file</span><br><span class="line">              has no section header table,e_shnum holds the value of</span><br><span class="line">              zero.</span><br><span class="line"></span><br><span class="line">              If the number of entries in the section header table is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), e_shnum</span><br><span class="line">              holds the value zero and the real number of entries in the</span><br><span class="line">              section header table is held in the sh_size member of the</span><br><span class="line">              initial entry in section header table.  Otherwise, the</span><br><span class="line">sh_size member of the initial entry in the section header</span><br><span class="line">              table holds the value zero.</span><br><span class="line"></span><br><span class="line">e_shstrndx</span><br><span class="line">              This member holds the section header table index of the</span><br><span class="line">              entry associated with the section name string table.  If</span><br><span class="line">              the file has no section name string table, this member</span><br><span class="line">              holds the value SHN_UNDEF.</span><br><span class="line"></span><br><span class="line">              If the index of section name string table section is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), this</span><br><span class="line">              member holds SHN_XINDEX(0xffff) and the real index of the</span><br><span class="line">              section name string table section is held in thesh_link</span><br><span class="line">              member of the initial entry in section header table.</span><br><span class="line">              Otherwise, thesh_link member of the initial entry in</span><br><span class="line">              section header table contains the value zero.</span><br></pre></td></tr></table></figure><p>e_shnum和e_shstrndx是在EHDR中的信息。首先是shnum，当shdr table，也就是说section的数量超过SHN_LORESERVE的时候，e_shnum会设置为0，实际的数量会保存在shdr table的初始条目中的sh_size的字段里，其他情况这个条目的sh_size的字段是0。</p><p>这里创建了一个SymtabShndxSection，也就是”symtab_shndx”段，这个段保留了特殊的symbol table section index arrry，指向与符号表关联的shdr的索引。</p><blockquote><p><code>.symtab_shndx</code></p><p>This section holds the special symbol table section index array, as described above. The section’s attributes will include the <code>SHF_ALLOC</code> bit if the associated symbol table section does; otherwise that bit will be off.</p></blockquote><p>这个section的sh_type为SHT_SYMTAB_SHNDX</p><blockquote><p><code>SHT_SYMTAB_SHNDX</code></p><p>This section is associated with a section of type <code>SHT_SYMTAB</code> and is required if any of the section header indexes referenced by that symbol table contain the escape value <code>SHN_XINDEX</code>. The section is an array of <code>Elf32_Word</code> values. Each value corresponds one to one with a symbol table entry and appear in the same order as those entries. The values represent the section header indexes against which the symbol table entries are defined. Only if corresponding symbol table entry’s <code>st_shndx</code> field contains the escape value <code>SHN_XINDEX</code> will the matching <code>Elf32_Word</code> hold the actual section header index; otherwise, the entry must be <code>SHN_UNDEF</code> (<code>0</code>).</p></blockquote><p>关于e_shstrndx，这里也设置了ctx中的symtab_shndx。不论是e_shnum还是e_shstrndx都是在后续的过程中实际计算或者使用其信息，等到后面讲的时候再联系前面这些来看。</p><p>创建了SymtabShndxSection后则是设置其基本信息，至此compute_section_headers的过程就结束了。</p><h1 id="set-osec-offsets"><a href="#set-osec-offsets" class="headerlink" title="set_osec_offsets"></a>set_osec_offsets</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign offsets to output sections</span></span><br><span class="line">i64 filesize = <span class="built_in">set_osec_offsets</span>(ctx);</span><br></pre></td></tr></table></figure><p>设置所有output section的offset，根据是否有section_order会选择不同的排列方式，导致output的offset是不同的。</p><p>主要分为如下几部分</p><ol><li>设置段的虚拟地址</li><li>设置段在文件中的offset</li><li>处理phdr并且返回文件的长度</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign virtual addresses and file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">set_osec_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;set_osec_offsets&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="built_in">set_virtual_addresses_regular</span>(ctx);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">set_virtual_addresses_by_order</span>(ctx);</span><br><span class="line"></span><br><span class="line">    i64 fileoff = <span class="built_in">set_file_offsets</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning new offsets may change the contents and the length</span></span><br><span class="line">    <span class="comment">// of the program header, so repeat it until converge.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.phdr)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line"></span><br><span class="line">    i64 sz = ctx.phdr-&gt;shdr.sh_size;</span><br><span class="line">    ctx.phdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (sz == ctx.phdr-&gt;shdr.sh_size)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="virtual-address设置规则"><a href="#virtual-address设置规则" class="headerlink" title="virtual address设置规则"></a>virtual address设置规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function assigns virtual addresses to output sections. Assigning</span></span><br><span class="line"><span class="comment">// addresses is a bit tricky because we want to pack sections as tightly</span></span><br><span class="line"><span class="comment">// as possible while not violating the constraints imposed by the hardware</span></span><br><span class="line"><span class="comment">// and the OS kernel. Specifically, we need to satisfy the following</span></span><br><span class="line"><span class="comment">// constraints:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Memory protection (readable, writable and executable) works at page</span></span><br><span class="line"><span class="comment">//   granularity. Therefore, if we want to set different memory attributes</span></span><br><span class="line"><span class="comment">//   to two sections, we need to place them into separate pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - The ELF spec requires that a section&#x27;s file offset is congruent to</span></span><br><span class="line"><span class="comment">//   its virtual address modulo the page size. For example, a section at</span></span><br><span class="line"><span class="comment">//   virtual address 0x401234 on x86-64 (4 KiB, or 0x1000 byte page</span></span><br><span class="line"><span class="comment">//   system) can be at file offset 0x3234 or 0x50234 but not at 0x1000.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We need to insert paddings between sections if we can&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">// above constraints without them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We don&#x27;t want to waste too much memory and disk space for paddings.</span></span><br><span class="line"><span class="comment">// There are a few tricks we can use to minimize paddings as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We want to place sections with the same memory attributes</span></span><br><span class="line"><span class="comment">//   contiguous as possible.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We can map the same file region to memory more than once. For</span></span><br><span class="line"><span class="comment">//   example, we can write code (with R and X bits) and read-only data</span></span><br><span class="line"><span class="comment">//   (with R bit) adjacent on file and map it twice as the last page of</span></span><br><span class="line"><span class="comment">//   the executable segment and the first page of the read-only data</span></span><br><span class="line"><span class="comment">//   segment. This doesn&#x27;t save memory but saves disk space.</span></span><br></pre></td></tr></table></figure><p>mold中不论是指定order还是不指定都是遵循基本的两条规则</p><ol><li>memory protection: 不同attr的section分配到不同的页中，为了满足每个段只有一个attr的条件</li><li>ELF spec requires: vaddr的地址的模要是page size，这里会在设置地址的时候进行align，也就是insert padding。</li></ol><p>这里提及的ticks:</p><ol><li>place sections with the same memory attributes contiguous as possible. 相同attr尽可能连续。（因为不同attr需要放入不同的页）</li><li>map the same file region to memory more than once. map两次，因此不会节约内存空间，但是会节约磁盘空间</li></ol><h2 id="set-virtual-addresses-regular"><a href="#set-virtual-addresses-regular" class="headerlink" title="set_virtual_addresses_regular"></a>set_virtual_addresses_regular</h2><p>在设置地址之前，需要先对tls chunk计算一个align。因为tls chunk需要满足如下条件</p><ol><li>tls块在vaddr中的起始地址地址需要对齐（普通内存块的要求是相同的）</li><li>当被拷贝到新线程区域时tls_begin的offset也必须对齐。更具体的说，tls会有多个块，而每个块都有一个tls_begin，实际上是这个值要求对齐。</li></ol><p>而mold的做法是选择其中最大的align值。</p><p>之后设置了起始地址image_base：默认0x200000</p><blockquote><p>-image-base ADDR Set the base address to a given value</p></blockquote><p>regular设置地址的过程有如下几种情况</p><ol><li>跳过不需要alloc的段，因为并不需要加载到内存中</li><li>relro_padding，一定是满足memory protection的。</li><li>指定section_start，不需要考虑memory protection，因为后面考虑这个的时候会和前一个的段进行比较。假设说连续两个都指定了start，即便不满足，那也是指定的行为。</li><li>满足memory protection的条件。当前chunk和下一个chunk都不是relro_padding的情况，如果两个chunk的attr不同，那么处理。处理后继续执行后面的代码</li><li>tbss：SHF_TLS &amp; SHT_NOBITS</li><li>剩余的情况就是简单的进行align然后更新addr信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_regular</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> i64 RELRO = <span class="number">1LL</span> &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_flags = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    i64 flags = <span class="built_in">to_phdr_flags</span>(ctx, chunk);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_relro</span>(ctx, chunk))</span><br><span class="line">      <span class="keyword">return</span> flags | RELRO;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign virtual addresses</span></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TLS chunks alignments are special: in addition to having their virtual</span></span><br><span class="line">  <span class="comment">// addresses aligned, they also have to be aligned when the region of</span></span><br><span class="line">  <span class="comment">// tls_begin is copied to a new thread&#x27;s storage area. In other words, their</span></span><br><span class="line">  <span class="comment">// offset against tls_begin also has to be aligned.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A good way to achieve this is to take the largest alignment requirement</span></span><br><span class="line">  <span class="comment">// of all TLS sections and make tls_begin also aligned to that.</span></span><br><span class="line">  Chunk&lt;E&gt; *first_tls_chunk = <span class="literal">nullptr</span>;</span><br><span class="line">  u64 tls_alignment = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_TLS) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!first_tls_chunk)</span><br><span class="line">        first_tls_chunk = chunk;</span><br><span class="line">      tls_alignment = std::<span class="built_in">max</span>(tls_alignment, (u64)chunk-&gt;shdr.sh_addralign);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> alignment = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk == first_tls_chunk ? tls_alignment : (u64)chunk-&gt;shdr.sh_addralign;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; chunks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .relro_padding is a padding section to extend a PT_GNU_RELRO</span></span><br><span class="line">    <span class="comment">// segment to cover an entire page. Technically, we don&#x27;t need a</span></span><br><span class="line">    <span class="comment">// .relro_padding section because we can leave a trailing part of a</span></span><br><span class="line">    <span class="comment">// segment an unused space. However, the `strip` command would delete</span></span><br><span class="line">    <span class="comment">// such an unused trailing part and make an executable invalid.</span></span><br><span class="line">    <span class="comment">// So we add a dummy section.</span></span><br><span class="line">    <span class="keyword">if</span> (chunks[i] == ctx.relro_padding) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_size = <span class="built_in">align_to</span>(addr, ctx.page_size) - addr;</span><br><span class="line">      addr += ctx.page_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle --section-start first</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = ctx.arg.section_start.<span class="built_in">find</span>(chunks[i]-&gt;name);</span><br><span class="line">        it != ctx.arg.section_start.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      addr = it-&gt;second;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">    <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">    <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; chunks[i - <span class="number">1</span>] != ctx.relro_padding) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">get_flags</span>(chunks[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">get_flags</span>(chunks[i]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X)) &#123;</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          [[fallthrough]];</span><br><span class="line">        <span class="keyword">case</span> NOSEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> (addr % ctx.page_size != <span class="number">0</span>)</span><br><span class="line">            addr += ctx.page_size;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">unreachable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS BSS sections are laid out so that they overlap with the</span></span><br><span class="line">    <span class="comment">// subsequent non-tbss sections. Overlapping is fine because a STT_TLS</span></span><br><span class="line">    <span class="comment">// segment contains an initialization image for newly-created threads,</span></span><br><span class="line">    <span class="comment">// and no one except the runtime reads its contents. Even the runtime</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t need a BSS part of a TLS initialization image; it just</span></span><br><span class="line">    <span class="comment">// leaves zero-initialized bytes as-is instead of copying zeros.</span></span><br><span class="line">    <span class="comment">// So no one really read tbss at runtime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We can instead allocate a dedicated virtual address space to tbss,</span></span><br><span class="line">    <span class="comment">// but that would be just a waste of the address and disk space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_tbss</span>(chunks[i])) &#123;</span><br><span class="line">      u64 addr2 = addr;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        addr2 = <span class="built_in">align_to</span>(addr2, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">        chunks[i]-&gt;shdr.sh_addr = addr2;</span><br><span class="line">        addr2 += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> == chunks.<span class="built_in">size</span>() || !<span class="built_in">is_tbss</span>(chunks[i + <span class="number">1</span>]))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">    chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="relro-padding"><a href="#relro-padding" class="headerlink" title="relro_padding"></a>relro_padding</h3><p>relro_padding用于确保RELRO页对齐，通常无需考虑，但是strip后会删除未使用的尾部空间，导致可执行文件无效。因此这里计算size的过程是用align的size减去当前的地址，之后addr直接递增一个page_size</p><p>关于PT_GNU_RELRO</p><blockquote><p>The array element specifies the location and size of a segment which may be made read-only after relocation shave been processed.</p></blockquote><h3 id="section-start"><a href="#section-start" class="headerlink" title="section_start"></a>section_start</h3><p>根据命令行参数指定对应段的地址为指定的位置，更新当前段地址，并且递增对应段的size。其中提到的命令行参数的介绍</p><blockquote><p>-Tbss=ADDR Set address to .bss<br>-Tdata Set address to .data<br>-Ttext Set address to .text</p></blockquote><h3 id="满足memory-protection"><a href="#满足memory-protection" class="headerlink" title="满足memory protection"></a>满足memory protection</h3><p>这里主要是针对相邻两个chunk的attr不同的情况。</p><p>根据链接选项可以分为三类</p><ol><li>SEPARATE_LOADABLE_SEGMENTS<ol><li>这里只是更新了当前的addr为根据page size进行align的值</li></ol></li><li>SEPARATE_CODE<ol><li>两个都不是PF_X（执行的权限）的情况下进行align</li></ol></li><li>NOSEPARATE_CODE<ol><li>如果当前的地址不是整除page size，那么直接增加一个page_size </li></ol></li></ol><h3 id="to-phdr-flags"><a href="#to-phdr-flags" class="headerlink" title="to_phdr_flags"></a>to_phdr_flags</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">to_phdr_flags</span><span class="params">(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All sections are put into a single RWX segment if --omagic</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.omagic)</span><br><span class="line">    <span class="keyword">return</span> PF_R | PF_W | PF_X;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> write = (chunk-&gt;shdr.sh_flags &amp; SHF_WRITE);</span><br><span class="line">  <span class="keyword">bool</span> exec = (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .text is not readable if --execute-only</span></span><br><span class="line">  <span class="keyword">if</span> (exec &amp;&amp; ctx.arg.execute_only) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--execute-only is not compatible with writable section: &quot;</span></span><br><span class="line">                 &lt;&lt; chunk-&gt;name;</span><br><span class="line">    <span class="keyword">return</span> PF_X;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .rodata is merged with .text if --no-rosegment</span></span><br><span class="line">  <span class="keyword">if</span> (!write &amp;&amp; !ctx.arg.rosegment)</span><br><span class="line">    exec = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PF_R | (write ? PF_W : <span class="number">0</span>) | (exec ? PF_X : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于页来说attr只有三种，读，写，执行。</p><p>如果指定omagic那么所有段都会塞到一个segment里面，因此其attr都是RWX的</p><blockquote><p>-N, –omagic Do not page align data, do not make text readonly<br>–no-omagic</p></blockquote><p>之后则是根据shdr的flag判断是否可写可执行返回对应的flag</p><h3 id="tbss"><a href="#tbss" class="headerlink" title="tbss"></a>tbss</h3><p>这里是针对tbss(tls bss) section的处理，其判断逻辑为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_tbss</span><span class="params">(Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (chunk-&gt;shdr.sh_type == SHT_NOBITS) &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_TLS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.bss的SHT为SHT_NOBITS，并且其Flag为SHF_ALLOC &amp; SHF_WRITE，因此这里只需要判断sh_type是否为SHT_NOBITS以及tls的判断条件就可以确定是否为tbss</p><blockquote><p>sh_offset: The byte offset from the beginning of the file to the first byte in the section. Section type SHT_NOBITS occupies no space in the file. Its sh_offset member locates the conceptual placement in the file.</p><p>sh_size: The section’s size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS can have a nonzero size, but it occupies no space in the file.</p><p>SHT_NOBITS: Identifies a section that occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</p></blockquote><p>tbss会和后续的非tbss段重叠，因为STT_TLS segment包含了一个初始化image，运行时才会读取，运行时也不需要tbss的初始化image，会保留零初始的变化字节不变，所以运行时不会实际读取。尽管可以单独给tbss分配空间，但是会浪费地址和磁盘空间。</p><p>所以这里的代码单独创建了一个地址进行递增，不会影响到正常更新的地址。</p><h2 id="set-virtual-addresses-by-order"><a href="#set-virtual-addresses-by-order" class="headerlink" title="set_virtual_addresses_by_order"></a>set_virtual_addresses_by_order</h2><p>根据order的信息来设置地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br></pre></td></tr></table></figure><p>根据SectionOrder信息的不同有如下几种情况处理</p><ol><li>SECTION<ol><li>计算一个地址赋给对应section的sh_addr以及更新当前的addr</li></ol></li><li>GROUP<ol><li>针对group段所有成员做和SECTION情况下相同的操作</li></ol></li><li>ADDR<ol><li>当前地址设置为SectionOrder中的值</li></ol></li><li>ALIGN<ol><li>当前地址设置为根据给定value对齐后的地址</li></ol></li><li>SYMBOL<ol><li>特定符号的地址设置为当前的地址</li></ol></li></ol><p>针对section的过程具体分为如下几步</p><ol><li>判断相邻段的attr，不同则进行将section根据page size进行padding</li><li>根据对应段的align计算一个地址，赋给section并且更新shdr以及当前addr的信息</li><li>找到下一个alloc的段</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_by_order</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;c = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> assign_addr = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">to_phdr_flags</span>(ctx, c[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">to_phdr_flags</span>(ctx, c[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">      <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">      <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X))</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, c[i]-&gt;shdr.sh_addralign);</span><br><span class="line">    c[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += c[i]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; ctx.arg.section_order.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    SectionOrder &amp;ord = ctx.arg.section_order[j];</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ord.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SECTION:</span><br><span class="line">      <span class="keyword">if</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::GROUP:</span><br><span class="line">      <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ADDR:</span><br><span class="line">      addr = ord.value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ALIGN:</span><br><span class="line">      addr = <span class="built_in">align_to</span>(addr, ord.value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SYMBOL:</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;value = addr;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-file-offsets"><a href="#set-file-offsets" class="headerlink" title="set_file_offsets"></a>set_file_offsets</h2><p>在设置完段的虚拟地址后，需要设定段在文件中的offset</p><ol><li>不需要alloc的情况，仍然需要计算其align更新size。有一些段需要占用空间，但是不需要载入内存，因此前面设置虚拟地址的时候跳过了所有不需要alloc的段，这里计算offset的时候还是要考虑到的。</li><li>bss段不做处理直接跳过</li><li>对offset做一次align。因为有的段可能并没有完整填充一个page size的空间，前面设置虚拟地址的过程并没有使得所有的size都满足page align。</li><li>给alloc section设置尽可能连续的文件的offset，因此会从当前的chunk开始循环设置offset。这样连续加载提高了效率，并且减少碎片空间。不符合条件的情况如下<ol><li>非alloc或者是bss</li><li>如果是给定了start_section的段，这样就无法设置连续的offset了，需要单独处理。包含了两种情况<ol><li>start的位置在开始循环的first chunk之前</li><li>相邻两个chunk的size过大，超过了page_size</li></ol></li></ol></li><li>使用最后一个设置offset的chunk的信息更新offset</li><li>找到下一个alloc的并且非SHT_NOBITS的chunk的index，之后处理下一个chunk</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> i64 <span class="title">set_file_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 fileoff = <span class="number">0</span>;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;first = *chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(first.shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">      first.shdr.sh_offset = fileoff;</span><br><span class="line">      fileoff += first.shdr.sh_size;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_type == SHT_NOBITS) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_addralign &gt; ctx.page_size)</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      fileoff = <span class="built_in">align_with_skew</span>(fileoff, ctx.page_size, first.shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign ALLOC sections contiguous file offsets as long as they</span></span><br><span class="line">    <span class="comment">// are contiguous in memory.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_offset =</span><br><span class="line">        fileoff + chunks[i]-&gt;shdr.sh_addr - first.shdr.sh_addr;</span><br><span class="line">      i++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= chunks.<span class="built_in">size</span>() ||</span><br><span class="line">          !(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">          chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, addresses may not increase</span></span><br><span class="line">      <span class="comment">// monotonically.</span></span><br><span class="line">      <span class="keyword">if</span> (chunks[i]-&gt;shdr.sh_addr &lt; first.shdr.sh_addr)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      i64 gap_size = chunks[i]-&gt;shdr.sh_addr - chunks[i - <span class="number">1</span>]-&gt;shdr.sh_addr -</span><br><span class="line">                     chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, there may be a large gap between</span></span><br><span class="line">      <span class="comment">// sections. We don&#x27;t want to allocate a disk space for a gap if</span></span><br><span class="line">      <span class="comment">// exists.</span></span><br><span class="line">      <span class="keyword">if</span> (gap_size &gt;= ctx.page_size)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileoff = chunks[i - <span class="number">1</span>]-&gt;shdr.sh_offset + chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">           (chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">           chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fileoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="riscv-resize-sections"><a href="#riscv-resize-sections" class="headerlink" title="riscv_resize_sections"></a>riscv_resize_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On RISC-V, branches are encode using multiple instructions so</span></span><br><span class="line"><span class="comment">// that they can jump to anywhere in ±2 GiB by default. They may</span></span><br><span class="line"><span class="comment">// be replaced with shorter instruction sequences if destinations</span></span><br><span class="line"><span class="comment">// are close enough. Do this optimization.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  filesize </span>= <span class="built_in">riscv_resize_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要是针对riscv跳转在2GB范围的限制做的优化，优化后重新计算shdr</p><p>做了如下几个步骤</p><ol><li>获取eflag，unix通常假设RV64GC是baseline，所以这里flag要加上C扩展的flag（EF_RISCV_RVC），而C扩展则是允许压缩指令集，使用2字节编码指令。</li><li>针对resizeable的section进行shrink</li><li>修正符号值</li><li>重新执行上一步的计算offset操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink sections by interpreting relocations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This operation seems to be optional, because by default longest</span></span><br><span class="line"><span class="comment">// instructions are being used. However, calling this function is actually</span></span><br><span class="line"><span class="comment">// mandatory because of R_RISCV_ALIGN. R_RISCV_ALIGN is a directive to the</span></span><br><span class="line"><span class="comment">// linker to align the location referred to by the relocation to a</span></span><br><span class="line"><span class="comment">// specified byte boundary. We at least have to interpret them to satisfy</span></span><br><span class="line"><span class="comment">// the alignment constraints.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">riscv_resize_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;riscv_resize_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// True if we can use the 2-byte instructions. This is usually true on</span></span><br><span class="line">  <span class="comment">// Unix because RV64GC is generally considered the baseline hardware.</span></span><br><span class="line">  <span class="keyword">bool</span> use_rvc = <span class="built_in">get_eflags</span>(ctx) &amp; EF_RISCV_RVC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find all the relocations that can be relaxed.</span></span><br><span class="line">  <span class="comment">// This step should only shrink sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_resizable</span>(ctx, isec.<span class="built_in">get</span>()))</span><br><span class="line">        <span class="built_in">shrink_section</span>(ctx, *isec, use_rvc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fix symbol values.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>();</span><br><span class="line">      <span class="keyword">if</span> (!isec || isec-&gt;extra.r_deltas.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), sym-&gt;value,</span><br><span class="line">                                 [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r, u64 val) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.r_offset &lt; val;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      sym-&gt;value -= isec-&gt;extra.r_deltas[it - rels.<span class="built_in">begin</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-compute section offset again to finalize them.</span></span><br><span class="line">  <span class="built_in">compute_section_sizes</span>(ctx);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">u64 <span class="title">get_eflags</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> EF_ARM_EABI_VER5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">    std::<span class="built_in">erase</span>(objs, ctx.internal_obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objs.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    u32 ret = objs[<span class="number">0</span>]-&gt;<span class="built_in">get_ehdr</span>().e_flags;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; objs.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span> (objs[i]-&gt;<span class="built_in">get_ehdr</span>().e_flags &amp; EF_RISCV_RVC)</span><br><span class="line">        ret |= EF_RISCV_RVC;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V2&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resizable"><a href="#resizable" class="headerlink" title="resizable"></a>resizable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_resizable</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">         (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SHF_EXECINSTR</p><blockquote><p>This section contains executable machine instructions.</p></blockquote><p>需要分配空间且包含可执行的指令的段才能进行resize。</p><h2 id="shrink"><a href="#shrink" class="headerlink" title="shrink"></a>shrink</h2><p>针对所有的rel进行操作，最终为了更新delta值（shrink的size），用于后续fix symbol value</p><ol><li><p>更新delta的值</p></li><li><p>R_RISCV_ALIGN是用于align的部分，指向nop指令，因此需要删除nop指令使得对齐到指定alignment</p></li><li><p>针对一些无法优化的情况进行跳过</p><ol><li><p>未开启relax选项</p><p>其中的relax选项是</p><blockquote><p>–relax Optimize instructions (default)<br>–no-relax</p></blockquote></li><li><p>搜寻到了最后一个re l</p></li><li><p>另外下一个rel如果不是RELAX的也无法进行优化</p></li></ol></li><li><p>跳过internal_obj，因为synthetic符号还没有最终值，只有确定值的情况才能进行shrink</p></li><li><p>针对不同rel type进行处理，添加不同的delta值。这里细节不再深究</p></li><li><p>减少当前input section的size并且更新deltas的值</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scan relocations to shrink sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shrink_section</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec, <span class="keyword">bool</span> use_rvc)</span> </span>&#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  isec.extra.r_deltas.<span class="built_in">resize</span>(rels.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  i64 delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r = rels[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[r.r_sym];</span><br><span class="line">    isec.extra.r_deltas[i] = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling R_RISCV_ALIGN is mandatory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// R_RISCV_ALIGN refers NOP instructions. We need to eliminate some</span></span><br><span class="line">    <span class="comment">// or all of the instructions so that the instruction that immediately</span></span><br><span class="line">    <span class="comment">// follows the NOPs is aligned to a specified alignment boundary.</span></span><br><span class="line">    <span class="keyword">if</span> (r.r_type == R_RISCV_ALIGN) &#123;</span><br><span class="line">      <span class="comment">// The total bytes of NOPs is stored to r_addend, so the next</span></span><br><span class="line">      <span class="comment">// instruction is r_addend away.</span></span><br><span class="line">      u64 loc = isec.<span class="built_in">get_addr</span>() + r.r_offset - delta;</span><br><span class="line">      u64 next_loc = loc + r.r_addend;</span><br><span class="line">      u64 alignment = <span class="built_in">bit_ceil</span>(r.r_addend + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">assert</span>(alignment &lt;= (<span class="number">1</span> &lt;&lt; isec.p2align));</span><br><span class="line">      delta += next_loc - <span class="built_in">align_to</span>(loc, alignment);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling other relocations is optional.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.relax || i == rels.<span class="built_in">size</span>() - <span class="number">1</span> ||</span><br><span class="line">        rels[i + <span class="number">1</span>].r_type != R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linker-synthesized symbols haven&#x27;t been assigned their final</span></span><br><span class="line">    <span class="comment">// values when we are shrinking sections because actual values can</span></span><br><span class="line">    <span class="comment">// be computed only after we fix the file layout. Therefore, we</span></span><br><span class="line">    <span class="comment">// assume that relocations against such symbols are always</span></span><br><span class="line">    <span class="comment">// non-relaxable.</span></span><br><span class="line">    <span class="keyword">if</span> (sym.file == ctx.internal_obj)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      <span class="comment">// These relocations refer an AUIPC + JALR instruction pair to</span></span><br><span class="line">      <span class="comment">// allow to jump to anywhere in PC ± 2 GiB. If the jump target is</span></span><br><span class="line">      <span class="comment">// close enough to PC, we can use C.J, C.JAL or JAL instead.</span></span><br><span class="line">      i64 dist = <span class="built_in">compute_distance</span>(ctx, sym, isec, r);</span><br><span class="line">      <span class="keyword">if</span> (dist &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view contents = isec.contents;</span><br><span class="line">      i64 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + r.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rd == <span class="number">0</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc) &#123;</span><br><span class="line">        <span class="comment">// If rd is x0 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.J, saving 6 bytes.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rd == <span class="number">1</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc &amp;&amp; !E::is_64) &#123;</span><br><span class="line">        <span class="comment">// If rd is x1 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.JAL. This is RV32 only because C.JAL is RV32-only instruction.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(dist, <span class="number">20</span>) == dist) &#123;</span><br><span class="line">        <span class="comment">// If the jump target is within ±1 MiB, we can use JAL.</span></span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      <span class="comment">// If the upper 20 bits are all zero, we can remove LUI.</span></span><br><span class="line">      <span class="comment">// The corresponding instructions referred by LO12_I/LO12_S</span></span><br><span class="line">      <span class="comment">// relocations will use the zero register instead.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD: &#123;</span><br><span class="line">      <span class="comment">// These relocations are used to materialize the upper 20 bits of</span></span><br><span class="line">      <span class="comment">// an address relative to the thread pointer as follows:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  lui  a5,%tprel_hi(foo)         # R_RISCV_TPREL_HI20 (symbol)</span></span><br><span class="line">      <span class="comment">//  add  a5,a5,tp,%tprel_add(foo)  # R_RISCV_TPREL_ADD (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Then thread-local variable `foo` is accessed with a 12-bit offset</span></span><br><span class="line">      <span class="comment">// like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(a5)     # R_RISCV_TPREL_LO12_S (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// However, if the offset is ±2 KiB, we don&#x27;t need to materialize</span></span><br><span class="line">      <span class="comment">// the upper 20 bits in a register. We can instead access the</span></span><br><span class="line">      <span class="comment">// thread-local variable directly with TP like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(tp)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Here, we remove `lui` and `add` if the offset is within ±2 KiB.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx) + r.r_addend - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isec.extra.r_deltas[rels.<span class="built_in">size</span>()] = delta;</span><br><span class="line">  isec.sh_size -= deltfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">requires</span> is_riscv&lt;E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputSectionExtras</span>&lt;</span>E&gt; &#123;</span><br><span class="line">  std::vector&lt;i32&gt; r_deltas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-13-comput</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="shdr" scheme="https://fusionbolt.github.io/tags/shdr/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十二 创建一些输出段</title>
    <link href="https://fusionbolt.github.io/2023/07/09/mold/mold-12-create-some-output-section/"/>
    <id>https://fusionbolt.github.io/2023/07/09/mold/mold-12-create-some-output-section/</id>
    <published>2023-07-09T08:35:19.000Z</published>
    <updated>2023-07-15T12:04:40.908Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-12-create-some-output-section/105296500_p0_master1200.jpg"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:105296500_p0</center> <h1 id="Fill-gnu-version-section-contents"><a href="#Fill-gnu-version-section-contents" class="headerlink" title="Fill gnu.version section contents"></a>Fill gnu.version section contents</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill .gnu.version_d section contents.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.verdef)</span><br><span class="line">  ctx.verdef-&gt;<span class="built_in">construct</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill .gnu.version_r section contents.</span></span><br><span class="line">ctx.verneed-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里对verdef和verneed段进行构造，实际写入内容。其中包含了字符串信息，因此还会将字符串写入dynstr中。</p><h2 id="verdef"><a href="#verdef" class="headerlink" title="verdef"></a>verdef</h2><p>对于VerdefSection中的contents是多组ElfVerDef + ElfVerdaux。前者是verdef的信息，后者则是指向对应字符串在dynstr中的offset。</p><p>需要将ctx.arg.version_definitions以及output自身的信息写入到verdef段中，因此这样的数据实际有ctx.arg.version_definitions.size() + 1组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| verdef | verdaux | verdef | verdaux |</span><br><span class="line">/                  /</span><br><span class="line">|     dynstr0    |    dynstr1    | ... | dynstrn |</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerdefSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VerdefSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.gnu.version_d&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_GNU_VERDEF;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;u8&gt; contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次写入的时候会先在当前位置写入ElfVerDef的信息，之后写入ElfVerdaux的信息，同时在这个过程中更新当前位置的指针。传入的verstr实际保存在ctx.dynstr中，而Verdaux中保存的是则是verstr在dynstr中的offset，而VerDef仅保存索引，hash等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> VerdefSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;fill_verdef&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.version_definitions.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize .gnu.version</span></span><br><span class="line">  ctx.versym-&gt;contents.<span class="built_in">resize</span>(ctx.dynsym-&gt;symbols.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">  ctx.versym-&gt;contents[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a buffer for .gnu.version_d.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;) + <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdaux&lt;E&gt;)) *</span><br><span class="line">                  (ctx.arg.version_definitions.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  u8 *buf = (u8 *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  u8 *ptr = buf;</span><br><span class="line">  ElfVerdef&lt;E&gt; *verdef = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> write = [&amp;](std::string_view verstr, i64 idx, i64 flags) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_info++;</span><br><span class="line">    <span class="keyword">if</span> (verdef)</span><br><span class="line">      verdef-&gt;vd_next = ptr - (u8 *)verdef;</span><br><span class="line"></span><br><span class="line">    verdef = (ElfVerdef&lt;E&gt; *)ptr;</span><br><span class="line">    ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">    verdef-&gt;vd_version = <span class="number">1</span>;</span><br><span class="line">    verdef-&gt;vd_flags = flags;</span><br><span class="line">    verdef-&gt;vd_ndx = idx;</span><br><span class="line">    verdef-&gt;vd_cnt = <span class="number">1</span>;</span><br><span class="line">    verdef-&gt;vd_hash = <span class="built_in">elf_hash</span>(verstr);</span><br><span class="line">    verdef-&gt;vd_aux = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">    ElfVerdaux&lt;E&gt; *aux = (ElfVerdaux&lt;E&gt; *)ptr;</span><br><span class="line">    ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdaux&lt;E&gt;);</span><br><span class="line">    aux-&gt;vda_name = ctx.dynstr-&gt;<span class="built_in">add_string</span>(verstr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::string_view basename = ctx.arg.soname.<span class="built_in">empty</span>() ?</span><br><span class="line">    ctx.arg.output : ctx.arg.soname;</span><br><span class="line">  <span class="built_in">write</span>(basename, <span class="number">1</span>, VER_FLG_BASE);</span><br><span class="line"></span><br><span class="line">  i64 idx = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::string_view verstr : ctx.arg.version_definitions)</span><br><span class="line">    <span class="built_in">write</span>(verstr, idx++, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : std::span&lt;Symbol&lt;E&gt; *&gt;(ctx.dynsym-&gt;symbols).<span class="built_in">subspan</span>(<span class="number">1</span>))</span><br><span class="line">    ctx.versym-&gt;contents[sym-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)] = sym-&gt;ver_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ver_idx的值是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static constexpr u32 VER_NDX_LOCAL = 0;</span><br><span class="line">static constexpr u32 VER_NDX_GLOBAL = 1;</span><br><span class="line">static constexpr u32 VER_NDX_LAST_RESERVED = 1;</span><br></pre></td></tr></table></figure><h2 id="verneed"><a href="#verneed" class="headerlink" title="verneed"></a>verneed</h2><p>这里的数据格式和vardef不太一样，content是一个Verneed接着多个Vednaux构成。每个Verneed表示一个文件的开始。由于这里是针对dynsym处理，因此实际Vednaux的数量和dynsym的数量相同。在分配空间的时候注释也有写到allocate large enought buffer，避免了每个文件一个dynsym的极端场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|verneed|vednaux|vednaux|...|verneed|vednaux|vednaux|vednaux|</span><br></pre></td></tr></table></figure><p>另外不在dso或者sym-&gt;ver_idx &lt;= VER_NDX_LAST_RESERVED的sym，这些符号并不需要填充verneed字段，因此会先被过滤掉。之后由于content是以一个文件为一个小组，为了后面添加信息方便会根据soname以及ver_idx进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> VerneedSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;fill_verneed&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.dynsym-&gt;symbols.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a list of versioned symbols and sort by file and version.</span></span><br><span class="line">  std::vector&lt;Symbol&lt;E&gt; *&gt; <span class="built_in">syms</span>(ctx.dynsym-&gt;symbols.<span class="built_in">begin</span>() + <span class="number">1</span>,</span><br><span class="line">                                ctx.dynsym-&gt;symbols.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(syms, [](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">return</span> !sym-&gt;file-&gt;is_dso || sym-&gt;ver_idx &lt;= VER_NDX_LAST_RESERVED;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (syms.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(syms, [](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(((SharedFile&lt;E&gt; *)a-&gt;file)-&gt;soname, a-&gt;ver_idx) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(((SharedFile&lt;E&gt; *)b-&gt;file)-&gt;soname, b-&gt;ver_idx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize of .gnu.version</span></span><br><span class="line">  ctx.versym-&gt;contents.<span class="built_in">resize</span>(ctx.dynsym-&gt;symbols.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">  ctx.versym-&gt;contents[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a large enough buffer for .gnu.version_r.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerneed&lt;E&gt;) + <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVernaux&lt;E&gt;)) * syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill .gnu.version_r.</span></span><br><span class="line">  u8 *buf = (u8 *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  u8 *ptr = buf;</span><br><span class="line">  ElfVerneed&lt;E&gt; *verneed = <span class="literal">nullptr</span>;</span><br><span class="line">  ElfVernaux&lt;E&gt; *aux = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  u16 veridx = VER_NDX_LAST_RESERVED + ctx.arg.version_definitions.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || syms[i - <span class="number">1</span>]-&gt;file != syms[i]-&gt;file) &#123;</span><br><span class="line">      <span class="built_in">start_group</span>(syms[i]-&gt;file);</span><br><span class="line">      <span class="built_in">add_entry</span>(syms[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (syms[i - <span class="number">1</span>]-&gt;ver_idx != syms[i]-&gt;ver_idx) &#123;</span><br><span class="line">      <span class="built_in">add_entry</span>(syms[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.versym-&gt;contents[syms[i]-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)] = veridx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize .gnu.version_r to fit to its contents.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>(ptr - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理过程中根据如果是第一个符号或者连续两个符号不是相同的file就start_group。</p><p>要注意ctx.versym-&gt;contents又重新resize了一次，在后面遍历符号的时候又会再次写入，或许是因为verdef是根据选项来决定是否执行的。两次resize实际上size是相同的，而verneed中并非所有符号都会写入versym→content，部分被过滤的符号是没有再次写入的，也就是说被过滤的符号会保留verneed的部分。</p><p>接着来看一下start_group的部分。这个函数中会sh_info递增，处理verneed（关联一个file），并且aux置空。也就是说VerneedSection的sh_info存放的是ElfVerneed的数量。每个ElfVerneed关联了一个文件，以及aux的size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start_group = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_info++;</span><br><span class="line">  <span class="keyword">if</span> (verneed)</span><br><span class="line">    verneed-&gt;vn_next = ptr - (u8 *)verneed;</span><br><span class="line"></span><br><span class="line">  verneed = (ElfVerneed&lt;E&gt; *)ptr;</span><br><span class="line">  ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(*verneed);</span><br><span class="line">  verneed-&gt;vn_version = <span class="number">1</span>;</span><br><span class="line">  verneed-&gt;vn_file = ctx.dynstr-&gt;<span class="built_in">find_string</span>(((SharedFile&lt;E&gt; *)file)-&gt;soname);</span><br><span class="line">  verneed-&gt;vn_aux = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerneed&lt;E&gt;);</span><br><span class="line">  aux = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在add_entry中会递增当前的verneed的计数，将信息填写到ElfVernaux中，并且更新当前aux的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_entry = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  verneed-&gt;vn_cnt++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aux)</span><br><span class="line">    aux-&gt;vna_next = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVernaux&lt;E&gt;);</span><br><span class="line">  aux = (ElfVernaux&lt;E&gt; *)ptr;</span><br><span class="line">  ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(*aux);</span><br><span class="line"></span><br><span class="line">  std::string_view verstr = sym-&gt;<span class="built_in">get_version</span>();</span><br><span class="line">  aux-&gt;vna_hash = <span class="built_in">elf_hash</span>(verstr);</span><br><span class="line">  aux-&gt;vna_other = ++veridx;</span><br><span class="line">  aux-&gt;vna_name = ctx.dynstr-&gt;<span class="built_in">add_string</span>(verstr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="create-output-symtab"><a href="#create-output-symtab" class="headerlink" title="create_output_symtab"></a>create_output_symtab</h1><p>这个过程是用于创建symtab和strtab，创建的时候会实际选择哪些符号要写到文件中。我们熟悉的strip，如果添加了链接选项那么就是在这里开始生效的。</p><p>相关的链接选项在mold中有如下几个</p><blockquote><p>-s, –strip-all             Strip .symtab section</p></blockquote><blockquote><p>–retain-symbols-file FILE  Keep only symbols listed in FILE</p></blockquote><blockquote><p>discard_all</p></blockquote><p>strip大家都很熟悉了，就是去掉生成文件中的symtab段</p><p>retain-symbols-file则是会产生一个符号文件，包含程序的调试信息，也就是说生成的文件说不包含符号信息，所有符号都在符号文件中。</p><p>discard_all是丢弃目标程序中未直接使用的信息，其中就包含符号表和调试信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute .symtab and .strtab sizes for each file.</span></span><br><span class="line"><span class="built_in">create_output_symtab</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_output_symtab</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_symtab_size&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    chunk-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk::compute_symtab_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some synethetic sections add local symbols to the output.</span></span><br><span class="line"><span class="comment">// For example, range extension thunks adds function_name@thunk</span></span><br><span class="line"><span class="comment">// symbol for each thunk entry. The following members are used</span></span><br><span class="line"><span class="comment">// for such synthesizing symbols.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">compute_symtab_size</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>对于chunk来说，不是所有的都需要做这一步操作的。在mold中仅针对OutputSection，Got，Plt，PltGot这几个chunk来处理。</p><p>实际要做的就是遍历所有符号更新其strtab_size以及num_local_symtab（用于标记local符号的数量，也就是这个阶段要计算的symtab size），不论是哪一种chunk都是如此，下面就不再赘述，只贴代码了。</p><h3 id="OutputSection"><a href="#OutputSection" class="headerlink" title="OutputSection"></a>OutputSection</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute spaces needed for thunk symbols</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file || ctx.arg.relocatable)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">this</span>-&gt;strtab_size </span>= <span class="number">9</span>; <span class="comment">// for &quot;$t&quot;, &quot;$a&quot; and &quot;$d&quot; symbols</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk : thunks) &#123;</span><br><span class="line">      <span class="comment">// For ARM32, we emit additional symbol &quot;$t&quot;, &quot;$a&quot; and &quot;$d&quot; for</span></span><br><span class="line">      <span class="comment">// each thunk to mark the beginning of ARM code.</span></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>-&gt;num_local_symtab +</span>= thunk-&gt;symbols.<span class="built_in">size</span>() * <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num_local_symtab += thunk-&gt;symbols.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : thunk-&gt;symbols)</span><br><span class="line">        <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$thunk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里relocatable的段也不会算入symtab size中，因为地址并非固定，需要加载时重定位，如果把符号放入输出文件中，会使得重定位更加困难，并且加载时会失效。</p><p>need_thunk：</p><ol><li>输出段中代码间隔比较大，直接跳转无法到达的时候需要thunk来中专</li><li>跳转的src和dest指令集不兼容需要thunk翻译</li><li>地址随机化(ASLR: Address space layout randomization)时需要thunk动态计算目标地址</li><li>地址运行时才能确定时需要thunk计算地址</li></ol><p>基本上都是一些无法直接跳转的情况，也因此会引入新的符号。而thunk本质上是一个新的代码段，需要符号进行表示，用以被其他代码识别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> needs_thunk = <span class="keyword">requires</span> &#123; E::thunk_size; &#125;;</span><br></pre></td></tr></table></figure><p>根据mold代码中的实现，目前需要thunk的是ARM32，ARM64，PPC64V1，PPC64V2</p><h3 id="got"><a href="#got" class="headerlink" title="got"></a>got</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GotSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : got_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$got&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : gottp_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$gottp&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : tlsgd_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsgd&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : tlsdesc_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsdesc&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tlsld_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsld&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> PltSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = symbols.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : symbols)</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$plt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PLTGOT"><a href="#PLTGOT" class="headerlink" title="PLTGOT"></a>PLTGOT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> PltGotSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = symbols.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : symbols)</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$pltgot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h2><p>在obj中，主要计算了local和global符号的名字占用的空间，用于更新strtable_size，另外还会更新对应的output_sym_indices</p><p>要注意的是计算名字空间的时候，这里的名字需要使用null结尾，因此size还需要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;output_sym_indices.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> is_alive = [&amp;](Symbol&lt;E&gt; &amp;sym) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.gc_sections)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>())</span><br><span class="line">      <span class="keyword">return</span> frag-&gt;is_alive;</span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="keyword">return</span> isec-&gt;is_alive;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of local symbols</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.discard_all &amp;&amp; !ctx.arg.strip_all &amp;&amp; !ctx.arg.retain_symbols_file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_alive</span>(sym) &amp;&amp; <span class="built_in">should_write_to_local_symtab</span>(ctx, sym)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">        sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of global symbols.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file == <span class="keyword">this</span> &amp;&amp; <span class="built_in">is_alive</span>(sym) &amp;&amp;</span><br><span class="line">        (!ctx.arg.retain_symbols_file || sym.write_to_symtab)) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// Global symbols can be demoted to local symbols based on visibility,</span></span><br><span class="line">      <span class="comment">// version scripts etc.</span></span><br><span class="line">      <span class="keyword">if</span> (sym.<span class="built_in">is_local</span>(ctx))</span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_global_symtab++;</span><br><span class="line">      sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于local symbol除了要判断alive之外，还有一个should_write_to_local_symtab的判断，除了更新size外还会更新write_to_symtab</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">should_write_to_local_symtab</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() == STT_SECTION)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Local symbols are discarded if --discard-local is given or they</span></span><br><span class="line">  <span class="comment">// are in a mergeable section. I *believe* we exclude symbols in</span></span><br><span class="line">  <span class="comment">// mergeable sections because (1) there are too many and (2) they are</span></span><br><span class="line">  <span class="comment">// merged, so their origins shouldn&#x27;t matter, but I don&#x27;t really</span></span><br><span class="line">  <span class="comment">// know the rationale. Anyway, this is the behavior of the</span></span><br><span class="line">  <span class="comment">// traditional linkers.</span></span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">name</span>().<span class="built_in">starts_with</span>(<span class="string">&quot;.L&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.discard_locals)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="keyword">if</span> (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_MERGE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>-X, –discard-locals        Discard temporary local symbols</p></blockquote><p>本地符号以本地标签为前缀开头，这个标签通常为.L，这里主要是对discard_locals进行处理，另外属于SHF_MERGE的段也不会写到local，根据这里注释的意思是SHF_MERGE段段符号太多了，并且是merge以后的，所以其来源不重要，并且传统的链接器都是这么做的。（我对这块也不了解，只能按照注释所说的来看了）</p><p>还有一个sym.is_local的判断看起来比较疑惑。根据注释所描述，global sym会基于visibility和version scripts等因素变成local sym，比如说设置某个global sym的可见性为特定范围，或者对应的脚本。当全局符号降级为local的时候则不再对外可见，因此不再占用全局符号表的空间。</p><p>代码里的判断是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Symbol&lt;E&gt;::<span class="built_in">is_local</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.relocatable)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">esym</span>().st_bind == STB_LOCAL;</span><br><span class="line">  <span class="keyword">return</span> !is_imported &amp;&amp; !is_exported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于relocatable来说，如果st_bind为STB_LOCAL，那么这个符号一定是local的</p><p>对于非imported以及非exported的全局符号，通常是模块内部实现细节使用，不能外部访问。比如说有如下几种情况</p><ol><li>静态全局符号，只能模块内部可见（因为静态符号的作用域限定在模块内，因此会被认为是local符号，对全局静态变量的访问只需要通过内存地址，而不需要符号名进行绑定）</li><li>匿名全局符号，没有被显示的使用export或者extern等进行标记，并且对外部是不可见的。比如说在.c中定义了一个全局变量，但是外部无法访问到。</li><li>未使用的全局符号，不会被访问，同时会被优化掉</li></ol><p>因此这些情况属于local，记入num_local_symtab</p><p>关于imported和exported的计算过程，可以参考之前第五期的文章，其中有根据可见性来设置exported和imported的部分</p><p><a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/" >https://homura.live/2023/04/29/mold/mold-5-symbol/<i class="fas fa-external-link-alt"></i></a></p><h2 id="dso"><a href="#dso" class="headerlink" title="dso"></a>dso</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;output_sym_indices.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of global symbols.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file == <span class="keyword">this</span> &amp;&amp; (sym.is_imported || sym.is_exported) &amp;&amp;</span><br><span class="line">        (!ctx.arg.retain_symbols_file || sym.write_to_symtab)) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_global_symtab++;</span><br><span class="line">      sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的要点就是imported或者exported才需要计入num_global_symtab</p><h1 id="eh-frame-construct"><a href="#eh-frame-construct" class="headerlink" title="eh_frame_construct"></a>eh_frame_construct</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eh_frame is a special section from the linker&#x27;s point of view,</span></span><br><span class="line"><span class="comment">// as its contents are parsed and reconstructed by the linker,</span></span><br><span class="line"><span class="comment">// unlike other sections that are regarded as opaque bytes.</span></span><br><span class="line"><span class="comment">// Here, we construct output .eh_frame contents.</span></span><br><span class="line">ctx.eh_frame-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><p>由于eh_frame在mold中自行做了parse的，因此需要再手动构造output中eh_frame的部分，在构造的过程中主要是消除重复的部分，另外各个段是由offset以及idx关联起来的，更新这些信息也是必要的工作。</p><p>关于mold自行parse eh_frame的部分可以参考第二期的内容<a class="link"   href="https://homura.live/2023/04/05/mold/mold-2-read-shared-files/" >https://homura.live/2023/04/05/mold/mold-2-read-shared-files/<i class="fas fa-external-link-alt"></i></a></p><p>在构造的过程主要由如下几部分组成</p><ol><li>确保输入存在eh_frame，不存在则无需构造</li><li>删除dead fed，重新设置offset</li><li>uniquify cie，重新设置offset</li><li>fde idx的更新</li><li>重新设置文件中存储的fde的offset</li><li>填充最后的null word</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EhFrameSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EhFrameSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.eh_frame&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_PROGBITS;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">apply_reloc</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel, u64 offset, u64 val)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> EhFrameSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;eh_frame&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If .eh_frame is missing in all input files, we don&#x27;t want to</span></span><br><span class="line">  <span class="comment">// create an output .eh_frame section.</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(ctx.objs.<span class="built_in">begin</span>(), ctx.objs.<span class="built_in">end</span>(),</span><br><span class="line">                  [](ObjectFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> file-&gt;cies.<span class="built_in">empty</span>(); &#125;)) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove dead FDEs and assign them offsets within their corresponding</span></span><br><span class="line">  <span class="comment">// CIE group.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    std::<span class="built_in">erase_if</span>(file-&gt;fdes, [](FdeRecord&lt;E&gt; &amp;fde) &#123; <span class="keyword">return</span> !fde.is_alive; &#125;);</span><br><span class="line"></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : file-&gt;fdes) &#123;</span><br><span class="line">      fde.output_offset = offset;</span><br><span class="line">      offset += fde.<span class="built_in">size</span>(*file);</span><br><span class="line">    &#125;</span><br><span class="line">    file-&gt;fde_size = offset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uniquify CIEs and assign offsets to them.</span></span><br><span class="line">  std::vector&lt;CieRecord&lt;E&gt; *&gt; leaders;</span><br><span class="line">  <span class="keyword">auto</span> find_leader = [&amp;](CieRecord&lt;E&gt; &amp;cie) -&gt; CieRecord&lt;E&gt; * &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; *leader : leaders)</span><br><span class="line">      <span class="keyword">if</span> (cie.<span class="built_in">equals</span>(*leader))</span><br><span class="line">        <span class="keyword">return</span> leader;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  i64 offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CieRecord&lt;E&gt; *leader = <span class="built_in">find_leader</span>(cie)) &#123;</span><br><span class="line">        cie.output_offset = leader-&gt;output_offset;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cie.output_offset = offset;</span><br><span class="line">        cie.is_leader = <span class="literal">true</span>;</span><br><span class="line">        offset += cie.<span class="built_in">size</span>();</span><br><span class="line">        leaders.<span class="built_in">push_back</span>(&amp;cie);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign FDE offsets to files.</span></span><br><span class="line">  i64 idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    file-&gt;fde_idx = idx;</span><br><span class="line">    idx += file-&gt;fdes.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    file-&gt;fde_offset = offset;</span><br><span class="line">    offset += file-&gt;fde_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .eh_frame must end with a null word.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = offset + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gdb-index"><a href="#gdb-index" class="headerlink" title="gdb index"></a>gdb index</h1><p>gdb-index是用于加速gdb的段，对应的链接选项</p><blockquote><p>–gdb-index                 Create .gdb_index for faster gdb startup</p></blockquote><p>这边就不具体详细介绍了，有兴趣的可以自行看一下资料</p><p><a class="link"   href="https://sourceware.org/gdb/onlinedocs/gdb/Index-Files.html" >https://sourceware.org/gdb/onlinedocs/gdb/Index-Files.html<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --gdb-index.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.gdb_index)</span><br><span class="line">  ctx.gdb_index-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This page explains the format of .gdb_index:</span></span><br><span class="line"><span class="comment">// https://sourceware.org/gdb/onlinedocs/gdb/Index-Section-Format.html</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GdbIndexSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;GdbIndexSection::construct&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="keyword">atomic_bool</span> has_debug_info = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read debug sections</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;debug_info) &#123;</span><br><span class="line">      <span class="comment">// Read compilation units from .debug_info.</span></span><br><span class="line">      file-&gt;compunits = <span class="built_in">read_compunits</span>(ctx, *file);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Count the number of address areas contained in this file.</span></span><br><span class="line">      file-&gt;num_areas = <span class="built_in">estimate_address_areas</span>(ctx, *file);</span><br><span class="line">      has_debug_info = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!has_debug_info)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize `area_offset` and `compunits_idx`.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;area_offset =</span><br><span class="line">      ctx.objs[i]-&gt;area_offset + ctx.objs[i]-&gt;num_areas * <span class="number">20</span>;</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;compunits_idx =</span><br><span class="line">      ctx.objs[i]-&gt;compunits_idx + ctx.objs[i]-&gt;compunits.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read .debug_gnu_pubnames and .debug_gnu_pubtypes.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;gdb_names = <span class="built_in">read_pubnames</span>(ctx, *file);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Estimate the unique number of pubnames.</span></span><br><span class="line">  HyperLogLog estimator;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    HyperLogLog e;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names)</span><br><span class="line">      e.<span class="built_in">insert</span>(name.hash);</span><br><span class="line">    estimator.<span class="built_in">merge</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uniquify pubnames by inserting all name strings into a concurrent</span></span><br><span class="line">  <span class="comment">// hashmap.</span></span><br><span class="line">  map.<span class="built_in">resize</span>(estimator.<span class="built_in">get_cardinality</span>() * <span class="number">2</span>);</span><br><span class="line">  tbb::enumerable_thread_specific&lt;i64&gt; num_names;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names) &#123;</span><br><span class="line">      MapEntry *ent;</span><br><span class="line">      <span class="keyword">bool</span> inserted;</span><br><span class="line">      std::<span class="built_in">tie</span>(ent, inserted) = map.<span class="built_in">insert</span>(name.name, name.hash, &#123;file, name.hash&#125;);</span><br><span class="line">      <span class="keyword">if</span> (inserted)</span><br><span class="line">        num_names.<span class="built_in">local</span>()++;</span><br><span class="line"></span><br><span class="line">      ObjectFile&lt;E&gt; *old_val = ent-&gt;owner;</span><br><span class="line">      <span class="keyword">while</span> (file-&gt;priority &lt; old_val-&gt;priority &amp;&amp;</span><br><span class="line">             !ent-&gt;owner.<span class="built_in">compare_exchange_weak</span>(old_val, file));</span><br><span class="line"></span><br><span class="line">      ent-&gt;num_attrs++;</span><br><span class="line">      name.entry_idx = ent - map.values;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign offsets for names and attributes within each file.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names) &#123;</span><br><span class="line">      MapEntry &amp;ent = map.values[name.entry_idx];</span><br><span class="line">      <span class="keyword">if</span> (ent.owner == file) &#123;</span><br><span class="line">        ent.attr_offset = file-&gt;attrs_size;</span><br><span class="line">        file-&gt;attrs_size += (ent.num_attrs + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        ent.name_offset = file-&gt;names_size;</span><br><span class="line">        file-&gt;names_size += name.name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute per-file name and attributes offsets.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;attrs_offset =</span><br><span class="line">      ctx.objs[i]-&gt;attrs_offset + ctx.objs[i]-&gt;attrs_size;</span><br><span class="line"></span><br><span class="line">  ctx.objs[<span class="number">0</span>]-&gt;names_offset =</span><br><span class="line">    ctx.objs.<span class="built_in">back</span>()-&gt;attrs_offset + ctx.objs.<span class="built_in">back</span>()-&gt;attrs_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;names_offset =</span><br><span class="line">      ctx.objs[i]-&gt;names_offset + ctx.objs[i]-&gt;names_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .gdb_index contains an on-disk hash table for pubnames and</span></span><br><span class="line">  <span class="comment">// pubtypes. We aim 75% utilization. As per the format specification,</span></span><br><span class="line">  <span class="comment">// It must be a power of two.</span></span><br><span class="line">  i64 num_symtab_entries =</span><br><span class="line">    std::max&lt;i64&gt;(<span class="built_in">bit_ceil</span>(num_names.<span class="built_in">combine</span>(std::<span class="built_in">plus</span>()) * <span class="number">4</span> / <span class="number">3</span>), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now that we can compute the size of this section.</span></span><br><span class="line">  ObjectFile&lt;E&gt; &amp;last = *ctx.objs.<span class="built_in">back</span>();</span><br><span class="line">  i64 compunits_size = (last.compunits_idx + last.compunits.<span class="built_in">size</span>()) * <span class="number">16</span>;</span><br><span class="line">  i64 areas_size = last.area_offset + last.num_areas * <span class="number">20</span>;</span><br><span class="line">  i64 offset = <span class="built_in"><span class="keyword">sizeof</span></span>(header);</span><br><span class="line"></span><br><span class="line">  header.cu_list_offset = offset;</span><br><span class="line">  offset += compunits_size;</span><br><span class="line"></span><br><span class="line">  header.cu_types_offset = offset;</span><br><span class="line">  header.areas_offset = offset;</span><br><span class="line">  offset += areas_size;</span><br><span class="line"></span><br><span class="line">  header.symtab_offset = offset;</span><br><span class="line">  offset += num_symtab_entries * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  header.const_pool_offset = offset;</span><br><span class="line">  offset += last.names_offset + last.names_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-12-create</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="eh_frame" scheme="https://fusionbolt.github.io/tags/eh-frame/"/>
    
    <category term="symtab" scheme="https://fusionbolt.github.io/tags/symtab/"/>
    
  </entry>
  
</feed>
