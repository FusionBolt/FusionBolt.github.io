<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2023-05-07T16:16:54.092Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mold源码阅读六 section size优化</title>
    <link href="https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/"/>
    <id>https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/</id>
    <published>2023-05-07T15:59:24.000Z</published>
    <updated>2023-05-07T16:16:54.092Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-6-section-size-reduce/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341 p2</center> <p>上一期我们讲解了一些符号相关的处理，这一期我们来讲一些对于section size的优化处理。</p><h1 id="mark-addrsig"><a href="#mark-addrsig" class="headerlink" title="mark_addrsig"></a>mark_addrsig</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read address-significant section information.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf &amp;&amp; !ctx.arg.icf_all)</span><br><span class="line">  <span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_addrsig</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_addrsig&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的命令行参数</p><blockquote><p>-icf=[all,safe,none] Fold identical code<br>–no-icf</p></blockquote><p>针对所有的obj处理，因为dso的地址相关信息是在运行时加载进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">mark_addrsig</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Parse a .llvm_addrsig section.</span></span><br><span class="line">  <span class="keyword">if</span> (llvm_addrsig) &#123;</span><br><span class="line">    u8 *cur = (u8 *)llvm_addrsig-&gt;contents.<span class="built_in">data</span>();</span><br><span class="line">    u8 *end = cur + llvm_addrsig-&gt;contents.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[<span class="built_in">read_uleb</span>(cur)];</span><br><span class="line">      <span class="keyword">if</span> (sym.file == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We treat a symbol&#x27;s address as significant if</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 1. we have no address significance information for the symbol, or</span></span><br><span class="line">  <span class="comment">// 2. the symbol can be referenced from the outside in an address-</span></span><br><span class="line">  <span class="comment">//    significant manner.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="keyword">this</span>-&gt;symbols)</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>())</span><br><span class="line">        <span class="keyword">if</span> (!llvm_addrsig || sym-&gt;is_exported)</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于llvm_addrsig，处理的是一个范围的Symbol，将这个范围的Symbol的address_significant设置为True</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ObjectFile&lt;E&gt;::initialize_sections</span></span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; llvm_addrsig;</span><br><span class="line"><span class="comment">// Save .llvm_addrsig for --icf=safe.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_type == SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">  llvm_addrsig = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的symbol address，针对非llvm_addrsig或者exported的symbol将address_significant为True</p><p>那么address_significant是什么呢</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table" >https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>the address of the symbol is used in a comparison or leaks outside the translation unit</p></blockquote><p>简单来说就是这个地址会被用于比较或者用于翻译单元之外，这个变量的具体含义到后面使用的时候会结合场景进一步讲述。</p><h1 id="gc-sections"><a href="#gc-sections" class="headerlink" title="gc_sections"></a>gc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Garbage-collect unreachable sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.gc_sections)</span><br><span class="line">  <span class="built_in">gc_sections</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_nonalloc_fragments</span>(ctx);</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; rootset;</span><br><span class="line">  <span class="built_in">collect_root_set</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">mark</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">sweep</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gc_sections主要是对section像GC一样进行mark and sweep，清理掉未被使用的段，关于gc_sections的选项</p><blockquote><p>–gc-sections               Remove unreferenced sections</p></blockquote><h2 id="mark-nonalloc-fragments"><a href="#mark-nonalloc-fragments" class="headerlink" title="mark_nonalloc_fragments"></a>mark_nonalloc_fragments</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-alloc section fragments are not subject of garbage collection.</span></span><br><span class="line"><span class="comment">// This function marks such fragments.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_nonalloc_fragments</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_nonalloc_fragments&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : file-&gt;mergeable_sections)</span><br><span class="line">      <span class="keyword">if</span> (m)</span><br><span class="line">        <span class="keyword">for</span> (SectionFragment&lt;E&gt; *frag : m-&gt;fragments)</span><br><span class="line">          <span class="keyword">if</span> (!(frag-&gt;output_section.shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">            frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Non-alloc的fragment不是垃圾回收的对象，因此这里只是标记，避免后续被sweep</p><h2 id="collect-root-set"><a href="#collect-root-set" class="headerlink" title="collect_root_set"></a>collect_root_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect_root_set</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                             tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;collect_root_set&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_section = [&amp;](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mark_section</span>(isec))</span><br><span class="line">      rootset.<span class="built_in">push_back</span>(isec);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_symbol = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym-&gt;<span class="built_in">get_frag</span>())</span><br><span class="line">        frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">enqueue_section</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections that are not subject to garbage collection.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -gc-sections discards only SHF_ALLOC sections. If you want to</span></span><br><span class="line">      <span class="comment">// reduce the amount of non-memory-mapped segments, you should</span></span><br><span class="line">      <span class="comment">// use `strip` command, compile without debug info or use</span></span><br><span class="line">      <span class="comment">// -strip-all linker option.</span></span><br><span class="line">      u32 flags = isec-&gt;<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; SHF_ALLOC))</span><br><span class="line">        isec-&gt;is_visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">should_keep</span>(*isec))</span><br><span class="line">        <span class="built_in">enqueue_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections containing exported symbols</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols)</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file == file &amp;&amp; sym-&gt;is_exported)</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(sym);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections referenced by root symbols.</span></span><br><span class="line">  <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, ctx.arg.entry));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .eh_frame consists of variable-length records called CIE and FDE</span></span><br><span class="line">  <span class="comment">// records, and they are a unit of inclusion or exclusion.</span></span><br><span class="line">  <span class="comment">// We just keep all CIEs and everything that are referenced by them.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : cie.<span class="built_in">get_rels</span>())</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(file-&gt;symbols[rel.r_sym]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是进行收集root，以便之后进行mark and sweep。</p><p>主要收集的方向有两个</p><ol><li><p>对section直接添加，这里主要是针对一些不受垃圾回收影响的段。具体条件参考should_keep的实现。</p></li><li><p>针对符号进行处理，如果是在fragment中则会设置其为alive，因为fragment并非扫描的root。如果是在普通的段中则将符号引用的section添加到root中。</p><p>而符号的来源分为这么几种</p><ol><li>is_exported</li><li>undefined</li><li>require_defined</li><li>cie中的rel符号</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">should_keep</span><span class="params">(<span class="keyword">const</span> InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  u32 type = isec.<span class="built_in">shdr</span>().sh_type;</span><br><span class="line">  u32 flags = isec.<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (flags &amp; SHF_GNU_RETAIN) ||</span><br><span class="line">         type == SHT_NOTE ||</span><br><span class="line">         type == SHT_INIT_ARRAY ||</span><br><span class="line">         type == SHT_FINI_ARRAY ||</span><br><span class="line">         type == SHT_PREINIT_ARRAY ||</span><br><span class="line">         (std::is_same_v&lt;E, ARM32&gt; &amp;&amp; type == SHT_ARM_EXIDX) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ctors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.dtors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.init&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.fini&quot;</span>) ||</span><br><span class="line">         <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all reachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                 tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(rootset, [&amp;](InputSection&lt;E&gt; *isec,</span><br><span class="line">                                    tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(ctx, isec, feeder, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec,</span></span></span><br><span class="line"><span class="params"><span class="function">                  tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder, i64 depth)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;is_visited);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a text section, .eh_frame may contain records</span></span><br><span class="line">  <span class="comment">// describing how to handle exceptions for that function.</span></span><br><span class="line">  <span class="comment">// We want to keep associated .eh_frame records.</span></span><br><span class="line">  <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : isec-&gt;<span class="built_in">get_fdes</span>())</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : fde.<span class="built_in">get_rels</span>(isec-&gt;file).<span class="built_in">subspan</span>(<span class="number">1</span>))</span><br><span class="line">      <span class="keyword">if</span> (Symbol&lt;E&gt; *sym = isec-&gt;file.symbols[rel.r_sym])</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mark_section</span>(sym-&gt;<span class="built_in">get_input_section</span>()))</span><br><span class="line">          feeder.<span class="built_in">add</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec-&gt;file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol can refer either a section fragment or an input section.</span></span><br><span class="line">    <span class="comment">// Mark a fragment as alive.</span></span><br><span class="line">    <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">      frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mark_section</span>(sym.<span class="built_in">get_input_section</span>()))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark a section alive. For better performacne, we don&#x27;t call</span></span><br><span class="line">    <span class="comment">// `feeder.add` too often.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">visit</span>(ctx, sym.<span class="built_in">get_input_section</span>(), feeder, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      feeder.<span class="built_in">add</span>(sym.<span class="built_in">get_input_section</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从rootset出发</p><ol><li>针对fde record中的rel符号所在的section进行标记，并且添加到feeder中（本质是加到了rootset中，后续会继续从这些节点开始遍历）</li><li>针对rel段中的符号进行遍历，如果是fragment则设置其alive，之后对sym的input section进行标记，标记成功的话则继续递归执行。</li></ol><h2 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove unreachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sweep</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;garbage_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; !isec-&gt;is_visited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.print_gc_sections)</span><br><span class="line">          <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;removing unused section &quot;</span> &lt;&lt; *isec;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ehframe那一期提到会清理未用到的record，而在这里实际执行了fde的清理工作。</p><h1 id="icf-sections"><a href="#icf-sections" class="headerlink" title="icf_sections"></a>icf_sections</h1><p>这段内容比较长，建议单独查看源码对应位置进行对照，相关实现在elf/icf.cc中</p><p>icf的全拼推测是identical code folding</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge identical read-only sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf)</span><br><span class="line"><span class="built_in">icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icf_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;icf&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">uniquify_cies</span>(ctx);</span><br><span class="line">  <span class="built_in">merge_leaf_nodes</span>(ctx);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniquify-cies"><a href="#uniquify-cies" class="headerlink" title="uniquify_cies"></a>uniquify_cies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uniquify_cies</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;uniquify_cies&quot;</span>)</span></span>;</span><br><span class="line">  std::vector&lt;CieRecord&lt;E&gt; *&gt; cies;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; cies.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cie.<span class="built_in">equals</span>(*cies[i])) &#123;</span><br><span class="line">          cie.icf_idx = i;</span><br><span class="line">          <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cie.icf_idx = cies.<span class="built_in">size</span>();</span><br><span class="line">      cies.<span class="built_in">push_back</span>(&amp;cie);</span><br><span class="line">    found:;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中的所有cie，如果cie和cies中的任何一个相同，也就是出现了重复，则继续查看下一个cie是否重复，没有重复则将cie加进去。</p><p>这里我不太明白，为什么不保存一个CieRecord的Set，避免了再写一个循环的麻烦？如果有读者能解答我的疑惑欢迎邮件联系我。</p><h2 id="merge-leaf-nodes"><a href="#merge-leaf-nodes" class="headerlink" title="merge_leaf_nodes"></a>merge_leaf_nodes</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Early merge of leaf nodes, which can be processed without constructing the</span></span><br><span class="line"><span class="comment">// entire graph. This reduces the vertex count and improves memory efficiency.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_leaf_nodes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;merge_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eligible</span><span class="params">(<span class="string">&quot;icf_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">non_eligible</span><span class="params">(<span class="string">&quot;icf_non_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">leaf</span><span class="params">(<span class="string">&quot;icf_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_unordered_map&lt;InputSection&lt;E&gt; *, InputSection&lt;E&gt; *,</span><br><span class="line">                                LeafHasher&lt;E&gt;, LeafEq&lt;E&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_eligible</span>(ctx, *isec)) &#123;</span><br><span class="line">        non_eligible++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_leaf</span>(ctx, *isec)) &#123;</span><br><span class="line">        leaf++;</span><br><span class="line">        isec-&gt;icf_leaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> [it, inserted] = map.<span class="built_in">insert</span>(&#123;isec.<span class="built_in">get</span>(), isec.<span class="built_in">get</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">          it-&gt;second = isec.<span class="built_in">get</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eligible++;</span><br><span class="line">        isec-&gt;icf_eligible = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_leaf) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">        <span class="built_in">assert</span>(it != map.<span class="built_in">end</span>());</span><br><span class="line">        isec-&gt;leader = it-&gt;second;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中eligible的sections来处理。</p><p>是leaf则设置leaf并且插入到map中，但是如果insert失败，且priority更高，那么就更新对应的section</p><p>非leaf的情况下只设置eligible，留到后面进行处理。</p><p>之后针对所有obj的sections，如果是icf_leaf，那么更新其leader为map中对应的值</p><h3 id="关于其中出现的InputSection的字段"><a href="#关于其中出现的InputSection的字段" class="headerlink" title="关于其中出现的InputSection的字段"></a>关于其中出现的InputSection的字段</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in InputSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For ICF</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `leader` is the section that this section has been merged with.</span></span><br><span class="line"><span class="comment">// Three kind of values are possible:</span></span><br><span class="line"><span class="comment">// - `leader == nullptr`: This section was not eligible for ICF.</span></span><br><span class="line"><span class="comment">// - `leader == this`: This section was retained.</span></span><br><span class="line"><span class="comment">// - `leader != this`: This section was merged with another identical section.</span></span><br><span class="line">InputSection&lt;E&gt; *leader = <span class="literal">nullptr</span>;</span><br><span class="line">u32 icf_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_eligible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_leaf = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>简单来说这个leader实际上是用于指向当前section的一个唯一实现。</p><p>如果leader存在且为自己，那么对应内容的段只访问过一次，如果不为自己的话，那么代表这不是第一次访问对应内容的段了。</p><p>用实际实现结合注释来说明leader这个字段。</p><ol><li>==nullptr：这种情况表明这个section是not eligible的，也就是说会在上面的循环被忽略掉</li><li>==this：这种情况表明这个section是对应内容的段第一次出现，在后面更新leader的过程中是找到的section和自身相同。</li><li>≠this：这种情况表明后面更新leader的查找过程中，找到的section其实是其对应内容在前面第一次出现的段，也就是指向了对应的leader</li></ol><p>举个例子，假设有s1, s2, s3三个section，s1是not eligible的，s2和s3是相同的，按照s1-s3的顺序进行扫描</p><p>s1 = nullptr</p><p>s2 = s2 # leader</p><p>s3 = s2</p><h3 id="is-eligible"><a href="#is-eligible" class="headerlink" title="is_eligible"></a>is_eligible</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_eligible</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = isec.<span class="built_in">shdr</span>();</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_alloc = (shdr.sh_flags &amp; SHF_ALLOC);</span><br><span class="line">  <span class="keyword">bool</span> is_exec = (shdr.sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">                 ctx.arg.ignore_data_address_equality;</span><br><span class="line">  <span class="keyword">bool</span> is_relro = (name == <span class="string">&quot;.data.rel.ro&quot;</span> ||</span><br><span class="line">                   name.<span class="built_in">starts_with</span>(<span class="string">&quot;.data.rel.ro.&quot;</span>));</span><br><span class="line">  <span class="keyword">bool</span> is_readonly = !(shdr.sh_flags &amp; SHF_WRITE) || is_relro;</span><br><span class="line">  <span class="keyword">bool</span> is_bss = (shdr.sh_type == SHT_NOBITS);</span><br><span class="line">  <span class="keyword">bool</span> is_empty = (shdr.sh_size == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_init = (shdr.sh_type == SHT_INIT_ARRAY || name == <span class="string">&quot;.init&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_fini = (shdr.sh_type == SHT_FINI_ARRAY || name == <span class="string">&quot;.fini&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_enumerable = <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">  <span class="keyword">bool</span> is_addr_taken = !ctx.arg.icf_all &amp;&amp; isec.address_significant;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_alloc &amp;&amp; is_exec &amp;&amp; is_readonly &amp;&amp; !is_bss &amp;&amp; !is_empty &amp;&amp;</span><br><span class="line">         !is_init &amp;&amp; !is_fini &amp;&amp; !is_enumerable &amp;&amp; !is_addr_taken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不满足这些情况的话无法被fold，具体条件以及判断方式无需再多讲解，纯粹是对应的规则。</p><p>注意这里出现了上面说的address_significant，需要为false才能满足，也就是说需要用地址比较的情况是无法被fold的。</p><h2 id="gather-sections"><a href="#gather-sections" class="headerlink" title="gather_sections"></a>gather_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare for the propagation rounds.</span></span><br><span class="line">std::vector&lt;InputSection&lt;E&gt; *&gt; sections = <span class="built_in">gather_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">gather_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gather_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count the number of input sections for each input file.</span></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">num_sections</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        num_sections[i]++;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">section_indices</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    section_indices[i + <span class="number">1</span>] = section_indices[i] + num_sections[i];</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">sections</span>(</span><br><span class="line">    section_indices.<span class="built_in">back</span>() + num_sections.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill `sections` contents.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    i64 idx = section_indices[i];</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        sections[idx++] = isec.<span class="built_in">get</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    sections[i]-&gt;icf_idx = i;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了三个vector，先来理清对应的作用</p><ol><li>num_sections：每个obj中icf_eligible的input sections数量</li><li>section_indices：由前一个section_indices和num_sections的值决定，其实是用于标记每个位置的objs的input section的起始在最终的sections中的坐标</li><li>sections：初始化的容量是其实是section_indices[ctx.objs.size()]的值</li></ol><p>这样说可能比较抽象，举个例子</p><p>num_sections: 2, 3, 4, 5</p><p>section_indices: 0, 2+0, 3+2+0, 4+3+2+0</p><p>5+4+3+2+0</p><p>算出来的其实是所有obj中icf_eligible的input sections的数量</p><p>之后是fill content的部分，并行的获取每个obj中的所有icf_eligible的input section的指针</p><h2 id="Digest"><a href="#Digest" class="headerlink" title="Digest"></a>Digest</h2><p>接下来的部分都是在计算digest，具体算法有兴趣的可以去实现中自行查看细节。</p><p>什么是digest，这个链接中的一个回答说的比较明白了，我选取了关键内容放出来</p><p><a class="link"   href="https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function" >https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>The digest is the output of the hash function.<br>For example, sha256 has a digest of 256 bits, i.e. its digest has a length of 32 bytes.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="keyword">uint8_t</span>, HASH_SIZE&gt; Digest;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// We allocate 3 arrays to store hashes for each vertex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 0 and 1 are used for tree hashes from the previous</span></span><br><span class="line"><span class="comment">// iteration and the current iteration. They switch roles every</span></span><br><span class="line"><span class="comment">// iteration. See `slot` below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 2 stores the initial, single-vertex hash. This is combined</span></span><br><span class="line"><span class="comment">// with hashes from the connected vertices to form the tree hash</span></span><br><span class="line"><span class="comment">// described above.</span></span><br><span class="line">std::vector&lt;std::vector&lt;Digest&gt;&gt; <span class="built_in">digests</span>(<span class="number">3</span>);</span><br><span class="line">digests[<span class="number">0</span>] = compute_digests&lt;E&gt;(ctx, sections);</span><br><span class="line">digests[<span class="number">1</span>].<span class="built_in">resize</span>(digests[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">digests[<span class="number">2</span>] = digests[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">std::vector&lt;u32&gt; edges;</span><br><span class="line">std::vector&lt;u32&gt; edge_indices;</span><br><span class="line">gather_edges&lt;E&gt;(ctx, sections, edges, edge_indices);</span><br><span class="line"></span><br><span class="line"><span class="function">BitVector <span class="title">converged</span><span class="params">(digests[<span class="number">0</span>].size())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> slot = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the propagation rounds until convergence is obtained.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;propagate&quot;</span>)</span></span>;</span><br><span class="line">  tbb::affinity_partitioner ap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A cheap test that the graph hasn&#x27;t converged yet.</span></span><br><span class="line">  <span class="comment">// The loop after this one uses a strict condition, but it&#x27;s expensive</span></span><br><span class="line">  <span class="comment">// as it requires sorting the entire hash collection.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For nodes that have a cycle in downstream (i.e. recursive</span></span><br><span class="line">  <span class="comment">// functions and functions that calls recursive functions) will always</span></span><br><span class="line">  <span class="comment">// change with the iterations. Nodes that doesn&#x27;t (i.e. non-recursive</span></span><br><span class="line">  <span class="comment">// functions) will stop changing as soon as the propagation depth reaches</span></span><br><span class="line">  <span class="comment">// the call tree depth.</span></span><br><span class="line">  <span class="comment">// Here, we test whether we have reached sufficient depth for the latter,</span></span><br><span class="line">  <span class="comment">// which is a necessary (but not sufficient) condition for convergence.</span></span><br><span class="line">  i64 num_changed = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    i64 n = propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_changed)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_changed = n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Run the pass until the unique number of hashes stop increasing, at which</span></span><br><span class="line">  <span class="comment">// point we have achieved convergence (proof omitted for brevity).</span></span><br><span class="line">  i64 num_classes = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// count_num_classes requires sorting which is O(n log n), so do a little</span></span><br><span class="line">    <span class="comment">// more work beforehand to amortize that log factor.</span></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line"></span><br><span class="line">    i64 n = count_num_classes&lt;E&gt;(digests[slot], ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_classes)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_classes = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-sections"><a href="#group-sections" class="headerlink" title="group sections"></a>group sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group sections by SHA digest.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;group&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *map = <span class="keyword">new</span> tbb::concurrent_unordered_map&lt;Digest, InputSection&lt;E&gt; *&gt;;</span><br><span class="line">  std::span&lt;Digest&gt; digest = digests[slot];</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    InputSection&lt;E&gt; *isec = sections[i];</span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = map-&gt;<span class="built_in">insert</span>(&#123;digest[i], isec&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">      it-&gt;second = isec;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = map-&gt;<span class="built_in">find</span>(digest[i]);</span><br><span class="line">    <span class="built_in">assert</span>(it != map-&gt;<span class="built_in">end</span>());</span><br><span class="line">    sections[i]-&gt;leader = it-&gt;second;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since free&#x27;ing the map is slow, postpone it.</span></span><br><span class="line">  ctx.on_exit.<span class="built_in">push_back</span>([=] &#123; <span class="keyword">delete</span> map; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.print_icf_sections)</span><br><span class="line">  <span class="built_in">print_icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里我们暂时忽略digest是怎么来的细节，直接看这里使用的过程。将digest关联一个input section，这里的逻辑很像merge_leaf_nodes，只是key换成了Digest，本质更换了一种hash方式，另外不再是只针对leaf的了</p><h2 id="sweep-sections"><a href="#sweep-sections" class="headerlink" title="sweep sections"></a>sweep sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eliminate duplicate sections.</span></span><br><span class="line"><span class="comment">// Symbols pointing to eliminated sections will be redirected on the fly when</span></span><br><span class="line"><span class="comment">// exporting to the symtab.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eliminated</span><span class="params">(<span class="string">&quot;icf_eliminated&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;<span class="built_in">is_killed_by_icf</span>()) &#123;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        eliminated++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> InputSection&lt;E&gt;::<span class="built_in">is_killed_by_icf</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;leader &amp;&amp; <span class="keyword">this</span>-&gt;leader != <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后消除掉重复的section。判断重复的依据是leader不等于自身。</p><h2 id="icf-sections-总结"><a href="#icf-sections-总结" class="headerlink" title="icf_sections 总结"></a>icf_sections 总结</h2><ol><li>CieRecord去重</li><li>merge leaf node</li><li>取出所有需要处理的section</li><li>计算digest</li><li>根据digest处理所有需要处理的section</li><li>消除重复的section</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-6-section</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>”荒原狼训练者的奇迹“</title>
    <link href="https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/"/>
    <id>https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/</id>
    <published>2023-05-04T09:27:54.000Z</published>
    <updated>2023-05-04T09:42:17.441Z</updated>
    
    <content type="html"><![CDATA[<p>当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒原狼双重人格的痛苦，而这一切碎片，又唤醒了我疯狂的那一面。</p><p>哈里的个性使得他成为了一个非市民般的存在，但为了生存，依然住在市民所在的城市，银行里有着一定的财产，这些都约束住了他。而在市民之中，他那强烈的个性使得他与这个社会格格不入，无法被理解，亦无法被接受。</p><p>他既超脱于人，却又受限于人，对于他来说内心中人和狼的关系似乎也是如此矛盾，与他的身份不同，人和狼必须要有一方战胜另一方并且存在，为此他的内心中几乎每天都在上演一场人狼大战。但这场战争不可能有他想要的结果，除非他选择自我了断，使得这场战争成立的条件本身不复存在。</p><p>但他过去却一直未能注意到，即便不这样做，这场战争仍可以不复存在，而且本身其实是无意义的。因为人和狼的战争并非是为了争夺什么领土，它们本来是在这里和平相处，但受到了作为主观意识的哈里影响，所以他们认为必须要战胜对方，统一这个世界。除此之外哈里还未注意到的一个真相是这里除了人和狼之外，这里还有非常多种类的存在。</p><p>直到另一个“自己”，赫尔米娜的出现，这一切才开始发生改变。身为另一个哈里，她十分理解哈里所想，同时哈里带入崭新的世界，将他所忽视的、遗漏的东西再度展现在他的面前，哈里也因此开始看到自己内心中更多的角色。</p><p>这一切最终都在魔剧院中由哈里亲眼见证。当哈里暂时杀死了荒原狼的存在，哈里内心中的其他存在不再受到其抑制，因此它们全部从镜子中跳了出来，而哈里跟着内心中的无数个“我“前往了它们各自所在的区域，看到这些被遗忘、忽略了的自己。直到最后，哈里如另一个“自己”所想，亲手处决了另一个“自己”，并且迎来了自我的绞刑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="黑塞" scheme="https://fusionbolt.github.io/tags/%E9%BB%91%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>局外人</title>
    <link href="https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/"/>
    <id>https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/</id>
    <published>2023-05-03T09:03:59.000Z</published>
    <updated>2023-05-03T09:09:16.591Z</updated>
    
    <content type="html"><![CDATA[<p>对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种态度来传达给我们什么呢？是想表达出他所认为的人生无意义吗？</p><p>在序言中讲到局外人的直接含义是默尔索在审判过程被隔离在外，整个审判过程自己参与了但是又没有参与。想到了故事中律师说到了这样一句话：“这就是这场审讯的形象，所有一切都是真的，但又没有任何东西是真的！”网上一个评价的重点则是提到是因为对母亲的死无动于衷被判了死刑，这点过于荒谬。</p><p>在第一部分中出现了许多的角色，都有一些非常看似矛盾的行为：沙拉玛诺老头每天都在骂狗，但实际丢了又是那么牵挂。雷蒙虽然说这跟人打架自己没去惹对方，是对方来冒犯自己，但他却供养着对方的老婆，作者这里还添加了一句“我没有答言。”</p><blockquote><p>他对我说，他一直供养着这个女人。我没有答言。接着他又说，他知道附近一带关于他的流言飞语，但他问心无愧，他确实是一个仓库保管员。</p></blockquote><p>这个样子甚至还能问心无愧，我觉得实属荒谬。还有第二部中最后出现的神父，他不顾主角的心情和想法，只是想要将自己的想法强加，这可以说是他自大，但是最让人感到惊讶与荒谬的是他居然也是囚犯，身为神父还做出犯罪之举。</p><p>我感觉到默尔索与现实世界的分离，联想到文章后面的内容并且结合加缪的思想来看，也许是因为他觉得现实世界是无理的且不可掌控的。</p><blockquote><p>他的神气不是那么确信有把握吗？但他的确信不值女人的一根头发，他甚至连自己是否活着都没有把握，因为他干脆就像行尸走肉。而我，我好像是两手空空，一无所有，但我对自己很有把握，对我所有的一切都有把握，比他有把握得多，对我的生命，对我即将来到的死亡，都有把握。是的，我只有这份把握，但至少我掌握了这个真理，正如这个真理抓住了我一样。我以前有理，现在有理，将来永远有理。</p></blockquote><p>后面他对即将到来的死亡是有把握的，这种分离在后面也有谈及</p><blockquote><p>正当我的律师在继续发言时，一个卖冰的小贩吹响了喇叭，声音从街上穿过一个个大厅与法庭，传到了我耳边，对过去生活的种种回忆突然涌入我的脑海，那生活已经不属于我了。</p></blockquote><p>回到书名与故事中。局外人这个名字所象征的事情，在故事中的主角身上充分表现了出来。主角在许多发生的事情上像局外人一样存在，而他在这个世界像一个局外人一样存在。两章的内容中，第一章中默尔索那漠不关心的态度，像是在说默尔索自己主动选择作为一切的局外人，而第二章中则是处于审判中，虽然参与其中，但是整个过程并没有任何说话与行动的权利。</p><blockquote><p>我呢，我认为这仍然是把我这个人排斥出审判过程，把我化成一个零，又以某种方式，由他取代了我。</p></blockquote><p>我想加缪正是想要通过这样一则有些不讲理的故事来表达出他对这个世界的看法，他所认为的荒谬，在序言中译者也提到了</p><blockquote><p>人类对理性、和谐、永恒的渴求与向往和自然社会生存有限性之间的“断裂”，人类的奋斗作为与徒劳无功这一后果之间的断裂。</p></blockquote><p>这样一则不讲理的故事，正是这种看法的体现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="加缪" scheme="https://fusionbolt.github.io/tags/%E5%8A%A0%E7%BC%AA/"/>
    
  </entry>
  
  <entry>
    <title>艾尔登法环</title>
    <link href="https://fusionbolt.github.io/2023/05/03/elden-ring/"/>
    <id>https://fusionbolt.github.io/2023/05/03/elden-ring/</id>
    <published>2023-05-03T09:01:53.000Z</published>
    <updated>2023-05-03T09:02:43.804Z</updated>
    
    <content type="html"><![CDATA[<p>二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。</p><p>首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能找到一个传送点，再加上玛丽卡楔石的帮助，几乎不需要花费太多的时间在打boss的路上。</p><p>招魂机制可以通过骨灰召唤角色出来吸引仇恨，你可以安心输出，当然魂系列其他作品也是有召唤npc的机制存在，但是都远不如这作骨灰的强大，后期召唤大哥甚至可以单挑许多boss，玩家被称为摇铃仆人。其次由于开放世界的设计，你可以绕过绝大多数boss，同时可以提前跑到中后期的地区捡垃圾，把自己的装备和等级提升一下再回来砍boss。</p><p>不过说到这里就要提到宫崎英高的恶意了，开局的大树守卫估计是很多人的阴影，可能很多人也没想到可以直接绕过，不过我想这里的设计是为了让玩家理解后面遇到的许多boss是可以直接跑的。另外有的玩家会选择直接到史东威尔去打恶兆，恶兆对于低级入门玩家还是不太友好，我觉得这里也有让你再去其他区域多探索的一个想法，只是这些设计都比较隐晦。</p><p>不熟悉的玩家个人开荒还是有些费劲的，我一开始也吃了很多瘪，后来“学习”了一下装备选择以及跑路捡强化石，以及去龙墓升级，也慢慢开始舒服多了。从数值方面降低了受苦的要素，之后作为一个探索类游戏真的非常棒，地图是真的大，而且景色非常棒。尤其是当你一开始走出了漆黑的新手洞窟后，当你通过升降梯到达了王城后，看到的那美丽的景色。</p><p>整体来说还是有许多有特色的boss。恶兆王给我的印象是比较深刻的，除了早期受苦的原因，另外独特的配音，在整个故事中其所在的位置，整个角色的塑造，以及经典的怒斥众臣等让这个角色深深的引入了我的脑海。</p><p>除了boss，许多精英怪也让大家印象深刻，比如说虾薪王，熊薪王，王室幽魂等，虽然受苦，但是也给网上的视频创作添加了许多素材，通过这种方式也给玩家们带来了很多欢乐，虽然这点或许并不在设计的初衷内。</p><p>这一作内容非常多，最首先感受到这一点的地方是地图。当我第一次打开地图，心想地图就这吗？但是随着后来我收集了一块又一块的地图碎片，整个地图也逐渐显现出了它原本的样子，这个过程中逐渐意识到原来一开始所能看到的部分只是整个交界地的冰山一角。</p><p>这一作的细节也非常非常多，游戏内容远超以往的魂系列，我一周目认真收集花了一百个小时才结束，但依然漏了许多东西。尽管不可避免的有一些偏向重复的要素，或者有一些玩家觉得很应付的要素，比如说一个后期的精英怪作为前中期区域的一些小boss，但是瑕不掩瑜。</p><p>泥头车的设计者你这样搞晚上睡得着觉吗？！</p><p>同时法环继承了魂系列一如既往的叙事，尽管拥有非常庞大的故事背景，但将故事隐藏在各种支线，以及各种道具的说明之中，给足了玩家们发掘、思考和想象的空间。</p><p>总体来说《艾尔登法环》是当之无愧的2022年度最佳游戏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。&lt;/p&gt;
&lt;p&gt;首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能</summary>
      
    
    
    
    <category term="Game" scheme="https://fusionbolt.github.io/categories/Game/"/>
    
    
    <category term="魂系列" scheme="https://fusionbolt.github.io/tags/%E9%AD%82%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>游植物园</title>
    <link href="https://fusionbolt.github.io/2023/05/02/Life/china-national-botanical-garden/"/>
    <id>https://fusionbolt.github.io/2023/05/02/Life/china-national-botanical-garden/</id>
    <published>2023-05-02T12:10:44.000Z</published>
    <updated>2023-05-02T12:18:04.069Z</updated>
    
    <content type="html"><![CDATA[<p>到了植物园，最先映入眼帘的不是什么植物，而是人山人海，且颇为吵闹，坏了兴致，不过这也是在预料之中的事情。</p><p>在观光车排队排了很久，在大概还要等两车人的时候前面问有没有独自前来的，正好有一个空位。便因此“合理插队”，提前坐上了观光车。上了观光车后感受到的炎热被迎面而来的微风一扫而光，一直沉浸于风所带来的清凉中，不知不觉车辆就到站了。下了车也不知道附近哪里有花，就开始一边看地图一边乱转了起来。偶尔也看到了一些花，或许是前些天未能承受住风雨的洗礼，都已是风中残烛。</p><p>此时正好已是正午，天气炎热加上并没有看到预期的百花绽放，便开始失去了继续游玩的兴趣。不过这里本身并不是花园而是植物园，只为花而来，也颇为奇怪。并不是为了欣赏什么植物，认识什么植物，而是单纯为了出来走走，或者是为了看花而来，从这样的角度来说或许对植物园是一种大不敬。</p><p>总之走的很累了，找到一处树荫下的凳子坐下。听着旁边风吹树叶窸窸窣窣的声音，想着多久没有听到过这样的声音了呢？每天都在办公室，在家里，听着电子音乐，听着人声，和大自然距离实在太远了。没多久又听到了聒噪的鸟叫声，听到这阵声音想到的不是美好的大自然，反而是今天早上五点醒来的时候被鸟叫吵到睡不着的痛苦。</p><p>恢复一些精力后继续逛了下去，走到了郁金香区，看到了成片的郁金香总算觉得不枉此行。由于这边花开的状态比较好，人还是比较多的，到了郁金香区的高台，到处都是拍照的人，等了很久才勉强有一个适合拍照的位置。由于今天的着装比较特别，机会难得因此想用相机自拍纪念下，虽然最后也成功拍到了，但是拍的过程中总是会有旁边在拍花的人上镜，加上没什么自拍经验，拍了非常多次才拍到还算能看的照片。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/china-national-botanical-garden/DSCF6892.JPG"                      alt="DSCF6892"                ></p><p>之后又沿路拍了一些还算好看的花，决定要走了，发现温室还没去，于是匆匆赶往那边。一进热带植物区和热带雨林区感受到的只有炎热，相比之下，中午在室外的炎热已经算不上什么了。顾不上耐心拍照，只有拍几张感兴趣的然后匆匆出去，最后全身已被汗水湿透。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/china-national-botanical-garden/DSCF6922.JPG"                      alt="DSCF6922"                ></p><p>最后出了植物园大门的时候，由于水喝的比较少，嘴里已经开始渗出了苦味。今天没有装东西的兜，手里拿着相机和手机，还夹着伞，实在不方便拿水喝，尽管一直比较渴，但就喝了带的一小瓶水。看西郊线人比较多，因此约了滴滴。在等滴滴的路上看到门口有一个人因为孩子差点被人贩子直接拉走，好像还控制住对方一会，同时在喊警察，但警察一直没来。我看到的时候他已经带着孩子去找周围警察了，很生气，责备警察无用，也能理解他的愤怒，另外又觉得这些人真的是胆大妄为。之后车来了，我已经比较疲惫，也无心做些什么，就只是任由风将我的头发吹飞，看着窗外的风景，看着一片片绿色的树林，不加以任何思考与判断，只是这样看着过去的事物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;到了植物园，最先映入眼帘的不是什么植物，而是人山人海，且颇为吵闹，坏了兴致，不过这也是在预料之中的事情。&lt;/p&gt;
&lt;p&gt;在观光车排队排了很久，在大概还要等两车人的时候前面问有没有独自前来的，正好有一个空位。便因此“合理插队”，提前坐上了观光车。上了观光车后感受到的炎热被迎面</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="植物园" scheme="https://fusionbolt.github.io/tags/%E6%A4%8D%E7%89%A9%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读五 符号相关</title>
    <link href="https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/"/>
    <id>https://fusionbolt.github.io/2023/04/29/mold/mold-5-symbol/</id>
    <published>2023-04-29T09:09:46.000Z</published>
    <updated>2023-05-07T16:16:43.191Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-5-symbol/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:73005507</center> <p>上期讲完了resolve_section_pieces，在这之后本应是combine_object，但是combine_object几乎包含了后面的所有过程，因此等到整个流程讲完后或许会再回来讲，这一期的内容以符号版本的处理为主。</p><h1 id="为common-symbol创建bss段"><a href="#为common-symbol创建bss段" class="headerlink" title="为common symbol创建bss段"></a>为common symbol创建bss段</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert_common_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;convert_common_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="common-symbol"><a href="#common-symbol" class="headerlink" title="common symbol"></a>common symbol</h2><p>首先解释一下common symbol。根据mold的注释所讲，common symbols被用于C的tentative definition，tentative definition是指C语言在一个头文件中允许全局变量定义省略extern。header会存在于多个翻译单元中，但这个符号不会导致duplicate symbol error，相反linker会将他们merge到一个单一的实例中。</p><p>还给出了一个例子，比如说一个头文件中有一个tentative definition是int foo，在一个C文件中包含了其包含初始值定义，比如说int foo = 5（real definition），那么这个tentative definition的符号会被resolve到real definition上。如果没有real definition，那么tentative definition会得到默认值。</p><p><a class="link"   href="https://stackoverflow.com/questions/3095861/about-tentative-definition" >About Tentative definition<i class="fas fa-external-link-alt"></i></a></p><p>参考这个stackoverflow的回答，C语言中纯变量声明会被处理为extern的，我想这就是允许省略extern的原因，编译器帮你做了这件事情，尽管这或许与你的预期不符。</p><p>简单总结来说就是头文件中一个全局的声明在不同编译单元有不同定义的时候需要进行resolve一个单一实现，声明的symbol其实是属于多个文件的，因此是common的。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">convert_common_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_common_symbol)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>has_common_symbol初始化的地方是在input-files.cc中的void ObjectFile<E>::initialize_symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize_symbols</span></span><br><span class="line"><span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际的处理是针对所有global的common符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;elf_syms[i].<span class="built_in">is_common</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym.file != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.warn_common)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: multiple common symbols: &quot;</span> &lt;&lt; sym;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>提示warning</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in for</span></span><br><span class="line">elf_sections2.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">ElfShdr&lt;E&gt; &amp;shdr = elf_sections2.<span class="built_in">back</span>();</span><br><span class="line"><span class="built_in">memset</span>(&amp;shdr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(shdr));</span><br><span class="line"></span><br><span class="line">std::string_view name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() == STT_TLS) &#123;</span><br><span class="line">  name = <span class="string">&quot;.tls_common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE | SHF_TLS;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  name = <span class="string">&quot;.common&quot;</span>;</span><br><span class="line">  shdr.sh_flags = SHF_ALLOC | SHF_WRITE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shdr.sh_type = SHT_NOBITS;</span><br><span class="line">shdr.sh_size = <span class="keyword">this</span>-&gt;elf_syms[i].st_size;</span><br><span class="line">shdr.sh_addralign = <span class="keyword">this</span>-&gt;elf_syms[i].st_value;</span><br></pre></td></tr></table></figure><p>关于SHF_TLS</p><blockquote><p>SHF_TLS: This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data. Implementations need not support this flag.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>对每个global common符号创建了一个ElfShdr后开始设置其基本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i64 idx = <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>() + elf_sections2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; isec =</span><br><span class="line">  std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, idx);</span><br><span class="line"></span><br><span class="line">sym.file = <span class="keyword">this</span>;</span><br><span class="line">sym.<span class="built_in">set_input_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">sym.value = <span class="number">0</span>;</span><br><span class="line">sym.sym_idx = i;</span><br><span class="line">sym.ver_idx = ctx.default_version;</span><br><span class="line">sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">sym.is_exported = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">sections.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(isec));</span><br><span class="line"><span class="comment">// for end</span></span><br></pre></td></tr></table></figure><p>创建了一个指向elf_sections的InputSecion，之后添加到sections中。</p><h1 id="apply-version-script"><a href="#apply-version-script" class="headerlink" title="apply_version_script"></a>apply_version_script</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br></pre></td></tr></table></figure><h2 id="simple"><a href="#simple" class="headerlink" title="simple"></a>simple</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_version_script</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_version_script&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If all patterns are simple (i.e. not containing any meta-</span></span><br><span class="line">  <span class="comment">// characters and is not a C++ name), we can simply look up</span></span><br><span class="line">  <span class="comment">// symbols.</span></span><br><span class="line">  <span class="keyword">auto</span> is_simple = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns)</span><br><span class="line">      <span class="keyword">if</span> (v.is_cpp || v.pattern.<span class="built_in">find_first_of</span>(<span class="string">&quot;*?[&quot;</span>) != v.pattern.npos)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先定义了is_simple。</p><p>simple的定义</p><ol><li>非cpp name。VersionPattern是根据链接器参数创建与添加的，is_cpp也同样是在那时指定的。</li><li>不包含meta字符的名字。根据代码中，meta字符即是*[?中的char</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">is_simple</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (VersionPattern &amp;v : ctx.version_patterns) &#123;</span><br><span class="line">      Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, v.pattern);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sym-&gt;file &amp;&amp; !ctx.arg.undefined_version)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; v.source &lt;&lt; <span class="string">&quot;: cannot assign version `&quot;</span> &lt;&lt; v.ver_str</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;` to symbol `&quot;</span> &lt;&lt; *sym &lt;&lt; <span class="string">&quot;`: symbol not found&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso)</span><br><span class="line">        sym-&gt;ver_idx = v.ver_idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果是simple的那么直接针对所有的version_pattern找到对应的符号，并且将其通过设置ver_idx的方式与VersionPattern进行关联</p><h2 id="otherwise"><a href="#otherwise" class="headerlink" title="otherwise"></a>otherwise</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Otherwise, use glob pattern matchers.</span></span><br><span class="line">MultiGlob matcher;</span><br><span class="line">MultiGlob cpp_matcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.version_patterns.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  VersionPattern &amp;v = ctx.version_patterns[i];</span><br><span class="line">  <span class="keyword">if</span> (v.is_cpp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!matcher.<span class="built_in">add</span>(v.pattern, i))</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;invalid version pattern: &quot;</span> &lt;&lt; v.pattern;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将cpp和其他复杂的符号区分开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name = sym-&gt;<span class="built_in">name</span>();</span><br><span class="line">    i64 match = INT64_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = matcher.<span class="built_in">find</span>(name))</span><br><span class="line">      match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Match non-mangled symbols against the C++ pattern as well.</span></span><br><span class="line">    <span class="comment">// Weird, but required to match other linkers&#x27; behavior.</span></span><br><span class="line">    <span class="keyword">if</span> (!cpp_matcher.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;std::string_view&gt; s = <span class="built_in">cpp_demangle</span>(name))</span><br><span class="line">        name = *s;</span><br><span class="line">      <span class="keyword">if</span> (std::optional&lt;u32&gt; idx = cpp_matcher.<span class="built_in">find</span>(name))</span><br><span class="line">        match = std::min&lt;i64&gt;(match, *idx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (match != INT64_MAX)</span><br><span class="line">      sym-&gt;ver_idx = ctx.version_patterns[match].ver_idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在所有obj文件中找到所有global symbol</p><p>如果普通matcher中能找到其名字，那么更新match的index</p><p>如果cpp matcher非空，那么对其进行demangle操作，之后在cpp matcher中寻找其名字并且更新match的index</p><p>最后将符号与对应VersionPattern进行关联。</p><p>而这里的demangle操作是直接调用对应平台的abi。starts_with(”_Z”)是代表这是一个mangling的名字。关于mangling的规则参考</p><p><a class="link"   href="https://github.com/gchatelet/gcc_cpp_mangling_documentation" >https://github.com/gchatelet/gcc_cpp_mangling_documentation<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::optional&lt;std::string_view&gt; <span class="title">cpp_demangle</span><span class="params">(std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">char</span> *buf;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">size_t</span> buflen;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(cwasser): Actually demangle Symbols on Windows using e.g.</span></span><br><span class="line">  <span class="comment">// `UnDecorateSymbolName` from Dbghelp, maybe even Itanium symbols?</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN32</span></span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;_Z&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">char</span> *p = abi::__cxa_demangle(std::<span class="built_in">string</span>(name).<span class="built_in">c_str</span>(), buf, &amp;buflen, &amp;status);</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="number">0</span>) &#123;</span><br><span class="line">      buf = p;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obj-only"><a href="#obj-only" class="headerlink" title="obj only"></a>obj only</h2><p>我在读到这里，很好奇为什么只针对的是obj而不考虑dso，看了下相关的命令行参数的介绍才明白过来</p><blockquote><p>-E, –export-dynamic Put symbols in the dynamic symbol table –no-export-dynamic</p></blockquote><h1 id="parse-symbol-version"><a href="#parse-symbol-version" class="headerlink" title="parse_symbol_version"></a>parse_symbol_version</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_symbol_version</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这是针对生成shared库的操作，因为只有动态链接才需要考虑加载符号版本的问题，符号版本是为了加载动态库的时候确保更新后符号的实现一致，如果和预想的实现不一致可能引起其他问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;std::string_view, u16&gt; verdefs;</span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.version_definitions.<span class="built_in">size</span>(); i++)</span><br><span class="line">  verdefs[ctx.arg.version_definitions[i]] = i + VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>实现中首先是将每一个version信息绑定到一个i + VER_NDX_LAST_RESERVED + 1的值（其中的version_definitions则是在read_version_script中读取的）。</p><p>接下来是针对了所有的global object进行操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>() - file-&gt;first_global; i++) &#123;</span><br><span class="line">      <span class="comment">// Match VERSION part of symbol foo@VERSION with version definitions.</span></span><br><span class="line">      <span class="comment">// The symbols&#x27; VERSION parts are in file-&gt;symvers.</span></span><br><span class="line">      <span class="keyword">if</span> (!file-&gt;symvers[i])</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      Symbol&lt;E&gt; *sym = file-&gt;symbols[i + file-&gt;first_global];</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view ver = file-&gt;symvers[i];</span><br><span class="line">...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>首先找到了对应文件的global符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> is_default = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>)) &#123;</span><br><span class="line">  is_default = <span class="literal">true</span>;</span><br><span class="line">  ver = ver.<span class="built_in">substr</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取符号的版本具体的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = verdefs.<span class="built_in">find</span>(ver);</span><br><span class="line"><span class="keyword">if</span> (it == verdefs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">  <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: symbol &quot;</span> &lt;&lt; *sym &lt;&lt;  <span class="string">&quot; has undefined version &quot;</span></span><br><span class="line">             &lt;&lt; ver;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据具体的值查找到上面保存的index</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sym-&gt;ver_idx = it-&gt;second;</span><br><span class="line"><span class="keyword">if</span> (!is_default)</span><br><span class="line">  sym-&gt;ver_idx |= VERSYM_HIDDEN;</span><br></pre></td></tr></table></figure><p>非default行为的版本，也就是非@开头的版本则ver_idx设置为HIDDEN。关于非default的情况，这种符号version则是在default_symver选项中添加的。</p><p>该选项对应的介绍以及代码实现处</p><blockquote><p>Use soname as a symbol version and append that version to all symbols.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.default_symver) &#123;</span><br><span class="line">    std::string ver = ctx.arg.soname.<span class="built_in">empty</span>() ?</span><br><span class="line">      <span class="built_in">filepath</span>(ctx.arg.output).<span class="built_in">filename</span>().<span class="built_in">string</span>() : std::<span class="built_in">string</span>(ctx.arg.soname);</span><br><span class="line">    ctx.arg.version_definitions.<span class="built_in">push_back</span>(ver);</span><br><span class="line">    ctx.default_version = VER_NDX_LAST_RESERVED + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If both symbol `foo` and `foo@VERSION` are defined, `foo@VERSION`</span></span><br><span class="line"><span class="comment">// hides `foo` so that all references to `foo` are resolved to a</span></span><br><span class="line"><span class="comment">// versioned symbol. Likewise, if `foo@VERSION` and `foo@@VERSION` are</span></span><br><span class="line"><span class="comment">// defined, the default one takes precedence.</span></span><br><span class="line">Symbol&lt;E&gt; *sym2 = <span class="built_in">get_symbol</span>(ctx, sym-&gt;<span class="built_in">name</span>());</span><br><span class="line"><span class="keyword">if</span> (sym2-&gt;file == file &amp;&amp; !file-&gt;symvers[sym2-&gt;sym_idx - file-&gt;first_global])</span><br><span class="line">  <span class="keyword">if</span> (sym2-&gt;ver_idx == ctx.default_version ||</span><br><span class="line">      (sym2-&gt;ver_idx &amp; ~VERSYM_HIDDEN) == (sym-&gt;ver_idx &amp; ~VERSYM_HIDDEN))</span><br><span class="line">    sym2-&gt;ver_idx = VER_NDX_LOCAL;</span><br></pre></td></tr></table></figure><p>最后是一个符号名同时存在带有version和没有version的两种定义，那么带有version信息的则会对外隐藏不带有特殊version信息的实现（设置为local）。通过当前sym的名字在ctx中查找同名符号，之后进行处理操作。</p><h1 id="compute-import-export"><a href="#compute-import-export" class="headerlink" title="compute_import_export"></a>compute_import_export</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_import_export</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_import_export&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we are creating an executable, we want to export symbols referenced</span></span><br><span class="line">  <span class="comment">// by DSOs unless they are explicitly marked as local by a version script.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.shared) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sym-&gt;file &amp;&amp; !sym-&gt;file-&gt;is_dso &amp;&amp; sym-&gt;visibility != STV_HIDDEN) &#123;</span><br><span class="line">          <span class="keyword">if</span> (sym-&gt;ver_idx != VER_NDX_LOCAL || !ctx.default_version_from_version_script) &#123;</span><br><span class="line">            std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">            sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在不生成shared库的情况下，针对所有的dso进行处理，在创建可执行文件的时候，导出被dso引用的且不被标记为local的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Export symbols that are not hidden or marked as local.</span></span><br><span class="line"><span class="comment">// We also want to mark imported symbols as such.</span></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;<span class="built_in">get_global_syms</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sym-&gt;file || sym-&gt;visibility == STV_HIDDEN ||</span><br><span class="line">        sym-&gt;ver_idx == VER_NDX_LOCAL)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file != file &amp;&amp; sym-&gt;file-&gt;is_dso &amp;&amp; !sym-&gt;<span class="built_in">is_absolute</span>()) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are creating a DSO, all global symbols are exported by default.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == file) &#123;</span><br><span class="line">      std::scoped_lock <span class="built_in">lock</span>(sym-&gt;mu);</span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym-&gt;visibility != STV_PROTECTED &amp;&amp;</span><br><span class="line">          !ctx.arg.Bsymbolic &amp;&amp;</span><br><span class="line">          !(ctx.arg.Bsymbolic_functions &amp;&amp; sym-&gt;<span class="built_in">get_type</span>() == STT_FUNC))</span><br><span class="line">        sym-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>objs中找到global符号，对于HIDDEN或者NDX_LOCAL的符号都跳过。</p><p>如果使用一个在dso中的符号，就需要运行时import它，因此需要设置对应符号为imported</p><p>如果创建dso，那么所有的global符号默认都要export。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>convert_common_symbols：给所有global的common符号创建一个对应的InputSection段</p><p>apply_version_script：将解析命令行参数产生的VersionPatten关联到对应的obj文件中的symbol</p><p>parse_symbol_version：读取symbol version信息，处理对应的ver_idx，以及针对不同版本符号的处理</p><p>compute_import_export：对所有符号计算对应的import和export信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-5-symbol/</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>斯通纳</title>
    <link href="https://fusionbolt.github.io/2023/04/18/Reading/Stoner/"/>
    <id>https://fusionbolt.github.io/2023/04/18/Reading/Stoner/</id>
    <published>2023-04-18T13:30:38.000Z</published>
    <updated>2023-04-18T13:32:08.928Z</updated>
    
    <content type="html"><![CDATA[<p>刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是找到故事中角色与自己的相似之处，又或是将自己代入到角色中。</p><p>文中讲述了斯通纳的一生，从大学开始，到爱情，事业，直至最后的死亡。他在大学结交了非常好的朋友，不论是精神上，还是实际行为上都对他有所支持。他经历了一见钟情的爱情，也顺势结了婚，但却毫无幸福可言，唯一的幸福也只有饱受非议的婚外情。他在事业上还算成功，兢兢业业工作直至退休。在这些过程中斯通纳的傲骨也是十分明显的，遇到问题不愿低头，一直保有自己的骄傲。我想大部分人读完这本书后，都会对斯通纳留下正直，不寻求权利，不愿低头，遇到什么事情都不愿让步的印象。面对舞弊的行为坚守原则，即便这导致了他频繁受到针对，甚至调离到了偏远的岗位。</p><p>他的人生充满坎坷，无法说是幸福的，但</p><blockquote><p>即使没有完美的一生，所幸追求过完整的自我</p></blockquote><p>不论他的一生经历了多少苦难，出现了多少问题，但他内心的自我，他的本性，他的灵魂仍未变质，这是让人十分欣慰的。</p><p>刚开始读的时候感觉略微不适应，后来发现是因为最初的部分没什么环境描写，对话相对较少，内容更倾向于流水账一样，和前段时间刚读完的《虞美人草》形成了非常明显的对比，这个问题读到后面觉得多少有些缓解。不过用这样篇幅的一本书讲述一个人的一生，同时想要保持细节是完全不可能的，也只能去掉许多描写性质的部分，同时只选取最典型的一些故事。另外不知是翻译问题还是原文就是这样写的，许多地方让我感觉比较粗糙。</p><p>读完整本书后最让我意外的感受是我开始害怕一切。看到斯通纳的经历，我觉得越阅读，越学习，反而越是害怕。害怕对人性的恶看的更透彻，害怕被人的恶所影响，害怕不平和的未来，害怕和一个不合适的人结婚，害怕自己也像书中的故事的痛苦的一面一般，害怕自己极度抑制的充满恶的本性泄漏出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;刚开始读到主人公斯通纳在大学时的境遇，那种无法融入，无法理解一些东西的感觉时，我感到非常触动，也许是因为我过去经常有这样的体会吧，这种情况下能感受到的只有无助。想到书腰中有这样一段话：第一眼故事，第二眼经典，第三眼生活，第四眼自己。或许我们都会在书中寻求与自己的关联，不论是</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="约翰·威廉斯" scheme="https://fusionbolt.github.io/tags/%E7%BA%A6%E7%BF%B0%C2%B7%E5%A8%81%E5%BB%89%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>莫失莫忘</title>
    <link href="https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/"/>
    <id>https://fusionbolt.github.io/2023/04/17/Reading/never-let-me-go/</id>
    <published>2023-04-17T13:23:03.000Z</published>
    <updated>2023-04-17T13:26:10.734Z</updated>
    
    <content type="html"><![CDATA[<p>这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。</p><p>从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱有疑问，是否和我所想的一样，后来证明了这一点。不知道原版的用词带给母语者的感受是怎么样的，如果会让人引起和我相同的想法那或许是作者有意为之。在后面揭露更多真相的时候，作者都是用了类似的做法，先透露出一点似乎不那么令人意外的线索，后来又从对话中传达真相并使读者感到震惊。至于为什么这么写，或许是提前进行漫长的铺垫，使得读者读到这里的时候有更强烈的感受。</p><p>回到书中的内容。凯西、汤米、露丝显然是整个故事中最核心的角色。凯西和汤米对一切进行了思考，而不是一直只有接受。</p><p>露丝则是很明显被用于对比的角色，她的态度更倾向于接受外部的一切，不论是汤米和凯西的看法还是当汤米实际与她讨论可能的真相时她都表现出了如此的特质。但同时露丝也是一个传达许多真相并且推进的角色，当一切都铺垫好以后，也就不再需要这样一个只是接受的角色一起参与探索背后的真相，自然的将故事舞台的主导权完全交给了汤米和凯西。汤米则是推动这一切进展的角色，思考一切背后的真相，去做各种尝试。而”我“，也就是凯西，更像是观察这一切，关联起这一切的角色。不论是和汤米接触，还是和露丝的关系，又或者是直到最后看着这一切。最后提到了“我”记忆中的黑尔舍姆，“我”从未寻找黑尔舍姆，却到处都能发现黑尔舍姆的点点滴滴，到不同的地方，看到不同的东西，找到黑尔舍姆也许是意味着回忆起了曾经的时光。后面还有这样一段话</p><blockquote><p>就像是我对汤米和露丝的回忆。一旦我能够过上比较平静的生活，不论他们把我送到哪间康复中心，黑尔舍姆都会始终跟我在一起，安全的保留在我脑海中，这是任何人都无法拿走的。</p></blockquote><p>在书中一开始的剧情中，艺廊或许是一个令人疑惑的存在，而对艺廊的疑问直到最终才被揭开。在提及艺廊的真相时，不论是汤米的推论还是实际的真相，都谈到了从作品中揭示出人的灵魂，或者说证明他们有灵魂。那么我想可以反过来，换一个非常极端的说法：人若无法创造出什么，那么无法证明这个人有灵魂。或许是缺少内在、无法产生自己的想法、没有自我、无法对外部质疑，不论怎么说都无法被称为人，而是一类什么。</p><p>说到做了，我想再提及之前凯西提出的质疑：“如果我们反正只是为了捐献，然后死去，那么上那些课是为什么？”答案并没有直说，但我想是让学生通过这样的课程，能够在活着的时间内形成自己独特的灵魂，尽管是部分受限的（因为接收到的信息是经过挑选的）。而这个问题，即便对普通人也是一样的，我来换个问法：如果我们生来只是为了活几十年，然后死去，那么做现在这些事情是为什么？这件事情一定没有什么标准答案。首先我认同的是人生无意义的观点，但我认为人灵魂的存在可以选择在离去之前选择填充自己的灵魂并留下些什么，也并非一定要有什么意义，我们不需要满世界去寻找什么意义，这种东西本就不存在于任何地方，也不应当一切用意义来蒙蔽自己的眼睛。</p><p>看到最后的真相我才明白为什么这本书被归结为科幻小说。对于科幻小说的定位我起初也有些费解，认为科幻小说就是各种未来世界、充满了不存在的科技等等，尤其是当我看到最终真相之前，绝大部分的内容完全没有看到科技的痕迹。这本书与我所想的科幻小说相差巨大，尤其是在我没读到最后的时候。但偶然有一天我听到一档播客节目，里面谈到各种各样科幻小说的形式，提及作者石黑一雄的小说相比于科幻更注重于人与人之间的关系，才明白科幻小说还可以这样来写。</p><p>在这些正文后还有译后记，在这部分内容提到一个从我完全没想到的角度提到的细思恐极的事情</p><blockquote><p>当艾米丽小姐坐着轮椅从阴影中出来的时候，读者不禁期望她会有更多的情感流露。她为之奋斗终生的黑尔舍姆事业已经告终，但这两个孩子是她事业的成果，他们的成就值得她自豪。然而她一心都放在要卖掉的柜子上，甚至基本的待客礼仪都欠奉，终究“我们”和“他们”的壁垒如此森严，毕竟她要从轮椅上站起来、恢复健康，多半还要指望从“他们”身上收获的器官。</p></blockquote><p>写到这里我联想到了一个很重要的细节，当真相大白的时候，夫人和艾米丽小姐也都提到其实她们是和外人一样对他们是抱有恐惧的，甚至艾米丽小姐还会对他们感到厌恶。此时艾米丽小姐说“可我下决心不让这种情绪阻止我去做正确的事。我跟这些情绪作战，并且战胜了。”这句话在当时读的时候我没觉得有什么，但现在回头看来，她所说的正确的事情到底是什么，到底是让他们成为人，还是让他们成为捐献者呢？另外此时我才意识到过去夫人对他们的害怕也是真的对他们这些人自身，而不是其他东西感到害怕。许多事情和夫人对他们的害怕一样，在前面只是未提及，有的很晚才给出解释，有的甚至并未直白的给出解释。但当我们无意中发现真相时，又会感受到骇人。这种处处埋藏线索与问题的写法，除了让我们感受强烈，我认为可以有另一种过度的解读，这或许是作者刻意这样做的，是为了让我们去思考问题，而不只是去接受这一切。</p><p>另外译者认为他们不质疑人生，不反抗生来的宿命，关于这一点我有一些想法。他们获得的信息都是经过精挑细选的，因此对他们来说根本没有质疑人生和反抗宿命的概念。对他们来说，能去思考背后的真相以及想要尝试延迟几乎可以说是能做到的极限了。如果是作为反乌托邦小说来讲，和我之前看过的美丽新世界和1984相同，这样的设定下人们都是会被各种方式所影响，几乎不会产生这样的概念，我目前看的不多，但就我看过的几本来说，反乌托邦总是离不开人们被“教育”成接受一切，无法反抗的状态，同时主线也是类似探寻真相与反抗的故事，不知其他同类书籍怀有怎样的观点和故事。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书从平淡的校园生活回忆开始，一点一点揭露出整个故事的真相。&lt;/p&gt;
&lt;p&gt;从我对于这本书的感觉开始。一开始我看这个故事是有些摸不着头脑的，作者的意图有些让我捉摸不透，我不明白作者想借此表达什么。但是当我读到真相，似乎开始明白了一些作者的用意。对于捐献一词我一开始也一直抱</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="石黑一雄" scheme="https://fusionbolt.github.io/tags/%E7%9F%B3%E9%BB%91%E4%B8%80%E9%9B%84/"/>
    
  </entry>
  
  <entry>
    <title>2023.4.10-4.16 下陷</title>
    <link href="https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/"/>
    <id>https://fusionbolt.github.io/2023/04/16/Life/2023-4-16/</id>
    <published>2023-04-16T14:46:37.000Z</published>
    <updated>2023-04-17T13:28:37.114Z</updated>
    
    <content type="html"><![CDATA[<p>和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存在于这里。</p><h1 id="本周的变化"><a href="#本周的变化" class="headerlink" title="本周的变化"></a>本周的变化</h1><p>这周我几乎看到了自己从动力十足的状态逐渐一步步变烂的整个过程，我觉得有必要来回顾一下这周发生了什么。</p><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><p>周一正常的工作，但是到点早早回到家开始修改自己的sideproj，难得的好状态，因此一直肝到了晚上十二点多，太上头甚至没怎么练琴。</p><p>周二正常的工作，大部分事情和周一相同，状态也是比较好。这天花了不少时间去练琴，练的是新的部分，还是比较吃力。</p><p>前两天都是打车上下班，大风加沙尘暴的恶劣天气加上早上起不来，仅有的一点运动都缺失了。</p><p>但周三开始就不对劲了，研究dwarf的时候迟迟没有什么所想的进展，渐渐开始紧张，烦躁，给自己加压，最后把自己逼迫到了出现负面想法的情况。之后出去走了一公里，情绪渐渐缓解了一点，但回来就开始感到疲惫，勉强看完书后身体就开始想要刷视频，刷完视频后练琴有些不在状态，很快就停下了。也没有精力去做sideproj，之后继续刷视频，最后晚睡。</p><p>周四也遇到了问题，开始觉得发懵，觉得意识与行动的联系变弱了，开始有一种恍惚感：不知道该做什么，不知道对错，无法深入理性思考，只能看到什么做什么，而且是不用脑子的那种。这一天也开始眼睛感到不适，除了休息不好以及最近可能用不干净的手频繁触摸眼睛周围外，高强度的用眼也是难逃其责。工作期间起身去厕所的时候也能明显感受到身体的疲劳。晚上迟迟搞不定工作上的问题，开始钻牛角尖，缺乏耐心，攻击自己，最后也是很晚回家，并且同样多走了一段路（都是为了一定程度的锻炼身体），但是这两天自我攻击比较严重，现在看来这个时候多走路反而是负担。到了家优先趴在了床上，勉强看了一点书，之后也没怎么练琴。</p><p>周五更是严重，前一天晚上睡眠平均心率增加到了79，早上到公司的时候开始有些轻微头晕，易怒。下午一直没有搞出周四没解决的问题，越来越钻牛角尖，感到更多压力，紧张，开始觉得任务会无法完成。其实这个时候已经几乎无法正常思考问题的解决方案了，但仍然只是在那里堆时间，胡乱操作。</p><h2 id="时间记录"><a href="#时间记录" class="headerlink" title="时间记录"></a>时间记录</h2><p>首先是写代码的时间，周一到周四线性的减少了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.png"                      alt="Untitled"                ></p><p>练琴开启节拍器的时间。但有两个部分没有记录，一个是识谱，另一个是在使用另一个app的时间没有记录，但是这两部分在周三和周四也都是没在用的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled.jpeg"                      alt="Untitled"                ></p><p>睡眠心率平均值，最近的常规值是70出头，周四的晚上到了最高值79，不过这个的影响因素很多，很难直接断定。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.png"                      alt="Untitled"                ></p><p>另外则是睡眠的时间，这个难以准确记录。</p><p>根据其他信息记录，上床时间分别为</p><ol><li>1:26</li><li>1:00</li><li>1:30</li><li>1:40</li><li>1:40</li></ol><p>屏幕使用时间难以准确记录，但是周三开始回家就想看动画，刷视频，也刷了蛮久</p><h2 id="我出了什么问题？"><a href="#我出了什么问题？" class="headerlink" title="我出了什么问题？"></a>我出了什么问题？</h2><p>自大与碰壁。周一周二sideproj良好的进度让我觉得dwarf那边也能随便解决，但实际上我想要的资料几乎没有，开始觉得自己不行。</p><p>发现自己在钻牛角尖没能及时停下来。不论是dwarf的问题还是工作上的问题，我都多少有点意识到自己进入了死胡同，但是都没能及时停下，而是加速朝着墙冲过去。过度集中使得我反而迷失了方向。这是我一直以来的坏毛病。</p><p>没有根据自己身体的疲劳调整。这几天多次行动使得自己开始累积压力，积压疲劳，而此时我并没有停下，而是尽可能的再去做些什么。我就像一个机器人一样，只是给自己安排任务，不到难以控制的情况是不会停下来的。</p><h1 id="心理咨询的结束"><a href="#心理咨询的结束" class="headerlink" title="心理咨询的结束"></a>心理咨询的结束</h1><p>大概是最后一次心理咨询，谈了一下近况，聊了一些问题。</p><p>首先是最近的情况怎么样？我提到之前被人问及的最焦虑的事情，我一时之间不知道怎么回答，后来回答的是不安，工作的焦虑，但其实自己一方面觉得焦虑一方面又觉得无所谓，最近这种无所谓的态度特别强烈。而我不论是否那么关心这个问题，不论怎么折腾，现实也就这个样，没什么变化。</p><p>那你是觉得不论怎么样生活都是一样的，就因此不折腾了吗？并不是该折腾折腾，能折腾到什么样就是什么样。</p><p>又从我之前说过遇到问题时可能有人一起会更好开始，问我如果和别人在一起呢？而我前两天则开始觉得，似乎跟朋友在一起也是一样，女朋友又不可能有。后来讲下去谈到了找女朋友的问题，这部分还讲了半天。</p><p>之后问到我要解决的现实问题怎么办？我的答复是只能每个方面磨下去，自己没办法像钻头一样，逐个击破，所以需要自己在更漫长时间的努力，将每个方面一点点磨下去。有点像是无奈之举，除此之外只有等待什么机会，或者什么事件。</p><p>说到自我贬低的部分，我说自己不接受赞美只接受批评，因为我认为别人的赞美是因为看到了我的一些表象。</p><p>咨询师说别人看到的都是不对的吗？我的回答是有许多错觉的部分，当然也有正确的部分。</p><p>又问我那你能不能相信一下别人说的夸奖的内容？我说不信，本质上是我没有认同自己，主要是我发自内心不觉得自己是多么好的人。尽管有一点点好的部分，但自己有着数不尽的问题。自己做的好的那么一点点也都是“应该”，做的不好的地方就是自己的问题。</p><p>后来说到自己脑中一闪而过的“给别人挑刺，贬低别人”的想法，自己也正如这样对待自己。“如果自己变厉害了就不会这样不认同自己了”，如果一直怀有这样的想法，即便站上顶点也依然不会放过自己。因为即便在顶点，也可以站的更高，这也有一部分是因为人上进的本性，不接受自己，批评自己的想法也是有促进自己前进的正面意义，只是这样的自己像是严酷的监工（-1hp +2atk）。</p><p>又说到自己最近一周，由于不放过自己，持续逼迫自己，使得自己的情况十分清晰可见的越来越不好。我觉得自己要做的还是应该多放过自己一些，感受自己的想法，避免进入泥潭，而未掉入泥潭的我相比于掉入的我还是会多不少处理能力。</p><p>最后要结束的时候咨询师说我实际上很强大，希望我能记得。不过我对此其实还是没有什么实感，没有什么想法，还是会继续当监工，只是监督力度可能会开始有意识的减弱，否则我会继续倒下去。我的心理咨询大概到这里就彻底结束了。</p><h1 id="本周其他想法的一些记录"><a href="#本周其他想法的一些记录" class="headerlink" title="本周其他想法的一些记录"></a>本周其他想法的一些记录</h1><h2 id="4-12"><a href="#4-12" class="headerlink" title="4.12"></a>4.12</h2><p>dwarf没有什么我想要的例子，看了半天连个开头都没搞明白，瞬间变得特别沮丧了…又开始意识到自己是个废物，准备出门走走，起身来才意识到刚才自己看的时候压力多大，明显感到十分疲惫，呼吸短浅，渐渐察觉自己又到了这种极其负面的状态，意识到自己又在和以往一样遇到点解不出的难题就开始烦，给身体不断施加压力，同时想到自己只是想根据潜意识解决，或者找一个现有的东西抄，而没想过怎么用现有知识去进一步思考…</p><h2 id="4-13"><a href="#4-13" class="headerlink" title="4.13"></a>4.13</h2><p>感觉到自己的精力太少远远不够用的…前两天有些拼，这两天已经明显开始觉得身体在抗议，疲惫，想要享乐这个想法变得更强烈，更难抵抗，最近每日有效工作加学习时间逐日渐少…</p><p>今天我又感觉到那种因为疲劳而感到抽离于现实的感觉。这种时候能做的就是看到什么能做的去做什么，而没有办法去思考自己该怎么做，自己该做什么，如果工作996的话简直不敢想会变成什么样子</p><p>不仅是精力不足以及身体疲劳，昨天遇到搞不懂的东西后自己对自己的心理压迫也是一个很大的影响因素…</p><h2 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/2023-4-16/Untitled%201.jpeg"                      alt="Untitled"                ></p><p>这样说了，心里在欺骗自己说自己本来就是个废物，爱咋咋地，就这样摆烂吧。转去练琴的时候想到了自己练琴也都很慢，就潜意识中加快了速度，选择了我跟不上的节拍练习…</p><p>想起白天好几个同事来问我问题，我当时其实有点虚荣，觉得大家都来问我，这样好啊，但又知道自己也就那一点点东西。但是没办法，这件事情上并不是为了荣誉什么的，反而是觉得被人需要了很开心…虽然如此，但还是像我上面说的有虚荣心在，自己没有什么过硬的水准，只好从这种方面和角度给自己找信心，这样说出来也蛮丢人的</p><p>觉得比别人好的自己，觉得比别人差的自己，自傲的自己，自卑的自己，无一例外都是自己，真的是分裂</p><p>感觉负面想法开始冒出来了，这是我没有好好照顾自己，没有重视自己感受到一个结果吧。不知道这几天里疲劳和负面情绪是谁先动的手，反正现在是两败俱伤，我也一直没有太关注平常的身体状态。对我来说不论状态好还是不好，要做的事情都是一样的，只是说做多做少，逼不逼自己的区别罢了，只想无止境的压榨着远不如常人的精力</p><h2 id="4-15"><a href="#4-15" class="headerlink" title="4.15"></a>4.15</h2><p>看到别人在参与复杂的项目，讨论相关技术，想到自己只是一直在做自己的玩具项目，而且进度非常非常慢，觉得自己大概只有做这点玩具的份了，技术和其他条件都不行，以后能不能在编译器的岗位都很成问题…</p><p>担心失业，担心做什么都只能在入门处徘徊。虽然失业也不是就没路了，但我终归想在这条路走下去，也想做的更深入更好<br>想起两年前全程找工作的那个月，觉得以我的条件根本就找不到，也不可能找得上做编译器的工作，现在也这样觉得，只是之前运气好一点做了ai编译器，但霉运的我不可能以后都去依靠运气…</p><p>做玩具也挺开心的，能实现些什么东西我觉得很棒，不然我也不会花时间去做<br>只是当这件事情与生活的压力产生了交集，与我停滞不前的水平产生了交集，加上我的扭曲思考方式，最后这件事情产生了完全不一样的性质…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和每个周一样，这周一如既往的168个小时，但不一样的是这周我十分清晰的见证了自己一周内的身心变化，并且大概也是我最后一次心理咨询，另外这周也发了不少想法，因此我想要将这些记录下来。正像我一个朋友说的，将一些想法记录下来，以便未来再回来看，不论未来和现在是怎样的，过去就这样存</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其四 mergeable section</title>
    <link href="https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/"/>
    <id>https://fusionbolt.github.io/2023/04/16/mold/mold-4-mergeable-section/</id>
    <published>2023-04-16T07:37:08.000Z</published>
    <updated>2023-04-16T07:39:34.874Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-4-mergeable-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:83834646</center> <p>上一期的内容讲完了一些针对文件的简单处理以及符号决议，这一期的主要内容是在这之后针对mergeable section的决议与合并。</p><h1 id="resolve-section-pieces"><a href="#resolve-section-pieces" class="headerlink" title="resolve_section_pieces"></a>resolve_section_pieces</h1><p>这个过程是将mergeable的section split到更小的pieces中，并且将每一个piece和其他来自不同文件的pieces进行合并，最典型的例子是不同object file中string段的合并。mold中称mergeable section原子单元为section pieces。</p><p>所以这里的过程分为了两部分</p><ol><li>将普通的section转换为MegeableSection</li><li>resolve and merge</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_section_pieces</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_section_pieces&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">initialize_mergeable_sections</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_section_pieces</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="initialize-mergeable-sections"><a href="#initialize-mergeable-sections" class="headerlink" title="initialize_mergeable_sections"></a>initialize_mergeable_sections</h1><p>mold中attach section pieces symbols</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_mergeable_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  mergeable_sections.<span class="built_in">resize</span>(sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; m = <span class="built_in">split_section</span>(ctx, *isec)) &#123;</span><br><span class="line">        mergeable_sections[i] = std::<span class="built_in">move</span>(m);</span><br><span class="line">        isec-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每一个section进行split_section，转换为一个MergeableSection，之后将原始的section设置为非alive。</p><h2 id="MergeableSection"><a href="#MergeableSection" class="headerlink" title="MergeableSection"></a>MergeableSection</h2><p>首先我们来看和MergeableSection相关的数据结构，有如下三个</p><ol><li>MergeableSection</li><li>MergedSection</li><li>SectionFragment</li></ol><p>其中每个MergeableSection中包含了多个SectionFragment，又关联了其对应的MergedSection。MergedSection是一个chunk，而chunk则是在链接后期要输出到文件的时候的一个基本单位，暂时先不进一步讲解。SectionFragment则是MergedSection根据MergeableSection传入的信息构造的，并且返回给MergeableSection保存的结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MergeableSection</span> &#123;</span></span><br><span class="line">  std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt; <span class="built_in">get_fragment</span>(i64 offset);</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; *parent;</span><br><span class="line">  u8 p2align = <span class="number">0</span>;</span><br><span class="line">  std::vector&lt;std::string_view&gt; strings;</span><br><span class="line">  std::vector&lt;u64&gt; hashes;</span><br><span class="line">  std::vector&lt;u32&gt; frag_offsets;</span><br><span class="line">  std::vector&lt;SectionFragment&lt;E&gt; *&gt; fragments;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MergedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> MergedSection&lt;E&gt; *</span></span><br><span class="line"><span class="function">  <span class="title">get_instance</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view name, u64 type, u64 flags)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">SectionFragment&lt;E&gt; *<span class="title">insert</span><span class="params">(std::string_view data, u64 hash, i64 p2align)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assign_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_to</span><span class="params">(Context&lt;E&gt; &amp;ctx, u8 *buf)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print_stats</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  HyperLogLog estimator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">MergedSection</span>(std::string_view name, u64 flags, u32 type);</span><br><span class="line"></span><br><span class="line">  ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br><span class="line">  std::vector&lt;i64&gt; shard_offsets;</span><br><span class="line">  std::once_flag once_flag;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionFragment</span> &#123;</span></span><br><span class="line">  <span class="built_in">SectionFragment</span>(MergedSection&lt;E&gt; *sec) : <span class="built_in">output_section</span>(*sec) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SectionFragment</span>(<span class="keyword">const</span> SectionFragment &amp;other)</span><br><span class="line">    : <span class="built_in">output_section</span>(other.output_section), <span class="built_in">offset</span>(other.offset),</span><br><span class="line">      <span class="built_in">p2align</span>(other.p2align.<span class="built_in">load</span>()), <span class="built_in">is_alive</span>(other.is_alive.<span class="built_in">load</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">u64 <span class="title">get_addr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  MergedSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  u32 offset = <span class="number">-1</span>;</span><br><span class="line">  std::<span class="keyword">atomic_uint8_t</span> p2align = <span class="number">0</span>;</span><br><span class="line">  std::<span class="keyword">atomic_bool</span> is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>MergedSection并不暴露对应的构造函数，而是通过对应的get_instance来获取实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(Context&lt;E&gt; &amp;ctx, std::string_view name,</span><br><span class="line">                               u64 type, u64 flags) &#123;</span><br><span class="line">  name = <span class="built_in">get_merged_output_name</span>(ctx, name, flags);</span><br><span class="line">  flags = flags &amp; ~(u64)SHF_GROUP &amp; ~(u64)SHF_COMPRESSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;]() -&gt; MergedSection * &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;osec : ctx.merged_sections)</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">tuple</span>(name, flags, type) ==</span><br><span class="line">          std::<span class="built_in">tuple</span>(osec-&gt;name, osec-&gt;shdr.sh_flags, osec-&gt;shdr.sh_type))</span><br><span class="line">        <span class="keyword">return</span> osec.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search for an exiting output section.</span></span><br><span class="line">  <span class="keyword">static</span> std::shared_mutex mu;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">      <span class="keyword">return</span> osec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new output section.</span></span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (MergedSection *osec = <span class="built_in">find</span>())</span><br><span class="line">    <span class="keyword">return</span> osec;</span><br><span class="line"></span><br><span class="line">  MergedSection *osec = <span class="keyword">new</span> <span class="built_in">MergedSection</span>(name, flags, type);</span><br><span class="line">  ctx.merged_sections.<span class="built_in">emplace_back</span>(osec);</span><br><span class="line">  <span class="keyword">return</span> osec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次获取的时候去ctx中寻找实例，不存在则创建新的并且返回。</p><h2 id="split-section"><a href="#split-section" class="headerlink" title="split_section"></a>split_section</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt;</span><br><span class="line"><span class="built_in">split_section</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;sec) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!sec.is_alive || sec.sh_size == <span class="number">0</span> || sec.relsec_idx != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = sec.<span class="built_in">shdr</span>();</span><br><span class="line">  <span class="keyword">if</span> (!(shdr.sh_flags &amp; SHF_MERGE))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>由于是针对mergeable section，而判断标准则是根据section header中的sh_flgas的值，因此先通过检查flga来进行过滤。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; <span class="built_in">rec</span>(<span class="keyword">new</span> MergeableSection&lt;E&gt;);</span><br><span class="line">rec-&gt;parent = MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(ctx, sec.<span class="built_in">name</span>(), shdr.sh_type,</span><br><span class="line">                                             shdr.sh_flags);</span><br><span class="line">rec-&gt;p2align = sec.p2align;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If thes section contents are compressed, uncompress them.</span></span><br><span class="line">sec.<span class="built_in">uncompress</span>(ctx);</span><br><span class="line"></span><br><span class="line">std::string_view data = sec.contents;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *begin = data.<span class="built_in">data</span>();</span><br><span class="line">u64 entsize = shdr.sh_entsize;</span><br><span class="line">HyperLogLog estimator;</span><br></pre></td></tr></table></figure><p>做一些基本的初始化操作，包括创建了MergeableSection以及关联对应的MergedSection，取出数据等。</p><h3 id="split-string"><a href="#split-string" class="headerlink" title="split string"></a>split string</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Split sections</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_flags &amp; SHF_STRINGS) &#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// GHC (Glasgow Haskell Compiler) sometimes creates a mergeable</span></span><br><span class="line">    <span class="comment">// string section with entsize of 0 instead of 1, though such</span></span><br><span class="line">    <span class="comment">// entsize is technically wrong. This is a workaround for the issue.</span></span><br><span class="line">    entsize = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> end = <span class="built_in">find_null</span>(data, entsize);</span><br><span class="line">    <span class="keyword">if</span> (end == data.npos)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: string is not null terminated&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, end + entsize);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(end + entsize);</span><br><span class="line"></span><br><span class="line">    rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">    rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">    u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">    rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">    estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">find_null</span><span class="params">(std::string_view data, u64 entsize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (entsize == <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">find</span>(<span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt;= data.<span class="built_in">size</span>() - entsize; i += entsize)</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">substr</span>(i, entsize).<span class="built_in">find_first_not_of</span>(<span class="string">&#x27;\0&#x27;</span>) == data.npos)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> data.npos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到terminator（’\0’）</li><li>将对应的rec的strings添加找到的str</li><li>添加对应的frag_offsets</li><li>添加string的hash到estimator中</li></ol><p>estimator是用于优化时间的方案，等到最后会提及，不影响合并的正确性。</p><h3 id="split-other"><a href="#split-other" class="headerlink" title="split other"></a>split other</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// OCaml compiler seems to create a mergeable non-string section with</span></span><br><span class="line">    <span class="comment">// entisze of 0. Such section is malformed. We do not split such section.</span></span><br><span class="line">    <span class="keyword">if</span> (entsize == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % entsize)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; sec &lt;&lt; <span class="string">&quot;: section size is not multiple of sh_entsize&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!data.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      std::string_view substr = data.<span class="built_in">substr</span>(<span class="number">0</span>, entsize);</span><br><span class="line">      data = data.<span class="built_in">substr</span>(entsize);</span><br><span class="line"></span><br><span class="line">      rec-&gt;strings.<span class="built_in">push_back</span>(substr);</span><br><span class="line">      rec-&gt;frag_offsets.<span class="built_in">push_back</span>(substr.<span class="built_in">data</span>() - begin);</span><br><span class="line"></span><br><span class="line">      u64 hash = <span class="built_in">hash_string</span>(substr);</span><br><span class="line">      rec-&gt;hashes.<span class="built_in">push_back</span>(hash);</span><br><span class="line">      estimator.<span class="built_in">insert</span>(hash);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>和split string的区别在于不是通过’\0’而是通过entsize判断一个piece的结束位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rec-&gt;parent-&gt;estimator.<span class="built_in">merge</span>(estimator);</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;string_fragments&quot;</span>)</span></span>;</span><br><span class="line">counter += rec-&gt;fragments.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">return</span> rec;</span><br></pre></td></tr></table></figure><p>最后的收尾</p><h1 id="ObjectFile-resolve-section-pieces"><a href="#ObjectFile-resolve-section-pieces" class="headerlink" title="ObjectFile::resolve_section_pieces"></a>ObjectFile::resolve_section_pieces</h1><ul><li><input disabled="" type="checkbox"> 如何判断是相同的字符串？？对应地址怎么办</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_section_pieces</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : mergeable_sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      m-&gt;fragments.<span class="built_in">reserve</span>(m-&gt;strings.<span class="built_in">size</span>());</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; m-&gt;strings.<span class="built_in">size</span>(); i++)</span><br><span class="line">        m-&gt;fragments.<span class="built_in">push_back</span>(m-&gt;parent-&gt;<span class="built_in">insert</span>(m-&gt;strings[i], m-&gt;hashes[i],</span><br><span class="line">                                                 m-&gt;p2align));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Shrink vectors that we will never use again to reclaim memory.</span></span><br><span class="line">      m-&gt;strings.<span class="built_in">clear</span>();</span><br><span class="line">      m-&gt;hashes.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>将所有MergableSection的数据merge到对应的parent中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_abs</span>() || esym.<span class="built_in">is_common</span>() || esym.<span class="built_in">is_undef</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">  <span class="keyword">if</span> (!m)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  i64 frag_offset;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!frag)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad symbol value: &quot;</span> &lt;&lt; esym.st_value;</span><br><span class="line"></span><br><span class="line">  sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">  sym.value = frag_offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后是attach section piece to symbols的过程。本质的操作是将对应的有定义的且非abs的符号关联到对应的fragment。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the size of frag_syms.</span></span><br><span class="line">  i64 nfrag_syms = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections)</span><br><span class="line">    <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx))</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">            esym.st_type == STT_SECTION &amp;&amp; mergeable_sections[<span class="built_in">get_shndx</span>(esym)])</span><br><span class="line">          nfrag_syms++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">resize</span>(nfrag_syms);</span><br></pre></td></tr></table></figure><p>之后寻找满足条件的esym，统计对应的size。</p><p>注意寻找的是ElfRel中的esym，只有ElfRel中的esym才能被relocation，因为merge的过程中必然会修改各种地址信息。</p><p>这里根据sym得到的index获取对应的mergeable_section是在前一步init的过程中初始化的，也就是说这个index对于mergeable_section和原始的section是完全对应的，如果不是mergeable的section则返回的会是空指针。</p><p>接下来是引用mergeable section的relocation symbol，会针对每一个这样的symbol redirect rel sym到一个新创建的dummy到symbol上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For each relocation referring a mergeable section symbol, we create</span></span><br><span class="line"><span class="comment">// a new dummy non-section symbol and redirect the relocation to the</span></span><br><span class="line"><span class="comment">// newly-created symbol.</span></span><br><span class="line">i64 idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[r.r_sym];</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type != STT_SECTION)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m = mergeable_sections[<span class="built_in">get_shndx</span>(esym)];</span><br><span class="line">    <span class="keyword">if</span> (!m)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    i64 r_addend = <span class="built_in">get_addend</span>(*isec, r);</span><br><span class="line"></span><br><span class="line">    SectionFragment&lt;E&gt; *frag;</span><br><span class="line">    i64 in_frag_offset;</span><br><span class="line">    std::<span class="built_in">tie</span>(frag, in_frag_offset) = m-&gt;<span class="built_in">get_fragment</span>(esym.st_value + r_addend);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!frag)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: bad relocation at &quot;</span> &lt;&lt; r.r_sym;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;frag_syms[idx];</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.<span class="built_in">set_name</span>(<span class="string">&quot;&lt;fragment&gt;&quot;</span>);</span><br><span class="line">    sym.sym_idx = r.r_sym;</span><br><span class="line">    sym.visibility = STV_HIDDEN;</span><br><span class="line">    sym.<span class="built_in">set_frag</span>(frag);</span><br><span class="line">    sym.value = in_frag_offset - r_addend;</span><br><span class="line">    r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line">    idx++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> i64 <span class="title">get_addend</span><span class="params">(u8 *loc, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> rel.r_addend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::pair&lt;SectionFragment&lt;E&gt; *, i64&gt;</span><br><span class="line">MergeableSection&lt;E&gt;::<span class="built_in">get_fragment</span>(i64 offset) &#123;</span><br><span class="line">  std::vector&lt;u32&gt; &amp;vec = frag_offsets;</span><br><span class="line">  <span class="keyword">auto</span> it = std::<span class="built_in">upper_bound</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), offset);</span><br><span class="line">  i64 idx = it - <span class="number">1</span> - vec.<span class="built_in">begin</span>();</span><br><span class="line">  <span class="keyword">return</span> &#123;fragments[idx], offset - vec[idx]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的对新的sym设置了基本信息，主要是进行双向的关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sym.sym_idx = r.r_sym;</span><br><span class="line">r.r_sym = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() + idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbol:sym_idx</span></span><br><span class="line"><span class="comment">// Index into the symbol table of the owner file.</span></span><br><span class="line">i32 sym_idx = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>这里将rel中的sym指向了elf_syms后面的位置，后面会将执行frag_syms逐一添加到elf_syms之后。</p><p>最后将frag_syms都添加到ObjectFile的symbols中，整个过程就全部结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(idx == <span class="keyword">this</span>-&gt;frag_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Symbol&lt;E&gt; &amp;sym : <span class="keyword">this</span>-&gt;frag_syms)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(&amp;sym);</span><br></pre></td></tr></table></figure><h2 id="MergedSection-insert"><a href="#MergedSection-insert" class="headerlink" title="MergedSection::insert"></a>MergedSection::insert</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SectionFragment&lt;E&gt; *</span><br><span class="line">MergedSection&lt;E&gt;::<span class="built_in">insert</span>(std::string_view data, u64 hash, i64 p2align) &#123;</span><br><span class="line">  std::<span class="built_in">call_once</span>(once_flag, [&amp;] &#123;</span><br><span class="line">    <span class="comment">// We aim 2/3 occupation ratio</span></span><br><span class="line">    map.<span class="built_in">resize</span>(estimator.<span class="built_in">get_cardinality</span>() * <span class="number">3</span> / <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  SectionFragment&lt;E&gt; *frag;</span><br><span class="line">  <span class="keyword">bool</span> inserted;</span><br><span class="line">  std::<span class="built_in">tie</span>(frag, inserted) = map.<span class="built_in">insert</span>(data, hash, <span class="built_in">SectionFragment</span>(<span class="keyword">this</span>));</span><br><span class="line">  <span class="built_in">assert</span>(frag);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_maximum</span>(frag-&gt;p2align, p2align);</span><br><span class="line">  <span class="keyword">return</span> frag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ConcurrentMap&lt;SectionFragment&lt;E&gt;&gt; map;</span><br></pre></td></tr></table></figure><p>第一次insert的时候进行预估大小，之后进行insert。</p><p>在看到这里的实现我在想，在merge string的时候是要比较长度吗，在这里我得到了答案，是直接通过之前保存的hash保证unique。</p><p>另外这里用到了estimator，estimator的类型是hyperloglog，根据注释</p><blockquote><p>This file implements HyperLogLog algorithm, which estimates the number of unique items in a given multiset.</p></blockquote><p>谷歌的结果是这样的</p><blockquote><p>HyperLogLog is <strong>an algorithm for the count-distinct problem, approximating the number of distinct elements in a multiset</strong><br>. Calculating the exact cardinality of the distinct elements of a multiset requires an amount of memory proportional to the cardinality, which is impractical for very large data sets.</p></blockquote><p>有兴趣的可以去看wiki或者更多资料，这不在此系列博客的研究范围内。</p><h1 id="整个过程的回顾"><a href="#整个过程的回顾" class="headerlink" title="整个过程的回顾"></a>整个过程的回顾</h1><p>resolve_section_pieces由两部分操作组成</p><ol><li>针对所有mergeable的段进行split，将InputSection转换为对应的MergeableSection</li><li>针对所有MergeableSection进行merge<ol><li>strings Merge到相关联的MergedSection中</li><li>symbols attach to piece section</li><li>针对rel的symbol关联到一个新创建的dummy的symbol上</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-4-mergeab</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="Section" scheme="https://fusionbolt.github.io/tags/Section/"/>
    
  </entry>
  
  <entry>
    <title>1984</title>
    <link href="https://fusionbolt.github.io/2023/04/09/Reading/1984/"/>
    <id>https://fusionbolt.github.io/2023/04/09/Reading/1984/</id>
    <published>2023-04-09T09:16:34.000Z</published>
    <updated>2023-04-09T09:20:55.444Z</updated>
    
    <content type="html"><![CDATA[<p>未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。</p><blockquote><p>是老派改革家想象中那种愚蠢快乐主义乌托邦的精确对立面。一个恐惧、背叛与折磨的世界，一个践踏与被践踏的世界，一个在变得更精致的同时会变得更加残酷，而非更不残酷的世界。我们这个世界里的进步，会是朝向带来更多痛苦的进步。</p></blockquote><p>而人们所在的世界，其实更仅一步来说是由所在的社会构成，社会的构成又很大程度归结于所在国家的权力机构。我一直在想人们对于“关注政治和社会问题”这个问题本身应该怀有怎样的态度，至少我一直是不太关心，也不想去关心。但读完了这本书似乎让我对这个问题的想法产生了一些变化。起源于温斯顿和茱莉亚的交流过程，茱莉亚是一个学会在这种环境下生存的人，也会认为这个环境很蠢，但是不愿去谈论这些。当温斯顿和她讲述关于一些党的内容却是毫不关心。</p><blockquote><p>对于党内教条的种种分支，她连一点兴趣都没有。每次他开始讲到英社的种种原则、双重思想、过去的易变性、对客观现实的否定，还有用到新语字汇时，她就会变得既无聊又困惑，还说她从来不去注意那种事情。你知道那全都是废话，那么为什么要让自己去操心那个？</p></blockquote><p>而在后面的内容作者讲述了这样一段的内容</p><blockquote><p>他们可以被动地接受最明目张胆的违反现实，因为他们从来没有彻底掌握到他们受到的要求是多么大的罪恶，对于公共事件也不够有兴趣，不足以注意到发生了什么事。因为缺乏理解力，他们保持心智健全。他们就只是把什么都吞下去，就像一颗玉米粒完全未经消化，就通过了一只鸟的身体。</p></blockquote><p>这个世界是很残酷的，当读到这些内容，我觉得作者很明显是想告诉我们应该意识到问题，而不应该无视这一切。关于政治问题，基于国情似乎已经没什么办法，但是关于社会问题与我们越来越息息相关，比如说前两年的疫情的情况，比如说退休年龄的变动。而我想这个问题也可以引申为人们对于外在信息的态度，不应当照单全收，而是应该去思考，否则很容易受到欺骗。虽然受到过一些要敢于怀疑答案和质疑的教育，但是似乎并没有留下多深的印象，在我写这部分内容之前已经忘却了大半。不管你怎么处理，首先要自己主动去理解，遇到错误的时候也不是所有的事情都能去纠正的。</p><p>而书中也谈及了许多社会相关的一些根源问题。印象深刻的是阶级的固化这部分内容，我认为在上层的人想要巩固自己阶级的位置，下层的人未曾想过也很难去改变，中间层的人大多又向上爬，或许这也是阶级的本质。而作者也表达出了类似的观点：</p><blockquote><p>就算在极大的动乱与看似无法挽回的改变之后，同样的模式总是会自动重新确立，就像一个陀螺仪不管朝着此方或彼方推得多用力，总是会回归均衡状态。</p></blockquote><p>我想也正因如此，1984的世界中强权者才肯放任“最下层”的普罗阶级，因为他们不会去想改变这些，只想留在原地，同时在文化和信息的限制下他们也无法习得去改变这一行为，只是去对党员进行十分严格的管制。温斯顿一直认为“希望在普罗阶级”，“普罗阶级一直保持人性。他们并没有变得心如铁石。他们坚守着他自己必须刻意努力重新学习的那些原始情绪。“，换个角度来说为了维持稳定，党员们这些所谓的“人性”都要被扼杀。</p><p>前面提到了阶级，那么平等问题是不可避免要被提及的，产生了阶级就意味着不平等。但是平等的话上位人就无法获得权力，以下是作者的观点：</p><blockquote><p>不平等是文明的代价。然而随着机器制造的发展，状况改变了。就算人类还是必须做不同类型的工作，他们却不再有必要过着社会或经济水平不同的生活。所以，在即将攫取权力的新群体眼中，人类的平等不再是值得奋起争取的理想，而是一个必须回避的危险。</p></blockquote><p>本文开头提到的《美丽新世界》尽管是人们富足快乐的世界，但是同样存在着上面所诉说的一些问题，并且和1984一切同样都是建立在强权统治下。相对于《美丽新世界》来说1984有些许多可以对比谈论的问题。在两个世界中，强权者都做了许多事情来避免大多数人们来动摇自己的权力。</p><p>首先是文化与信息上。两者都在避免人们了解过去了，不过一个是隐藏，一个是修改与破坏。同时在通过各种手段“修改与限制”人们的<strong>独立思考</strong>，一个是从小开始进行反复洗脑催眠，另一个则是出动”思想警察“来限制人们。正如1984中所说</p><blockquote><p>因为要是所有人都享有同样的闲暇与安全，在常态下被贫困弄得傻头傻脑的绝大多数人类都会变得有文化学识，也将学会如何为自己思考，而他们一旦做到这件事，他们迟早会领悟到掌握特权的少数根本没有用处，他们会把那些人扫到一旁去。长期来说，阶级社会只有在贫穷与无知的基础上才可能成立</p></blockquote><p>两者都谈到了技术的停滞，新世界的技术是为了稳定，因为科技、真理代表破坏现有的平衡，而1984则是为了限制自由，甚至只有在技术产物能够透过某种方式缩减人类的自由时，技术的进步才会发生。但是对于强权者来说，本质都是为了巩固自己的权力。</p><p>但对待大多数人们的态度是完全不同的。一个类似于让人们共同富裕，催眠洗脑，乐不思蜀，另一个类似于压迫，强权，威吓。但是两者又都明确了阶级，在美丽新世界中是不同的人种，同时又会对这些人种进行催眠，让他们觉得自己就应该做当前的事情，1984中则是明确区分了党员和普罗阶级，对于违反规定的党员进行最恐怖的制裁，使得他们“心甘情愿”产生改变。让我印象最深刻的是这样一句话：</p><blockquote><p>早就期待着的子弹进入了他的大脑。</p></blockquote><p>相比起1984来说，新世界确实非常美好。这个世界到底会走向什么样子呢？就目前的情况来说我想并不会那么乐观，至少对于大部分的地方如此。想要超越别人、掌控别人我觉得是人类作为动物的兽性中衍生出的一部分，那么也不可避免的有许多人会去追求权力，最后有人为了巩固强权做出什么也不奇怪。而在这样的世界中，大部分人能做的或许只有去学着不被动接受外部的信息，多进行独立思考，作者也许是想要警醒人们，并且试着影响读者们这样来做，至少能够一定程度上推迟或者避免这样的世界到来。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;未来会是怎么样的呢？许多人都会在设想一种美好的乌托邦，比如说美丽新世界中所描述的，尽管有些黑暗的真相但是对于参与者来说都是富足快乐的，但1984的作者赫胥黎给出的是更加令人恐惧且残酷的世界。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是老派改革家想象中那种愚蠢快乐主义乌托邦的</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="赫胥黎" scheme="https://fusionbolt.github.io/tags/%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其三 符号决议</title>
    <link href="https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/"/>
    <id>https://fusionbolt.github.io/2023/04/09/mold/mold-3-symbol-resolve/</id>
    <published>2023-04-09T08:06:20.000Z</published>
    <updated>2023-04-09T08:11:35.212Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-3-symbol-resolve/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:72272420</center> <p>前面两期将读取输入的部分全部讲完了，本期开始涉及链接过程中的处理。在讲主要的符号决议之前，先讲一下mold在符号决议执行之前做的一些其他处理。</p><h1 id="dso-uniquely"><a href="#dso-uniquely" class="headerlink" title="dso uniquely"></a>dso uniquely</h1><p>在读取完输入后首先做的是将shared object根据soname进行去重，因此我们可以在链接的过程中链接多个相同soname的库而不会产生冲突。</p><p>elf/main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    std::unordered_set&lt;std::string_view&gt; seen;</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">return</span> !seen.<span class="built_in">insert</span>(file-&gt;soname).second;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="apply-exclude-libs"><a href="#apply-exclude-libs" class="headerlink" title="apply_exclude_libs"></a>apply_exclude_libs</h1><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_exclude_libs</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;apply_exclude_libs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.exclude_libs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::unordered_set&lt;std::string_view&gt; <span class="title">set</span><span class="params">(ctx.arg.exclude_libs.begin(),</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ctx.arg.exclude_libs.end())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;archive_name.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">if</span> (set.<span class="built_in">contains</span>(<span class="string">&quot;ALL&quot;</span>) ||</span><br><span class="line">          set.<span class="built_in">contains</span>(<span class="built_in">filepath</span>(file-&gt;archive_name).<span class="built_in">filename</span>().<span class="built_in">string</span>()))</span><br><span class="line">        file-&gt;exclude_libs = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是简单将所有包含在exclude-libs里的lib名字对应的exclude_libs设置为true，而这个设置在后面符号决议的过程会用到。</p><p>exclude_libs是命令行中获取的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_arg</span>(<span class="string">&quot;exclude-libs&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">append</span>(ctx.arg.exclude_libs, <span class="built_in">split_by_comma_or_colon</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="create-internal-file"><a href="#create-internal-file" class="headerlink" title="create_internal_file"></a>create_internal_file</h1><h2 id="internal-file是什么"><a href="#internal-file是什么" class="headerlink" title="internal file是什么"></a>internal file是什么</h2><p>内部的文件，用来保存linker-synthesized符号。linker-synthesized符号或许也可以理解为编译产物中不存在的符号。作为一个并不实际存在的文件，依然会作为一个普通的ObjFile加入到obj_pool中，主要用途是在create_output_sections以后来add_synthetic_symbol，与之相关联的有一个internal_esyms，里面都是具体相关的符号。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在main函数中调用是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!ctx.arg.relocatable)</span><br><span class="line">  <span class="built_in">create_internal_file</span>(ctx);</span><br></pre></td></tr></table></figure><p>elf/passes.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_internal_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;;</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  ctx.internal_obj = obj;</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(obj);</span><br><span class="line"></span><br><span class="line">  ctx.internal_esyms.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(<span class="keyword">new</span> Symbol&lt;E&gt;);</span><br><span class="line">  obj-&gt;first_global = <span class="number">1</span>;</span><br><span class="line">  obj-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  obj-&gt;priority = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>首先创建了基本的ObjectFile对象并且进行了一些初始化的处理。</p><p>之后添加从命令行参数中读取的–defsym里的所有的defsym</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  std::pair&lt;Symbol&lt;E&gt; *, std::variant&lt;Symbol&lt;E&gt; *, u64&gt;&gt; &amp;defsym = ctx.arg.defsyms[i];</span><br><span class="line">  <span class="built_in">add</span>(defsym.first);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::holds_alternative&lt;Symbol&lt;E&gt; *&gt;(defsym.second)) &#123;</span><br><span class="line">    <span class="comment">// Add an undefined symbol to keep a reference to the defsym target.</span></span><br><span class="line">    <span class="comment">// This prevents elimination by e.g. LTO or gc-sections.</span></span><br><span class="line">    <span class="comment">// The undefined symbol will never make to the final object file; we</span></span><br><span class="line">    <span class="comment">// double-check that the defsym target is not undefined in</span></span><br><span class="line">    <span class="comment">// fix_synthetic_symbols.</span></span><br><span class="line">    <span class="keyword">auto</span> sym = std::get&lt;Symbol&lt;E&gt; *&gt;(defsym.second);</span><br><span class="line">    <span class="built_in">add_undef</span>(sym);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理完defsym后再从命令行参数中读取的SectionOrder的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">  <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">    <span class="built_in">add</span>(<span class="built_in">get_symbol</span>(ctx, ord.name));</span><br></pre></td></tr></table></figure><p>关于SectionOrder的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOrder</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br><span class="line">  std::string name;</span><br><span class="line">  u64 value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最后设置obj类的一些参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-&gt;elf_syms = ctx.internal_esyms;</span><br><span class="line">obj-&gt;symvers.<span class="built_in">resize</span>(ctx.internal_esyms.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="defsym"><a href="#defsym" class="headerlink" title="defsym"></a>defsym</h2><p>关于前面提到的defsym，我们来看一下mold的测试代码一部分来理解其作用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF | $CC -fPIC -o $t/a.o -c -xc -</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> foo;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> bar;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">baz</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Hello %p %p\n&quot;</span>, &amp;foo, &amp;bar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">baz</span>();</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">$CC -B. -o $t/exe $t/a.o -pie -Wl,-defsym=foo=<span class="number">16</span> \</span><br><span class="line">  -Wl,-defsym=bar=<span class="number">0x2000</span> -Wl,-defsym=baz=print</span><br><span class="line"></span><br><span class="line">$QEMU $t/exe | grep -q <span class="string">&#x27;^Hello 0x10 0x2000$&#x27;</span></span><br></pre></td></tr></table></figure><p>通过defsym指定了符号名以及其实现的位置，尽管对应的符号在代码中并没有实现。</p><p>关于这里的add和add_undef的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An actual value will be set to a linker-synthesized symbol by</span></span><br><span class="line">  <span class="comment">// fix_synthetic_symbols(). Until then, `value` doesn&#x27;t have a valid</span></span><br><span class="line">  <span class="comment">// value. 0xdeadbeef is a unique dummy value to make debugging easier</span></span><br><span class="line">  <span class="comment">// if the field is accidentally used before it gets a valid one.</span></span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_ABS;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_undef = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  obj-&gt;symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line">  sym-&gt;value = <span class="number">0xdeadbeef</span>;</span><br><span class="line"></span><br><span class="line">  ElfSym&lt;E&gt; esym;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">  esym.st_type = STT_NOTYPE;</span><br><span class="line">  esym.st_shndx = SHN_UNDEF;</span><br><span class="line">  esym.st_bind = STB_GLOBAL;</span><br><span class="line">  esym.st_visibility = STV_DEFAULT;</span><br><span class="line">  ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过add和add_undef函数把defsym指定的符号添加到symbols中，并且设定为了特殊值，关联到了一个esym里。主要的差别就在于st_shndx被设置为了不同的值。</p><h1 id="符号决议"><a href="#符号决议" class="headerlink" title="符号决议"></a>符号决议</h1><p>接下来是链接过程中比较重要的一个环节，符号决议（symbol resolve）</p><p>在mold中，这个部分做了四件事情</p><ol><li>检测所有需要使用的objet files</li><li>移除重复的COMDAT段</li><li>进行符号决议的过程。在多个不同的esym中选择出一个更高priority的关联到sym中</li><li>LTO的处理，处理后再次执行决议</li></ol><h2 id="resolve-symbols"><a href="#resolve-symbols" class="headerlink" title="resolve_symbols"></a>resolve_symbols</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;resolve_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">  std::vector&lt;SharedFile&lt;E&gt; *&gt; dsos = ctx.dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先省略lto相关的具体处理，很多处理和do_resolve_symbols中是类似的，因此放到后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_resolve_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> for_each_file = [&amp;](std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; fn) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, fn);</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, fn);</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">// 1. 检测object files</span></span><br><span class="line"><span class="comment">// 2. 消除重复COMDAT</span></span><br><span class="line"><span class="comment">// 3. 符号决议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-检测object-files"><a href="#1-检测object-files" class="headerlink" title="1. 检测object files"></a>1. 检测object files</h2><p>archive extraction: .a成员只会在满足非archive object文件未定义符号之一的情况下才会被包含在最终的二进制文件中</p><p>链接时为了满足archive extraction的规则，mold采取的策略是：</p><ol><li>初步resolve：假设全部include，match undef符号</li><li>mark sweep消除无需使用的archive成员</li><li>删除掉非archive成员</li></ol><p>下面是具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;extract_archive_members&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register symbols</span></span><br><span class="line">    for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark reachable objects to decide which files to include into an output.</span></span><br><span class="line">    <span class="comment">// This also merges symbol visibility.</span></span><br><span class="line">    <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup. The rule used for archive extraction isn&#x27;t accurate for the</span></span><br><span class="line">    <span class="comment">// general case of symbol extraction, so reset the resolution to be redone</span></span><br><span class="line">    <span class="comment">// later.</span></span><br><span class="line">    for_each_file([](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">clear_symbols</span>(); &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now that the symbol references are gone, remove the eliminated files from</span></span><br><span class="line">    <span class="comment">// the file list.</span></span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.objs, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">    std::<span class="built_in">erase_if</span>(ctx.dsos, [](InputFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> !file-&gt;is_alive; &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>for_each_file针对objs和dsos处理resolve，mark live，clear，erase file</li><li>标记所有可访问的输出到文件的object，之后合并可见性</li><li>清除file的symbols</li><li>最后清除掉objs和dsos中非alive的file</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">__attribute__((<span class="built_in">no_sanitize</span>(<span class="string">&quot;thread&quot;</span>)))</span><br><span class="line"><span class="keyword">void</span> InputFile&lt;E&gt;::<span class="built_in">clear_symbols</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="built_in">get_global_syms</span>())</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      sym-&gt;<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mark-live-objects"><a href="#mark-live-objects" class="headerlink" title="mark_live_objects"></a>mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_live_objects</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> mark_symbol = [&amp;](std::string_view name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (InputFile&lt;E&gt; *file = <span class="built_in">get_symbol</span>(ctx, name)-&gt;file)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">mark_symbol</span>(name);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputFile&lt;E&gt; *&gt; roots;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      roots.<span class="built_in">push_back</span>(file);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(roots, [&amp;](InputFile&lt;E&gt; *file,</span><br><span class="line">                                    tbb::feeder&lt;InputFile&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_alive)</span><br><span class="line">      file-&gt;<span class="built_in">mark_live_objects</span>(ctx, [&amp;](InputFile&lt;E&gt; *obj) &#123; feeder.<span class="built_in">add</span>(obj); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先对所有参数中传入的undef以及require_define的符号所关联的文件进行mark，之后遍历所有alive的obj和dso，加入到root中，之后再进行mark_live_objects。部分文件会因为特殊的链接选项，比如说whole-archive会影响是否设置为is_alive，这部分会之后再以这个为主题单独讲一篇。</p><p>对于ObjectFile和SharedFile的mark方式也是不同的。</p><h3 id="ObjectFile-mark-live-objects"><a href="#ObjectFile-mark-live-objects" class="headerlink" title="ObjectFile::mark_live_objects"></a>ObjectFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(<span class="keyword">this</span>-&gt;is_alive);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>() &amp;&amp; exclude_libs)</span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, STV_HIDDEN);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">merge_visibility</span>(ctx, sym, esym.st_visibility);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_weak</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sym.file)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> keep = esym.<span class="built_in">is_undef</span>() || (esym.<span class="built_in">is_common</span>() &amp;&amp; !sym.<span class="built_in">esym</span>().<span class="built_in">is_common</span>());</span><br><span class="line">    <span class="keyword">if</span> (keep &amp;&amp; <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有global的符号进行处理。</p><ol><li><p>首先对esym进行merge_visibility，对于存在定义的exclude_libs的符号来说是HIDDEN的，关于这一点在命令行参数处有说明。</p><blockquote><p>-exclude-libs LIB,LIB,.. Mark all symbols in given libraries hidden</p></blockquote></li><li><p>跳过弱符号以及文件不存在的符号。</p></li><li><p>keep并且fast_mark成功的符号加入到root中。</p></li></ol><p>keep这里需要是undef的情况，我认为是因为如果esym存在定义，那么定义就是存在于当前的ObjectFile中，也就不需要再重复加入到root中了。common我想同样是因为这种情况下所在的文件已经加入到root中了。</p><p>关于merge_visibility</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">merge_visibility</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                     u8 visibility) &#123;</span><br><span class="line">  <span class="comment">// Canonicalize visibility</span></span><br><span class="line">  <span class="keyword">if</span> (visibility == STV_INTERNAL)</span><br><span class="line">    visibility = STV_HIDDEN;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> priority = [&amp;](u8 visibility) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (visibility) &#123;</span><br><span class="line">    <span class="keyword">case</span> STV_HIDDEN:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_PROTECTED:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">case</span> STV_DEFAULT:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unknown symbol visibility: &quot;</span> &lt;&lt; sym;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">update_minimum</span>(sym.visibility, visibility, [&amp;](u8 a, u8 b) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">priority</span>(a) &lt; <span class="built_in">priority</span>(b);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先将INTERNAL转换为HIDDEN，之后按照最小的priority来更新visibility。</p><p>update_minimum只是一个针对多线程的封装，本质上是一个compare and exchange操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = std::less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">update_minimum</span>(std::atomic&lt;T&gt; &amp;atomic, u64 new_val, Compare cmp = &#123;&#125;) &#123;</span><br><span class="line">  T old_val = atomic.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">cmp</span>(new_val, old_val) &amp;&amp;</span><br><span class="line">         !atomic.<span class="built_in">compare_exchange_weak</span>(old_val, new_val,</span><br><span class="line">                                       std::memory_order_relaxed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fast_mark也是针对多线程的一个封装，如果是false则更新为true。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An optimized &quot;mark&quot; operation for parallel mark-and-sweep algorithms.</span></span><br><span class="line"><span class="comment">// Returns true if `visited` was false and updated to true.</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">fast_mark</span><span class="params">(std::atomic&lt;<span class="keyword">bool</span>&gt; &amp;visited)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// A relaxed load + branch (assuming miss) takes only around 20 cycles,</span></span><br><span class="line">  <span class="comment">// while an atomic RMW can easily take hundreds on x86. We note that it&#x27;s</span></span><br><span class="line">  <span class="comment">// common that another thread beat us in marking, so doing an optimistic</span></span><br><span class="line">  <span class="comment">// early test tends to improve performance in the ~20% ballpark.</span></span><br><span class="line">  <span class="keyword">return</span> !visited.<span class="built_in">load</span>(std::memory_order_relaxed) &amp;&amp;</span><br><span class="line">         !visited.<span class="built_in">exchange</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SharedFile-mark-live-objects"><a href="#SharedFile-mark-live-objects" class="headerlink" title="SharedFile::mark_live_objects"></a>SharedFile::mark_live_objects</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">mark_live_objects</span>(Context&lt;E&gt; &amp;ctx,</span><br><span class="line">                                 std::function&lt;<span class="built_in"><span class="keyword">void</span></span>(InputFile&lt;E&gt; *)&gt; feeder) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.traced)</span><br><span class="line">      <span class="built_in">print_trace_symbol</span>(ctx, *<span class="keyword">this</span>, esym, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; !sym.file-&gt;is_dso &amp;&amp;</span><br><span class="line">        <span class="built_in">fast_mark</span>(sym.file-&gt;is_alive)) &#123;</span><br><span class="line">      <span class="built_in">feeder</span>(sym.file);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.traced)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; keeps &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                     &lt;&lt; <span class="string">&quot; for &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要说的唯一一点是因为mark的是object而不是shared file，因此dso的情况下不会进行mark</p><h2 id="2-移除重复的COMDAT段"><a href="#2-移除重复的COMDAT段" class="headerlink" title="2. 移除重复的COMDAT段"></a>2. 移除重复的COMDAT段</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;eliminate_comdats&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">resolve_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">eliminate_duplicate_comdat_groups</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="built_in">update_minimum</span>(ref.group-&gt;owner, <span class="keyword">this</span>-&gt;priority);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新所有comdat_groups的priority</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">eliminate_duplicate_comdat_groups</span>() &#123;</span><br><span class="line">  <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : comdat_groups)</span><br><span class="line">    <span class="keyword">if</span> (ref.group-&gt;owner != <span class="keyword">this</span>-&gt;priority)</span><br><span class="line">      <span class="keyword">for</span> (u32 i : ref.members)</span><br><span class="line">        <span class="keyword">if</span> (sections[i])</span><br><span class="line">          sections[i]-&gt;<span class="built_in">kill</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>eliminate重复的section。将section和fde的is_alive都设置为false。</p><p>这里将fde设置为false正对应了上期提到单独解析eh_frame的原因之一：消除重复的fde。</p><h2 id="3-实际进行符号决议的过程"><a href="#3-实际进行符号决议的过程" class="headerlink" title="3. 实际进行符号决议的过程"></a>3. 实际进行符号决议的过程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each_file([&amp;](InputFile&lt;E&gt; *file) &#123; file-&gt;<span class="built_in">resolve_symbols</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>resolve_symbols的实现对于ObjectFile和SharedFile是不同的</p><h3 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    InputSection&lt;E&gt; *isec = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>() &amp;&amp; !esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">      isec = <span class="built_in">get_section</span>(esym);</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, !<span class="keyword">this</span>-&gt;is_alive) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(isec);</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = ctx.default_version;</span><br><span class="line">      sym.is_weak = esym.<span class="built_in">is_weak</span>();</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>符号决议是针对global symbol的elf_sym的。未定义的esym都跳过了，它们都不需要参与resolve的过程，因为resolve本质是找到需要加入到生成产物的符号实现，但是注意在前面mark的时候还是需要的。</p><p>也就是说Symbol类的sym其实是保留的最终唯一定义。而在决议的过程，不断的将esym和对应的sym进行比较。如果esym的rank小，也就是更加优先，那么就将sym中的信息更新为对应的esym的信息，这就是实际决议过程中做的事情。而这里也是实际初始化symbols成员里global的值的地方，local的部分初始化在parse的阶段就做好了，因为local的符号并不需要进行resolve。</p><h3 id="get-rank"><a href="#get-rank" class="headerlink" title="get_rank"></a>get_rank</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(<span class="keyword">const</span> Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!sym.file)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rank</span>(sym.file, sym.<span class="built_in">esym</span>(), !sym.file-&gt;is_alive);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Symbols with higher priorities overwrites symbols with lower priorities.</span></span><br><span class="line"><span class="comment">// Here is the list of priorities, from the highest to the lowest.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  1. Strong defined symbol</span></span><br><span class="line"><span class="comment">//  2. Weak defined symbol</span></span><br><span class="line"><span class="comment">//  3. Strong defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  4. Weak Defined symbol in a DSO/archive</span></span><br><span class="line"><span class="comment">//  5. Common symbol</span></span><br><span class="line"><span class="comment">//  6. Common symbol in an archive</span></span><br><span class="line"><span class="comment">//  7. Unclaimed (nonexistent) symbol</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Ties are broken by file priority.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> u64 <span class="title">get_rank</span><span class="params">(InputFile&lt;E&gt; *file, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym, <span class="keyword">bool</span> is_lazy)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(!file-&gt;is_dso);</span><br><span class="line">    <span class="keyword">if</span> (is_lazy)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">6</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">5</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (file-&gt;is_dso || is_lazy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">      <span class="keyword">return</span> (<span class="number">4</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (esym.st_bind == STB_WEAK)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) + file-&gt;priority;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_rank的实现，根据注释我们可以看到不同类别符号的优先级。</p><h3 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">resolve_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_rank</span>(<span class="keyword">this</span>, esym, <span class="literal">false</span>) &lt; <span class="built_in">get_rank</span>(sym)) &#123;</span><br><span class="line">      sym.file = <span class="keyword">this</span>;</span><br><span class="line">      sym.origin = <span class="number">0</span>;</span><br><span class="line">      sym.value = esym.st_value;</span><br><span class="line">      sym.sym_idx = i;</span><br><span class="line">      sym.ver_idx = versyms[i];</span><br><span class="line">      sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">      sym.is_imported = <span class="literal">false</span>;</span><br><span class="line">      sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于SharedFile中的符号中不需要考虑是否是global的问题，上期解析SharedFile的部分也有提到，对应的first_global就是0。相对于</p><h2 id="4-LTO的处理"><a href="#4-LTO的处理" class="headerlink" title="4. LTO的处理"></a>4. LTO的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.has_lto_object) &#123;</span><br><span class="line">  <span class="comment">// Do link-time optimization. We pass all IR object files to the</span></span><br><span class="line">  <span class="comment">// compiler backend to compile them into a few ELF object files.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// The compiler backend needs to know how symbols are resolved,</span></span><br><span class="line">  <span class="comment">// so compute symbol visibility, import/export bits, etc early.</span></span><br><span class="line">  <span class="built_in">mark_live_objects</span>(ctx);</span><br><span class="line">  <span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line">  <span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line">  <span class="built_in">compute_import_export</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do LTO. It compiles IR object files into a few big ELF files.</span></span><br><span class="line">  std::vector&lt;ObjectFile&lt;E&gt; *&gt; lto_objs = <span class="built_in">do_lto</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do_resolve_symbols() have removed unreferenced files. Restore the</span></span><br><span class="line">  <span class="comment">// original files here because some of them may have to be resurrected</span></span><br><span class="line">  <span class="comment">// because they are referenced by the ELF files returned from do_lto().</span></span><br><span class="line">  ctx.objs = objs;</span><br><span class="line">  ctx.dsos = dsos;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">append</span>(ctx.objs, lto_objs);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Redo name resolution from scratch.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">clear_symbols</span>();</span><br><span class="line">    file-&gt;is_alive = !file-&gt;is_needed;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove IR object files.</span></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;is_lto_obj)</span><br><span class="line">      file-&gt;is_alive = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> file-&gt;is_lto_obj; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">do_resolve_symbols</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于apply_version_script, parse_symbol_version, compute_import_export这三个过程，会在之后的过程中讲解。这里简单来讲就是获取符号对应的版本信息以及对应import/export的属性。</p><p>这个部分做了这么几件事情</p><ol><li>计算出符号所需的基本信息</li><li>实际执行lto</li><li>将lto结果的object加入到全局</li><li>清理旧的lto文件</li><li>再次执行do_resolve_symbols整个过程</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-3-symbol-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="symbol_resolve" scheme="https://fusionbolt.github.io/tags/symbol-resolve/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其二 读取SharedFile</title>
    <link href="https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/"/>
    <id>https://fusionbolt.github.io/2023/04/05/mold/mold-2-read-shared-files/</id>
    <published>2023-04-05T08:35:27.000Z</published>
    <updated>2023-04-05T08:50:32.743Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:70054356</center> <p>这期的内容主要是讲完读取输入的部分，有一些之前遗漏的信息，以及之前未讲完的初始化ehframe以及shared object读取的部分。有许多地方默认读者读过上期内容，建议先阅读上期内容后再来查看本期。</p><p><a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/" >https://homura.live/2023/02/26/mold/mold-1-read-input-files/<i class="fas fa-external-link-alt"></i></a></p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="get-string"><a href="#get-string" class="headerlink" title="get_string"></a>get_string</h2><p>之前在读取符号表的时候是通过这种方式读取的，但我们没有讲解这个读取的细节</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br></pre></td></tr></table></figure><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(idx &lt; elf_sections.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index: &quot;</span> &lt;&lt; idx;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> std::string_view</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_string</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  u8 *begin = mf-&gt;data + shdr.sh_offset;</span><br><span class="line">  u8 *end = begin + shdr.sh_size;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; end)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: section header is out of range: &quot;</span> &lt;&lt; shdr.sh_offset;</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)begin, (<span class="keyword">size_t</span>)(end - begin)&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上是找到文件中对应offset的data作为开始，根据长度构造一个<strong>string_view</strong>，注意这里并不是实际构造了一个string，因此返回的string并没有这块空间的所有权。</p><p>由get_string衍生出来的方法还有get_data，之前在读取elfsyms的时候就是使用了get_data</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr) &#123;</span><br><span class="line">  std::string_view view = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shdr);</span><br><span class="line">  <span class="keyword">if</span> (view.<span class="built_in">size</span>() % <span class="built_in"><span class="keyword">sizeof</span></span>(T))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted section&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;(T *)view.<span class="built_in">data</span>(), view.<span class="built_in">size</span>() / <span class="built_in"><span class="keyword">sizeof</span></span>(T)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::span&lt;T&gt; InputFile&lt;E&gt;::<span class="built_in">get_data</span>(Context&lt;E&gt; &amp;ctx, i64 idx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (elf_sections.<span class="built_in">size</span>() &lt;= idx)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid section index&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;T&gt;(elf_sections[idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里直接获取了get_string的结果，并且将对应的结果映射为了一个对应数据的span</p><h2 id="get-shndx"><a href="#get-shndx" class="headerlink" title="get_shndx"></a>get_shndx</h2><p>在之前从符号表取数据的时候是通过get_shndx实现的</p><p>elf/mold.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 ObjectFile&lt;E&gt;::<span class="built_in">get_shndx</span>(<span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(&amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>] &lt;= &amp;esym);</span><br><span class="line">  <span class="built_in">assert</span>(&amp;esym &lt;= &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.st_shndx == SHN_XINDEX)</span><br><span class="line">    <span class="keyword">return</span> symtab_shndx_sec[&amp;esym - &amp;<span class="keyword">this</span>-&gt;elf_syms[<span class="number">0</span>]];</span><br><span class="line">  <span class="keyword">return</span> esym.st_shndx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然符号中是有对应的shndx字段，但是这个字段的长度为16bit，如果超出这个长度的index那么需要去symtab_shndx_sec中获取。</p><p>这个限制在之前读取输入的时候多次遇到，比如说在构造InputFile类，读取shstrtab_idx的时候</p><p>input-files.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line"><span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">  ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br></pre></td></tr></table></figure><h2 id="eh-frame"><a href="#eh-frame" class="headerlink" title="eh_frame"></a>eh_frame</h2><p>eh_frame段对于大多数人来说比较陌生，因此首先来讲解eh_frame是什么。eh_frame是包含了记录如何处理异常信息的段，当异常抛出的时候runtime会寻找一个eh_frame记录的信息并且来处理。</p><p>我们来看一下hello world的汇编</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.section__TEXT,__text,regu</span><br><span class="line">lar,pure_instructions</span><br><span class="line">.build_version macos, <span class="number">12</span>, <span class="number">0</span>sdk_version <span class="number">12</span>, <span class="number">1</span></span><br><span class="line">.globl_main                           ; -- Begin function main</span><br><span class="line">.p2align<span class="number">2</span></span><br><span class="line">_main:                                  ; @main</span><br><span class="line">.cfi_startproc</span><br><span class="line">; %bb<span class="number">.0</span>:</span><br><span class="line">subsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">stpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Spill</span><br><span class="line">addx29, sp, #<span class="number">16</span>                    ; =<span class="number">16</span></span><br><span class="line">.cfi_def_cfa w29, <span class="number">16</span></span><br><span class="line">.cfi_offset w30, <span class="number">-8</span></span><br><span class="line">.cfi_offset w29, <span class="number">-16</span></span><br><span class="line">movw8, #<span class="number">0</span></span><br><span class="line">strw8, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Spill</span><br><span class="line">sturwzr, [x29, #<span class="number">-4</span>]</span><br><span class="line">adrpx0, l_.str@PAGE</span><br><span class="line">addx0, x0, l_.str@PAGEOFF</span><br><span class="line">bl_printf</span><br><span class="line">ldrw0, [sp, #<span class="number">8</span>]                    ; <span class="number">4</span>-byte Folded Reload</span><br><span class="line">ldpx29, x30, [sp, #<span class="number">16</span>]             ; <span class="number">16</span>-byte Folded Reload</span><br><span class="line">addsp, sp, #<span class="number">32</span>                     ; =<span class="number">32</span></span><br><span class="line">ret</span><br><span class="line">.cfi_endproc</span><br><span class="line">                                        ; -- End function</span><br><span class="line">.section__TEXT,__cstring,cstring_literals</span><br><span class="line">l_.str:                                 ; @.str</span><br><span class="line">.asciz<span class="string">&quot;Hello world\n&quot;</span></span><br><span class="line"></span><br><span class="line">.subsections_via_symbols</span><br></pre></td></tr></table></figure><p>关于eh_frame我有一个疑问，是否能像符号一样被strip掉？手动strip以后发现elf大小并没有发生改变。关于这个问题stackoverflow有这样一条回答</p><p><a class="link"   href="https://stackoverflow.com/questions/26300819/why-gcc-compiled-c-program-needs-eh-frame-section" >Why GCC compiled C program needs .eh_frame section?<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>You can disable generation of .eh_frame with -fno-asynchronous-unwind-tables for individual translation units, and this mostly eliminates the size cost</p></blockquote><blockquote><p>You cannot strip them with the strip command later; since .eh_frame is a section that lives in the loaded part of the program (this is the whole point), stripping it modifies the binary in ways that break it at runtime.</p></blockquote><p>大意是不能通过strip消除，但是eh_frame在gcc中可以通过开启特殊的编译选项避免生成。</p><h3 id="eh-frame的结构"><a href="#eh-frame的结构" class="headerlink" title="eh_frame的结构"></a>eh_frame的结构</h3><p><a class="link"   href="https://refspecs.linuxbase.org/LSB_4.0.0/LSB-Core-generic/LSB-Core-generic/ehframechpt.html" >Exception Frames<i class="fas fa-external-link-alt"></i></a></p><p>这里不详细介绍里面的具体字段了。简单来说，每个eh_frame段中会包含至少一个CFI（Call Frame Information），而每个CFI包含一个CIE（Common Information Entry），之后紧接着跟着许多FDE（Frame Description Entry）</p><p>一个CFI对应了一个单一的object文件，如果是多个object文件合并那么就会有多个，因此至少存在一个。CFI中包含了一个CIE，也就是这个object里的common information，而后面跟随的许多FDE则是对应了各个function。</p><p>这里引用一下MaskRay聚聚的资料，里面包含了更具体严谨的描述。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%201.png"                      alt="Untitled"                ></p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>对于链接器来说，ehframe和其他段不同是单独进行parse的。注释中给出了以下几条原因</p><ol><li>避免大量dead section的字段。如果只是最后拷贝所有的eh_frame则会有许多针对dead section的字段。</li><li>减少section的大小。删除function的时候顺便删除FDE，所以eh_frame不包含dead FDE。</li><li>增加搜索效率。扫描eh_frame段查找一个record是一个O(n)操作，通过linker创建一个sorted list后可以通过二分查找降低复杂度到O(log n)。</li></ol><p>接下来我们看一下具体的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">read_ehframe</span>(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec) &#123;</span><br><span class="line">  std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  i64 cies_begin = cies.<span class="built_in">size</span>();</span><br><span class="line">  i64 fdes_begin = fdes.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// Read CIEs and FDEs until empty.</span></span><br><span class="line">std::string_view contents = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, isec.<span class="built_in">shdr</span>());</span><br><span class="line">i64 rel_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (std::string_view data = contents; !data.<span class="built_in">empty</span>();) &#123;</span><br><span class="line">    i64 size = *(U32&lt;E&gt; *)data.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    i64 begin_offset = data.<span class="built_in">data</span>() - contents.<span class="built_in">data</span>();</span><br><span class="line">    i64 end_offset = begin_offset + size + <span class="number">4</span>;</span><br><span class="line">    i64 id = *(U32&lt;E&gt; *)(data.<span class="built_in">data</span>() + <span class="number">4</span>);</span><br><span class="line">    data = data.<span class="built_in">substr</span>(size + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    i64 rel_begin = rel_idx;</span><br><span class="line">    <span class="keyword">while</span> (rel_idx &lt; rels.<span class="built_in">size</span>() &amp;&amp; rels[rel_idx].r_offset &lt; end_offset)</span><br><span class="line">      rel_idx++;</span><br><span class="line">    <span class="built_in">assert</span>(rel_idx == rels.<span class="built_in">size</span>() || begin_offset &lt;= rels[rel_begin].r_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// This is CIE.</span></span><br><span class="line">      cies.<span class="built_in">emplace_back</span>(ctx, *<span class="keyword">this</span>, isec, begin_offset, rels, rel_begin);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is FDE.</span></span><br><span class="line">      <span class="keyword">if</span> (rel_begin == rel_idx || rels[rel_begin].r_sym == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// FDE has no valid relocation, which means FDE is dead from</span></span><br><span class="line">        <span class="comment">// the beginning. Compilers usually don&#x27;t create such FDE, but</span></span><br><span class="line">        <span class="comment">// `ld -r` tend to generate such dead FDEs.</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[rel_begin].r_offset - begin_offset != <span class="number">8</span>)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: FDE&#x27;s first relocation should have offset 8&quot;</span>;</span><br><span class="line"></span><br><span class="line">      fdes.<span class="built_in">emplace_back</span>(begin_offset, rel_begin);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>根据这个解析过程以及参考格式描述我们能够画出这样一张图</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-2-read-shared-files/Untitled%202.png"                      alt="Untitled"                ></p><p>在读取完所有基本的段以后，将CIE关联到FDE中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> find_cie = [&amp;](i64 offset) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = cies_begin; i &lt; cies.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (cies[i].input_offset == offset)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: bad FDE pointer&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  i64 cie_offset = *(I32&lt;E&gt; *)(contents.<span class="built_in">data</span>() + fdes[i].input_offset + <span class="number">4</span>);</span><br><span class="line">  fdes[i].cie_idx = <span class="built_in">find_cie</span>(fdes[i].input_offset + <span class="number">4</span> - cie_offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将FDE关联到InputSection中。注意这里进行了stable_sort，上面提到的第三条增加搜索效率就是通过这里实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">stable_sort</span>(fdes.<span class="built_in">begin</span>() + fdes_begin, fdes.<span class="built_in">end</span>(),</span><br><span class="line">                 [&amp;](<span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;a, <span class="keyword">const</span> FdeRecord&lt;E&gt; &amp;b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_isec</span>(a)-&gt;<span class="built_in">get_priority</span>() &lt; <span class="built_in">get_isec</span>(b)-&gt;<span class="built_in">get_priority</span>();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = fdes_begin; i &lt; fdes.<span class="built_in">size</span>();) &#123;</span><br><span class="line">  InputSection&lt;E&gt; *isec = <span class="built_in">get_isec</span>(fdes[i]);</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;fde_begin == <span class="number">-1</span>);</span><br><span class="line">  isec-&gt;fde_begin = i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; fdes.<span class="built_in">size</span>() &amp;&amp; isec == <span class="built_in">get_isec</span>(fdes[i]))</span><br><span class="line">    i++;</span><br><span class="line">  isec-&gt;fde_end = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，整个eh_frame部分的初始化就完毕了。</p><h1 id="SharedFile"><a href="#SharedFile" class="headerlink" title="SharedFile"></a>SharedFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先我们来看一下SharedFile的构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt; *</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf) &#123;</span><br><span class="line">  SharedFile&lt;E&gt; *obj = <span class="keyword">new</span> <span class="built_in">SharedFile</span>(ctx, mf);</span><br><span class="line">  ctx.dso_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">SharedFile&lt;E&gt;::<span class="built_in">SharedFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_needed = ctx.as_needed;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !ctx.as_needed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分没什么特别要讲的，关于is_needed和is_alive会涉及到关于whole-archive这个选项，之后会再单独开文章讲解。构造基类InputFile之前在ObjectFile的部分已经讲过了，不再赘述。接着来看parse的部分。</p><h2 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h2><p>首先是找到DYNSYM段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNSYM);</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>之后读取符号表和ver信息，这些是Shared only的成员。而soname是针对一个dso的，所以个dso关联一个soname</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">soname = <span class="built_in">get_soname</span>(ctx);</span><br><span class="line">version_strings = <span class="built_in">read_verdef</span>(ctx);</span><br></pre></td></tr></table></figure><p>读取具体的符号信息以及符号版本信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read a symbol table.</span></span><br><span class="line">std::span&lt;ElfSym&lt;E&gt;&gt; esyms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line"></span><br><span class="line">std::span&lt;U16&lt;E&gt;&gt; vers;</span><br><span class="line"><span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERSYM))</span><br><span class="line">  vers = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U16&lt;E&gt;&gt;(ctx, *sec);</span><br></pre></td></tr></table></figure><p>对于DYNSYM来说symtab_sec-&gt;sh_info是开始的符号数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = symtab_sec-&gt;sh_info; i &lt; esyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  u16 ver;</span><br><span class="line">  <span class="keyword">if</span> (vers.<span class="built_in">empty</span>() || esyms[i].<span class="built_in">is_undef</span>())</span><br><span class="line">    ver = VER_NDX_GLOBAL;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ver = (vers[i] &amp; ~VERSYM_HIDDEN);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ver == VER_NDX_LOCAL)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  std::string_view name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esyms[i].st_name;</span><br><span class="line">  <span class="keyword">bool</span> is_hidden = (!vers.<span class="built_in">empty</span>() &amp;&amp; (vers[i] &amp; VERSYM_HIDDEN));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;elf_syms2.<span class="built_in">push_back</span>(esyms[i]);</span><br><span class="line">  <span class="keyword">this</span>-&gt;versyms.<span class="built_in">push_back</span>(ver);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_hidden) &#123;</span><br><span class="line">    std::string_view mangled_name = <span class="built_in">save_string</span>(</span><br><span class="line">      ctx, std::<span class="built_in">string</span>(name) + <span class="string">&quot;@&quot;</span> + std::<span class="built_in">string</span>(version_strings[ver]));</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, mangled_name, name));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbols.<span class="built_in">push_back</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个for循环中针对每个符号信息来说做了以下几件事情</p><ol><li><p>处理version信息。</p><ol><li>跳过只有一个VER_NDX_LOCAL属性的</li><li>vers为空或esym未定义，则是global的（大概用于symbol resolve去寻找定义。因此设为了GLOBAL</li><li>不为空且有定义，那么就不是HIDDEN的</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_LOCAL = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VER_NDX_GLOBAL = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> u32 VERSYM_HIDDEN = <span class="number">0x8000</span>;</span><br></pre></td></tr></table></figure></li><li><p>添加elf_syms2（Shared Only的字段）以及versysms</p></li><li><p>处理hidden的符号，hidden的话要mangled才行</p><ul><li><input disabled="" type="checkbox"> 为什么呢…</li></ul></li></ol><p>设置基本信息后结束</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;elf_syms = elf_syms2;</span><br><span class="line"><span class="keyword">this</span>-&gt;first_global = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;dso_syms&quot;</span>)</span></span>;</span><br><span class="line">counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><p>这里first_global设置为0，也就是说dso中所有的符号都是global的。</p><h2 id="get-soname"><a href="#get-soname" class="headerlink" title="get_soname"></a>get_soname</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::string SharedFile&lt;E&gt;::<span class="built_in">get_soname</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ElfShdr&lt;E&gt; *sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_DYNAMIC))</span><br><span class="line">    <span class="keyword">for</span> (ElfDyn&lt;E&gt; &amp;dyn : <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfDyn&lt;E&gt;&gt;(ctx, *sec))</span><br><span class="line">      <span class="keyword">if</span> (dyn.d_tag == DT_SONAME)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + dyn.d_val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;mf-&gt;given_fullpath)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;filename;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">filepath</span>(<span class="keyword">this</span>-&gt;filename).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到DYNAMIC段，从里面的ElfDyn中查找tag为DT_SONAME的，找不到就用依靠完整文件路径作为soname。</p><p>关于ElfDyn</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="class"><span class="keyword">struct</span> <span class="title">ElfDyn</span>&lt;</span>RV64LE&gt;     : EL64Dyn &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EL64Dyn</span> &#123;</span></span><br><span class="line">  ul64 d_tag;</span><br><span class="line">  ul64 d_val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在elf规范中关于DT_SONAME这个tag的信息</p><table><thead><tr><th>Name</th><th>d_un</th><th>Executable</th><th>Shared Object</th></tr></thead><tbody><tr><td>DT_SONAME</td><td>d_val</td><td>ignored</td><td>optional</td></tr></tbody></table><blockquote><p>This element holds the string table offset of a null-terminated string, giving the name of the shared object. The offset is an index into the table recorded in the DT_STRTAB entry. See “Shared Object Dependencies” below for more information about these names.</p></blockquote><h2 id="verdef"><a href="#verdef" class="headerlink" title="verdef"></a>verdef</h2><blockquote><p>Symbol versioning is a <strong>GNU extension</strong> to the ELF file format.</p></blockquote><blockquote><p>Versions are just strings, and no ordering is defined between them. For example, “GLIBC_2.15” is not considered a newer version of “GLIBC_2.2.5” or vice versa. They are considered just different.</p></blockquote><blockquote><p>If a shared object file has versioned symbols, it contains a parallel array for the symbol table. Version strings can be found in that parallel table.</p></blockquote><blockquote><p>One version is considered the “default” version for each shared object. If an undefiend symbol <code>foo</code> is resolved to a symbol defined by the shared object, it’s marked so that it’ll be resolved to (<code>foo</code>, the default version of the library) at load-time.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">std::vector&lt;std::string_view&gt; SharedFile&lt;E&gt;::<span class="built_in">read_verdef</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">std::vector&lt;std::string_view&gt; <span class="title">ret</span><span class="params">(VER_NDX_LAST_RESERVED + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *verdef_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_GNU_VERDEF);</span><br><span class="line">  <span class="keyword">if</span> (!verdef_sec)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">  std::string_view verdef = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, *verdef_sec);</span><br><span class="line">  std::string_view strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, verdef_sec-&gt;sh_link);</span><br><span class="line"></span><br><span class="line">  ElfVerdef&lt;E&gt; *ver = (ElfVerdef&lt;E&gt; *)verdef.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret.<span class="built_in">size</span>() &lt;= ver-&gt;vd_ndx)</span><br><span class="line">      ret.<span class="built_in">resize</span>(ver-&gt;vd_ndx + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ElfVerdaux&lt;E&gt; *aux = (ElfVerdaux&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_aux);</span><br><span class="line">    ret[ver-&gt;vd_ndx] = strtab.<span class="built_in">data</span>() + aux-&gt;vda_name;</span><br><span class="line">    <span class="keyword">if</span> (!ver-&gt;vd_next)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    ver = (ElfVerdef&lt;E&gt; *)((u8 *)ver + ver-&gt;vd_next);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿一个helloworld的elf看一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">readelf -S ./a.out</span><br><span class="line"></span><br><span class="line">[ <span class="number">8</span>] .gnu.version      VERSYM           <span class="number">0000000000000516</span>  <span class="number">00000516</span></span><br><span class="line">     <span class="number">000000000000000</span>e  <span class="number">0000000000000002</span>   A       <span class="number">6</span>     <span class="number">0</span>     <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这里的全体大小为2，我们再看一下符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line">w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line">U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line">U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>其中两个是重复的符号，去重后也就是2个符号</p><h1 id="对比ObjectFile和SharedFile"><a href="#对比ObjectFile和SharedFile" class="headerlink" title="对比ObjectFile和SharedFile"></a>对比ObjectFile和SharedFile</h1><p>最后我们通过分析ObjectFile和SharedFile相关的异同来结束这期内容。</p><p>相比于ObjectFile的复杂解析过程，SharedFile的整个过程显得十分简单。这和文件本身的性质与使用场景都有关系。dso加载符号的定义以及其他信息绝大部分都是在运行时，因此在链接期间并不需要做太多操作，其主要用途是将会被引用的符号加入到决议过程，同时将对应符号的版本信息和dso的soname加入到生成的产物中，以便在运行时进行加载。在谷歌搜索的时候搜到了这样一句话，我觉得概括的更好</p><blockquote><p>A DSO can be used in place of archive libraries and will minimize overall memory usage because code is shared.</p></blockquote><p>在链接的时候dso的作用是in place of archive libraries，所以并不需要太多的信息。</p><p>虽然SharedFile在链接的时候并没有解析ObjectFile中许多信息，但是那些信息仍然是存在的，只是在链接的时候无需参与，而是全部交给运行时加载来处理。虽然在mold的类结构中ObjectFile和SharedFile都是直接继承自InputFile，但对于实际的object和dso来说我觉得dso更倾向于是特别的object，不过这个从dso的全名（dynamic shared object）也能看出来了。</p><p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：<a class="link"   href="https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w" >https://cloud.tencent.com/developer/support-plan?invite_code=239vtuizwri8w<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-2-read-sh</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="eh_frame" scheme="https://fusionbolt.github.io/tags/eh-frame/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其一 读取输入文件</title>
    <link href="https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/"/>
    <id>https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/</id>
    <published>2023-02-26T09:40:55.000Z</published>
    <updated>2023-02-26T09:45:10.272Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg"                      alt="图像"                >上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。</p><p>首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可能从代码中去捋清不同结构之间的联系。</p><p>我们从elf_main函数中的read_input_files开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_input_files</span>(ctx, file_args);</span><br></pre></td></tr></table></figure><h1 id="read-input-files"><a href="#read-input-files" class="headerlink" title="read_input_files"></a>read_input_files</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_input_files</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::span&lt;std::string&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;read_input_files&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>&gt;&gt; state;</span><br><span class="line">  ctx.is_static = ctx.arg.is_static;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string_view arg = args[<span class="number">0</span>];</span><br><span class="line">    args = args.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="string">&quot;--as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bstatic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bdynamic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--start-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--end-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--version-script=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--version-script: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_version_script</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--dynamic-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dynamic-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol=&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">        ctx.default_version = VER_NDX_GLOBAL;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.version_patterns.<span class="built_in">push_back</span>(&#123;arg, <span class="string">&quot;--export-dynamic-symbol&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;global&quot;</span>, VER_NDX_GLOBAL, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--export-dynamic-symbol-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--push-state&quot;</span>) &#123;</span><br><span class="line">      state.<span class="built_in">push_back</span>(&#123;ctx.as_needed, ctx.whole_archive, ctx.is_static,</span><br><span class="line">                       ctx.in_lib&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--pop-state&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no state pushed before popping&quot;</span>;</span><br><span class="line">      std::<span class="built_in">tie</span>(ctx.as_needed, ctx.whole_archive, ctx.is_static, ctx.in_lib) =</span><br><span class="line">        state.<span class="built_in">back</span>();</span><br><span class="line">      state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;-l&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_library</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      mf-&gt;given_fullpath = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, std::<span class="built_in">string</span>(arg)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no input files&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.tg.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是根据命令行参数确定要读取的输入文件，这里大部分的分支是为了读取符号version信息相关的，主要是看read_file的实现。在看实现之前可以看到传入了一个MappedFile，而这个类的实现其实就是在打开文件的时候使用了mmap进行映射，而must_open则是进行判断，失败了直接报错，这里也不贴具体细节代码了。</p><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.visited.<span class="built_in">contains</span>(mf-&gt;name))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  FileType type = <span class="built_in">get_file_type</span>(mf);</span><br><span class="line">... 省略对不同type的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是get_file_type，这个是通过文件开头的值确定文件的类型，我们这里以ELF的代码为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">FileType <span class="title">get_file_type</span><span class="params">(MappedFile&lt;C&gt; *mf)</span> </span>&#123;</span><br><span class="line">  std::string_view data = mf-&gt;<span class="built_in">get_contents</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> FileType::EMPTY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;\177ELF&quot;</span>)) &#123;</span><br><span class="line">    u8 byte_order = ((elf::EL32Ehdr *)data.<span class="built_in">data</span>())-&gt;e_ident[elf::EI_DATA];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (byte_order == elf::ELFDATA2LSB) &#123;</span><br><span class="line">      elf::EL32Ehdr &amp;ehdr = *(elf::EL32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::I386&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::X86_64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elf::EB32Ehdr &amp;ehdr = *(elf::EB32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::M68K&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::SPARC64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FileType::UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  ... 省略其他格式的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从数据开头的“\177ELF”确定为ELF文件，之后根据ELFHeader里面的内容读取更多的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FileType</span> &#123;</span></span><br><span class="line">  UNKNOWN,</span><br><span class="line">  EMPTY,</span><br><span class="line">  ELF_OBJ,</span><br><span class="line">  ELF_DSO,</span><br><span class="line">  MACH_OBJ,</span><br><span class="line">  MACH_EXE,</span><br><span class="line">  MACH_DYLIB,</span><br><span class="line">  MACH_BUNDLE,</span><br><span class="line">  MACH_UNIVERSAL,</span><br><span class="line">  AR,</span><br><span class="line">  THIN_AR,</span><br><span class="line">  TAPI,</span><br><span class="line">  TEXT,</span><br><span class="line">  GCC_LTO_OBJ,</span><br><span class="line">  LLVM_BITCODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mold当前所支持的FileType就是这些，但是注意，GitHub中mold项目下只存在elf文件的支持，mach的格式则是在sold这个项目中处理。除此之外的文件格式都在以下的switch中进行处理</p><p><a class="link"   href="https://github.com/bluewhalesystems/sold" >https://github.com/bluewhalesystems/sold<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, mf, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_DSO:</span><br><span class="line">  ctx.dsos.<span class="built_in">push_back</span>(<span class="built_in">new_shared_file</span>(ctx, mf));</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::AR:</span><br><span class="line"><span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">  <span class="keyword">for</span> (MappedFile&lt;Context&lt;E&gt;&gt; *child : <span class="built_in">read_archive_members</span>(ctx, mf)) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(child)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">      ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, child, mf-&gt;name));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line">    <span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">      <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, child, mf-&gt;name))</span><br><span class="line">        ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::TEXT:</span><br><span class="line">  <span class="built_in">parse_linker_script</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line"><span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">  <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, mf, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: unknown file type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化下来这里主要分为这么几类文件</p><ol><li>archive file</li><li>lto</li><li>linker_script</li><li>object_file</li><li>shared_file</li></ol><h2 id="archive-file"><a href="#archive-file" class="headerlink" title="archive file"></a>archive file</h2><p>archive file，也就是俗称的.a文件，其实就是许多个object文件塞到一起只需要解析其中所有member，之后将每个member进行读取即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">std::vector&lt;MappedFile&lt;C&gt; *&gt;</span><br><span class="line"><span class="built_in">read_archive_members</span>(C &amp;ctx, MappedFile&lt;C&gt; *mf) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(mf)) &#123;</span><br><span class="line">  <span class="keyword">case</span> FileType::AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_fat_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_thin_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ar和thin ar</p><p><a class="link"   href="https://sourceware.org/binutils/docs/binutils/ar.html" >ar (GNU Binary Utilities)<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>An archive can either be <em>thin</em> or it can be normal. It cannot be both at the same time. Once an archive is created its format cannot be changed without first deleting it and then creating a new archive in its place.</p></blockquote><p>这里的具体细节暂且略过，如感兴趣可自行查看源码</p><h2 id="lto"><a href="#lto" class="headerlink" title="lto"></a>lto</h2><p>lto是用于link time optimization的文件，而本质上还是一个object文件，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_lto_obj</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_lto_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.ignore_ir_file.<span class="built_in">count</span>(mf-&gt;<span class="built_in">get_identifier</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  ObjectFile&lt;E&gt; *file = <span class="built_in">read_lto_object</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  file-&gt;archive_name = archive_name;</span><br><span class="line">  file-&gt;is_in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  ctx.has_lto_object = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mold中解析lto的方式是通过指定plugin，加载对应的so来进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">ObjectFile&lt;E&gt; *<span class="title">read_lto_object</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// V0 API&#x27;s claim_file is not thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_gcc_linker_api_v1)</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.plugin.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: don&#x27;t know how to handle this LTO object file &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;because no -plugin option was given. Please make sure you &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;added -flto not only for creating object files but also for &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;creating the final executable.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dlopen the linker plugin file</span></span><br><span class="line">  <span class="keyword">static</span> std::once_flag flag;</span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;] &#123; <span class="built_in">load_plugin</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>学习解析文件的实现主要是要进一步了解ELF的格式，所以这里具体细节就不进行考据了。</p><h2 id="linker-script"><a href="#linker-script" class="headerlink" title="linker script"></a>linker script</h2><p>mold的linker script根据解析的过程来看比较简单，没有在ld的脚本中的指定SECTION地址之类的内容，主要是对format以及符号version的一些控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_linker_script</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  current_file&lt;E&gt; = mf;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string_view&gt; vec = <span class="built_in">tokenize</span>(ctx, mf-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">  std::span&lt;std::string_view&gt; tok = vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!tok.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;OUTPUT_FORMAT&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_output_format</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;INPUT&quot;</span> || tok[<span class="number">0</span>] == <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_group</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;VERSION&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">      <span class="built_in">read_version_script</span>(ctx, tok);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok.<span class="built_in">size</span>() &gt; <span class="number">3</span> &amp;&amp; tok[<span class="number">1</span>] == <span class="string">&quot;=&quot;</span> &amp;&amp; tok[<span class="number">3</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      ctx.arg.defsyms.<span class="built_in">emplace_back</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">0</span>])),</span><br><span class="line">                                   <span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">2</span>])));</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SyntaxError</span>(ctx, tok[<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;unknown linker script token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h2><p>object file是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_object_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  ObjectFile&lt;E&gt; *file = ObjectFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf, archive_name, in_lib);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mold以链接速度快出名，而其快的原因之一就是充分利用了多线程，实际进行多线程操作的地方是在这里，ctx.tg.run，tg则是一个tbb::task_group，简而言之就是在这里开启了多线程的解析input file。</p><p>做了一些简单的in_lib参数处理，因为archive的链接机制默认是按需链接，而不是像shared file一样全部链接，之后在这里创建了object file并且开始parse。关于创建和parse的细节在后面再说。</p><h2 id="shared-file"><a href="#shared-file" class="headerlink" title="shared file"></a>shared file</h2><p>shared file同样是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SharedFile&lt;E&gt; *</span></span><br><span class="line"><span class="function"><span class="title">new_shared_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  SharedFile&lt;E&gt; *file = SharedFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里做了和object file类似的事情。</p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>在详细讲解object file和shared file创建以及解析之前先介绍一下他们和InputFile类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled.png"                      alt="Untitled"                ></p><p>ObjectFile和SharedFile都是简单的从InputFile中继承下来的。而这里的InputFile更像是代表了一个输入的ELF文件，构造的过程中做了一些ELF的基础解析，同时还提供了一些通用的接口，交由ObjectFile和SharedFile各自实现。</p><p>我们来看一下InputFile的构造函数部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">InputFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : <span class="built_in">mf</span>(mf), <span class="built_in">filename</span>(mf-&gt;name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfEhdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: file too small&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(mf-&gt;data, <span class="string">&quot;\177ELF&quot;</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: not an ELF file&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfEhdr&lt;E&gt; &amp;ehdr = *(ElfEhdr&lt;E&gt; *)mf-&gt;data;</span><br><span class="line">  is_dso = (ehdr.e_type == ET_DYN);</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *sh_begin = (ElfShdr&lt;E&gt; *)(mf-&gt;data + ehdr.e_shoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shnum contains the total number of sections in an object file.</span></span><br><span class="line">  <span class="comment">// Since it is a 16-bit integer field, it&#x27;s not large enough to</span></span><br><span class="line">  <span class="comment">// represent &gt;65535 sections. If an object file contains more than 65535</span></span><br><span class="line">  <span class="comment">// sections, the actual number is stored to sh_size field.</span></span><br><span class="line">  i64 num_sections = (ehdr.e_shnum == <span class="number">0</span>) ? sh_begin-&gt;sh_size : ehdr.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; (u8 *)(sh_begin + num_sections))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: e_shoff or e_shnum corrupted: &quot;</span></span><br><span class="line">               &lt;&lt; mf-&gt;size &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_sections;</span><br><span class="line">  elf_sections = &#123;sh_begin, sh_begin + num_sections&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line">  <span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">  i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">    ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br><span class="line"></span><br><span class="line">  shstrtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shstrtab_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从文件大小和文件头部标识信息进行ELF的校验，其次是做一些简单的解析。根据代码中可知，整个文件最开始的部分即可作为一个ElfEhdr（Ehdr：Elf Header）</p><p>根据header的信息可以解析出是否为dso文件，ElfShdr（Shdr：Section Header）的起始地址和长度，以及shstrtab（Section Header String Table）的位置。</p><p>大多数的参数直接可以获取，但是对于e_shnum和e_shstrndx来说，由于长度只有16bit的限制，因此如果值过大，则会分别存到第一个Shdr的sh_size以及sh_link中。</p><p>那么根据这段代码我们可以看出ELF的文件信息是这样的</p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先是ObjectFile的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt; *</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                      std::string archive_name, <span class="keyword">bool</span> is_in_lib) &#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;(ctx, mf, archive_name, is_in_lib);</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">ObjectFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                          std::string archive_name, <span class="keyword">bool</span> is_in_lib)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf), <span class="built_in">archive_name</span>(archive_name), <span class="built_in">is_in_lib</span>(is_in_lib) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !is_in_lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数被放入了private中，因此必须通过静态的create方法来创建实例。在每次创建的时候会将对应的obj对象放入到全局的ctx.obj_pool中，mold中的内存与生命周期的管理方式则是全部交由ctx保有，到最后一起释放。而对应的obj_pool为了多线程的设计也都使用了并发的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbb::concurrent_vector&lt;std::unique_ptr&lt;ObjectFile&lt;E&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数只是传递了参数，大部分的解析还是在InputFile的构造函数中执行。</p><h2 id="parse过程开始"><a href="#parse过程开始" class="headerlink" title="parse过程开始"></a>parse过程开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  sections.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>());</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_SYMTAB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (symtab_sec) &#123;</span><br><span class="line">    <span class="comment">// In ELF, all local symbols precede global symbols in the symbol table.</span></span><br><span class="line">    <span class="comment">// sh_info has an index of the first global symbol.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;first_global = symtab_sec-&gt;sh_info;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialize_sections</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_symbols</span>(ctx);</span><br><span class="line">  <span class="built_in">sort_relocations</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_ehframe_sections</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symtab-sec"><a href="#symtab-sec" class="headerlink" title="symtab_sec"></a>symtab_sec</h2><p>首先是寻找symtab_sec的过程，寻找段的过程非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ElfShdr&lt;E&gt; *InputFile&lt;E&gt;::<span class="built_in">find_section</span>(i64 type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ElfShdr&lt;E&gt; &amp;sec : elf_sections)</span><br><span class="line">    <span class="keyword">if</span> (sec.sh_type == type)</span><br><span class="line">      <span class="keyword">return</span> &amp;sec;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>symtab_sec不存在的情况多半是strip了，直接在elf中搜索symtab是能搜到的，但是如果strip以后就无法找到这个段了，也就是为空的情况</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%201.png"                      alt="Untitled"                ></p><p>sh_link和sh_info对于不同的section有不同的含义，对于这里的symtab来说sh_info就是保存了第一个global symbol的index，而sh_link就是保存了symbol_strtab的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%202.png"                      alt="Untitled"                ></p><h2 id="initialize-sections"><a href="#initialize-sections" class="headerlink" title="initialize_sections"></a>initialize_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Read sections</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br></pre></td></tr></table></figure><p>针对所有的sections开始处理，以下内容都在个循环体之中</p><h3 id="特殊SHT的处理"><a href="#特殊SHT的处理" class="headerlink" title="特殊SHT的处理"></a>特殊SHT的处理</h3><p>SHT（Section Header Type）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((shdr.sh_flags &amp; SHF_EXCLUDE) &amp;&amp; !(shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">    shdr.sh_type != SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这几个段无法在ELF标准中查到，后来查到了这么一段介绍</p><p>SHF_EXCLUDE：This section is excluded from input to the link-edit of an executable or shared object. This flag is ignored if the SHF_ALLOC flag is also set, or if relocations exist against the section.</p><ol><li>如果alloc被set则失效，因此这里要SHF_EXCLUDE以及SHF_ALLOC都满足条件</li><li>同时sh_type为SHF_LLVM_ADDRSIG且不是relocatable</li></ol><p>关于SHF_LLVM_ADDRSIG</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#id20" >LLVM Extensions — LLVM 17.0.0git documentation<i class="fas fa-external-link-alt"></i></a></p><h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p>首先是关于Group的介绍</p><blockquote><p>This section defines a section group. A section group is a set of sections that are related and that must be treated specially by the linker (see <a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html#section_groups" >below<i class="fas fa-external-link-alt"></i></a> for further details). Sections of type <code>SHT_GROUP</code> may appear only in relocatable objects (objects with the ELF header <code>e_type</code> member set to <code>ET_REL</code>). The section header table entry for a group section must appear in the section header table before the entries for any of the sections that are members of the group.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>在实现中首先是寻找对应group的签名，签名是关联到了一个esym上，而这个符号的索引则是记录在sh_info中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the signature of this section group.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_info &gt;= <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid symbol index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[shdr.sh_info];</span><br><span class="line"></span><br><span class="line">std::string_view signature;</span><br><span class="line"><span class="keyword">if</span> (esym.st_type == STT_SECTION) &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() +</span><br><span class="line">              <span class="keyword">this</span>-&gt;elf_sections[esym.st_shndx].sh_name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些特殊情况的处理。</p><ol><li>跳过wm4</li><li>跳过entries[0]为0的情况</li><li>如果[0]不是GRP_COMDAT则是错误</li></ol><p>之后获取comdat group members，并使用signature来关联一个ComdatGroup</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ignore a broken comdat group GCC emits for .debug_macros.</span></span><br><span class="line"><span class="comment">// https://github.com/rui314/mold/issues/438</span></span><br><span class="line"><span class="keyword">if</span> (signature.<span class="built_in">starts_with</span>(<span class="string">&quot;wm4.&quot;</span>))</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get comdat group members.</span></span><br><span class="line">std::span&lt;U32&lt;E&gt;&gt; entries = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U32&lt;E&gt;&gt;(ctx, shdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: empty SHT_GROUP&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] != GRP_COMDAT)</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported SHT_GROUP format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.comdat_groups)</span>::const_accessor acc</span>;</span><br><span class="line">ctx.comdat_groups.<span class="built_in">insert</span>(acc, &#123;signature, <span class="built_in">ComdatGroup</span>()&#125;);</span><br><span class="line">ComdatGroup *group = <span class="keyword">const_cast</span>&lt;ComdatGroup *&gt;(&amp;acc-&gt;second);</span><br><span class="line">comdat_groups.<span class="built_in">push_back</span>(&#123;group, (u32)i, entries.<span class="built_in">subspan</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>关于上面处理过程中出现的成员的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in context</span></span><br><span class="line">tbb::concurrent_hash_map&lt;std::string_view, ComdatGroup, HashCmp&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ObjectFile</span></span><br><span class="line">std::vector&lt;ComdatGroupRef&lt;E&gt;&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComdatGroupRef</span> &#123;</span></span><br><span class="line">  ComdatGroup *group;</span><br><span class="line">  u32 sect_idx;</span><br><span class="line">  std::span&lt;U32&lt;E&gt;&gt; members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是根据签名关联一个group空，之后将对应group的引用传递给ObjectFile中的comdat_groups</p><p>里面的i就是section的index</p><p>来看一下这个group段的排布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| SectionSize | Group1SectionIndex | Group2SectionIndex | … |</span><br></pre></td></tr></table></figure><p>关于GRP_COMDAT文档中也有提到</p><blockquote><p>This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded.</p></blockquote><h3 id="常规SHT处理"><a href="#常规SHT处理" class="headerlink" title="常规SHT处理"></a>常规SHT处理</h3><p>此处还有很长的特殊段以及开启—gdb-index后需要处理的内容，并非重点，此处先跳过。</p><p>常规处理就是简单创建了一个InputSection</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;sections[i] = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br></pre></td></tr></table></figure><h3 id="Attach-relocation-sections-to-their-target-sections"><a href="#Attach-relocation-sections-to-their-target-sections" class="headerlink" title="Attach relocation sections to their target sections."></a>Attach relocation sections to their target sections.</h3><p>到这里，所有的section已经执行过了一遍，最后再进行关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach relocation sections to their target sections.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_info &gt;= sections.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid relocated section index: &quot;</span></span><br><span class="line">               &lt;&lt; (u32)shdr.sh_info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;target = sections[shdr.sh_info]) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(target-&gt;relsec_idx == <span class="number">-1</span>);</span><br><span class="line">    target-&gt;relsec_idx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对RELA和REL处理，设置上对应的relsec_idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_rela = <span class="built_in"><span class="keyword">requires</span></span>(ElfRel&lt;E&gt; r) &#123; r.r_addend; &#125;;</span><br></pre></td></tr></table></figure><h2 id="initialize-symbols"><a href="#initialize-symbols" class="headerlink" title="initialize_symbols"></a>initialize_symbols</h2><p>这部分的过程主要是将esym转换为Symbol。esym则是ElfSym的缩写，也就是Elf文件中的Symbol定义，而Symbol则是mold中自己定义的，相当于转换为自己想要的格式。</p><p>这里的symtab_sec是parse刚开始的时候寻找的section，对应的符号表不存在则不进行这个过程。首先初始化了local_syms以及第0个符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;all_syms&quot;</span>)</span></span>;</span><br><span class="line">  counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize local symbols</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;first_global);</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].file = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].sym_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="local-symbol"><a href="#local-symbol" class="headerlink" title="local symbol"></a>local symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: common local symbol?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type == STT_SECTION)</span><br><span class="line">      name = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() + <span class="keyword">this</span>-&gt;elf_sections[<span class="built_in">get_shndx</span>(esym)].sh_name;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;local_syms[i];</span><br><span class="line">    sym.<span class="built_in">set_name</span>(name);</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.value = esym.st_value;</span><br><span class="line">    sym.sym_idx = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>())</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(sections[<span class="built_in">get_shndx</span>(esym)].<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先是对于common符号的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_COMMON; &#125;</span><br></pre></td></tr></table></figure><p>关于这个SHN_COMMON</p><blockquote><p>SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.</p></blockquote><p>大意是common的话不能是local，比如这里说的unallocated C external variables，external和local就是冲突的。</p><p>除了报错的common符号之外，其他符号在后面获取对应的名字，如果是section name则去shstrtab中寻找，否则就是常规的符号名，去symbol_strtab中寻找。这里的名字本质上是一个距离对应字符串段的offset，因为字符串相关的数据都统一保存在这shstrtab和symbol_strtab中了。</p><p>之后就是获取local_syms的引用，开始设置对应的信息。</p><p>在最后，对非abs符号的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_ABS; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have <strong>absolute values and are not affected by relocation.</strong></p></blockquote><p>非abs符号，也就是说都是相对地址，会affected by relocation。</p><p>而实际set_input_section则是设置其mask位，用于区分什么性质的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_input_section</span>(InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> addr = (<span class="keyword">uintptr_t</span>)isec;</span><br><span class="line">  <span class="built_in">assert</span>((addr &amp; TAG_MASK) == <span class="number">0</span>);</span><br><span class="line">  origin = addr | TAG_ISEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用2bit区分不同情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol usually belongs to an input section, but it can belong</span></span><br><span class="line"><span class="comment">// to a section fragment, an output section or nothing</span></span><br><span class="line"><span class="comment">// (i.e. absolute symbol). `origin` holds one of them. We use the</span></span><br><span class="line"><span class="comment">// least significant two bits to distinguish type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">  TAG_ABS  = <span class="number">0b00</span>,</span><br><span class="line">  TAG_ISEC = <span class="number">0b01</span>,</span><br><span class="line">  TAG_OSEC = <span class="number">0b10</span>,</span><br><span class="line">  TAG_FRAG = <span class="number">0b11</span>,</span><br><span class="line">  TAG_MASK = <span class="number">0b11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-symbol"><a href="#global-symbol" class="headerlink" title="global symbol"></a>global symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbols.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">i64 num_globals = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="keyword">this</span>-&gt;first_global;</span><br><span class="line">symvers.<span class="built_in">resize</span>(num_globals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = &amp;<span class="keyword">this</span>-&gt;local_syms[i];</span><br></pre></td></tr></table></figure><p>在开始处理之前可以看到这里又有两个resize容器的位置，目前为止有三处，这里写明了对应的容器以及所处的类，用于区分这个信息是否为ObjectFile only的</p><ol><li>local symbols(InputFile)</li><li>symbols(InputFile)</li><li>symvers (ObjectFile)</li></ol><p>之后将local_sym绑定到symbols中</p><p>之后是详细的处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize global symbols</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a symbol name</span></span><br><span class="line">  std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">  std::string_view name = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse symbol version after atsign</span></span><br><span class="line">  <span class="keyword">if</span> (i64 pos = name.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != name.npos) &#123;</span><br><span class="line">    std::string_view ver = name.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    name = name.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ver.<span class="built_in">empty</span>() &amp;&amp; ver != <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">        key = name;</span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">        symvers[i - <span class="keyword">this</span>-&gt;first_global] = ver.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">    has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; symvers;</span><br></pre></td></tr></table></figure><p>这里不需要再区分是否为Section的符号，因为global符号不包含section符号。</p><p>这里最主要的是需要解析symbol version，因为有的符号会依赖于版本号。要注意的是这个东西并非ELF的官方定义，而是GNU的一个扩展，因此去看elf specification是找不到的。关于名称规范也很简单，常规符号名后接@加符号版本</p><p>解析符号版本完成后设置到symvers中，关于这个版本号，最常见的就是GLIBC，以下是本机helloworld代码的示范</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/tmp &gt; nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line"> w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"> U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line"> U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>之后是insert symbol，并且设置其common属性。要注意除了这些解析方式外，global symbol和local symbol相比还有一个比较隐藏的不同，global symbol没有设置对应的file，后面很多符号的处理会进行判断file。</p><p>接下来是insert symbol的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a symbol object for a given key. This function handles</span></span><br><span class="line"><span class="comment">// the -wrap option.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Symbol&lt;E&gt; *<span class="title">insert_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string_view key, std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; name.<span class="built_in">starts_with</span>(<span class="string">&quot;__real_&quot;</span>) &amp;&amp;</span><br><span class="line">      ctx.arg.wrap.<span class="built_in">contains</span>(name.<span class="built_in">substr</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">7</span>), name.<span class="built_in">substr</span>(<span class="number">7</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym-&gt;wrap) &#123;</span><br><span class="line">    key = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(key));</span><br><span class="line">    name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(name));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">save_string</span><span class="params">(C &amp;ctx, <span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">  u8 *buf = <span class="keyword">new</span> u8[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">  buf[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  ctx.string_pool.<span class="built_in">push_back</span>(std::unique_ptr&lt;u8[]&gt;(buf));</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)buf, str.<span class="built_in">size</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不只是不存在key就创建key并返回那么简单。</p><ol><li>关于save_string的问题，这里也是和之前一样，创建了string后由ctx来管理生命周期，返回一个string_view提供使用。</li><li>除此之外get_symbol的部分是实际执行了符号不存在则创建新符号并且返回的工作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we haven&#x27;t seen the same `key` before, create a new instance</span></span><br><span class="line"><span class="comment">// of Symbol and returns it. Otherwise, returns the previously-</span></span><br><span class="line"><span class="comment">// instantiated object. `key` is usually the same as `name`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">Symbol&lt;E&gt; *<span class="title">get_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.symbol_map)</span>::const_accessor acc</span>;</span><br><span class="line">  ctx.symbol_map.<span class="built_in">insert</span>(acc, &#123;key, Symbol&lt;E&gt;(name)&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Symbol&lt;E&gt; *&gt;(&amp;acc-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最后提一下-wrap option选项</li></ol><p>这个-wrap是在main中read_input_files之前的地方设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --wrap options if any.</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.wrap)</span><br><span class="line">  <span class="built_in">get_symbol</span>(ctx, name)-&gt;wrap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>关于这个选项我参考了这个回答里的内容，虽然是gcc的介绍，但是本质是相同的</p><p><a href="https://stackoverflow.com/questions/46444052/how-to-wrap-functions-with-the-wrap-option-correctly">How to wrap functions with the <code>--wrap</code> option correctly?</a></p><p>我摘选了一些关键的段落</p><blockquote><p>-wrap=symbol<br>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.<br>…<br>If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.</p></blockquote><blockquote><p>… Any <strong>undefined reference</strong> to symbol will be resolved to “__wrap_symbol”. Any <strong>undefined reference</strong>  to “__real_symbol” will be resolved to symbol.</p></blockquote><p>至此，initialize_symbols就结束了</p><h2 id="sort-relocations"><a href="#sort-relocations" class="headerlink" title="sort_relocations"></a>sort_relocations</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relocations are usually sorted by r_offset in relocation tables,</span></span><br><span class="line"><span class="comment">// but for some reason only RISC-V does not follow that convention.</span></span><br><span class="line"><span class="comment">// We expect them to be sorted, so sort them if necessary.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">sort_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> less = [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.r_offset &lt; b.r_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i];</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">is_sorted</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), less))</span><br><span class="line">        <span class="built_in">sort</span>(rels, less);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，这里的sort是为了将不遵守约定没按照r_offset排序的rv的relocations转换为遵循约定的格式</p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>关于这里的内容比较长，不仅要包含解析本身，还有ehframe本身的内容，因此留到下期再继续讲。</p><h1 id="图解总结"><a href="#图解总结" class="headerlink" title="图解总结"></a>图解总结</h1><p>画了一些比较粗糙的图示将今天的内容串联起来（未标记长度信息，部分大小不标准，没精力画了）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%203.png"                      alt="Untitled"                ></p><p>首先是读取InputFile时的流程，主要是ElfHeader指向ELF文件的哪一部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%204.png"                      alt="Untitled"                ></p><p>其次是读取Section的时候符号表相关的查找流程，这里还没来得及画具体取名字的部分</p><p>从Section Header Table中找到对应sh_type为SHT_SYMTAB的段，之后根据offset和size找到具体存放symbol的位置，同时通过sh_info确定第一个global symbol的index</p><h1 id="参考资料汇总"><a href="#参考资料汇总" class="headerlink" title="参考资料汇总"></a>参考资料汇总</h1><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >Sections<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://refspecs.linuxfoundation.org/elf/elf.pdf" >Elf Specification 1.2<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-1-read-in</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>美丽新世界</title>
    <link href="https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/"/>
    <id>https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/</id>
    <published>2023-02-19T13:25:02.000Z</published>
    <updated>2023-02-19T13:25:58.736Z</updated>
    
    <content type="html"><![CDATA[<p>起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。</p><blockquote><p>到最后，孩童的心灵就是这些暗示，暗示的总和就是孩童的心灵。而且不只是孩童的心灵，成人的心灵也是——一辈子都是。下判断、产生欲望、做决定的那个心灵——就由这些暗示构成。但这所有暗示都是我们的暗示！</p></blockquote><p>这哪里美丽了，这简直是地狱。</p><p>但是读到后面，我开始动摇了。在这里的人只需要舒适就可以了，无需遭受病痛的折磨，每个人之间都彼此相属也就因此不会因为孤单而痛苦，甚至不需要思考，顺从周围的人以及大脑中已经调整好的暗示去做就好了。即便遇到不如意的事情，还有索麻来将他们从痛苦的当下逃离。</p><blockquote><p>因为我们的世界跟奥瑟罗的世界不同了。你无法不用钢铁来制造福利佛——而没有不稳定的社会，你也不可能创造出悲剧。这个世界现在稳定了。人人都很快乐，他们得到他们想要的东西，而他们永远不会想要他们得不到的。他们很富裕，他们很安全，他们从不生病，他们不怕死，他们幸福地不知何谓激情与老迈，他们没有母亲或父亲的折磨，他们没有妻子、孩子或爱人可以激起强烈的感觉，他们被制约得这么厉害，以至于他们实际上忍不住要表现出他们应有的行为。而要是有任何事情出了错，还有索麻</p></blockquote><p>而上面提到的丧失自由，被歧视，阶级固化等内容，对于”劣等“的人种自身来说并不是什么问题，他们也从来没有觉得这是什么问题。这里的人们也并非丧失了所有的自由，他们有着局限于新世界法则的自由，对于他们来说这样就可以了。所有的消息渠道都不会让他们了解一切的真相，只要他们不了解，继续蒙在鼓里，那么就不会感到任何痛苦。</p><blockquote><p>对他们而言，他们不是牺牲品，他们是最没有抗拒能力的品系。他的制约已经铺好他该沿着哪条铁轨前进。他无法克制自己不这样做，他注定如此。</p></blockquote><p>遭受痛苦与折磨的我无法否认自己读到这里产生了对这种环境的向往，尽管有最初那么多令人反感的描述，尽管明知代价是失去自我、放弃真正的自由、放弃崇高的精神，但这里的人不需要承受痛苦，只需要舒适就可以了。这样撒手不管是很轻松，我想大多数人也都是更倾向于这样的选择，不去产生改变。</p><p>如果身为当局者的话很难对这些问题进行讨论与判断，想法会受到世界本身的限制，如果我是那个世界中的一员，那么我大概率也是会和大多数人一样认为所谓真正的自由、痛苦都很荒谬。接下来还是回到旁观者的上帝视角来看待这一切。以上提到的内容在新世界中是完全对立的：是选择要自我、自由与痛苦，还是舒适和快乐。</p><p>如管制官所说</p><blockquote><p>强调的重点从真理与美转移到舒适与快乐。<br>普遍的快乐，让轮子稳定地转动下去，真理与美却做不到。</p></blockquote><p>新的世界也是如此形成的。追求真理与美是不可能舒适与快乐的，真理与美来自于经历苦难，破坏性的变化。这让我想起加缪的《快乐的死》中提到的观点，高质量的幸福需要通过痛苦体现。同时在管制官和野人的对话中屡次出现莎士比亚的作品，其作品以悲剧美而闻名，也是一个很好的例子。沉溺在舒适与快乐之中无法寻求到真理，每种科学的发现都有潜在的破坏性，而要突破这种破坏性并不会使得舒适与破坏性。在舒适和快乐中也无法体现出人性的美，罗翔老师举过一个例子。</p><blockquote><p>如果现在有一个小黄书，郭德纲相声，一个莎士比亚，三者都会给你带来一些快乐。但是你即便真诚的认为小黄书给你带来了愉悦，郭德纲的相声给你带来了快乐，但只能留一本书，你留哪本书？莎士比亚。这个故事告诉我们，越能体现人性尊严的快乐，越是一种最大的快乐，因为它跟人的尊严有关。</p></blockquote><p>对于“新世界”来说，他们无法得知这一切，大部分人也没有选择的权利。对于现实社会来说，我们完全可以了解到这一切，并且两者都选择，只是或多或少罢了。还是如罗翔老师所说</p><blockquote><p>我读莎士比亚并不妨碍我听郭德纲的相声，但是如果你的眼目永远只关心地下，你永远不知道向上看有多么快乐。</p></blockquote><p>不过我们现在所处的“小小世界”，在许多方面已经有了这样的影子，逐渐开始失去了选择的权利。从想法来说，所谓人们的想法就是来自所处的环境、所处的社会、所接触到的地域文化，这让我想到了某些洗脑的宣传，以及不断试图阻挡人们看到真相的，某个大家都很熟知的地方。既然你无法得知真相与其他答案，面前只有一个选项，那么你很大概率不会去考虑这个选项的对与错。除此之外，我还想到了昨天和朋友聊天的时候他提到的“异化”一词</p><blockquote><p>所谓的「自由而来的不自由」。你有一定的自由分工、自由迁徙的能力，但是正是由于深度的投入到了某个社会分工内而被困在了这个环境下的「不自由」。</p></blockquote><p>这个“世界”的人们都是如此，渐渐开始失去了部分的自由，而这份不自由也正是由所处的这个“世界”所造成的。大部分人像阿尔法一样遵循着一直以来的”睡眠教学法“，有的人们像伯纳德一样略微窥探到了一些，有的人像管制官一样看到了全部，即便看到了一切，但我们仍然是被禁锢着，只是所在的“瓶子”或许没有那么小但是不知道哪一天这个瓶子可能会缩到非常小，我想这也正是作者所担忧的事情，担心人们连自己选择一切的权利都失去了，担心人们人生的一切都是被安排的。</p><p>这样的世界我无法断言好还是坏。如果选择经历苦难，那么你要具备面对苦难的能力，你要不断的经历痛苦以及发现真理与美。如果你选择舒适与快乐，那么你将放弃自我，放弃自由。管制官与“野人”的选择则是非常强烈的对比，两者在得知了一切并且有选择权的情况下，一个选择了前者，另一个选择了后者。不论选择哪一个，其实都要付出代价。在这样的世界，绝大部分人其实是没有选择的权利的，但是在现实世界中绝大部分人依然有选择的权利，如果只能在这两者之间选择，你是要成为野人，还是管制官呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;到最后</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="奥尔德斯·赫胥黎" scheme="https://fusionbolt.github.io/tags/%E5%A5%A5%E5%B0%94%E5%BE%B7%E6%96%AF%C2%B7%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>心理咨询是怎样的</title>
    <link href="https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/"/>
    <id>https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/</id>
    <published>2023-02-18T14:30:49.000Z</published>
    <updated>2023-02-18T14:56:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。</p><p>首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询师进行商定，间隔超过一周可能时间太久内容难以连贯，少于一周可能费用上更难接受一些，即便是最便宜的档次一周一次，一个月也要2000的费用，更何况这是一项长期的工作，<strong>如果你能接受这个价格再继续看下去</strong>。流程上也没有什么特别的，预约时间，当天到咨询师所在的地方进行一小时左右的沟通，基本上是一对一。（这里咱不探讨团体咨询以及多人咨询）</p><p>咨询的方式有着不同的流派，而不论是什么流派，咨询的过程都是沟通为主。咨询师会问你各种问题，又或者由你自己挑起某些话题，如果可以还是自己选择某些比较关心的话题开场比较好，而具体的话题会因流派不同而异。有的流派会倾向于长期咨询，有的会倾向于短期解决问题，在选择的时候还是需要注意，通常咨询之前也会问你是想要进行短期还是长期的咨询ty。我在此更建议长期的咨询，首先咨询师需要几次对话充分了解你，你也需要几次机会去熟悉跟咨询师去讲述一些事情，后面需要更长的周期去一点点深入自己的内心，一点点的去修复问题。在对话的过程中，通常会涉及到你的许多想法、感受、过去、秘密、家庭、人际关系等等，同时在这个交流沟通的过程中，会不断探寻自己的内心，有的时候就戳到痛处，如果要选择咨询，要做好暴露一切的心理准备。有的人并不在意和陌生人讲这些，但也有的人面对陌生人会比较难以说出这些，这些人群需要一定时间去适应，也不必觉得因为自己不想说就完全不适合去咨询。咨询时有什么不适的感受也都尽情的跟咨询师提出，不用担心提出意见会有什么攻击性的反应，我之前对咨询师的一些问法感到厌烦，及时和咨询师进行沟通，这种厌烦感也就慢慢结束了。</p><p>在我目前的理解与体验咨询主要以两种形式起作用。第一种是感性上的支持，对于心里积攒着很多想法的人来说，咨询师会耐心倾听你的诉说，在这个过程中你可以放心的讲你所不愿跟别人讲的秘密，或者你认为会被人厌烦的内容，不必担心被人拒绝，被人讨厌。而对于孤单的人来说，咨询师也是一个每周陪伴你的人，不会因为你做错了什么就会放弃你。他们会给予你情感上的支持，在你遇到问题会与你产生共情。第二种则是理性上的支持，对于需要咨询的人来讲，通常会有许多思维的误区，而找出这些误区也是咨询师们的工作之一。另外还会对你一些具体的问题会给出建设性的建议，最关键的是和你一起分析你的问题，你的思维方式，作为一个旁观者，而不是作为你自己来观察这一切，远比自己观察的要清楚。你需要明白这些，在这个过程中你可能会学会自己查找自己的问题，同时还会增强你对于自己问题的修正。</p><p>以下是《神经症与人的成长》这本书中的摘录</p><blockquote><p>所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。</p></blockquote><blockquote><p>此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互间的作用。</p></blockquote><blockquote><p>了解所有的这些因素，并非指懂得这些因素的死知识，而是意指要彻底地去认识它们。</p></blockquote><p>对于一些十分特别的流派或许会有其他更特别的解决方式，这里暂且不谈论。</p><p>不论如何起作用，心理咨询的过程是一个不断探寻自己内心的过程，看到现在的自己和过去的联系，而目的是为了让你重新找回对抗问题的力量，而不是帮助你解决所有问题。理解了一个又一个的问题，解决了一个又一个问题的过程，同时也是在不断增强自身力量的过程。</p><p>也许你会在纠结到底要不要进行咨询，你不如换个问题，你想要通过咨询获得什么？对于我来说，通常会对自己的想法进行基本的觉察与反思，也并没有什么一定要跟别人倾诉的苦水，我需要一个人从外部来看待我，帮助我更快的解决自己的问题，找到我自己难以看到的想法中的误区，毕竟“当局者迷”，同时想要有人跟我深入的探讨一些个人成长与性格中的一些问题。事实上我最近三次的咨询也确实达到了期望的效果。这些问题没法跟认识的绝大部分人去交流，有的人不关心这些，有的人不愿意聊这些，或者说没有那么要好的朋友，谈论这些内容或许是需要非常深入密切的关系才行，你需要袒露你内心中的秘密，你要愿意将这个秘密讲出来，而对方也要愿意接受你的秘密，愿意帮助你解决这些问题。</p><p>在这里要认清一些思维误区。首先并不是去咨询了就一定能解决任何问题，也不是依靠咨询师就能解决大部分问题，咨询师只是辅助你解决问题，最终还是需要你自己去真正改变想法。其次咨询并不是什么丢人的事情，或许在大众的认知中去接受心理咨询就是所谓的“神经病“，但我想你看了上面的内容后或许不会这样想，即便是这个领域大师级别的人物仍然需要他人帮助自己进行心理咨询。</p><p>如果想要了解更多关于心理咨询的过程或者其他内容，可以参考《也许你该找个人聊聊》。另外个人十分推荐《神经症与人的成长》，书中的一些分析讲的非常棒，非常有助于理解自己的一些问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。&lt;/p&gt;
&lt;p&gt;首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="心理咨询" scheme="https://fusionbolt.github.io/tags/%E5%BF%83%E7%90%86%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其零 main</title>
    <link href="https://fusionbolt.github.io/2023/02/12/mold/mold-0/"/>
    <id>https://fusionbolt.github.io/2023/02/12/mold/mold-0/</id>
    <published>2023-02-12T14:06:32.000Z</published>
    <updated>2023-02-19T05:33:14.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/FWlv3FsaMAAdSs2-20230212221048408.jpeg"                      alt="图像"                ></p><p>我们从main函数的开始，大致讲一下都做了哪些事情。之后再从每个流程中的具体实现开始阅读（如果我记得的话会回头在这里补上对应的链接），或者会以解决某些问题为线索写一篇，比如说某一些常见的参数具体在mold中怎么生效的，比如说whole_archive这种。为保证两部分文章内容的连贯性，内容不可避免会有一定重叠。</p><p>这个系列的一些约定</p><ol><li>只考虑elf的支持，其他平台相关的不再考虑</li><li>文件路径都是项目根目录的相对路径</li></ol><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>由于代码比较少，项目的结构非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── docs</span><br><span class="line">├── elf</span><br><span class="line">├── test</span><br><span class="line">│   └── elf</span><br><span class="line">└── third-party</span><br><span class="line">    ├── mimalloc</span><br><span class="line">    ├── rust-demangle</span><br><span class="line">    ├── tbb</span><br><span class="line">    ├── xxhash</span><br><span class="line">    ├── zlib</span><br><span class="line">    └── zstd</span><br></pre></td></tr></table></figure><p>根目录下有一些共用的文件以及一些项目的常规文件</p><p>启动的main函数也是在根目录下</p><p>在elf目录下是我们需要看的主要核心代码</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/Untitled.png"                      alt="Untitled"                ></p><p>在这之中有两个作为主线的文件: main.cc和passes.cc</p><p>实际执行链接的主要流程都存放在main.cc的elf_main中，而这个过程执行的代码大多会指向passes.cc中的函数。不同目标arch的文件都用相应的文件名区分开了，以及其他的文件看名字也相对比较易懂。</p><h1 id="链接前的准备流程"><a href="#链接前的准备流程" class="headerlink" title="链接前的准备流程"></a>链接前的准备流程</h1><p>main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  mold::mold_version = mold::<span class="built_in">get_mold_version</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MOLD_IS_SOLD</span></span><br><span class="line">  std::string cmd = mold::<span class="built_in">filepath</span>(argv[<span class="number">0</span>]).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">  <span class="keyword">if</span> (cmd == <span class="string">&quot;ld64&quot;</span> || cmd == <span class="string">&quot;ld64.mold&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mold::macho::<span class="built_in">main</span>(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mold::elf::<span class="built_in">main</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elf/main.cc</p><p>默认采用了X86_64</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elf_main&lt;X86_64&gt;(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的Machine Type是通过模板类型来区分的。在elf_main里面创建了全局的Context对象（并非是代码实现层面上的全局对象，只是所有的流程都需要传递ctx）并且解析命令行参数（命令行参数的具体实现就不再细看了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">elf_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  Context&lt;E&gt; ctx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process -run option first. process_run_subcommand() does not return.</span></span><br><span class="line">  <span class="keyword">if</span> (argc &gt;= <span class="number">2</span> &amp;&amp; (argv[<span class="number">1</span>] == <span class="string">&quot;-run&quot;</span>sv || argv[<span class="number">1</span>] == <span class="string">&quot;--run&quot;</span>sv)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(__APPLE__)</span></span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;-run is supported only on Unix&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">process_run_subcommand</span>(ctx, argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse non-positional command line options</span></span><br><span class="line">  ctx.cmdline_args = <span class="built_in">expand_response_files</span>(ctx, argv);</span><br><span class="line">  std::vector&lt;std::string&gt; file_args = <span class="built_in">parse_nonpositional_args</span>(ctx);</span><br></pre></td></tr></table></figure><p>获取具体的machine_type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If no -m option is given, deduce it from input files.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emulation == MachineType::NONE)</span><br><span class="line">  ctx.arg.emulation = <span class="built_in">deduce_machine_type</span>(ctx, file_args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redo if -m is not x86-64.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, X86_64&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(ctx.arg.emulation != MachineType::X86_64)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> redo_main&lt;E&gt;<span class="params">(argc, argv, ctx.arg.emulation)</span></span>;</span><br></pre></td></tr></table></figure><p>redo_main就是简单的根据命令行参数指定的target来选择对应的模板类型进行特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">redo_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, MachineType ty)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ty) &#123;</span><br><span class="line">  <span class="keyword">case</span> MachineType::I386:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;I386&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM32:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM32&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V1:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V1&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V2:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V2&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::S390X:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;S390X&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::SPARC64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;SPARC64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::M68K:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;M68K&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接大体流程"><a href="#链接大体流程" class="headerlink" title="链接大体流程"></a>链接大体流程</h1><p>根据注释和我个人的理解，分为如下这么几大部分</p><ol><li>解析所有的输入，包含命令行参数，输入的各种文件</li><li>对于输入做链接器最基本的处理，包含符号解析，段合并，符号检查之类的</li><li>创建一些synthetic的内容，包括一些段和符号</li><li>将所有段、符号进行扫描以及按照需求进行排序，添加到全局的ctxt中</li><li>计算与修正一些具体的信息，固定生成产物的memory layout</li><li>修正某些地址，确保固定file layout</li><li>将所有文件拷贝到输出文件中</li><li>结束的清理操作</li></ol><p>其中有些地方可以根据Timer来协助划分链接的流程。比如说拷贝到输出之前有这样一行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timer <span class="title">t_copy</span><span class="params">(ctx, <span class="string">&quot;copy&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>而到了后面的部分有这么一行对应，中间的部分很自然就是这一个步骤做的事情了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_copy.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure><p>而main函数中的内容比较简洁，几乎每个小功能都划分为了一个函数，而且附加了大量的注释，比如说这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><p>再加上代码比较长，这里就不放后续完整代码了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-0/FWlv3Fs</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>链接器起始篇</title>
    <link href="https://fusionbolt.github.io/2023/01/17/linker/linker-init/"/>
    <id>https://fusionbolt.github.io/2023/01/17/linker/linker-init/</id>
    <published>2023-01-17T12:31:34.000Z</published>
    <updated>2023-01-17T12:27:42.292Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/linker-init/Untitled.jpeg"                      alt="Untitled"                ></p><p>又开始不务正业乱开新坑了。接下来会通过阅读mold的源码来学习如何实现一个ELF链接器，有精力也会再跟着plct的这个课程学习实现一个简单的RV ELF链接器，可能会跟着将代码换一门语言翻译一遍，将这个学习过程中遇到的知识点记录到博客中。如果坑能开到后面的话我还会针对这门课程实现的链接器在功能上与mold的进行比较，一门教学用的链接器和真正实用的链接器在功能上有哪些差别。</p><p><a class="link"   href="https://github.com/rui314/mold" >https://github.com/rui314/mold<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ksco.cc/rvld/" >index<i class="fas fa-external-link-alt"></i></a></p><p>从未了解过链接器实现的我，在跟着mold源码和这门课程之前，先来写一下根据我现有的知识去设想一个链接器内部应该大致有哪些功能。（本期内容不是教程，只是我个人对知识的回忆，因此很多地方都会缺很多东西）同时回忆过后对比检查理解的问题，在差不多理解整体运作过程的情况下学习会更有效一些。</p><h1 id="链接器做了什么"><a href="#链接器做了什么" class="headerlink" title="链接器做了什么"></a>链接器做了什么</h1><ol><li>链接器做的事情是将多个编译器生成的目标文件的内容合到一起</li><li>处理符号。在编译期间要求编译生成的目标文件中每个符号小于等于一个定义，在链接的时候链接器负责找到未定义的符号的地址，重复符号的解决（如果是弱符号则根据规则选取其中一个定义，如果非弱符号则需要报错）</li></ol><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>要合并目标文件那么我们要知道目标文件的内容是什么样的（这里我们仅探讨ELF的格式）。先不查阅文档，想一下目标文件大概会有什么内容。</p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>首先是对于我们写代码的时候经常提到的一些段，比如说代码段、数据段、BSS段、堆、栈等等。这些段本身只是一串数据，那么我们需要一个位置存放起始位置和数据长度。而其中的各种段名以及各种符号名也需要一个位置保存，因此目标文件中还需要有一个符号段用于保存各种用于链接使用的符号。（strip是否就是去掉这里）我们知道debug模式生成的代码包含debug信息，而这些信息对于elf来说是写在内部的，因此里面还需要有保存调试信息的段。</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>类似于段段起始和长度这种</p><p>寻找保存具体信息的信息需要放到一个文件头中，除此之外文件头中还需要一些魔数来标识文件类型。</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>保存所有代码中符号的相关信息（而不是段名的符号），最容易想到的就是地址，其次上面提到了符号的强弱。</p><h1 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h1><p>而更精细控制这些行为的方式一个是命令行参数，另一个是链接脚本。由于系统中内置了默认的链接脚本，我们日常很少会接触到这些。读取链接脚本也是链接器很重要的一个功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下来，链接器主要的功能如下</p><ol><li>读取目标文件ELF文件头</li><li>读取链接脚本并且按照链接脚本控制链接行为</li><li>符号解析</li><li>合并段</li><li>生成对应的ELF文件</li></ol><p>而plct课程的大纲如下</p><p>第一课：搭建开发环境、初始化项目、开始读取 ELF 文件</p><p>第二课：继续读取 ELF 文件</p><p>第三课：解析链接器参数</p><p>第四课：解析静态链接库文件</p><p>第五课：解析未定义符号，移除未使用文件</p><p>第六课：处理 Mergeable Sections</p><p>第七课：开始写文件</p><p>第八课：处理 Output Sections</p><p>第九课：继续处理 Output Sections</p><p>第十课：Phdr 和 Merged Sections</p><p>第十一课：处理重定向，课程回顾</p><p>可以说做的功能大致类似，之后就会先从mold的源码开始开新系列了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/linker-init/Un</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
  </entry>
  
  <entry>
    <title>调试器之工作原理</title>
    <link href="https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/"/>
    <id>https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/</id>
    <published>2023-01-09T15:27:58.000Z</published>
    <updated>2023-01-09T15:30:36.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试器之工作原理"><a href="#调试器之工作原理" class="headerlink" title="调试器之工作原理"></a>调试器之工作原理</h1><p>之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么实现运行时断点的。今天来简单了解一下调试器部分功能的工作原理。</p><h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>对于调试来说第一步是要下断点。断点本质是到了指定位置后中断当前的进程，进入对应的中断处理程序。（信号的本质是软中断，这里、统一称发生了中断）</p><p>根据实现方式的不同分为如下三类。</p><h2 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h2><p>当cpu执行了特定调试指令后会发出一个中断，而软件断点要做的就是在对应的pc位置“插入”断点指令，说是插入，实际上是修改原指令，触发中断后再写回。</p><p>以x86的INT3指令为例，在一个位置设置断点后会保存该位置的原指令，之后在该位置写入INT3，当执行到这条指令的时候发生软中断，内核向子进程发送SIGTRAP信号，之后这个信号转发给父进程，此时再用保存的指令替换之前写入的INT3指令等待中断恢复。</p><h2 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h2><p>某些cpu包含调试用的寄存器，通过设置对应的值来控制对应产生中断的pc位置以及一些其他信息。</p><p><a class="link"   href="https://en.wikipedia.org/wiki/X86_debug_register" >x86 debug register - Wikipedia<i class="fas fa-external-link-alt"></i></a></p><p>cpu在执行代码之前会先确定要执行的地址是否保存在中断寄存器中，同时确认访问的地址是否处于设置了硬件断点的区域内，满足条件后会触发INT1中断。</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>通过设置对应内存位置所在页为guard page，对保护页访问则会触发异常，之后页面恢复访问前的状态。</p><h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p>Linux中我们可以直接通过ptrace来打断点、读取信息或者是单步执行等。</p><p>关于ptrace的文档：<a class="link"   href="https://man7.org/linux/man-pages/man2/ptrace.2.html" >https://man7.org/linux/man-pages/man2/ptrace.2.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h2><p>首先我们来看一下用法示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = <span class="built_in">ptrace</span>(PTRACE_PEEKUSER,child, <span class="number">4</span> * ORIG_EAX,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child made a &quot;</span><span class="string">&quot;system call %ld\n&quot;</span>, orig_eax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被调试的程序通过ptrace(PTRACE_TRACEME)来设定自身是被trace的对象，接着通过execl来执行对应的命令行程序，此时执行的程序作为调试器的子进程。</p><p>而调试器进程本身则是通过wait去等待子进程停下来，等wait返回后就可以查看子进程的信息或者对子进程进行操作。对于ptrace使用方面来说最重要的是选择合适的__ptrace_request，大多数调试器常见的功能都能通过设置这个参数来实现，比如说单步。</p><p>这个项目使用ptrace实现了许多debug的基础功能</p><p><a class="link"   href="https://github.com/Kakaluoto/ptraceDebugger" >https://github.com/Kakaluoto/ptraceDebugger<i class="fas fa-external-link-alt"></i></a></p><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>通过设置__ptrace_request为PTRACE_ATTACH或者PTRACE_SEIZE还可以调试一个当前已经启动的进程。</p><p>对于常规的调试和attach的本质区别自然是进程间的关系，直接调试中调试器进程和被调试进程互为父子进程，而attach时两者是独立的，也因此有的时候attch会需要管理员权限。</p><h1 id="其他系统"><a href="#其他系统" class="headerlink" title="其他系统"></a>其他系统</h1><p>以上ptrace的实现都是基于Linux的api来讲的，macOS的ptrace的request缺少非常多基本功能，比如说读取寄存器的值。如果想要在mac下实现可以参考如下链接，如果是arm的Mac则这里很多接口仍然过时。（我反正不想折腾了，有这时间多看下Linux的不香吗）</p><p><a class="link"   href="http://uninformed.org/index.cgi?v=4&a=3&p=14" >Uninformed - vol 4 article 3<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.spaceflint.com/?p=150" >Using ptrace on OS X<i class="fas fa-external-link-alt"></i></a></p><p>而对于windows来说则是提供了另一套完全不同的api，有兴趣的可以自行了解。</p><p><a class="link"   href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-engine-and-extension-apis" >Debugger Programming Extension APIs - Windows drivers<i class="fas fa-external-link-alt"></i></a></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>这一期的内容都是一些非常容易搜到的基础知识，如果不鸽的话调试器后面会继续深入学习，造一个自己的debugger之类的。大概也会作为一个系列更新，可能深入的方向有如下几个</p><ol><li>ptrace的具体实现细节代码</li><li>debug信息的格式以及源码级调试</li><li>lldb的学习</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试器之工作原理&quot;&gt;&lt;a href=&quot;#调试器之工作原理&quot; class=&quot;headerlink&quot; title=&quot;调试器之工作原理&quot;&gt;&lt;/a&gt;调试器之工作原理&lt;/h1&gt;&lt;p&gt;之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么</summary>
      
    
    
    
    <category term="Debugger" scheme="https://fusionbolt.github.io/categories/Debugger/"/>
    
    
    <category term="ptrace" scheme="https://fusionbolt.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/"/>
    <id>https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/</id>
    <published>2022-12-31T14:59:28.000Z</published>
    <updated>2022-12-31T15:08:11.573Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。</p><h1 id="去年的愿景"><a href="#去年的愿景" class="headerlink" title="去年的愿景"></a>去年的愿景</h1><p>去年的愿景许多方面我没有非常明确具体的目标，这对实现目标来说恰恰是致命的。以下这段来自我去年的年终总结</p><blockquote><p>不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的</p><p>想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升</p><p>想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西</p><p>自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈</p><p>想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等</p><p>明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战</p></blockquote><p>去年的年终总结：<a class="link"   href="https://homura.live/2021/12/26/Summary/summary-2021/" >https://homura.live/2021/12/26/Summary/summary-2021/<i class="fas fa-external-link-alt"></i></a></p><h2 id="身心健康"><a href="#身心健康" class="headerlink" title="身心健康"></a>身心健康</h2><p>按我现在的状态怎么都算不上身心健康。今年去体检查出一大堆的小问题，其中一项还影响到了脑血管，某种物质代谢不完全残留在血液中，导致容易形成了斑块，大概是基因加饮食习惯的问题，及时查出来也算是好事，补充了一些维生素B族后相关参数明显恢复正常值了，还没来得及再复诊。</p><p>精神状况今年一开始的时候状态还算可以，但是2月底有一次我超负荷运转了两三天，之后开始各种不太好。4月去医院大夫又加了新的药，后来6月底为了改善睡眠质量加上了安眠药，几个月后我发现这个大夫一直有问题就加药，同时每次和这个大夫沟通都感觉被当傻子一样对待，于是我又换了大夫，这个大夫让我停掉了安眠药。在这个不断换药的途中不论是睡眠还是精神状态都没有趋于稳定。</p><p>说到健康一定离不开锻炼。这方面确实做得不够，每次都是锻炼了一段时间就因为各种各样的理由暂停了。也不是多么讨厌锻炼，只是没有形成一种自然而然的习惯。</p><h2 id="做好编译器"><a href="#做好编译器" class="headerlink" title="做好编译器"></a>做好编译器</h2><p>一直到5月份还都在认真做自己的compiler，其中2月底开始用Scala换掉ruby，由于开发的效率不高，5月的时候前端的东西才差不多能跑了，此时需要开始做一些优化层面相关的事情，我从每天固定提交代码转变到了学习阶段。</p><p>在前期实现的过程中研究了一段时间rust的代码，开始学习优化的时候又去学了一点LLVM的东西，从PassManager开始到一些简单的Pass，对LLVM的整体结构以及一些组件有了一些了解。之后关于compiler随便读了点书，了解了一些概念，实现了一点简单的分析和优化，还实现了一点后端部分，结合gcc能够生成非常简单的native代码，这些部分我就没有放到我的博客里了。这个过程大概持续到九月多，中间也有很长一段时间都很少去学些什么。</p><p>LLVM相关的文章：<a class="link"   href="https://homura.live/tags/LLVM/" >https://homura.live/tags/LLVM/<i class="fas fa-external-link-alt"></i></a></p><p>自己的compiler开发周记：<a class="link"   href="https://homura.live/tags/Rc-lang/" >https://homura.live/tags/Rc-lang/<i class="fas fa-external-link-alt"></i></a></p><h2 id="拍到很多照片"><a href="#拍到很多照片" class="headerlink" title="拍到很多照片"></a>拍到很多照片</h2><p>今年也算是拍了一些照片，最初的安排是每周末出门拍照，只是从五月疫情严重居家办公开始，之后出门拍照的次数越来越少，而夏天也因为太热几乎没有出门拍照。不过到了合适的时节，（比如说中秋节）还是会去特定的地点拍一些照片。关于照片集，虽然有过想做的想法，也调研过一点点相关资料，但是后续似乎是因为当前照片素材不够，需要再拍一些再考虑成相册。关于设计和排版今年也学了一丁点相关软件的使用和一点点简单的知识，但是后面因为思路枯竭，没有应用场景，以及时间与生活节奏开始混乱，也没有再多学习了（总之就是给自己找各种各样的借口）。除了设计画册相关的之外也大概看了一点关于摄影的书籍，也多少有一些收获，但实践太少还是学的太肤浅。今年关于拍照相关的大概就是这些，最后选几张我还算喜欢的照片。（未进行调整，别问为什么，问就是懒）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/sakura.jpg"                      alt="sakura.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DSCF4435.jpg"                      alt="DSCF4435.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                      alt="40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                      alt="DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.jpeg"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.jpeg"                      alt="Untitled"                ></p><h2 id="和别人一起努力"><a href="#和别人一起努力" class="headerlink" title="和别人一起努力"></a>和别人一起努力</h2><p>这个目标是完完全全不沾边。我后来几乎没有考虑过这件事情了，也许我从最初就没有抱有过希望。有人一起努力，或者在某个圈子里一起努力，我觉得是非常有利于个人前进的事情，但是现在的我似乎并不能这样。我的行为习惯在让我避开他人，同时我慵懒的态度导致也无法跟上一直在努力学习的他人的步伐，也无法融入什么圈子。对于这个目标的态度我只有用“摆烂”这个词了，这个问题的依赖还没有被解决，这个问题本身也自然不可能去发生什么变化。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>不论是技术文还是水文，都算下来今年博客上提交了42篇文章。</p><p>我本来的计划是一周一篇，但是自从我停下了周记后（5.15）渐渐开始打乱了节奏。之后的LLVM Pass系列的相关博客又维持了一阵子时间，但完结后又未能维持更新的节奏，尤其是这两个月几乎停摆。技术博客相关和我学习的进展有关系，今年后半段我学习的进展也是停滞不前，博客也跟着一起没什么变化。</p><p>很多时候我都不知道该怎么写，即便今年过去了，我觉得自己对写博客这件事情依然没有那么熟练，对于让别人能看懂以及组织语言和结构这些事情都做不好，可能需要专门的练习，但我不太会专门花时间去做这件事情，至少先能保证稳定更新频率再说。</p><p>写的时候都是抱着反正也没人看的态度，本身确实不会有什么人对我写的内容感兴趣，另一方面希望越大失望越大。但后来有的人看到了我的技术文，还找到我的联系方式来联系我，这让我感到意外和开心。虽然并不是为了功利去写，但是这也确实给了我比较正向的反馈。</p><h1 id="今年还做了些什么"><a href="#今年还做了些什么" class="headerlink" title="今年还做了些什么"></a>今年还做了些什么</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年工作的内容比较杂，组内的项目在全部推倒重来，我基本上是每个环节都在跟着做，由于算是初期，各个方面都需要我们来做，以及都是优先移植好原有的功能，所以各方面涉及的都比较浅，但也可以说是熟悉每个模块，同时熟悉模块之间的关系，能够把握每个模块对于其他模块的影响，格局打开了！这个过程中也接触到了一些新东西，算是有所收获。工作的同时还开发了一些便于调试的工具，过去同事们的调试方法实在不适合我这种又笨又懒的人。</p><p>有几篇博客记录了工作相关的一些踩坑经历</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/03/29/Problem/solve-ci-and-link/" >https://homura.live/2022/03/29/Problem/solve-ci-and-link/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/some-work-problem/" >https://homura.live/2022/10/02/Problem/some-work-problem/<i class="fas fa-external-link-alt"></i></a></p><h2 id="工作外的学习"><a href="#工作外的学习" class="headerlink" title="工作外的学习"></a>工作外的学习</h2><p>作为程序员那不可避免的要留下小格子的记录，趁着前段时间GitHub变蓝就留了个截图。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.png"                      alt="Untitled"                ></p><p>这些提交基本上都是自己的东西，也有一部分是在其他分支没有统计到，总之今年什么时候在家的时间摸鱼一目了然。</p><p>除了上面提到的编译器相关的内容，又开了os的坑，开这个坑很大一部分原因是上面提到的这篇博客。</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p>基于裸机系统修复了内存分配问题，让我想起了过去想实现os的愿望，接着参考现有的项目（xv6-riscv为主）抄了一部分的rvv os的实现，rvv的启动代码比起Intel的各种历史包袱真的是太简单了，难免产生了如果我早来看这个该多好的想法。抄os代码这部分也开了博客，不过目前只写了第0期。</p><p><a class="link"   href="https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/" >https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/<i class="fas fa-external-link-alt"></i></a></p><p>生活上的技能以及代码之外知识的学习也是必不可少的，各种乱七八糟的东西三分钟热度买了杂七杂八的书籍，趁着上头看了那么一点点，或者三分钟热度去搜了一些东西记到了笔记中。曾经有那么一段时间我意识到自己目前的行为方式就是这样三分钟热度，觉得目前改不掉，那不如就随着这股热情去，只要选择一种能够积累下东西的方式就可以了，比如说每次三分钟热度的内容都留下笔记，之后不论什么时候想重新回来看都不必从头再来。今年也算是在笔记软件里多少积累了一点点东西，希望能在以后用上。</p><h2 id="还做了些什么"><a href="#还做了些什么" class="headerlink" title="还做了些什么"></a>还做了些什么</h2><p>首先是前面尚未提到但是在实施的一些习惯。</p><p>学习钢琴 从二月开始上钢琴课，也算是坚持了快一年，除了生病和偶尔几天实在专注不了外每天都有在坚持练习。这么久下来拜厄勉强通关了，虽然我练的非常慢，但和我一开始真的是天差地别了。</p><p>读书的目标是平均一个月一本，今年也是轻松的达到了。我的阅读量很小，目标也不敢设的太高，就这样慢慢的积累也挺好的。今年在一个朋友的影响下读了一些文学，也写了一些感想，希望明年都能保持。看到许多朋友写了读书总结，我读的也不多，也不值得再开一篇文章，不过后面的部分会提我觉得不错的书。关于读书和影视相关的记录，7月开始我也开始在豆瓣上进行标记，这是我今年豆瓣的格子记录，<del>虽然没什么用就是了</del>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.png"                      alt="Untitled"                ></p><p>同时在继续更新自己的读书channel（尽管最近两个月都摸了），对愿意订阅这个channel的读者我在此表示感谢，希望明年能在channel发更多的内容，而不是像最近一样总是摸鱼。tg channel链接：<a class="link"   href="https://t.me/homura_grand_archives" >https://t.me/homura_grand_archives<i class="fas fa-external-link-alt"></i></a></p><p>还养成了见到镜子中的自己就笑一笑的习惯。最初想到这个是5月份，看到几个喜欢的up主一直都充满着笑容，我知道自己平常的表情更倾向于一脸阴沉，让人看着就不想接触，同时试图通过这种身体的行为改变去改变自己的情绪，半年下来这个习惯也算是养成了，只是最近似乎有些忘，需要再重复巩固一下。</p><p>除了实施的一些习惯之外，今年还有幸接触到了许多以往未曾接触的东西，比如说开始学乐器，去听音乐会，去做瑜伽（做了半年就没继续了，实在太远了…），给朋友写信，尝试许多女装，去心理咨询等等。<del>不过…还是没有谈过女朋友（悲），有好心人愿意介绍女生认识吗。</del></p><h2 id="接触的作品"><a href="#接触的作品" class="headerlink" title="接触的作品"></a>接触的作品</h2><p>今年看的认为很不错的动画是《吹响！上低音号》，《利兹与青鸟》，《灵能百分百》第三季，都可以说是神作。</p><p><a class="link"   href="https://homura.live/2022/08/24/Animate/Sound-Enphonium/" >https://homura.live/2022/08/24/Animate/Sound-Enphonium/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/" >https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/12/31/Animate/MobPsycho100/" >https://homura.live/2022/12/31/Animate/MobPsycho100/<i class="fas fa-external-link-alt"></i></a></p><p>今年读过的印象深刻且非常喜欢的书有费尔南多·佩索阿的《不安之书》（未读完），莎士比亚的《哈姆雷特》，夏目漱石的《草枕》和《虞美人草》，村上春树的《世界尽头与冷酷仙境》和《海边的卡夫卡》。现在回想《不安之书》是最让我感到惊奇的，《海边的卡夫卡》是最有趣的，只可惜我并没有为它们写点什么。</p><p>虽然看到好多人在写年终阅读总结，我这里就不写了，读的太少不值得拿出来讲。今年内针对部分书籍写了一点想法，其他的书有的写了零碎一点就没好意思发出来，或者干脆没发。</p><p>虞美人草：<a class="link"   href="https://homura.live/2022/10/16/Reading/papaver-rhoeas/" >https://homura.live/2022/10/16/Reading/papaver-rhoeas/<i class="fas fa-external-link-alt"></i></a></p><p>世界尽头与冷酷仙境：<a class="link"   href="https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/" >https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/<i class="fas fa-external-link-alt"></i></a></p><p>加缪的《快乐的死》也还可以</p><p><a class="link"   href="https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/" >https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/<i class="fas fa-external-link-alt"></i></a></p><h2 id="计划与习惯"><a href="#计划与习惯" class="headerlink" title="计划与习惯"></a>计划与习惯</h2><p>我原本做了一个比较简单的计划用于规划晚上回家以后的时间，前半年执行的也都还可以。但是到了七月发生了一些事情，我的注意力全部被拉走了，完全破坏了执行习惯相关的要点。而这次一直持续了两个月，加上钢琴课作业我觉得需要更多时间，时间分配上也开始乱了套。而上个月底开始的居家办公，又因为我爆肝宝可梦导致又花了很多时间在打游戏上，最后每天只能保证基本的练琴了。尽管后期有些失败，但也算是切身体会到执行习惯的一些关键点的重要性。</p><p>关于习惯参考了《掌控习惯》这本书，十分感谢推荐给我这本书的朋友。</p><p>豆瓣链接：<a class="link"   href="https://book.douban.com/subject/34326931/" >https://book.douban.com/subject/34326931/<i class="fas fa-external-link-alt"></i></a></p><p>今年内也如往年一样，尝试做过各种规划，从改善各种坏习惯到想要做出什么改变，罗列了很多，当然也如往年一样绝大多数根本没成功。比如说想每月反思，定期选择新的习惯进行养成等。也许都是因为每次列了太多，而不是每次选择一个最重要的去培养，又或者是其他原因，现在的我还未能理解。</p><h1 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h1><p>写完后回头看去年的总结，没想到也是提到同样的主题，或许人的本性不会这么轻易改变吧。</p><p>高浓度负能量和没意义的大道理警告⚠️，不喜欢请直接跳至下一节。</p><p>对于我来说，重要的不仅是这一年我做了什么，还有到了今年年底我的心态变成了什么样子，我是个怎样的人。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>这一年来，我从来未停止过试图改变些什么，这种寻求改变的念头甚至到了魔怔的地步。我的一个朋友说我总是在试图改变，也有些着急改变，我的确是恨不得立刻就能把我身上的问题都改掉，因为在我的内心中如果我不去努力改变些什么那我不值得任何美好的事物，只值得另一个理想自我或者是他人的唾弃，夸张的说会觉得无法在社会生存。尽管有一些看起来像是真的因为追求些什么而去改变，但现在的我似乎又觉得这些所谓的追求也是同样为了“生存”。</p><p>现在的我和过往一样，犯错犯蠢多到令人发指的地步，待人冷漠，经常会因为自我攻击而开始在网上说疯话胡言乱语，性格越来越扭曲。但相比去年来说更好的方面是我的自我觉察能力能强了，能理解此时此刻的我处于什么情境，我到底为什么会这样做，同时即便在说疯话我也能明白我此时此刻在做些什么。难过的是我即便了解这些，产生异样想法的时候试图用理智去说服自己，即便不断的重复，大部分情况仍未能起到什么用处。这些想法本身就令人痛苦，清醒的看着它们而无法做到些什么则会令人更痛苦。不过我在这个过程中也算是真正感受到理性的不可靠性，作为人来说还是感受更加重要，感受完全是不受理性束缚的，我却总想要用理性去修正感性，这也是完全不合理的。</p><p>自己心怀自卑却依然会有自大的妄想，不过今年意识并且切身体会到在某些方面自己远远没有想象中的自己那样好。虽然说着要做这个做那个，但实际上每天都无所事事，经常沉浸于虚拟世界之中（特指各种动画片）。感受到理想与现实的割裂感，说的时候会依照想象中完美自我的说话方式，但行动上却依然是弱小的自己。这让我想到《哈姆雷特》里面国王的一句令我印象深刻的台词</p><blockquote><p>我的言语高高在上，我的思想滞留地下。没有思想的言语永远不会上升天界。</p></blockquote><p>尽管我没有剧情中国王那么坏，但这种不一致性和矛盾性是相通的。</p><p>即使我知道今年有一些做的好的地方，但我依然无法认同自己，相比起这些“看起来微不足道”的改变，自己剩下的问题更严重。这本质是一个视角问题，即便当下的问题已经解决，我大概率也总会找理由去攻击自己。痛苦和折磨绝大部分来自于自身，自己看待问题的态度，自己的行为方式。</p><p>和往年一样，感觉时间过的越来越快了，这让我很是害怕。也许是害怕死亡，也许是害怕一事无成，也许是害怕虚度光阴，我不敢断言害怕的东西到底是什么样的。今年工作日每日重复的时间地点行为，每周末也都是几乎类似的，重复这件事情本身我觉得并无大碍，我只是不舍得时间就这样过去了。上半年都在做着自己要做的事情，却还总是担心时间的流逝，也许是感觉自己的时间利用的很差劲，觉得最后什么都没做好，迷失在了时间的洪流之中又无力掌控方向。而实际似乎也因为并没有花费多少时间学习也就没有学到多少，大多数时间还在发呆，娱乐。</p><p>前半年顺从着习惯，而后半年习惯渐渐瓦解，我的状态也各种有问题，做的事情渐渐开始变少了，不想做任何事情的状态再度袭来。后来我才真正体会到对于现在的我或许不需要去追寻什么非常喜欢的东西，至少当前不想做任何事情的时候是这样。我需要的是在我状态还算可以的时候选择几件事情，然后每日去做，不去想什么想不想做，只是每天一定要做的任务。</p><p>在写总结的时候偶然想到似乎最近没有那么强烈的一定要成为什么大佬的想法，开始思考起所谓成为大佬这种事意味着什么呢，而这件事对我来说又意味着什么呢？仔细想想我也许只是为了那么一个名号，喊的只有成为这个结果，却没有去追求学会什么知识，只是想通过这样的结果和标签获取关注和认同罢了。我之前发表过想成为编译器专家这种暴论，但渐渐我发现了，现在的我不是能成为什么领域专家的人。在我看了各种乱七八糟东西以后，意识到这和一个人的行为习惯有很大的关系，人一天绝大部分都是依靠无意识的习惯。同时我的目标应该是学好某个方面的知识，到达什么名号或者名誉都不是我应该去考虑的。</p><p>今年最后一个月的一半时间除了工作就是专心打游戏，这段时间非常平静，没有抱有对这种事情的执念。但当我从游戏世界中走出来，看着现实世界，思考起现实世界的问题，又难以恢复平静的心态，尤其是在最后几天大家纷纷放出了自己的年终总结，不由得对别人丰富多彩的一年感到羡慕，又三分钟热度想要成为多么好的人。想必明年也会如此，时而平静，时而扭曲，时而上推发疯。这些想法强烈的时候会非常痛苦，过去也不知该如何去缓解，也许需要等到真的接纳自己，真的觉得这样的自己也能很好的生存的时候，到时我的目标或许就会真正变为学好些什么，而不是成为什么带有名头的人。</p><p>人为什么一定要向着顶端爬呢，有的人是因为想要征服山顶，有的人是因为不安。我一定是后者吧，没有能够安稳生存的自信，想要通过这一种极端的方式来掩盖所有生活中的其他问题，真是懦弱。</p><h2 id="年初的我"><a href="#年初的我" class="headerlink" title="年初的我"></a>年初的我</h2><blockquote><p>我想过，我把时间分成这么多份最后的结果一定是每样都做不好。<br>我不是说所有人都是这样，只是我比较笨，多方面全能的天才太多了，不论是看过的传记，还是推特上实际见到过的大佬，他们都是切实做到全才<br>尽管我每样都不会做好，但是总比浪费时间要强的多。我在选择一些东西的时候就在想，如果不做这个，我的时间可以拿来做什么？答案显而易见，和我过去的周末一样，浪费时间。<br>我也在想，这些东西是否真的有必要，但是我感兴趣就够了，什么东西能够起到什么作用这种事情充满了太多的未知。<br>年初写下这些话，不知道年末的我怎么想</p></blockquote><p>一年下来，发现对我来说如果在做了就很好了，因为很多的时间依然被我随意浪费与挥霍。想要尽量减少浪费时间就去多做一些能够积累下来的东西，比如说学的东西用笔记的形式记录下来。而在这个时间洪流中前进的方法只有养成各种方面的习惯，习惯到了很多事情也就能做到了，但这个过程比做到什么事情本身还要难上许多。</p><h2 id="迷失方向"><a href="#迷失方向" class="headerlink" title="迷失方向"></a>迷失方向</h2><p>找不到自己应去之处，找不到人生的方向，这是一个困扰着绝大多数人的问题，而我也是绝大多数人的其中一员。对于未来的发展方向今年有过许多乱七八糟的想法，年初有，但到年中逐渐开始变化，到年末变化太大导致年初的想法又全军覆没。其中也做过一些奇奇怪怪的努力，但是都有些无功而返。自己尚未具备选择些什么的决心，也缺少将其实现的能力与自信。有过许多想法，但几乎每次都在变。这样的我现在能做的或许只能像最上面所说，先选中一些什么东西，坚持做下去吧。</p><p>除了之外，我对于自身的存在也感到迷茫。对于自己的人格，对于道德，对于对与错，对于各种各样的问题都在疑惑。疑惑也算是好事，起码我开始思考起这些问题了，开始想要跳出这个圈子看待问题，而不是继续陷入圈内。越发觉得不了解自己，不知道自己的兴趣爱好，不知道自己想要的是什么。因此什么都要，放弃做出选择，还会为得不到某些不需要的东西而产生负面情绪。也因此所追寻的大多数是别人的东西，外界所灌输的“我这样的人”所应该追求的，而不真正属于我自己想要的。我到底想要到哪里去，想要成为怎么样的人呢？</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>今年无疑是被疫情影响最大的一年。五月开始常态化核酸。后来核酸的频率降低，一直持续到了12月彻底放开。疫情影响导致多次居家远程办公，远程办公有好有坏，硬要说坏的方面比较多，但是家里的硬件设备远比公司舒服，同时又可以一直一个人窝着，因此还是更喜欢远程办公。彻底放开导致许多人都感染了新冠，而我选择蜗居在家，也因此暂时避免了感染。</p><h2 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h2><p>今年作息越来越阴间了，年初还是在12点睡，后来渐渐的12点半，10月底的时候差不多1点睡了。自从上个月底开始居家办公，仗着可以更晚起床，居然过分的到了一点半甚至到了两点才睡。</p><h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>今年涨了工资，经济状况相对来说宽裕了一些。今年依然在记账，虽然可能一如既往的记的不够精细，但是分析开销还是够用了。看了今年的账单，有点想打消整租的念头了，如果整租每个月起码要多支出2k多，以及冬天供暖还需要自己一个人承担费用。</p><p>随便讲一下情况，最大头的分类自然还是必须支出，吃穿住用的日常用品。住就不提了，一年吃了2w8，也花了不少。今年舍得打车了，没想到打车就花了快2k…淘汰了很多旧衣服，这方面也花了不少钱，电费什么的也花了不少，还有各种买药，杂七杂八的日用品。第二大头就是消费了，电子产品居多。其中很大一部分都是去年分期买的（比如说去年24期分息入手了M1Max…），加装了显示器以及入了相机镜头什么的。最后一大部分就是钢琴课，心理咨询以及前半年瑜伽的费用。书也花了不少钱，尤其是双十一的时候囤了20多本，一年下来杂七杂八的书花了快2000…虽然可能没看多少吧，很多都是有需要买来翻一翻。</p><h2 id="人际"><a href="#人际" class="headerlink" title="人际"></a>人际</h2><p>我这个人独来独往习惯了，便不想和人去打交道。有不擅长的成分，有害怕的成分，有觉得浪费时间的成分，总之有很多乱七八糟的原因形成了我现在这个样子。不过大多数不会因为讨厌别人，也因此我几乎不会为了维持关系去私聊他人。用一句话来形容，大概就是“我为来来往往的人流感到烦躁，但并没有因为你而烦躁“（已不记得原话）。这也是一个非常复杂的问题，和咨询师提到过这个问题一两次，但后来因为生病加各种问题，未再深入讨论这个话题了，明年一定要再深入讨论下去。不过不论怎么讨论，最终都是需要我来做出些什么改变。</p><p>今年发现了一个非常非常喜欢的网友，和他交流的过程中发现他简直就是我理想中的样子，追随着他的身影，也多少受到了他的一些正面影响。充满了想要成为他那样的想法，尽管那是不可能的。而在和他相处的过程中我受到了他的帮助，也改变并且成长了许多。人的成长还是要和什么人发生什么事情才行，只身一人游离于一切之外是不可能发生多少变化的，这是我今年的经历中切身体会到并且意识到的事情。</p><p>自己现在认识人的途径几乎只有Twitter了，今年新认识了许多Twitter上的朋友，也面基了几位，也有一些朋友没来得及面基，今年也要感谢朋友们对我的帮助以及对这样的我的容忍。</p><h1 id="明年的愿景"><a href="#明年的愿景" class="headerlink" title="明年的愿景"></a>明年的愿景</h1><p>我是非常贪心并且做不出选择的人，因此想添加上非常多的愿景。写这么多其实是不利于实现的，或许应该找几个核心目标再围绕展开，但这里还是想到什么写什么。</p><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><p>学习和生活想要恢复到今年刚开始的状态，并且希望能维持下去。身体健康方面还是要尽量下功夫，起码要保持每天运动的习惯，即便锻炼量很少，也要坚持动下去。关于情绪方面，尽管我有很多负面或者扭曲的想法，但是我大多能够及时觉察，认为自己能够一定程度的应对，只是很多时候由于各种大脑成分的原因我无法停止一些负面的想法，这些就不属于我改变想法就能做到的了。</p><p>找画师约一个皮套，直接出道。目前打算每天直播回家以后的学习生活，但似乎实现起来会有很多不方便，所以暂且将目标定在约好皮套这一步。</p><p>想遇到属于自己的madoka，这个是最想实现但是最不抱希望的了，做梦都没有这种好事的。</p><p>疫情好一些的话可能会挑个假期去南方转转。</p><p>希望今年能形成一些新的好习惯。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>compiler和os的坑会继续填，compiler的话继续开发我的玩具，以及再花些时间学习一下LLVM相关的内容，os起码要到把xv6里提到的功能抄一遍的地步，如果可以自制cpu这方面我也想开个坑，这个就尽力而为了。我觉得光是这些超大的坑就已经够占据我的精力了，暂时不去多想其他内容。</p><p>博客希望起码能保证两周一篇，如果可以还是想一周一篇，可以实施以写博客为目的的学习，既能保证博客更新又能保证持续学到东西。</p><p>除了专业技术之外我希望能多学一些专业之外的知识和技能，可能会向视觉类（设计/摄影）之类的靠近，也可能向一些科学方面的。</p><p>读书还是维持每个月一本好了。双十一阶段一口气囤了二十多本书，也不奢求能读完，毕竟比起要求读完还是持续阅读并且享受书中的内容更加重要。</p><h2 id="自我-1"><a href="#自我-1" class="headerlink" title="自我"></a>自我</h2><p>希望能对自己的生活有更多的掌控力，而这件事情的实现需要依赖于每一件小事的积累，并不需要我特地完成什么，只要做好其他任务自然能够做到。希望通过这样的方式逐渐增长一点自信。</p><p>最重要的是希望能够更加清楚的认识自己，找到自己的方向，不再因为没有自己想要的东西就去想要所有的东西，羡慕所有的人。</p><p>还想要多探究一些自己的感受，而不是自己的想法，多接触一些带有情感的事物或者作品，而不是只有冷冰冰的机器和科学知识。</p><h2 id="不重要的想法"><a href="#不重要的想法" class="headerlink" title="不重要的想法"></a>不重要的想法</h2><p>这部分的内容都是随缘了，不会太过于关注。</p><ol><li>小概率可能会继续写日记。去年写了几天但是后来就没再写了。</li><li>会试着强迫自己去再接触一些人，尤其是线下，也会试着开展新的交友渠道。</li><li>希望夏天有机会拍到英仙座流星雨。</li><li>想女装出门拍照，再修个图出来康康。</li><li>尝试一些其他新事物什么的。</li></ol><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>今年也多多少少做了一些事情，并且我能够确信有了不小的进步，这份进步也必然来自于我自身的行动。不过即便如此，这些内容放到一年的维度上来说真的是感觉非常渺小，每天都觉得在混日子一样的活着。因此说不上好，也说不上坏，只是又度过了一年平淡时光。</p><p>不过，平平淡淡也没什么不好。</p><blockquote><p>你的人生你做主，平淡无奇又何妨。总有一天，定能发现，各自的答案。</p></blockquote><p>来自《灵能百分百》第一季op</p><p>最后放一下今年最后一餐的烤鱼照片，不知为何今天突然想吃了，晚上火速下单！</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/IMG_5946.jpeg"                      alt="DSCF4435.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。&lt;/p&gt;
&lt;h1 id=&quot;去年的愿景&quot;&gt;&lt;a href=&quot;#去年的愿景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
</feed>
