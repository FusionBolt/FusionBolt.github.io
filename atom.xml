<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2023-02-26T09:45:10.272Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mold源码阅读 其一 读取输入文件</title>
    <link href="https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/"/>
    <id>https://fusionbolt.github.io/2023/02/26/mold/mold-1-read-input-files/</id>
    <published>2023-02-26T09:40:55.000Z</published>
    <updated>2023-02-26T09:45:10.272Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/FhW-kVdagAI7itc.jpeg"                      alt="图像"                >上一期主要讲了链接前的一些准备流程以及在mold中链接过程的简单介绍。这期开始我们从链接过程中的功能开始介绍。在开始之前，提前说明一下里面各种缩写有很多，我会在第一次出现时提及缩写具体含义是什么，如果后期更的期数比较多会考虑专门写一页缩写的参考，方便查阅。</p><p>首先是解析输入，命令行参数解析的细节略过，但是这里不能略过elf文件的解析。我们从代码的实现去看elf的结构，再和文档中的图进行对比，同时尽可能从代码中去捋清不同结构之间的联系。</p><p>我们从elf_main函数中的read_input_files开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read_input_files</span>(ctx, file_args);</span><br></pre></td></tr></table></figure><h1 id="read-input-files"><a href="#read-input-files" class="headerlink" title="read_input_files"></a>read_input_files</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read_input_files</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::span&lt;std::string&gt; args)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;read_input_files&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::tuple&lt;<span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>, <span class="keyword">bool</span>&gt;&gt; state;</span><br><span class="line">  ctx.is_static = ctx.arg.is_static;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    std::string_view arg = args[<span class="number">0</span>];</span><br><span class="line">    args = args.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (arg == <span class="string">&quot;--as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-as-needed&quot;</span>) &#123;</span><br><span class="line">      ctx.as_needed = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--no-whole-archive&quot;</span>) &#123;</span><br><span class="line">      ctx.whole_archive = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bstatic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--Bdynamic&quot;</span>) &#123;</span><br><span class="line">      ctx.is_static = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--start-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--end-lib&quot;</span>) &#123;</span><br><span class="line">      ctx.in_lib = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--version-script=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--version-script: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_version_script</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--dynamic-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dynamic-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol=&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arg == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">        ctx.default_version = VER_NDX_GLOBAL;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.version_patterns.<span class="built_in">push_back</span>(&#123;arg, <span class="string">&quot;--export-dynamic-symbol&quot;</span>,</span><br><span class="line">                                        <span class="string">&quot;global&quot;</span>, VER_NDX_GLOBAL, <span class="literal">false</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;--export-dynamic-symbol-list=&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_from_search_paths</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      <span class="keyword">if</span> (!mf)</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--export-dynamic-symbol-list: file not found: &quot;</span> &lt;&lt; arg;</span><br><span class="line">      <span class="built_in">parse_dynamic_list</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--push-state&quot;</span>) &#123;</span><br><span class="line">      state.<span class="built_in">push_back</span>(&#123;ctx.as_needed, ctx.whole_archive, ctx.is_static,</span><br><span class="line">                       ctx.in_lib&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;--pop-state&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (state.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no state pushed before popping&quot;</span>;</span><br><span class="line">      std::<span class="built_in">tie</span>(ctx.as_needed, ctx.whole_archive, ctx.is_static, ctx.in_lib) =</span><br><span class="line">        state.<span class="built_in">back</span>();</span><br><span class="line">      state.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">remove_prefix</span>(arg, <span class="string">&quot;-l&quot;</span>)) &#123;</span><br><span class="line">      MappedFile&lt;Context&lt;E&gt;&gt; *mf = <span class="built_in">find_library</span>(ctx, std::<span class="built_in">string</span>(arg));</span><br><span class="line">      mf-&gt;given_fullpath = <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, mf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">read_file</span>(ctx, MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, std::<span class="built_in">string</span>(arg)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;no input files&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ctx.tg.<span class="built_in">wait</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是根据命令行参数确定要读取的输入文件，这里大部分的分支是为了读取符号version信息相关的，主要是看read_file的实现。在看实现之前可以看到传入了一个MappedFile，而这个类的实现其实就是在打开文件的时候使用了mmap进行映射，而must_open则是进行判断，失败了直接报错，这里也不贴具体细节代码了。</p><h1 id="read-file"><a href="#read-file" class="headerlink" title="read_file"></a>read_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.visited.<span class="built_in">contains</span>(mf-&gt;name))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  FileType type = <span class="built_in">get_file_type</span>(mf);</span><br><span class="line">... 省略对不同type的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是get_file_type，这个是通过文件开头的值确定文件的类型，我们这里以ELF的代码为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">FileType <span class="title">get_file_type</span><span class="params">(MappedFile&lt;C&gt; *mf)</span> </span>&#123;</span><br><span class="line">  std::string_view data = mf-&gt;<span class="built_in">get_contents</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> FileType::EMPTY;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data.<span class="built_in">starts_with</span>(<span class="string">&quot;\177ELF&quot;</span>)) &#123;</span><br><span class="line">    u8 byte_order = ((elf::EL32Ehdr *)data.<span class="built_in">data</span>())-&gt;e_ident[elf::EI_DATA];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (byte_order == elf::ELFDATA2LSB) &#123;</span><br><span class="line">      elf::EL32Ehdr &amp;ehdr = *(elf::EL32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::I386&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::X86_64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      elf::EB32Ehdr &amp;ehdr = *(elf::EB32Ehdr *)data.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_REL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ehdr.e_ident[elf::EI_CLASS] == elf::ELFCLASS32) &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::M68K&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (is_gcc_lto_obj&lt;elf::SPARC64&gt;(mf))</span><br><span class="line">            <span class="keyword">return</span> FileType::GCC_LTO_OBJ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_OBJ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ehdr.e_type == elf::ET_DYN)</span><br><span class="line">        <span class="keyword">return</span> FileType::ELF_DSO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FileType::UNKNOWN;</span><br><span class="line">  &#125;</span><br><span class="line">  ... 省略其他格式的判断</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先从数据开头的“\177ELF”确定为ELF文件，之后根据ELFHeader里面的内容读取更多的信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">FileType</span> &#123;</span></span><br><span class="line">  UNKNOWN,</span><br><span class="line">  EMPTY,</span><br><span class="line">  ELF_OBJ,</span><br><span class="line">  ELF_DSO,</span><br><span class="line">  MACH_OBJ,</span><br><span class="line">  MACH_EXE,</span><br><span class="line">  MACH_DYLIB,</span><br><span class="line">  MACH_BUNDLE,</span><br><span class="line">  MACH_UNIVERSAL,</span><br><span class="line">  AR,</span><br><span class="line">  THIN_AR,</span><br><span class="line">  TAPI,</span><br><span class="line">  TEXT,</span><br><span class="line">  GCC_LTO_OBJ,</span><br><span class="line">  LLVM_BITCODE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mold当前所支持的FileType就是这些，但是注意，GitHub中mold项目下只存在elf文件的支持，mach的格式则是在sold这个项目中处理。除此之外的文件格式都在以下的switch中进行处理</p><p><a class="link"   href="https://github.com/bluewhalesystems/sold" >https://github.com/bluewhalesystems/sold<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">  ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, mf, <span class="string">&quot;&quot;</span>));</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::ELF_DSO:</span><br><span class="line">  ctx.dsos.<span class="built_in">push_back</span>(<span class="built_in">new_shared_file</span>(ctx, mf));</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::AR:</span><br><span class="line"><span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">  <span class="keyword">for</span> (MappedFile&lt;Context&lt;E&gt;&gt; *child : <span class="built_in">read_archive_members</span>(ctx, mf)) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(child)) &#123;</span><br><span class="line">    <span class="keyword">case</span> FileType::ELF_OBJ:</span><br><span class="line">      ctx.objs.<span class="built_in">push_back</span>(<span class="built_in">new_object_file</span>(ctx, child, mf-&gt;name));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line">    <span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">      <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, child, mf-&gt;name))</span><br><span class="line">        ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ctx.visited.<span class="built_in">insert</span>(mf-&gt;name);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::TEXT:</span><br><span class="line">  <span class="built_in">parse_linker_script</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">case</span> FileType::GCC_LTO_OBJ:</span><br><span class="line"><span class="keyword">case</span> FileType::LLVM_BITCODE:</span><br><span class="line">  <span class="keyword">if</span> (ObjectFile&lt;E&gt; *file = <span class="built_in">new_lto_obj</span>(ctx, mf, <span class="string">&quot;&quot;</span>))</span><br><span class="line">    ctx.objs.<span class="built_in">push_back</span>(file);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: unknown file type&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简化下来这里主要分为这么几类文件</p><ol><li>archive file</li><li>lto</li><li>linker_script</li><li>object_file</li><li>shared_file</li></ol><h2 id="archive-file"><a href="#archive-file" class="headerlink" title="archive file"></a>archive file</h2><p>archive file，也就是俗称的.a文件，其实就是许多个object文件塞到一起只需要解析其中所有member，之后将每个member进行读取即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line">std::vector&lt;MappedFile&lt;C&gt; *&gt;</span><br><span class="line"><span class="built_in">read_archive_members</span>(C &amp;ctx, MappedFile&lt;C&gt; *mf) &#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">get_file_type</span>(mf)) &#123;</span><br><span class="line">  <span class="keyword">case</span> FileType::AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_fat_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">case</span> FileType::THIN_AR:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">read_thin_archive_members</span>(ctx, mf);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于ar和thin ar</p><p><a class="link"   href="https://sourceware.org/binutils/docs/binutils/ar.html" >ar (GNU Binary Utilities)<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>An archive can either be <em>thin</em> or it can be normal. It cannot be both at the same time. Once an archive is created its format cannot be changed without first deleting it and then creating a new archive in its place.</p></blockquote><p>这里的具体细节暂且略过，如感兴趣可自行查看源码</p><h2 id="lto"><a href="#lto" class="headerlink" title="lto"></a>lto</h2><p>lto是用于link time optimization的文件，而本质上还是一个object文件，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_lto_obj</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_lto_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.ignore_ir_file.<span class="built_in">count</span>(mf-&gt;<span class="built_in">get_identifier</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  ObjectFile&lt;E&gt; *file = <span class="built_in">read_lto_object</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  file-&gt;archive_name = archive_name;</span><br><span class="line">  file-&gt;is_in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  file-&gt;is_alive = !file-&gt;is_in_lib;</span><br><span class="line">  ctx.has_lto_object = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在mold中解析lto的方式是通过指定plugin，加载对应的so来进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">ObjectFile&lt;E&gt; *<span class="title">read_lto_object</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// V0 API&#x27;s claim_file is not thread-safe.</span></span><br><span class="line">  <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">  <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mu, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!is_gcc_linker_api_v1)</span><br><span class="line">    lock.<span class="built_in">lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.plugin.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; mf-&gt;name &lt;&lt; <span class="string">&quot;: don&#x27;t know how to handle this LTO object file &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;because no -plugin option was given. Please make sure you &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;added -flto not only for creating object files but also for &quot;</span></span><br><span class="line">               &lt;&lt; <span class="string">&quot;creating the final executable.&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// dlopen the linker plugin file</span></span><br><span class="line">  <span class="keyword">static</span> std::once_flag flag;</span><br><span class="line">  std::<span class="built_in">call_once</span>(flag, [&amp;] &#123; <span class="built_in">load_plugin</span>(ctx); &#125;);</span><br></pre></td></tr></table></figure><p>学习解析文件的实现主要是要进一步了解ELF的格式，所以这里具体细节就不进行考据了。</p><h2 id="linker-script"><a href="#linker-script" class="headerlink" title="linker script"></a>linker script</h2><p>mold的linker script根据解析的过程来看比较简单，没有在ld的脚本中的指定SECTION地址之类的内容，主要是对format以及符号version的一些控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parse_linker_script</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  current_file&lt;E&gt; = mf;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;std::string_view&gt; vec = <span class="built_in">tokenize</span>(ctx, mf-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">  std::span&lt;std::string_view&gt; tok = vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!tok.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;OUTPUT_FORMAT&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_output_format</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;INPUT&quot;</span> || tok[<span class="number">0</span>] == <span class="string">&quot;GROUP&quot;</span>) &#123;</span><br><span class="line">      tok = <span class="built_in">read_group</span>(ctx, tok.<span class="built_in">subspan</span>(<span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;VERSION&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#123;&quot;</span>);</span><br><span class="line">      <span class="built_in">read_version_script</span>(ctx, tok);</span><br><span class="line">      tok = <span class="built_in">skip</span>(ctx, tok, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok.<span class="built_in">size</span>() &gt; <span class="number">3</span> &amp;&amp; tok[<span class="number">1</span>] == <span class="string">&quot;=&quot;</span> &amp;&amp; tok[<span class="number">3</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      ctx.arg.defsyms.<span class="built_in">emplace_back</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">0</span>])),</span><br><span class="line">                                   <span class="built_in">get_symbol</span>(ctx, <span class="built_in">unquote</span>(tok[<span class="number">2</span>])));</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">4</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tok[<span class="number">0</span>] == <span class="string">&quot;;&quot;</span>) &#123;</span><br><span class="line">      tok = tok.<span class="built_in">subspan</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">SyntaxError</span>(ctx, tok[<span class="number">0</span>]) &lt;&lt; <span class="string">&quot;unknown linker script token&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h2><p>object file是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ObjectFile&lt;E&gt; *<span class="title">new_object_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      std::string archive_name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">count</span><span class="params">(<span class="string">&quot;parsed_objs&quot;</span>)</span></span>;</span><br><span class="line">  count++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> in_lib = ctx.in_lib || (!archive_name.<span class="built_in">empty</span>() &amp;&amp; !ctx.whole_archive);</span><br><span class="line">  ObjectFile&lt;E&gt; *file = ObjectFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf, archive_name, in_lib);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mold以链接速度快出名，而其快的原因之一就是充分利用了多线程，实际进行多线程操作的地方是在这里，ctx.tg.run，tg则是一个tbb::task_group，简而言之就是在这里开启了多线程的解析input file。</p><p>做了一些简单的in_lib参数处理，因为archive的链接机制默认是按需链接，而不是像shared file一样全部链接，之后在这里创建了object file并且开始parse。关于创建和parse的细节在后面再说。</p><h2 id="shared-file"><a href="#shared-file" class="headerlink" title="shared file"></a>shared file</h2><p>shared file同样是解析过程的重点之一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> SharedFile&lt;E&gt; *</span></span><br><span class="line"><span class="function"><span class="title">new_shared_file</span><span class="params">(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">check_file_compatibility</span>(ctx, mf);</span><br><span class="line"></span><br><span class="line">  SharedFile&lt;E&gt; *file = SharedFile&lt;E&gt;::<span class="built_in">create</span>(ctx, mf);</span><br><span class="line">  file-&gt;priority = ctx.file_priority++;</span><br><span class="line">  ctx.tg.<span class="built_in">run</span>([file, &amp;ctx] &#123; file-&gt;<span class="built_in">parse</span>(ctx); &#125;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.trace)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace: &quot;</span> &lt;&lt; *file;</span><br><span class="line">  <span class="keyword">return</span> file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里做了和object file类似的事情。</p><h1 id="InputFile"><a href="#InputFile" class="headerlink" title="InputFile"></a>InputFile</h1><p>在详细讲解object file和shared file创建以及解析之前先介绍一下他们和InputFile类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled.png"                      alt="Untitled"                ></p><p>ObjectFile和SharedFile都是简单的从InputFile中继承下来的。而这里的InputFile更像是代表了一个输入的ELF文件，构造的过程中做了一些ELF的基础解析，同时还提供了一些通用的接口，交由ObjectFile和SharedFile各自实现。</p><p>我们来看一下InputFile的构造函数部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">InputFile&lt;E&gt;::<span class="built_in">InputFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf)</span><br><span class="line">  : <span class="built_in">mf</span>(mf), <span class="built_in">filename</span>(mf-&gt;name) &#123;</span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;size &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfEhdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: file too small&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">memcmp</span>(mf-&gt;data, <span class="string">&quot;\177ELF&quot;</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: not an ELF file&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfEhdr&lt;E&gt; &amp;ehdr = *(ElfEhdr&lt;E&gt; *)mf-&gt;data;</span><br><span class="line">  is_dso = (ehdr.e_type == ET_DYN);</span><br><span class="line"></span><br><span class="line">  ElfShdr&lt;E&gt; *sh_begin = (ElfShdr&lt;E&gt; *)(mf-&gt;data + ehdr.e_shoff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shnum contains the total number of sections in an object file.</span></span><br><span class="line">  <span class="comment">// Since it is a 16-bit integer field, it&#x27;s not large enough to</span></span><br><span class="line">  <span class="comment">// represent &gt;65535 sections. If an object file contains more than 65535</span></span><br><span class="line">  <span class="comment">// sections, the actual number is stored to sh_size field.</span></span><br><span class="line">  i64 num_sections = (ehdr.e_shnum == <span class="number">0</span>) ? sh_begin-&gt;sh_size : ehdr.e_shnum;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mf-&gt;data + mf-&gt;size &lt; (u8 *)(sh_begin + num_sections))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: e_shoff or e_shnum corrupted: &quot;</span></span><br><span class="line">               &lt;&lt; mf-&gt;size &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num_sections;</span><br><span class="line">  elf_sections = &#123;sh_begin, sh_begin + num_sections&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// e_shstrndx is a 16-bit field. If .shstrtab&#x27;s section index is</span></span><br><span class="line">  <span class="comment">// too large, the actual number is stored to sh_link field.</span></span><br><span class="line">  i64 shstrtab_idx = (ehdr.e_shstrndx == SHN_XINDEX)</span><br><span class="line">    ? sh_begin-&gt;sh_link : ehdr.e_shstrndx;</span><br><span class="line"></span><br><span class="line">  shstrtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, shstrtab_idx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是从文件大小和文件头部标识信息进行ELF的校验，其次是做一些简单的解析。根据代码中可知，整个文件最开始的部分即可作为一个ElfEhdr（Ehdr：Elf Header）</p><p>根据header的信息可以解析出是否为dso文件，ElfShdr（Shdr：Section Header）的起始地址和长度，以及shstrtab（Section Header String Table）的位置。</p><p>大多数的参数直接可以获取，但是对于e_shnum和e_shstrndx来说，由于长度只有16bit的限制，因此如果值过大，则会分别存到第一个Shdr的sh_size以及sh_link中。</p><p>那么根据这段代码我们可以看出ELF的文件信息是这样的</p><h1 id="ObjectFile"><a href="#ObjectFile" class="headerlink" title="ObjectFile"></a>ObjectFile</h1><h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>首先是ObjectFile的创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt; *</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">create</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                      std::string archive_name, <span class="keyword">bool</span> is_in_lib) &#123;</span><br><span class="line">  ObjectFile&lt;E&gt; *obj = <span class="keyword">new</span> ObjectFile&lt;E&gt;(ctx, mf, archive_name, is_in_lib);</span><br><span class="line">  ctx.obj_pool.<span class="built_in">emplace_back</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ObjectFile&lt;E&gt;::<span class="built_in">ObjectFile</span>(Context&lt;E&gt; &amp;ctx, MappedFile&lt;Context&lt;E&gt;&gt; *mf,</span><br><span class="line">                          std::string archive_name, <span class="keyword">bool</span> is_in_lib)</span><br><span class="line">  : InputFile&lt;E&gt;(ctx, mf), <span class="built_in">archive_name</span>(archive_name), <span class="built_in">is_in_lib</span>(is_in_lib) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;is_alive = !is_in_lib;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数被放入了private中，因此必须通过静态的create方法来创建实例。在每次创建的时候会将对应的obj对象放入到全局的ctx.obj_pool中，mold中的内存与生命周期的管理方式则是全部交由ctx保有，到最后一起释放。而对应的obj_pool为了多线程的设计也都使用了并发的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tbb::concurrent_vector&lt;std::unique_ptr&lt;ObjectFile&lt;E&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>ObjectFile的构造函数只是传递了参数，大部分的解析还是在InputFile的构造函数中执行。</p><h2 id="parse过程开始"><a href="#parse过程开始" class="headerlink" title="parse过程开始"></a>parse过程开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">parse</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  sections.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>());</span><br><span class="line">  symtab_sec = <span class="keyword">this</span>-&gt;<span class="built_in">find_section</span>(SHT_SYMTAB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (symtab_sec) &#123;</span><br><span class="line">    <span class="comment">// In ELF, all local symbols precede global symbols in the symbol table.</span></span><br><span class="line">    <span class="comment">// sh_info has an index of the first global symbol.</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;first_global = symtab_sec-&gt;sh_info;</span><br><span class="line">    <span class="keyword">this</span>-&gt;elf_syms = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;ElfSym&lt;E&gt;&gt;(ctx, *symtab_sec);</span><br><span class="line">    <span class="keyword">this</span>-&gt;symbol_strtab = <span class="keyword">this</span>-&gt;<span class="built_in">get_string</span>(ctx, symtab_sec-&gt;sh_link);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initialize_sections</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_symbols</span>(ctx);</span><br><span class="line">  <span class="built_in">sort_relocations</span>(ctx);</span><br><span class="line">  <span class="built_in">initialize_ehframe_sections</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symtab-sec"><a href="#symtab-sec" class="headerlink" title="symtab_sec"></a>symtab_sec</h2><p>首先是寻找symtab_sec的过程，寻找段的过程非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">ElfShdr&lt;E&gt; *InputFile&lt;E&gt;::<span class="built_in">find_section</span>(i64 type) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ElfShdr&lt;E&gt; &amp;sec : elf_sections)</span><br><span class="line">    <span class="keyword">if</span> (sec.sh_type == type)</span><br><span class="line">      <span class="keyword">return</span> &amp;sec;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>symtab_sec不存在的情况多半是strip了，直接在elf中搜索symtab是能搜到的，但是如果strip以后就无法找到这个段了，也就是为空的情况</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%201.png"                      alt="Untitled"                ></p><p>sh_link和sh_info对于不同的section有不同的含义，对于这里的symtab来说sh_info就是保存了第一个global symbol的index，而sh_link就是保存了symbol_strtab的地址</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%202.png"                      alt="Untitled"                ></p><h2 id="initialize-sections"><a href="#initialize-sections" class="headerlink" title="initialize_sections"></a>initialize_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Read sections</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br></pre></td></tr></table></figure><p>针对所有的sections开始处理，以下内容都在个循环体之中</p><h3 id="特殊SHT的处理"><a href="#特殊SHT的处理" class="headerlink" title="特殊SHT的处理"></a>特殊SHT的处理</h3><p>SHT（Section Header Type）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((shdr.sh_flags &amp; SHF_EXCLUDE) &amp;&amp; !(shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">    shdr.sh_type != SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><p>这几个段无法在ELF标准中查到，后来查到了这么一段介绍</p><p>SHF_EXCLUDE：This section is excluded from input to the link-edit of an executable or shared object. This flag is ignored if the SHF_ALLOC flag is also set, or if relocations exist against the section.</p><ol><li>如果alloc被set则失效，因此这里要SHF_EXCLUDE以及SHF_ALLOC都满足条件</li><li>同时sh_type为SHF_LLVM_ADDRSIG且不是relocatable</li></ol><p>关于SHF_LLVM_ADDRSIG</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#id20" >LLVM Extensions — LLVM 17.0.0git documentation<i class="fas fa-external-link-alt"></i></a></p><h3 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h3><p>首先是关于Group的介绍</p><blockquote><p>This section defines a section group. A section group is a set of sections that are related and that must be treated specially by the linker (see <a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html#section_groups" >below<i class="fas fa-external-link-alt"></i></a> for further details). Sections of type <code>SHT_GROUP</code> may appear only in relocatable objects (objects with the ELF header <code>e_type</code> member set to <code>ET_REL</code>). The section header table entry for a group section must appear in the section header table before the entries for any of the sections that are members of the group.</p></blockquote><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html<i class="fas fa-external-link-alt"></i></a></p><p>在实现中首先是寻找对应group的签名，签名是关联到了一个esym上，而这个符号的索引则是记录在sh_info中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the signature of this section group.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_info &gt;= <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid symbol index&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[shdr.sh_info];</span><br><span class="line"></span><br><span class="line">std::string_view signature;</span><br><span class="line"><span class="keyword">if</span> (esym.st_type == STT_SECTION) &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() +</span><br><span class="line">              <span class="keyword">this</span>-&gt;elf_sections[esym.st_shndx].sh_name;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  signature = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是一些特殊情况的处理。</p><ol><li>跳过wm4</li><li>跳过entries[0]为0的情况</li><li>如果[0]不是GRP_COMDAT则是错误</li></ol><p>之后获取comdat group members，并使用signature来关联一个ComdatGroup</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ignore a broken comdat group GCC emits for .debug_macros.</span></span><br><span class="line"><span class="comment">// https://github.com/rui314/mold/issues/438</span></span><br><span class="line"><span class="keyword">if</span> (signature.<span class="built_in">starts_with</span>(<span class="string">&quot;wm4.&quot;</span>))</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get comdat group members.</span></span><br><span class="line">std::span&lt;U32&lt;E&gt;&gt; entries = <span class="keyword">this</span>-&gt;<span class="keyword">template</span> get_data&lt;U32&lt;E&gt;&gt;(ctx, shdr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: empty SHT_GROUP&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (entries[<span class="number">0</span>] != GRP_COMDAT)</span><br><span class="line">  <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported SHT_GROUP format&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.comdat_groups)</span>::const_accessor acc</span>;</span><br><span class="line">ctx.comdat_groups.<span class="built_in">insert</span>(acc, &#123;signature, <span class="built_in">ComdatGroup</span>()&#125;);</span><br><span class="line">ComdatGroup *group = <span class="keyword">const_cast</span>&lt;ComdatGroup *&gt;(&amp;acc-&gt;second);</span><br><span class="line">comdat_groups.<span class="built_in">push_back</span>(&#123;group, (u32)i, entries.<span class="built_in">subspan</span>(<span class="number">1</span>)&#125;);</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>关于上面处理过程中出现的成员的定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in context</span></span><br><span class="line">tbb::concurrent_hash_map&lt;std::string_view, ComdatGroup, HashCmp&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in ObjectFile</span></span><br><span class="line">std::vector&lt;ComdatGroupRef&lt;E&gt;&gt; comdat_groups;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ComdatGroupRef</span> &#123;</span></span><br><span class="line">  ComdatGroup *group;</span><br><span class="line">  u32 sect_idx;</span><br><span class="line">  std::span&lt;U32&lt;E&gt;&gt; members;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>首先是根据签名关联一个group空，之后将对应group的引用传递给ObjectFile中的comdat_groups</p><p>里面的i就是section的index</p><p>来看一下这个group段的排布</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| SectionSize | Group1SectionIndex | Group2SectionIndex | … |</span><br></pre></td></tr></table></figure><p>关于GRP_COMDAT文档中也有提到</p><blockquote><p>This is a COMDAT group. It may duplicate another COMDAT group in another object file, where duplication is defined as having the same group signature. In such cases, only one of the duplicate groups may be retained by the linker, and the members of the remaining groups must be discarded.</p></blockquote><h3 id="常规SHT处理"><a href="#常规SHT处理" class="headerlink" title="常规SHT处理"></a>常规SHT处理</h3><p>此处还有很长的特殊段以及开启—gdb-index后需要处理的内容，并非重点，此处先跳过。</p><p>常规处理就是简单创建了一个InputSection</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;sections[i] = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br></pre></td></tr></table></figure><h3 id="Attach-relocation-sections-to-their-target-sections"><a href="#Attach-relocation-sections-to-their-target-sections" class="headerlink" title="Attach relocation sections to their target sections."></a>Attach relocation sections to their target sections.</h3><p>到这里，所有的section已经执行过了一遍，最后再进行关联</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach relocation sections to their target sections.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;elf_sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = <span class="keyword">this</span>-&gt;elf_sections[i];</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_info &gt;= sections.<span class="built_in">size</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: invalid relocated section index: &quot;</span></span><br><span class="line">               &lt;&lt; (u32)shdr.sh_info;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;target = sections[shdr.sh_info]) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(target-&gt;relsec_idx == <span class="number">-1</span>);</span><br><span class="line">    target-&gt;relsec_idx = i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对RELA和REL处理，设置上对应的relsec_idx</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> is_rela = <span class="built_in"><span class="keyword">requires</span></span>(ElfRel&lt;E&gt; r) &#123; r.r_addend; &#125;;</span><br></pre></td></tr></table></figure><h2 id="initialize-symbols"><a href="#initialize-symbols" class="headerlink" title="initialize_symbols"></a>initialize_symbols</h2><p>这部分的过程主要是将esym转换为Symbol。esym则是ElfSym的缩写，也就是Elf文件中的Symbol定义，而Symbol则是mold中自己定义的，相当于转换为自己想要的格式。</p><p>这里的symtab_sec是parse刚开始的时候寻找的section，对应的符号表不存在则不进行这个过程。首先初始化了local_syms以及第0个符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">initialize_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!symtab_sec)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;all_syms&quot;</span>)</span></span>;</span><br><span class="line">  counter += <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize local symbols</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;first_global);</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].file = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;local_syms[<span class="number">0</span>].sym_idx = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="local-symbol"><a href="#local-symbol" class="headerlink" title="local symbol"></a>local symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: common local symbol?&quot;</span>;</span><br><span class="line"></span><br><span class="line">    std::string_view name;</span><br><span class="line">    <span class="keyword">if</span> (esym.st_type == STT_SECTION)</span><br><span class="line">      name = <span class="keyword">this</span>-&gt;shstrtab.<span class="built_in">data</span>() + <span class="keyword">this</span>-&gt;elf_sections[<span class="built_in">get_shndx</span>(esym)].sh_name;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      name = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = <span class="keyword">this</span>-&gt;local_syms[i];</span><br><span class="line">    sym.<span class="built_in">set_name</span>(name);</span><br><span class="line">    sym.file = <span class="keyword">this</span>;</span><br><span class="line">    sym.value = esym.st_value;</span><br><span class="line">    sym.sym_idx = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>())</span><br><span class="line">      sym.<span class="built_in">set_input_section</span>(sections[<span class="built_in">get_shndx</span>(esym)].<span class="built_in">get</span>());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先是对于common符号的判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_common</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_COMMON; &#125;</span><br></pre></td></tr></table></figure><p>关于这个SHN_COMMON</p><blockquote><p>SHN_COMMON Symbols defined relative to this section are common symbols, such as FORTRAN COMMON or unallocated C external variables.</p></blockquote><p>大意是common的话不能是local，比如这里说的unallocated C external variables，external和local就是冲突的。</p><p>除了报错的common符号之外，其他符号在后面获取对应的名字，如果是section name则去shstrtab中寻找，否则就是常规的符号名，去symbol_strtab中寻找。这里的名字本质上是一个距离对应字符串段的offset，因为字符串相关的数据都统一保存在这shstrtab和symbol_strtab中了。</p><p>之后就是获取local_syms的引用，开始设置对应的信息。</p><p>在最后，对非abs符号的处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_abs</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> st_shndx == SHN_ABS; &#125;</span><br></pre></td></tr></table></figure><blockquote><p>SHN_ABS This value specifies absolute values for the corresponding reference. For example, symbols defined relative to section number SHN_ABS have <strong>absolute values and are not affected by relocation.</strong></p></blockquote><p>非abs符号，也就是说都是相对地址，会affected by relocation。</p><p>而实际set_input_section则是设置其mask位，用于区分什么性质的符号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_input_section</span>(InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">  <span class="keyword">uintptr_t</span> addr = (<span class="keyword">uintptr_t</span>)isec;</span><br><span class="line">  <span class="built_in">assert</span>((addr &amp; TAG_MASK) == <span class="number">0</span>);</span><br><span class="line">  origin = addr | TAG_ISEC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用2bit区分不同情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol usually belongs to an input section, but it can belong</span></span><br><span class="line"><span class="comment">// to a section fragment, an output section or nothing</span></span><br><span class="line"><span class="comment">// (i.e. absolute symbol). `origin` holds one of them. We use the</span></span><br><span class="line"><span class="comment">// least significant two bits to distinguish type.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">uintptr_t</span> &#123;</span><br><span class="line">  TAG_ABS  = <span class="number">0b00</span>,</span><br><span class="line">  TAG_ISEC = <span class="number">0b01</span>,</span><br><span class="line">  TAG_OSEC = <span class="number">0b10</span>,</span><br><span class="line">  TAG_FRAG = <span class="number">0b11</span>,</span><br><span class="line">  TAG_MASK = <span class="number">0b11</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="global-symbol"><a href="#global-symbol" class="headerlink" title="global symbol"></a>global symbol</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>-&gt;symbols.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">i64 num_globals = <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>() - <span class="keyword">this</span>-&gt;first_global;</span><br><span class="line">symvers.<span class="built_in">resize</span>(num_globals);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++)</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = &amp;<span class="keyword">this</span>-&gt;local_syms[i];</span><br></pre></td></tr></table></figure><p>在开始处理之前可以看到这里又有两个resize容器的位置，目前为止有三处，这里写明了对应的容器以及所处的类，用于区分这个信息是否为ObjectFile only的</p><ol><li>local symbols(InputFile)</li><li>symbols(InputFile)</li><li>symvers (ObjectFile)</li></ol><p>之后将local_sym绑定到symbols中</p><p>之后是详细的处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize global symbols</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get a symbol name</span></span><br><span class="line">  std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">  std::string_view name = key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse symbol version after atsign</span></span><br><span class="line">  <span class="keyword">if</span> (i64 pos = name.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != name.npos) &#123;</span><br><span class="line">    std::string_view ver = name.<span class="built_in">substr</span>(pos + <span class="number">1</span>);</span><br><span class="line">    name = name.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ver.<span class="built_in">empty</span>() &amp;&amp; ver != <span class="string">&quot;@&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ver.<span class="built_in">starts_with</span>(<span class="string">&#x27;@&#x27;</span>))</span><br><span class="line">        key = name;</span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">        symvers[i - <span class="keyword">this</span>-&gt;first_global] = ver.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = <span class="built_in">insert_symbol</span>(ctx, esym, key, name);</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_common</span>())</span><br><span class="line">    has_common_symbol = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; symvers;</span><br></pre></td></tr></table></figure><p>这里不需要再区分是否为Section的符号，因为global符号不包含section符号。</p><p>这里最主要的是需要解析symbol version，因为有的符号会依赖于版本号。要注意的是这个东西并非ELF的官方定义，而是GNU的一个扩展，因此去看elf specification是找不到的。关于名称规范也很简单，常规符号名后接@加符号版本</p><p>解析符号版本完成后设置到symvers中，关于这个版本号，最常见的就是GLIBC，以下是本机helloworld代码的示范</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/tmp &gt; nm ./a.out | grep <span class="string">&quot;@&quot;</span></span><br><span class="line"> w __cxa_finalize@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br><span class="line"> U __libc_start_main@GLIBC_2<span class="number">.34</span></span><br><span class="line"> U puts@GLIBC_2<span class="number">.2</span><span class="number">.5</span></span><br></pre></td></tr></table></figure><p>之后是insert symbol，并且设置其common属性。要注意除了这些解析方式外，global symbol和local symbol相比还有一个比较隐藏的不同，global symbol没有设置对应的file，后面很多符号的处理会进行判断file。</p><p>接下来是insert symbol的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns a symbol object for a given key. This function handles</span></span><br><span class="line"><span class="comment">// the -wrap option.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Symbol&lt;E&gt; *<span class="title">insert_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::string_view key, std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; name.<span class="built_in">starts_with</span>(<span class="string">&quot;__real_&quot;</span>) &amp;&amp;</span><br><span class="line">      ctx.arg.wrap.<span class="built_in">contains</span>(name.<span class="built_in">substr</span>(<span class="number">7</span>))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">7</span>), name.<span class="built_in">substr</span>(<span class="number">7</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym-&gt;wrap) &#123;</span><br><span class="line">    key = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(key));</span><br><span class="line">    name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__wrap_&quot;</span> + std::<span class="built_in">string</span>(name));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_symbol</span>(ctx, key, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sym;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function">std::string_view <span class="title">save_string</span><span class="params">(C &amp;ctx, <span class="keyword">const</span> std::string &amp;str)</span> </span>&#123;</span><br><span class="line">  u8 *buf = <span class="keyword">new</span> u8[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(buf, str.<span class="built_in">data</span>(), str.<span class="built_in">size</span>());</span><br><span class="line">  buf[str.<span class="built_in">size</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  ctx.string_pool.<span class="built_in">push_back</span>(std::unique_ptr&lt;u8[]&gt;(buf));</span><br><span class="line">  <span class="keyword">return</span> &#123;(<span class="keyword">char</span> *)buf, str.<span class="built_in">size</span>()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不只是不存在key就创建key并返回那么简单。</p><ol><li>关于save_string的问题，这里也是和之前一样，创建了string后由ctx来管理生命周期，返回一个string_view提供使用。</li><li>除此之外get_symbol的部分是实际执行了符号不存在则创建新符号并且返回的工作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we haven&#x27;t seen the same `key` before, create a new instance</span></span><br><span class="line"><span class="comment">// of Symbol and returns it. Otherwise, returns the previously-</span></span><br><span class="line"><span class="comment">// instantiated object. `key` is usually the same as `name`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">Symbol&lt;E&gt; *<span class="title">get_symbol</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view key,</span></span></span><br><span class="line"><span class="params"><span class="function">                      std::string_view name)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.symbol_map)</span>::const_accessor acc</span>;</span><br><span class="line">  ctx.symbol_map.<span class="built_in">insert</span>(acc, &#123;key, Symbol&lt;E&gt;(name)&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;Symbol&lt;E&gt; *&gt;(&amp;acc-&gt;second);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>最后提一下-wrap option选项</li></ol><p>这个-wrap是在main中read_input_files之前的地方设置的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --wrap options if any.</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.wrap)</span><br><span class="line">  <span class="built_in">get_symbol</span>(ctx, name)-&gt;wrap = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>关于这个选项我参考了这个回答里的内容，虽然是gcc的介绍，但是本质是相同的</p><p><a href="https://stackoverflow.com/questions/46444052/how-to-wrap-functions-with-the-wrap-option-correctly">How to wrap functions with the <code>--wrap</code> option correctly?</a></p><p>我摘选了一些关键的段落</p><blockquote><p>-wrap=symbol<br>Use a wrapper function for symbol. Any undefined reference to symbol will be resolved to “__wrap_symbol”. Any undefined reference to “__real_symbol” will be resolved to symbol.<br>…<br>If you link other code with this file using –wrap malloc, then all calls to “malloc” will call the function “__wrap_malloc” instead. The call to “__real_malloc” in “__wrap_malloc” will call the real “malloc” function.</p></blockquote><blockquote><p>… Any <strong>undefined reference</strong> to symbol will be resolved to “__wrap_symbol”. Any <strong>undefined reference</strong>  to “__real_symbol” will be resolved to symbol.</p></blockquote><p>至此，initialize_symbols就结束了</p><h2 id="sort-relocations"><a href="#sort-relocations" class="headerlink" title="sort_relocations"></a>sort_relocations</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Relocations are usually sorted by r_offset in relocation tables,</span></span><br><span class="line"><span class="comment">// but for some reason only RISC-V does not follow that convention.</span></span><br><span class="line"><span class="comment">// We expect them to be sorted, so sort them if necessary.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">sort_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> less = [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> a.r_offset &lt; b.r_offset;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; sections.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec = sections[i];</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive || !(isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (!std::<span class="built_in">is_sorted</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), less))</span><br><span class="line">        <span class="built_in">sort</span>(rels, less);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释，这里的sort是为了将不遵守约定没按照r_offset排序的rv的relocations转换为遵循约定的格式</p><h2 id="initialize-ehframe-sections"><a href="#initialize-ehframe-sections" class="headerlink" title="initialize_ehframe_sections"></a>initialize_ehframe_sections</h2><p>关于这里的内容比较长，不仅要包含解析本身，还有ehframe本身的内容，因此留到下期再继续讲。</p><h1 id="图解总结"><a href="#图解总结" class="headerlink" title="图解总结"></a>图解总结</h1><p>画了一些比较粗糙的图示将今天的内容串联起来（未标记长度信息，部分大小不标准，没精力画了）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%203.png"                      alt="Untitled"                ></p><p>首先是读取InputFile时的流程，主要是ElfHeader指向ELF文件的哪一部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-1-read-input-files/Untitled%204.png"                      alt="Untitled"                ></p><p>其次是读取Section的时候符号表相关的查找流程，这里还没来得及画具体取名字的部分</p><p>从Section Header Table中找到对应sh_type为SHT_SYMTAB的段，之后根据offset和size找到具体存放symbol的位置，同时通过sh_info确定第一个global symbol的index</p><h1 id="参考资料汇总"><a href="#参考资料汇总" class="headerlink" title="参考资料汇总"></a>参考资料汇总</h1><p><a class="link"   href="https://refspecs.linuxbase.org/elf/gabi4+/ch4.sheader.html" >Sections<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://refspecs.linuxfoundation.org/elf/elf.pdf" >Elf Specification 1.2<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-1-read-in</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>美丽新世界</title>
    <link href="https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/"/>
    <id>https://fusionbolt.github.io/2023/02/19/Reading/brave-new-world/</id>
    <published>2023-02-19T13:25:02.000Z</published>
    <updated>2023-02-19T13:25:58.736Z</updated>
    
    <content type="html"><![CDATA[<p>起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。</p><blockquote><p>到最后，孩童的心灵就是这些暗示，暗示的总和就是孩童的心灵。而且不只是孩童的心灵，成人的心灵也是——一辈子都是。下判断、产生欲望、做决定的那个心灵——就由这些暗示构成。但这所有暗示都是我们的暗示！</p></blockquote><p>这哪里美丽了，这简直是地狱。</p><p>但是读到后面，我开始动摇了。在这里的人只需要舒适就可以了，无需遭受病痛的折磨，每个人之间都彼此相属也就因此不会因为孤单而痛苦，甚至不需要思考，顺从周围的人以及大脑中已经调整好的暗示去做就好了。即便遇到不如意的事情，还有索麻来将他们从痛苦的当下逃离。</p><blockquote><p>因为我们的世界跟奥瑟罗的世界不同了。你无法不用钢铁来制造福利佛——而没有不稳定的社会，你也不可能创造出悲剧。这个世界现在稳定了。人人都很快乐，他们得到他们想要的东西，而他们永远不会想要他们得不到的。他们很富裕，他们很安全，他们从不生病，他们不怕死，他们幸福地不知何谓激情与老迈，他们没有母亲或父亲的折磨，他们没有妻子、孩子或爱人可以激起强烈的感觉，他们被制约得这么厉害，以至于他们实际上忍不住要表现出他们应有的行为。而要是有任何事情出了错，还有索麻</p></blockquote><p>而上面提到的丧失自由，被歧视，阶级固化等内容，对于”劣等“的人种自身来说并不是什么问题，他们也从来没有觉得这是什么问题。这里的人们也并非丧失了所有的自由，他们有着局限于新世界法则的自由，对于他们来说这样就可以了。所有的消息渠道都不会让他们了解一切的真相，只要他们不了解，继续蒙在鼓里，那么就不会感到任何痛苦。</p><blockquote><p>对他们而言，他们不是牺牲品，他们是最没有抗拒能力的品系。他的制约已经铺好他该沿着哪条铁轨前进。他无法克制自己不这样做，他注定如此。</p></blockquote><p>遭受痛苦与折磨的我无法否认自己读到这里产生了对这种环境的向往，尽管有最初那么多令人反感的描述，尽管明知代价是失去自我、放弃真正的自由、放弃崇高的精神，但这里的人不需要承受痛苦，只需要舒适就可以了。这样撒手不管是很轻松，我想大多数人也都是更倾向于这样的选择，不去产生改变。</p><p>如果身为当局者的话很难对这些问题进行讨论与判断，想法会受到世界本身的限制，如果我是那个世界中的一员，那么我大概率也是会和大多数人一样认为所谓真正的自由、痛苦都很荒谬。接下来还是回到旁观者的上帝视角来看待这一切。以上提到的内容在新世界中是完全对立的：是选择要自我、自由与痛苦，还是舒适和快乐。</p><p>如管制官所说</p><blockquote><p>强调的重点从真理与美转移到舒适与快乐。<br>普遍的快乐，让轮子稳定地转动下去，真理与美却做不到。</p></blockquote><p>新的世界也是如此形成的。追求真理与美是不可能舒适与快乐的，真理与美来自于经历苦难，破坏性的变化。这让我想起加缪的《快乐的死》中提到的观点，高质量的幸福需要通过痛苦体现。同时在管制官和野人的对话中屡次出现莎士比亚的作品，其作品以悲剧美而闻名，也是一个很好的例子。沉溺在舒适与快乐之中无法寻求到真理，每种科学的发现都有潜在的破坏性，而要突破这种破坏性并不会使得舒适与破坏性。在舒适和快乐中也无法体现出人性的美，罗翔老师举过一个例子。</p><blockquote><p>如果现在有一个小黄书，郭德纲相声，一个莎士比亚，三者都会给你带来一些快乐。但是你即便真诚的认为小黄书给你带来了愉悦，郭德纲的相声给你带来了快乐，但只能留一本书，你留哪本书？莎士比亚。这个故事告诉我们，越能体现人性尊严的快乐，越是一种最大的快乐，因为它跟人的尊严有关。</p></blockquote><p>对于“新世界”来说，他们无法得知这一切，大部分人也没有选择的权利。对于现实社会来说，我们完全可以了解到这一切，并且两者都选择，只是或多或少罢了。还是如罗翔老师所说</p><blockquote><p>我读莎士比亚并不妨碍我听郭德纲的相声，但是如果你的眼目永远只关心地下，你永远不知道向上看有多么快乐。</p></blockquote><p>不过我们现在所处的“小小世界”，在许多方面已经有了这样的影子，逐渐开始失去了选择的权利。从想法来说，所谓人们的想法就是来自所处的环境、所处的社会、所接触到的地域文化，这让我想到了某些洗脑的宣传，以及不断试图阻挡人们看到真相的，某个大家都很熟知的地方。既然你无法得知真相与其他答案，面前只有一个选项，那么你很大概率不会去考虑这个选项的对与错。除此之外，我还想到了昨天和朋友聊天的时候他提到的“异化”一词</p><blockquote><p>所谓的「自由而来的不自由」。你有一定的自由分工、自由迁徙的能力，但是正是由于深度的投入到了某个社会分工内而被困在了这个环境下的「不自由」。</p></blockquote><p>这个“世界”的人们都是如此，渐渐开始失去了部分的自由，而这份不自由也正是由所处的这个“世界”所造成的。大部分人像阿尔法一样遵循着一直以来的”睡眠教学法“，有的人们像伯纳德一样略微窥探到了一些，有的人像管制官一样看到了全部，即便看到了一切，但我们仍然是被禁锢着，只是所在的“瓶子”或许没有那么小但是不知道哪一天这个瓶子可能会缩到非常小，我想这也正是作者所担忧的事情，担心人们连自己选择一切的权利都失去了，担心人们人生的一切都是被安排的。</p><p>这样的世界我无法断言好还是坏。如果选择经历苦难，那么你要具备面对苦难的能力，你要不断的经历痛苦以及发现真理与美。如果你选择舒适与快乐，那么你将放弃自我，放弃自由。管制官与“野人”的选择则是非常强烈的对比，两者在得知了一切并且有选择权的情况下，一个选择了前者，另一个选择了后者。不论选择哪一个，其实都要付出代价。在这样的世界，绝大部分人其实是没有选择的权利的，但是在现实世界中绝大部分人依然有选择的权利，如果只能在这两者之间选择，你是要成为野人，还是管制官呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;起初阅读前面对于这个“美丽新世界”构成的时候我并没有感觉到任何美丽，有的只有反感，这里的人们丧失自由，被制约，几乎人生的一切都被安排好，无法改变的人种歧视与阶级的固化，许多错误的观念从小就被根植在记忆深处，想法都是受到操纵的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;到最后</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="奥尔德斯·赫胥黎" scheme="https://fusionbolt.github.io/tags/%E5%A5%A5%E5%B0%94%E5%BE%B7%E6%96%AF%C2%B7%E8%B5%AB%E8%83%A5%E9%BB%8E/"/>
    
  </entry>
  
  <entry>
    <title>心理咨询是怎样的</title>
    <link href="https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/"/>
    <id>https://fusionbolt.github.io/2023/02/18/Life/psychological-counseling/</id>
    <published>2023-02-18T14:30:49.000Z</published>
    <updated>2023-02-18T14:56:45.413Z</updated>
    
    <content type="html"><![CDATA[<p>本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。</p><p>首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询师进行商定，间隔超过一周可能时间太久内容难以连贯，少于一周可能费用上更难接受一些，即便是最便宜的档次一周一次，一个月也要2000的费用，更何况这是一项长期的工作，<strong>如果你能接受这个价格再继续看下去</strong>。流程上也没有什么特别的，预约时间，当天到咨询师所在的地方进行一小时左右的沟通，基本上是一对一。（这里咱不探讨团体咨询以及多人咨询）</p><p>咨询的方式有着不同的流派，而不论是什么流派，咨询的过程都是沟通为主。咨询师会问你各种问题，又或者由你自己挑起某些话题，如果可以还是自己选择某些比较关心的话题开场比较好，而具体的话题会因流派不同而异。有的流派会倾向于长期咨询，有的会倾向于短期解决问题，在选择的时候还是需要注意，通常咨询之前也会问你是想要进行短期还是长期的咨询ty。我在此更建议长期的咨询，首先咨询师需要几次对话充分了解你，你也需要几次机会去熟悉跟咨询师去讲述一些事情，后面需要更长的周期去一点点深入自己的内心，一点点的去修复问题。在对话的过程中，通常会涉及到你的许多想法、感受、过去、秘密、家庭、人际关系等等，同时在这个交流沟通的过程中，会不断探寻自己的内心，有的时候就戳到痛处，如果要选择咨询，要做好暴露一切的心理准备。有的人并不在意和陌生人讲这些，但也有的人面对陌生人会比较难以说出这些，这些人群需要一定时间去适应，也不必觉得因为自己不想说就完全不适合去咨询。咨询时有什么不适的感受也都尽情的跟咨询师提出，不用担心提出意见会有什么攻击性的反应，我之前对咨询师的一些问法感到厌烦，及时和咨询师进行沟通，这种厌烦感也就慢慢结束了。</p><p>在我目前的理解与体验咨询主要以两种形式起作用。第一种是感性上的支持，对于心里积攒着很多想法的人来说，咨询师会耐心倾听你的诉说，在这个过程中你可以放心的讲你所不愿跟别人讲的秘密，或者你认为会被人厌烦的内容，不必担心被人拒绝，被人讨厌。而对于孤单的人来说，咨询师也是一个每周陪伴你的人，不会因为你做错了什么就会放弃你。他们会给予你情感上的支持，在你遇到问题会与你产生共情。第二种则是理性上的支持，对于需要咨询的人来讲，通常会有许多思维的误区，而找出这些误区也是咨询师们的工作之一。另外还会对你一些具体的问题会给出建设性的建议，最关键的是和你一起分析你的问题，你的思维方式，作为一个旁观者，而不是作为你自己来观察这一切，远比自己观察的要清楚。你需要明白这些，在这个过程中你可能会学会自己查找自己的问题，同时还会增强你对于自己问题的修正。</p><p>以下是《神经症与人的成长》这本书中的摘录</p><blockquote><p>所有精神方面可能涉及到的知识，都可以使每个人有机会找出自己的困难所在。</p></blockquote><blockquote><p>此外，病人不可只知道这些个别因素，而且也应该知道其间的关系与其相互间的作用。</p></blockquote><blockquote><p>了解所有的这些因素，并非指懂得这些因素的死知识，而是意指要彻底地去认识它们。</p></blockquote><p>对于一些十分特别的流派或许会有其他更特别的解决方式，这里暂且不谈论。</p><p>不论如何起作用，心理咨询的过程是一个不断探寻自己内心的过程，看到现在的自己和过去的联系，而目的是为了让你重新找回对抗问题的力量，而不是帮助你解决所有问题。理解了一个又一个的问题，解决了一个又一个问题的过程，同时也是在不断增强自身力量的过程。</p><p>也许你会在纠结到底要不要进行咨询，你不如换个问题，你想要通过咨询获得什么？对于我来说，通常会对自己的想法进行基本的觉察与反思，也并没有什么一定要跟别人倾诉的苦水，我需要一个人从外部来看待我，帮助我更快的解决自己的问题，找到我自己难以看到的想法中的误区，毕竟“当局者迷”，同时想要有人跟我深入的探讨一些个人成长与性格中的一些问题。事实上我最近三次的咨询也确实达到了期望的效果。这些问题没法跟认识的绝大部分人去交流，有的人不关心这些，有的人不愿意聊这些，或者说没有那么要好的朋友，谈论这些内容或许是需要非常深入密切的关系才行，你需要袒露你内心中的秘密，你要愿意将这个秘密讲出来，而对方也要愿意接受你的秘密，愿意帮助你解决这些问题。</p><p>在这里要认清一些思维误区。首先并不是去咨询了就一定能解决任何问题，也不是依靠咨询师就能解决大部分问题，咨询师只是辅助你解决问题，最终还是需要你自己去真正改变想法。其次咨询并不是什么丢人的事情，或许在大众的认知中去接受心理咨询就是所谓的“神经病“，但我想你看了上面的内容后或许不会这样想，即便是这个领域大师级别的人物仍然需要他人帮助自己进行心理咨询。</p><p>如果想要了解更多关于心理咨询的过程或者其他内容，可以参考《也许你该找个人聊聊》。另外个人十分推荐《神经症与人的成长》，书中的一些分析讲的非常棒，非常有助于理解自己的一些问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文根据自身心理咨询的认识与经历，写下了一些想要进行心理咨询的人们可能关心的问题。&lt;/p&gt;
&lt;p&gt;首先是价格，我目前在一些平台了解的结果，除去新手咨询师外价格通常在500-1000+不等（此处不推荐平台以及咨询师的选购指导）。而咨询的频率通常是在一周一次，具体频率需要和咨询</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="心理咨询" scheme="https://fusionbolt.github.io/tags/%E5%BF%83%E7%90%86%E5%92%A8%E8%AF%A2/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读 其零 main</title>
    <link href="https://fusionbolt.github.io/2023/02/12/mold/mold-0/"/>
    <id>https://fusionbolt.github.io/2023/02/12/mold/mold-0/</id>
    <published>2023-02-12T14:06:32.000Z</published>
    <updated>2023-02-19T05:33:14.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/FWlv3FsaMAAdSs2-20230212221048408.jpeg"                      alt="图像"                ></p><p>我们从main函数的开始，大致讲一下都做了哪些事情。之后再从每个流程中的具体实现开始阅读（如果我记得的话会回头在这里补上对应的链接），或者会以解决某些问题为线索写一篇，比如说某一些常见的参数具体在mold中怎么生效的，比如说whole_archive这种。为保证两部分文章内容的连贯性，内容不可避免会有一定重叠。</p><p>这个系列的一些约定</p><ol><li>只考虑elf的支持，其他平台相关的不再考虑</li><li>文件路径都是项目根目录的相对路径</li></ol><h1 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h1><p>由于代码比较少，项目的结构非常简单</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── docs</span><br><span class="line">├── elf</span><br><span class="line">├── test</span><br><span class="line">│   └── elf</span><br><span class="line">└── third-party</span><br><span class="line">    ├── mimalloc</span><br><span class="line">    ├── rust-demangle</span><br><span class="line">    ├── tbb</span><br><span class="line">    ├── xxhash</span><br><span class="line">    ├── zlib</span><br><span class="line">    └── zstd</span><br></pre></td></tr></table></figure><p>根目录下有一些共用的文件以及一些项目的常规文件</p><p>启动的main函数也是在根目录下</p><p>在elf目录下是我们需要看的主要核心代码</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-0/Untitled.png"                      alt="Untitled"                ></p><p>在这之中有两个作为主线的文件: main.cc和passes.cc</p><p>实际执行链接的主要流程都存放在main.cc的elf_main中，而这个过程执行的代码大多会指向passes.cc中的函数。不同目标arch的文件都用相应的文件名区分开了，以及其他的文件看名字也相对比较易懂。</p><h1 id="链接前的准备流程"><a href="#链接前的准备流程" class="headerlink" title="链接前的准备流程"></a>链接前的准备流程</h1><p>main.cc</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  mold::mold_version = mold::<span class="built_in">get_mold_version</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> MOLD_IS_SOLD</span></span><br><span class="line">  std::string cmd = mold::<span class="built_in">filepath</span>(argv[<span class="number">0</span>]).<span class="built_in">filename</span>().<span class="built_in">string</span>();</span><br><span class="line">  <span class="keyword">if</span> (cmd == <span class="string">&quot;ld64&quot;</span> || cmd == <span class="string">&quot;ld64.mold&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> mold::macho::<span class="built_in">main</span>(argc, argv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mold::elf::<span class="built_in">main</span>(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elf/main.cc</p><p>默认采用了X86_64</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> elf_main&lt;X86_64&gt;(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的Machine Type是通过模板类型来区分的。在elf_main里面创建了全局的Context对象（并非是代码实现层面上的全局对象，只是所有的流程都需要传递ctx）并且解析命令行参数（命令行参数的具体实现就不再细看了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">elf_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  Context&lt;E&gt; ctx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Process -run option first. process_run_subcommand() does not return.</span></span><br><span class="line">  <span class="keyword">if</span> (argc &gt;= <span class="number">2</span> &amp;&amp; (argv[<span class="number">1</span>] == <span class="string">&quot;-run&quot;</span>sv || argv[<span class="number">1</span>] == <span class="string">&quot;--run&quot;</span>sv)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(__APPLE__)</span></span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;-run is supported only on Unix&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">process_run_subcommand</span>(ctx, argc, argv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parse non-positional command line options</span></span><br><span class="line">  ctx.cmdline_args = <span class="built_in">expand_response_files</span>(ctx, argv);</span><br><span class="line">  std::vector&lt;std::string&gt; file_args = <span class="built_in">parse_nonpositional_args</span>(ctx);</span><br></pre></td></tr></table></figure><p>获取具体的machine_type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If no -m option is given, deduce it from input files.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emulation == MachineType::NONE)</span><br><span class="line">  ctx.arg.emulation = <span class="built_in">deduce_machine_type</span>(ctx, file_args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redo if -m is not x86-64.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, X86_64&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(ctx.arg.emulation != MachineType::X86_64)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> redo_main&lt;E&gt;<span class="params">(argc, argv, ctx.arg.emulation)</span></span>;</span><br></pre></td></tr></table></figure><p>redo_main就是简单的根据命令行参数指定的target来选择对应的模板类型进行特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">redo_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, MachineType ty)</span> </span>&#123;</span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ty) &#123;</span><br><span class="line">  <span class="keyword">case</span> MachineType::I386:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;I386&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::ARM32:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;ARM32&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV64BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV64BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32LE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32LE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::RV32BE:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;RV32BE&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V1:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V1&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::PPC64V2:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;PPC64V2&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::S390X:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;S390X&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::SPARC64:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;SPARC64&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">case</span> MachineType::M68K:</span><br><span class="line">    <span class="keyword">return</span> elf_main&lt;M68K&gt;(argc, argv);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链接大体流程"><a href="#链接大体流程" class="headerlink" title="链接大体流程"></a>链接大体流程</h1><p>根据注释和我个人的理解，分为如下这么几大部分</p><ol><li>解析所有的输入，包含命令行参数，输入的各种文件</li><li>对于输入做链接器最基本的处理，包含符号解析，段合并，符号检查之类的</li><li>创建一些synthetic的内容，包括一些段和符号</li><li>将所有段、符号进行扫描以及按照需求进行排序，添加到全局的ctxt中</li><li>计算与修正一些具体的信息，固定生成产物的memory layout</li><li>修正某些地址，确保固定file layout</li><li>将所有文件拷贝到输出文件中</li><li>结束的清理操作</li></ol><p>其中有些地方可以根据Timer来协助划分链接的流程。比如说拷贝到输出之前有这样一行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Timer <span class="title">t_copy</span><span class="params">(ctx, <span class="string">&quot;copy&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>而到了后面的部分有这么一行对应，中间的部分很自然就是这一个步骤做的事情了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t_copy.<span class="built_in">stop</span>();</span><br></pre></td></tr></table></figure><p>而main函数中的内容比较简洁，几乎每个小功能都划分为了一个函数，而且附加了大量的注释，比如说这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create .bss sections for common symbols.</span></span><br><span class="line"><span class="built_in">convert_common_symbols</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Apply version scripts.</span></span><br><span class="line"><span class="built_in">apply_version_script</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse symbol version suffixes (e.g. &quot;foo@ver1&quot;).</span></span><br><span class="line"><span class="built_in">parse_symbol_version</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set is_imported and is_exported bits for each symbol.</span></span><br><span class="line"><span class="built_in">compute_import_export</span>(ctx);</span><br></pre></td></tr></table></figure><p>再加上代码比较长，这里就不放后续完整代码了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-0/FWlv3Fs</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>链接器起始篇</title>
    <link href="https://fusionbolt.github.io/2023/01/17/linker/linker-init/"/>
    <id>https://fusionbolt.github.io/2023/01/17/linker/linker-init/</id>
    <published>2023-01-17T12:31:34.000Z</published>
    <updated>2023-01-17T12:27:42.292Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/linker-init/Untitled.jpeg"                      alt="Untitled"                ></p><p>又开始不务正业乱开新坑了。接下来会通过阅读mold的源码来学习如何实现一个ELF链接器，有精力也会再跟着plct的这个课程学习实现一个简单的RV ELF链接器，可能会跟着将代码换一门语言翻译一遍，将这个学习过程中遇到的知识点记录到博客中。如果坑能开到后面的话我还会针对这门课程实现的链接器在功能上与mold的进行比较，一门教学用的链接器和真正实用的链接器在功能上有哪些差别。</p><p><a class="link"   href="https://github.com/rui314/mold" >https://github.com/rui314/mold<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://ksco.cc/rvld/" >index<i class="fas fa-external-link-alt"></i></a></p><p>从未了解过链接器实现的我，在跟着mold源码和这门课程之前，先来写一下根据我现有的知识去设想一个链接器内部应该大致有哪些功能。（本期内容不是教程，只是我个人对知识的回忆，因此很多地方都会缺很多东西）同时回忆过后对比检查理解的问题，在差不多理解整体运作过程的情况下学习会更有效一些。</p><h1 id="链接器做了什么"><a href="#链接器做了什么" class="headerlink" title="链接器做了什么"></a>链接器做了什么</h1><ol><li>链接器做的事情是将多个编译器生成的目标文件的内容合到一起</li><li>处理符号。在编译期间要求编译生成的目标文件中每个符号小于等于一个定义，在链接的时候链接器负责找到未定义的符号的地址，重复符号的解决（如果是弱符号则根据规则选取其中一个定义，如果非弱符号则需要报错）</li></ol><h1 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h1><p>要合并目标文件那么我们要知道目标文件的内容是什么样的（这里我们仅探讨ELF的格式）。先不查阅文档，想一下目标文件大概会有什么内容。</p><h2 id="段"><a href="#段" class="headerlink" title="段"></a>段</h2><p>首先是对于我们写代码的时候经常提到的一些段，比如说代码段、数据段、BSS段、堆、栈等等。这些段本身只是一串数据，那么我们需要一个位置存放起始位置和数据长度。而其中的各种段名以及各种符号名也需要一个位置保存，因此目标文件中还需要有一个符号段用于保存各种用于链接使用的符号。（strip是否就是去掉这里）我们知道debug模式生成的代码包含debug信息，而这些信息对于elf来说是写在内部的，因此里面还需要有保存调试信息的段。</p><h2 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h2><p>类似于段段起始和长度这种</p><p>寻找保存具体信息的信息需要放到一个文件头中，除此之外文件头中还需要一些魔数来标识文件类型。</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>保存所有代码中符号的相关信息（而不是段名的符号），最容易想到的就是地址，其次上面提到了符号的强弱。</p><h1 id="行为控制"><a href="#行为控制" class="headerlink" title="行为控制"></a>行为控制</h1><p>而更精细控制这些行为的方式一个是命令行参数，另一个是链接脚本。由于系统中内置了默认的链接脚本，我们日常很少会接触到这些。读取链接脚本也是链接器很重要的一个功能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下来，链接器主要的功能如下</p><ol><li>读取目标文件ELF文件头</li><li>读取链接脚本并且按照链接脚本控制链接行为</li><li>符号解析</li><li>合并段</li><li>生成对应的ELF文件</li></ol><p>而plct课程的大纲如下</p><p>第一课：搭建开发环境、初始化项目、开始读取 ELF 文件</p><p>第二课：继续读取 ELF 文件</p><p>第三课：解析链接器参数</p><p>第四课：解析静态链接库文件</p><p>第五课：解析未定义符号，移除未使用文件</p><p>第六课：处理 Mergeable Sections</p><p>第七课：开始写文件</p><p>第八课：处理 Output Sections</p><p>第九课：继续处理 Output Sections</p><p>第十课：Phdr 和 Merged Sections</p><p>第十一课：处理重定向，课程回顾</p><p>可以说做的功能大致类似，之后就会先从mold的源码开始开新系列了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/linker-init/Un</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
  </entry>
  
  <entry>
    <title>调试器之工作原理</title>
    <link href="https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/"/>
    <id>https://fusionbolt.github.io/2023/01/09/Debugger/debugger-0/</id>
    <published>2023-01-09T15:27:58.000Z</published>
    <updated>2023-01-09T15:30:36.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试器之工作原理"><a href="#调试器之工作原理" class="headerlink" title="调试器之工作原理"></a>调试器之工作原理</h1><p>之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么实现运行时断点的。今天来简单了解一下调试器部分功能的工作原理。</p><h1 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h1><p>对于调试来说第一步是要下断点。断点本质是到了指定位置后中断当前的进程，进入对应的中断处理程序。（信号的本质是软中断，这里、统一称发生了中断）</p><p>根据实现方式的不同分为如下三类。</p><h2 id="软件断点"><a href="#软件断点" class="headerlink" title="软件断点"></a>软件断点</h2><p>当cpu执行了特定调试指令后会发出一个中断，而软件断点要做的就是在对应的pc位置“插入”断点指令，说是插入，实际上是修改原指令，触发中断后再写回。</p><p>以x86的INT3指令为例，在一个位置设置断点后会保存该位置的原指令，之后在该位置写入INT3，当执行到这条指令的时候发生软中断，内核向子进程发送SIGTRAP信号，之后这个信号转发给父进程，此时再用保存的指令替换之前写入的INT3指令等待中断恢复。</p><h2 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a>硬件断点</h2><p>某些cpu包含调试用的寄存器，通过设置对应的值来控制对应产生中断的pc位置以及一些其他信息。</p><p><a class="link"   href="https://en.wikipedia.org/wiki/X86_debug_register" >x86 debug register - Wikipedia<i class="fas fa-external-link-alt"></i></a></p><p>cpu在执行代码之前会先确定要执行的地址是否保存在中断寄存器中，同时确认访问的地址是否处于设置了硬件断点的区域内，满足条件后会触发INT1中断。</p><h2 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a>内存断点</h2><p>通过设置对应内存位置所在页为guard page，对保护页访问则会触发异常，之后页面恢复访问前的状态。</p><h1 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h1><p>Linux中我们可以直接通过ptrace来打断点、读取信息或者是单步执行等。</p><p>关于ptrace的文档：<a class="link"   href="https://man7.org/linux/man-pages/man2/ptrace.2.html" >https://man7.org/linux/man-pages/man2/ptrace.2.html<i class="fas fa-external-link-alt"></i></a></p><h2 id="直接调试"><a href="#直接调试" class="headerlink" title="直接调试"></a>直接调试</h2><p>首先我们来看一下用法示例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ptrace.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/user.h&gt;</span> </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">pid_t</span> child;</span><br><span class="line">    <span class="keyword">long</span> orig_eax;</span><br><span class="line">    child = fork();</span><br><span class="line">    <span class="keyword">if</span>(child == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">execl</span>(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        orig_eax = <span class="built_in">ptrace</span>(PTRACE_PEEKUSER,child, <span class="number">4</span> * ORIG_EAX,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The child made a &quot;</span><span class="string">&quot;system call %ld\n&quot;</span>, orig_eax);</span><br><span class="line">        <span class="built_in">ptrace</span>(PTRACE_CONT, child, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被调试的程序通过ptrace(PTRACE_TRACEME)来设定自身是被trace的对象，接着通过execl来执行对应的命令行程序，此时执行的程序作为调试器的子进程。</p><p>而调试器进程本身则是通过wait去等待子进程停下来，等wait返回后就可以查看子进程的信息或者对子进程进行操作。对于ptrace使用方面来说最重要的是选择合适的__ptrace_request，大多数调试器常见的功能都能通过设置这个参数来实现，比如说单步。</p><p>这个项目使用ptrace实现了许多debug的基础功能</p><p><a class="link"   href="https://github.com/Kakaluoto/ptraceDebugger" >https://github.com/Kakaluoto/ptraceDebugger<i class="fas fa-external-link-alt"></i></a></p><h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>通过设置__ptrace_request为PTRACE_ATTACH或者PTRACE_SEIZE还可以调试一个当前已经启动的进程。</p><p>对于常规的调试和attach的本质区别自然是进程间的关系，直接调试中调试器进程和被调试进程互为父子进程，而attach时两者是独立的，也因此有的时候attch会需要管理员权限。</p><h1 id="其他系统"><a href="#其他系统" class="headerlink" title="其他系统"></a>其他系统</h1><p>以上ptrace的实现都是基于Linux的api来讲的，macOS的ptrace的request缺少非常多基本功能，比如说读取寄存器的值。如果想要在mac下实现可以参考如下链接，如果是arm的Mac则这里很多接口仍然过时。（我反正不想折腾了，有这时间多看下Linux的不香吗）</p><p><a class="link"   href="http://uninformed.org/index.cgi?v=4&a=3&p=14" >Uninformed - vol 4 article 3<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.spaceflint.com/?p=150" >Using ptrace on OS X<i class="fas fa-external-link-alt"></i></a></p><p>而对于windows来说则是提供了另一套完全不同的api，有兴趣的可以自行了解。</p><p><a class="link"   href="https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-engine-and-extension-apis" >Debugger Programming Extension APIs - Windows drivers<i class="fas fa-external-link-alt"></i></a></p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>这一期的内容都是一些非常容易搜到的基础知识，如果不鸽的话调试器后面会继续深入学习，造一个自己的debugger之类的。大概也会作为一个系列更新，可能深入的方向有如下几个</p><ol><li>ptrace的具体实现细节代码</li><li>debug信息的格式以及源码级调试</li><li>lldb的学习</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;调试器之工作原理&quot;&gt;&lt;a href=&quot;#调试器之工作原理&quot; class=&quot;headerlink&quot; title=&quot;调试器之工作原理&quot;&gt;&lt;/a&gt;调试器之工作原理&lt;/h1&gt;&lt;p&gt;之前对于调试器并没有什么了解，对于很多问题也没什么头脑，比如说attach是怎么做到的，怎么</summary>
      
    
    
    
    <category term="Debugger" scheme="https://fusionbolt.github.io/categories/Debugger/"/>
    
    
    <category term="ptrace" scheme="https://fusionbolt.github.io/tags/ptrace/"/>
    
  </entry>
  
  <entry>
    <title>2022年终总结</title>
    <link href="https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/"/>
    <id>https://fusionbolt.github.io/2022/12/31/Summary/summary-2022/</id>
    <published>2022-12-31T14:59:28.000Z</published>
    <updated>2022-12-31T15:08:11.573Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。</p><h1 id="去年的愿景"><a href="#去年的愿景" class="headerlink" title="去年的愿景"></a>去年的愿景</h1><p>去年的愿景许多方面我没有非常明确具体的目标，这对实现目标来说恰恰是致命的。以下这段来自我去年的年终总结</p><blockquote><p>不用多说，身心健康是一定会有的，这个是持续的目标，也是最难达到的</p><p>想要成为编译器专家，但是我觉得自己能熟练掌握就不错了，先以这个作为目标吧……我能做的只有一点点积累，所以会先从搞好当前在做的编译器开始，在这个过程中让自己编译器方面的知识获得提升</p><p>想要拍到很多好照片，年底想做出自己的照片集，不过这还需要学习设计排版的知识。希望能在摄影的过程中发现更多的乐趣，并且能以此为媒介感受和表达更多的东西</p><p>自己想要和别人一起努力，而不是都是自己一个人闷头做。我认为和他人一起努力很多时候会产生数倍的效果，但是我自身的种种导致最终总是会使得他人远离我，不论是哪里。我自知这很悲观且问题出自自身，但这也是我的无奈</p><p>想要写好博客，而不是像今年一样咕咕咕；还想要学到很多新东西，想要认识新的人等等</p><p>明年想要的太多了，我的贪心今年仍未衰减，反而更强烈了。明年也要为了自己的各种想法而努力，不过对于我这样各方面能力值都不够的人贪心一定要付出更多的代价：需要花费更多的时间（现在每天的时间都已经满满当当了），精力会分散，对于本来精力槽就不高的我提出了挑战</p></blockquote><p>去年的年终总结：<a class="link"   href="https://homura.live/2021/12/26/Summary/summary-2021/" >https://homura.live/2021/12/26/Summary/summary-2021/<i class="fas fa-external-link-alt"></i></a></p><h2 id="身心健康"><a href="#身心健康" class="headerlink" title="身心健康"></a>身心健康</h2><p>按我现在的状态怎么都算不上身心健康。今年去体检查出一大堆的小问题，其中一项还影响到了脑血管，某种物质代谢不完全残留在血液中，导致容易形成了斑块，大概是基因加饮食习惯的问题，及时查出来也算是好事，补充了一些维生素B族后相关参数明显恢复正常值了，还没来得及再复诊。</p><p>精神状况今年一开始的时候状态还算可以，但是2月底有一次我超负荷运转了两三天，之后开始各种不太好。4月去医院大夫又加了新的药，后来6月底为了改善睡眠质量加上了安眠药，几个月后我发现这个大夫一直有问题就加药，同时每次和这个大夫沟通都感觉被当傻子一样对待，于是我又换了大夫，这个大夫让我停掉了安眠药。在这个不断换药的途中不论是睡眠还是精神状态都没有趋于稳定。</p><p>说到健康一定离不开锻炼。这方面确实做得不够，每次都是锻炼了一段时间就因为各种各样的理由暂停了。也不是多么讨厌锻炼，只是没有形成一种自然而然的习惯。</p><h2 id="做好编译器"><a href="#做好编译器" class="headerlink" title="做好编译器"></a>做好编译器</h2><p>一直到5月份还都在认真做自己的compiler，其中2月底开始用Scala换掉ruby，由于开发的效率不高，5月的时候前端的东西才差不多能跑了，此时需要开始做一些优化层面相关的事情，我从每天固定提交代码转变到了学习阶段。</p><p>在前期实现的过程中研究了一段时间rust的代码，开始学习优化的时候又去学了一点LLVM的东西，从PassManager开始到一些简单的Pass，对LLVM的整体结构以及一些组件有了一些了解。之后关于compiler随便读了点书，了解了一些概念，实现了一点简单的分析和优化，还实现了一点后端部分，结合gcc能够生成非常简单的native代码，这些部分我就没有放到我的博客里了。这个过程大概持续到九月多，中间也有很长一段时间都很少去学些什么。</p><p>LLVM相关的文章：<a class="link"   href="https://homura.live/tags/LLVM/" >https://homura.live/tags/LLVM/<i class="fas fa-external-link-alt"></i></a></p><p>自己的compiler开发周记：<a class="link"   href="https://homura.live/tags/Rc-lang/" >https://homura.live/tags/Rc-lang/<i class="fas fa-external-link-alt"></i></a></p><h2 id="拍到很多照片"><a href="#拍到很多照片" class="headerlink" title="拍到很多照片"></a>拍到很多照片</h2><p>今年也算是拍了一些照片，最初的安排是每周末出门拍照，只是从五月疫情严重居家办公开始，之后出门拍照的次数越来越少，而夏天也因为太热几乎没有出门拍照。不过到了合适的时节，（比如说中秋节）还是会去特定的地点拍一些照片。关于照片集，虽然有过想做的想法，也调研过一点点相关资料，但是后续似乎是因为当前照片素材不够，需要再拍一些再考虑成相册。关于设计和排版今年也学了一丁点相关软件的使用和一点点简单的知识，但是后面因为思路枯竭，没有应用场景，以及时间与生活节奏开始混乱，也没有再多学习了（总之就是给自己找各种各样的借口）。除了设计画册相关的之外也大概看了一点关于摄影的书籍，也多少有一些收获，但实践太少还是学的太肤浅。今年关于拍照相关的大概就是这些，最后选几张我还算喜欢的照片。（未进行调整，别问为什么，问就是懒）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/sakura.jpg"                      alt="sakura.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DSCF4435.jpg"                      alt="DSCF4435.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                      alt="40E4DF1F-E58D-4C3A-AB38-5F4E1FE4EBF4_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                      alt="DAB97ABC-CC7E-4770-B79B-B94F597D96E0_1_105_c.jpeg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.jpeg"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.jpeg"                      alt="Untitled"                ></p><h2 id="和别人一起努力"><a href="#和别人一起努力" class="headerlink" title="和别人一起努力"></a>和别人一起努力</h2><p>这个目标是完完全全不沾边。我后来几乎没有考虑过这件事情了，也许我从最初就没有抱有过希望。有人一起努力，或者在某个圈子里一起努力，我觉得是非常有利于个人前进的事情，但是现在的我似乎并不能这样。我的行为习惯在让我避开他人，同时我慵懒的态度导致也无法跟上一直在努力学习的他人的步伐，也无法融入什么圈子。对于这个目标的态度我只有用“摆烂”这个词了，这个问题的依赖还没有被解决，这个问题本身也自然不可能去发生什么变化。</p><h2 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h2><p>不论是技术文还是水文，都算下来今年博客上提交了42篇文章。</p><p>我本来的计划是一周一篇，但是自从我停下了周记后（5.15）渐渐开始打乱了节奏。之后的LLVM Pass系列的相关博客又维持了一阵子时间，但完结后又未能维持更新的节奏，尤其是这两个月几乎停摆。技术博客相关和我学习的进展有关系，今年后半段我学习的进展也是停滞不前，博客也跟着一起没什么变化。</p><p>很多时候我都不知道该怎么写，即便今年过去了，我觉得自己对写博客这件事情依然没有那么熟练，对于让别人能看懂以及组织语言和结构这些事情都做不好，可能需要专门的练习，但我不太会专门花时间去做这件事情，至少先能保证稳定更新频率再说。</p><p>写的时候都是抱着反正也没人看的态度，本身确实不会有什么人对我写的内容感兴趣，另一方面希望越大失望越大。但后来有的人看到了我的技术文，还找到我的联系方式来联系我，这让我感到意外和开心。虽然并不是为了功利去写，但是这也确实给了我比较正向的反馈。</p><h1 id="今年还做了些什么"><a href="#今年还做了些什么" class="headerlink" title="今年还做了些什么"></a>今年还做了些什么</h1><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>今年工作的内容比较杂，组内的项目在全部推倒重来，我基本上是每个环节都在跟着做，由于算是初期，各个方面都需要我们来做，以及都是优先移植好原有的功能，所以各方面涉及的都比较浅，但也可以说是熟悉每个模块，同时熟悉模块之间的关系，能够把握每个模块对于其他模块的影响，格局打开了！这个过程中也接触到了一些新东西，算是有所收获。工作的同时还开发了一些便于调试的工具，过去同事们的调试方法实在不适合我这种又笨又懒的人。</p><p>有几篇博客记录了工作相关的一些踩坑经历</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/03/29/Problem/solve-ci-and-link/" >https://homura.live/2022/03/29/Problem/solve-ci-and-link/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/some-work-problem/" >https://homura.live/2022/10/02/Problem/some-work-problem/<i class="fas fa-external-link-alt"></i></a></p><h2 id="工作外的学习"><a href="#工作外的学习" class="headerlink" title="工作外的学习"></a>工作外的学习</h2><p>作为程序员那不可避免的要留下小格子的记录，趁着前段时间GitHub变蓝就留了个截图。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled.png"                      alt="Untitled"                ></p><p>这些提交基本上都是自己的东西，也有一部分是在其他分支没有统计到，总之今年什么时候在家的时间摸鱼一目了然。</p><p>除了上面提到的编译器相关的内容，又开了os的坑，开这个坑很大一部分原因是上面提到的这篇博客。</p><p><a class="link"   href="https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/" >https://homura.live/2022/10/02/Problem/nuttx-mm-in-64/<i class="fas fa-external-link-alt"></i></a></p><p>基于裸机系统修复了内存分配问题，让我想起了过去想实现os的愿望，接着参考现有的项目（xv6-riscv为主）抄了一部分的rvv os的实现，rvv的启动代码比起Intel的各种历史包袱真的是太简单了，难免产生了如果我早来看这个该多好的想法。抄os代码这部分也开了博客，不过目前只写了第0期。</p><p><a class="link"   href="https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/" >https://homura.live/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/<i class="fas fa-external-link-alt"></i></a></p><p>生活上的技能以及代码之外知识的学习也是必不可少的，各种乱七八糟的东西三分钟热度买了杂七杂八的书籍，趁着上头看了那么一点点，或者三分钟热度去搜了一些东西记到了笔记中。曾经有那么一段时间我意识到自己目前的行为方式就是这样三分钟热度，觉得目前改不掉，那不如就随着这股热情去，只要选择一种能够积累下东西的方式就可以了，比如说每次三分钟热度的内容都留下笔记，之后不论什么时候想重新回来看都不必从头再来。今年也算是在笔记软件里多少积累了一点点东西，希望能在以后用上。</p><h2 id="还做了些什么"><a href="#还做了些什么" class="headerlink" title="还做了些什么"></a>还做了些什么</h2><p>首先是前面尚未提到但是在实施的一些习惯。</p><p>学习钢琴 从二月开始上钢琴课，也算是坚持了快一年，除了生病和偶尔几天实在专注不了外每天都有在坚持练习。这么久下来拜厄勉强通关了，虽然我练的非常慢，但和我一开始真的是天差地别了。</p><p>读书的目标是平均一个月一本，今年也是轻松的达到了。我的阅读量很小，目标也不敢设的太高，就这样慢慢的积累也挺好的。今年在一个朋友的影响下读了一些文学，也写了一些感想，希望明年都能保持。看到许多朋友写了读书总结，我读的也不多，也不值得再开一篇文章，不过后面的部分会提我觉得不错的书。关于读书和影视相关的记录，7月开始我也开始在豆瓣上进行标记，这是我今年豆瓣的格子记录，<del>虽然没什么用就是了</del>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/Untitled%201.png"                      alt="Untitled"                ></p><p>同时在继续更新自己的读书channel（尽管最近两个月都摸了），对愿意订阅这个channel的读者我在此表示感谢，希望明年能在channel发更多的内容，而不是像最近一样总是摸鱼。tg channel链接：<a class="link"   href="https://t.me/homura_grand_archives" >https://t.me/homura_grand_archives<i class="fas fa-external-link-alt"></i></a></p><p>还养成了见到镜子中的自己就笑一笑的习惯。最初想到这个是5月份，看到几个喜欢的up主一直都充满着笑容，我知道自己平常的表情更倾向于一脸阴沉，让人看着就不想接触，同时试图通过这种身体的行为改变去改变自己的情绪，半年下来这个习惯也算是养成了，只是最近似乎有些忘，需要再重复巩固一下。</p><p>除了实施的一些习惯之外，今年还有幸接触到了许多以往未曾接触的东西，比如说开始学乐器，去听音乐会，去做瑜伽（做了半年就没继续了，实在太远了…），给朋友写信，尝试许多女装，去心理咨询等等。<del>不过…还是没有谈过女朋友（悲），有好心人愿意介绍女生认识吗。</del></p><h2 id="接触的作品"><a href="#接触的作品" class="headerlink" title="接触的作品"></a>接触的作品</h2><p>今年看的认为很不错的动画是《吹响！上低音号》，《利兹与青鸟》，《灵能百分百》第三季，都可以说是神作。</p><p><a class="link"   href="https://homura.live/2022/08/24/Animate/Sound-Enphonium/" >https://homura.live/2022/08/24/Animate/Sound-Enphonium/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/" >https://homura.live/2022/08/15/Animate/LizAndTheBlueBird/<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://homura.live/2022/12/31/Animate/MobPsycho100/" >https://homura.live/2022/12/31/Animate/MobPsycho100/<i class="fas fa-external-link-alt"></i></a></p><p>今年读过的印象深刻且非常喜欢的书有费尔南多·佩索阿的《不安之书》（未读完），莎士比亚的《哈姆雷特》，夏目漱石的《草枕》和《虞美人草》，村上春树的《世界尽头与冷酷仙境》和《海边的卡夫卡》。现在回想《不安之书》是最让我感到惊奇的，《海边的卡夫卡》是最有趣的，只可惜我并没有为它们写点什么。</p><p>虽然看到好多人在写年终阅读总结，我这里就不写了，读的太少不值得拿出来讲。今年内针对部分书籍写了一点想法，其他的书有的写了零碎一点就没好意思发出来，或者干脆没发。</p><p>虞美人草：<a class="link"   href="https://homura.live/2022/10/16/Reading/papaver-rhoeas/" >https://homura.live/2022/10/16/Reading/papaver-rhoeas/<i class="fas fa-external-link-alt"></i></a></p><p>世界尽头与冷酷仙境：<a class="link"   href="https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/" >https://homura.live/2022/08/21/Reading/Hard-Boiled-Wonderland/<i class="fas fa-external-link-alt"></i></a></p><p>加缪的《快乐的死》也还可以</p><p><a class="link"   href="https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/" >https://homura.live/2022/10/15/Reading/a-happy-death-albert-camus/<i class="fas fa-external-link-alt"></i></a></p><h2 id="计划与习惯"><a href="#计划与习惯" class="headerlink" title="计划与习惯"></a>计划与习惯</h2><p>我原本做了一个比较简单的计划用于规划晚上回家以后的时间，前半年执行的也都还可以。但是到了七月发生了一些事情，我的注意力全部被拉走了，完全破坏了执行习惯相关的要点。而这次一直持续了两个月，加上钢琴课作业我觉得需要更多时间，时间分配上也开始乱了套。而上个月底开始的居家办公，又因为我爆肝宝可梦导致又花了很多时间在打游戏上，最后每天只能保证基本的练琴了。尽管后期有些失败，但也算是切身体会到执行习惯的一些关键点的重要性。</p><p>关于习惯参考了《掌控习惯》这本书，十分感谢推荐给我这本书的朋友。</p><p>豆瓣链接：<a class="link"   href="https://book.douban.com/subject/34326931/" >https://book.douban.com/subject/34326931/<i class="fas fa-external-link-alt"></i></a></p><p>今年内也如往年一样，尝试做过各种规划，从改善各种坏习惯到想要做出什么改变，罗列了很多，当然也如往年一样绝大多数根本没成功。比如说想每月反思，定期选择新的习惯进行养成等。也许都是因为每次列了太多，而不是每次选择一个最重要的去培养，又或者是其他原因，现在的我还未能理解。</p><h1 id="自我"><a href="#自我" class="headerlink" title="自我"></a>自我</h1><p>写完后回头看去年的总结，没想到也是提到同样的主题，或许人的本性不会这么轻易改变吧。</p><p>高浓度负能量和没意义的大道理警告⚠️，不喜欢请直接跳至下一节。</p><p>对于我来说，重要的不仅是这一年我做了什么，还有到了今年年底我的心态变成了什么样子，我是个怎样的人。</p><h2 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h2><p>这一年来，我从来未停止过试图改变些什么，这种寻求改变的念头甚至到了魔怔的地步。我的一个朋友说我总是在试图改变，也有些着急改变，我的确是恨不得立刻就能把我身上的问题都改掉，因为在我的内心中如果我不去努力改变些什么那我不值得任何美好的事物，只值得另一个理想自我或者是他人的唾弃，夸张的说会觉得无法在社会生存。尽管有一些看起来像是真的因为追求些什么而去改变，但现在的我似乎又觉得这些所谓的追求也是同样为了“生存”。</p><p>现在的我和过往一样，犯错犯蠢多到令人发指的地步，待人冷漠，经常会因为自我攻击而开始在网上说疯话胡言乱语，性格越来越扭曲。但相比去年来说更好的方面是我的自我觉察能力能强了，能理解此时此刻的我处于什么情境，我到底为什么会这样做，同时即便在说疯话我也能明白我此时此刻在做些什么。难过的是我即便了解这些，产生异样想法的时候试图用理智去说服自己，即便不断的重复，大部分情况仍未能起到什么用处。这些想法本身就令人痛苦，清醒的看着它们而无法做到些什么则会令人更痛苦。不过我在这个过程中也算是真正感受到理性的不可靠性，作为人来说还是感受更加重要，感受完全是不受理性束缚的，我却总想要用理性去修正感性，这也是完全不合理的。</p><p>自己心怀自卑却依然会有自大的妄想，不过今年意识并且切身体会到在某些方面自己远远没有想象中的自己那样好。虽然说着要做这个做那个，但实际上每天都无所事事，经常沉浸于虚拟世界之中（特指各种动画片）。感受到理想与现实的割裂感，说的时候会依照想象中完美自我的说话方式，但行动上却依然是弱小的自己。这让我想到《哈姆雷特》里面国王的一句令我印象深刻的台词</p><blockquote><p>我的言语高高在上，我的思想滞留地下。没有思想的言语永远不会上升天界。</p></blockquote><p>尽管我没有剧情中国王那么坏，但这种不一致性和矛盾性是相通的。</p><p>即使我知道今年有一些做的好的地方，但我依然无法认同自己，相比起这些“看起来微不足道”的改变，自己剩下的问题更严重。这本质是一个视角问题，即便当下的问题已经解决，我大概率也总会找理由去攻击自己。痛苦和折磨绝大部分来自于自身，自己看待问题的态度，自己的行为方式。</p><p>和往年一样，感觉时间过的越来越快了，这让我很是害怕。也许是害怕死亡，也许是害怕一事无成，也许是害怕虚度光阴，我不敢断言害怕的东西到底是什么样的。今年工作日每日重复的时间地点行为，每周末也都是几乎类似的，重复这件事情本身我觉得并无大碍，我只是不舍得时间就这样过去了。上半年都在做着自己要做的事情，却还总是担心时间的流逝，也许是感觉自己的时间利用的很差劲，觉得最后什么都没做好，迷失在了时间的洪流之中又无力掌控方向。而实际似乎也因为并没有花费多少时间学习也就没有学到多少，大多数时间还在发呆，娱乐。</p><p>前半年顺从着习惯，而后半年习惯渐渐瓦解，我的状态也各种有问题，做的事情渐渐开始变少了，不想做任何事情的状态再度袭来。后来我才真正体会到对于现在的我或许不需要去追寻什么非常喜欢的东西，至少当前不想做任何事情的时候是这样。我需要的是在我状态还算可以的时候选择几件事情，然后每日去做，不去想什么想不想做，只是每天一定要做的任务。</p><p>在写总结的时候偶然想到似乎最近没有那么强烈的一定要成为什么大佬的想法，开始思考起所谓成为大佬这种事意味着什么呢，而这件事对我来说又意味着什么呢？仔细想想我也许只是为了那么一个名号，喊的只有成为这个结果，却没有去追求学会什么知识，只是想通过这样的结果和标签获取关注和认同罢了。我之前发表过想成为编译器专家这种暴论，但渐渐我发现了，现在的我不是能成为什么领域专家的人。在我看了各种乱七八糟东西以后，意识到这和一个人的行为习惯有很大的关系，人一天绝大部分都是依靠无意识的习惯。同时我的目标应该是学好某个方面的知识，到达什么名号或者名誉都不是我应该去考虑的。</p><p>今年最后一个月的一半时间除了工作就是专心打游戏，这段时间非常平静，没有抱有对这种事情的执念。但当我从游戏世界中走出来，看着现实世界，思考起现实世界的问题，又难以恢复平静的心态，尤其是在最后几天大家纷纷放出了自己的年终总结，不由得对别人丰富多彩的一年感到羡慕，又三分钟热度想要成为多么好的人。想必明年也会如此，时而平静，时而扭曲，时而上推发疯。这些想法强烈的时候会非常痛苦，过去也不知该如何去缓解，也许需要等到真的接纳自己，真的觉得这样的自己也能很好的生存的时候，到时我的目标或许就会真正变为学好些什么，而不是成为什么带有名头的人。</p><p>人为什么一定要向着顶端爬呢，有的人是因为想要征服山顶，有的人是因为不安。我一定是后者吧，没有能够安稳生存的自信，想要通过这一种极端的方式来掩盖所有生活中的其他问题，真是懦弱。</p><h2 id="年初的我"><a href="#年初的我" class="headerlink" title="年初的我"></a>年初的我</h2><blockquote><p>我想过，我把时间分成这么多份最后的结果一定是每样都做不好。<br>我不是说所有人都是这样，只是我比较笨，多方面全能的天才太多了，不论是看过的传记，还是推特上实际见到过的大佬，他们都是切实做到全才<br>尽管我每样都不会做好，但是总比浪费时间要强的多。我在选择一些东西的时候就在想，如果不做这个，我的时间可以拿来做什么？答案显而易见，和我过去的周末一样，浪费时间。<br>我也在想，这些东西是否真的有必要，但是我感兴趣就够了，什么东西能够起到什么作用这种事情充满了太多的未知。<br>年初写下这些话，不知道年末的我怎么想</p></blockquote><p>一年下来，发现对我来说如果在做了就很好了，因为很多的时间依然被我随意浪费与挥霍。想要尽量减少浪费时间就去多做一些能够积累下来的东西，比如说学的东西用笔记的形式记录下来。而在这个时间洪流中前进的方法只有养成各种方面的习惯，习惯到了很多事情也就能做到了，但这个过程比做到什么事情本身还要难上许多。</p><h2 id="迷失方向"><a href="#迷失方向" class="headerlink" title="迷失方向"></a>迷失方向</h2><p>找不到自己应去之处，找不到人生的方向，这是一个困扰着绝大多数人的问题，而我也是绝大多数人的其中一员。对于未来的发展方向今年有过许多乱七八糟的想法，年初有，但到年中逐渐开始变化，到年末变化太大导致年初的想法又全军覆没。其中也做过一些奇奇怪怪的努力，但是都有些无功而返。自己尚未具备选择些什么的决心，也缺少将其实现的能力与自信。有过许多想法，但几乎每次都在变。这样的我现在能做的或许只能像最上面所说，先选中一些什么东西，坚持做下去吧。</p><p>除了之外，我对于自身的存在也感到迷茫。对于自己的人格，对于道德，对于对与错，对于各种各样的问题都在疑惑。疑惑也算是好事，起码我开始思考起这些问题了，开始想要跳出这个圈子看待问题，而不是继续陷入圈内。越发觉得不了解自己，不知道自己的兴趣爱好，不知道自己想要的是什么。因此什么都要，放弃做出选择，还会为得不到某些不需要的东西而产生负面情绪。也因此所追寻的大多数是别人的东西，外界所灌输的“我这样的人”所应该追求的，而不真正属于我自己想要的。我到底想要到哪里去，想要成为怎么样的人呢？</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="疫情"><a href="#疫情" class="headerlink" title="疫情"></a>疫情</h2><p>今年无疑是被疫情影响最大的一年。五月开始常态化核酸。后来核酸的频率降低，一直持续到了12月彻底放开。疫情影响导致多次居家远程办公，远程办公有好有坏，硬要说坏的方面比较多，但是家里的硬件设备远比公司舒服，同时又可以一直一个人窝着，因此还是更喜欢远程办公。彻底放开导致许多人都感染了新冠，而我选择蜗居在家，也因此暂时避免了感染。</p><h2 id="作息"><a href="#作息" class="headerlink" title="作息"></a>作息</h2><p>今年作息越来越阴间了，年初还是在12点睡，后来渐渐的12点半，10月底的时候差不多1点睡了。自从上个月底开始居家办公，仗着可以更晚起床，居然过分的到了一点半甚至到了两点才睡。</p><h2 id="经济"><a href="#经济" class="headerlink" title="经济"></a>经济</h2><p>今年涨了工资，经济状况相对来说宽裕了一些。今年依然在记账，虽然可能一如既往的记的不够精细，但是分析开销还是够用了。看了今年的账单，有点想打消整租的念头了，如果整租每个月起码要多支出2k多，以及冬天供暖还需要自己一个人承担费用。</p><p>随便讲一下情况，最大头的分类自然还是必须支出，吃穿住用的日常用品。住就不提了，一年吃了2w8，也花了不少。今年舍得打车了，没想到打车就花了快2k…淘汰了很多旧衣服，这方面也花了不少钱，电费什么的也花了不少，还有各种买药，杂七杂八的日用品。第二大头就是消费了，电子产品居多。其中很大一部分都是去年分期买的（比如说去年24期分息入手了M1Max…），加装了显示器以及入了相机镜头什么的。最后一大部分就是钢琴课，心理咨询以及前半年瑜伽的费用。书也花了不少钱，尤其是双十一的时候囤了20多本，一年下来杂七杂八的书花了快2000…虽然可能没看多少吧，很多都是有需要买来翻一翻。</p><h2 id="人际"><a href="#人际" class="headerlink" title="人际"></a>人际</h2><p>我这个人独来独往习惯了，便不想和人去打交道。有不擅长的成分，有害怕的成分，有觉得浪费时间的成分，总之有很多乱七八糟的原因形成了我现在这个样子。不过大多数不会因为讨厌别人，也因此我几乎不会为了维持关系去私聊他人。用一句话来形容，大概就是“我为来来往往的人流感到烦躁，但并没有因为你而烦躁“（已不记得原话）。这也是一个非常复杂的问题，和咨询师提到过这个问题一两次，但后来因为生病加各种问题，未再深入讨论这个话题了，明年一定要再深入讨论下去。不过不论怎么讨论，最终都是需要我来做出些什么改变。</p><p>今年发现了一个非常非常喜欢的网友，和他交流的过程中发现他简直就是我理想中的样子，追随着他的身影，也多少受到了他的一些正面影响。充满了想要成为他那样的想法，尽管那是不可能的。而在和他相处的过程中我受到了他的帮助，也改变并且成长了许多。人的成长还是要和什么人发生什么事情才行，只身一人游离于一切之外是不可能发生多少变化的，这是我今年的经历中切身体会到并且意识到的事情。</p><p>自己现在认识人的途径几乎只有Twitter了，今年新认识了许多Twitter上的朋友，也面基了几位，也有一些朋友没来得及面基，今年也要感谢朋友们对我的帮助以及对这样的我的容忍。</p><h1 id="明年的愿景"><a href="#明年的愿景" class="headerlink" title="明年的愿景"></a>明年的愿景</h1><p>我是非常贪心并且做不出选择的人，因此想添加上非常多的愿景。写这么多其实是不利于实现的，或许应该找几个核心目标再围绕展开，但这里还是想到什么写什么。</p><h2 id="生活-1"><a href="#生活-1" class="headerlink" title="生活"></a>生活</h2><p>学习和生活想要恢复到今年刚开始的状态，并且希望能维持下去。身体健康方面还是要尽量下功夫，起码要保持每天运动的习惯，即便锻炼量很少，也要坚持动下去。关于情绪方面，尽管我有很多负面或者扭曲的想法，但是我大多能够及时觉察，认为自己能够一定程度的应对，只是很多时候由于各种大脑成分的原因我无法停止一些负面的想法，这些就不属于我改变想法就能做到的了。</p><p>找画师约一个皮套，直接出道。目前打算每天直播回家以后的学习生活，但似乎实现起来会有很多不方便，所以暂且将目标定在约好皮套这一步。</p><p>想遇到属于自己的madoka，这个是最想实现但是最不抱希望的了，做梦都没有这种好事的。</p><p>疫情好一些的话可能会挑个假期去南方转转。</p><p>希望今年能形成一些新的好习惯。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>compiler和os的坑会继续填，compiler的话继续开发我的玩具，以及再花些时间学习一下LLVM相关的内容，os起码要到把xv6里提到的功能抄一遍的地步，如果可以自制cpu这方面我也想开个坑，这个就尽力而为了。我觉得光是这些超大的坑就已经够占据我的精力了，暂时不去多想其他内容。</p><p>博客希望起码能保证两周一篇，如果可以还是想一周一篇，可以实施以写博客为目的的学习，既能保证博客更新又能保证持续学到东西。</p><p>除了专业技术之外我希望能多学一些专业之外的知识和技能，可能会向视觉类（设计/摄影）之类的靠近，也可能向一些科学方面的。</p><p>读书还是维持每个月一本好了。双十一阶段一口气囤了二十多本书，也不奢求能读完，毕竟比起要求读完还是持续阅读并且享受书中的内容更加重要。</p><h2 id="自我-1"><a href="#自我-1" class="headerlink" title="自我"></a>自我</h2><p>希望能对自己的生活有更多的掌控力，而这件事情的实现需要依赖于每一件小事的积累，并不需要我特地完成什么，只要做好其他任务自然能够做到。希望通过这样的方式逐渐增长一点自信。</p><p>最重要的是希望能够更加清楚的认识自己，找到自己的方向，不再因为没有自己想要的东西就去想要所有的东西，羡慕所有的人。</p><p>还想要多探究一些自己的感受，而不是自己的想法，多接触一些带有情感的事物或者作品，而不是只有冷冰冰的机器和科学知识。</p><h2 id="不重要的想法"><a href="#不重要的想法" class="headerlink" title="不重要的想法"></a>不重要的想法</h2><p>这部分的内容都是随缘了，不会太过于关注。</p><ol><li>小概率可能会继续写日记。去年写了几天但是后来就没再写了。</li><li>会试着强迫自己去再接触一些人，尤其是线下，也会试着开展新的交友渠道。</li><li>希望夏天有机会拍到英仙座流星雨。</li><li>想女装出门拍照，再修个图出来康康。</li><li>尝试一些其他新事物什么的。</li></ol><h1 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h1><p>今年也多多少少做了一些事情，并且我能够确信有了不小的进步，这份进步也必然来自于我自身的行动。不过即便如此，这些内容放到一年的维度上来说真的是感觉非常渺小，每天都觉得在混日子一样的活着。因此说不上好，也说不上坏，只是又度过了一年平淡时光。</p><p>不过，平平淡淡也没什么不好。</p><blockquote><p>你的人生你做主，平淡无奇又何妨。总有一天，定能发现，各自的答案。</p></blockquote><p>来自《灵能百分百》第一季op</p><p>最后放一下今年最后一餐的烤鱼照片，不知为何今天突然想吃了，晚上火速下单！</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/summary-2022/IMG_5946.jpeg"                      alt="DSCF4435.jpg"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知不觉这一年又过去了，时间快到让我心里没底。到现在北漂已经有一年半了，而这一年也慢慢适应了这个地方，今年依然没有什么丰富多彩的生活，平平淡淡的工作，学习，玩乐。&lt;/p&gt;
&lt;h1 id=&quot;去年的愿景&quot;&gt;&lt;a href=&quot;#去年的愿景&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>灵能百分百 mob的改变与成长</title>
    <link href="https://fusionbolt.github.io/2022/12/31/Animate/MobPsycho100/"/>
    <id>https://fusionbolt.github.io/2022/12/31/Animate/MobPsycho100/</id>
    <published>2022-12-31T10:26:01.000Z</published>
    <updated>2022-12-31T12:59:04.202Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/MobPsycho100/image-20221231205833503.png"                      alt="image-20221231205833503"                ></p><p>灵能百分百，一个讲述了mob改变与成长过程中的故事。</p><h1 id="改变与成长"><a href="#改变与成长" class="headerlink" title="改变与成长"></a>改变与成长</h1><p>改变与成长，对于每个人来说都是不可避免的问题，对于mob也是一样。人的成长与改变离不开人，与他人相遇，然后发生些什么事情。mob受到了他人的影响，开始产生改变，而在这个过程中，其他人也受到mob的影响发生改变。</p><p>最上篇中mob所说的</p><blockquote><p><strong>人是可以改变的</strong>，这是最上与浅桐小姐教我的。我也被大家改变了，我也明白了<strong>自己或许可以改变某个人。</strong></p></blockquote><p>灵幻，小酒窝，花泽，芹泽，铃木等等许多人都是如此，受到了mob的影响所改变，而其中的许多人同时还是推动mob改变的一方，在人与人之间的交流中是互相影响和改变的。</p><p>mob和铃木的对决中有这样的台词</p><blockquote><p><strong>不管是谁，人都会在与他人的交往中成长，人需要别人，总有一天会需要他人</strong></p></blockquote><p>而铃木从中学开始“认为自己凌驾于他人之上”，认为不需要他人，而mob则对铃木说“止步于中学时期的是你”。不需要他人的铃木也正因如此这么多年来在许多方面仍未成长。</p><h1 id="接纳自我"><a href="#接纳自我" class="headerlink" title="接纳自我"></a>接纳自我</h1><p>而接纳自我，也是成长中非常重要的一部分。这部分主要都在最终的告白篇进行讲述与刻画。在这部分内容中，mob再次暴走了，而此刻是剧中唯一一次mob和暴走的自我进行持续对话，或者说他不得不在面对另一个自我。他畏惧情感化的另一个自己，但两者其实都是他自己。律一开始畏惧他，不断的跟自己说那不是哥哥，但到最后律明白了，那个也是mob的一部分，律选择去接受。</p><blockquote><p>他是一直被压抑的另一个哥哥，他们从根本上连在一起，无法剥离，哥哥今后也必须和这样的自己共存下去。</p></blockquote><p>正如律所说，暴走的是mob的一部分，而每个人则是由无数个这样的一部分组成的，我们要去尝试接纳自己的每一部分。现在回想看，似乎并非只有最终话才有接纳自我这件事情。mob最初对自己所拥有的力量感到烦恼，是灵幻教会他接受自己力量的方式以及使用力量的方式，这亦是一种接纳。</p><p>大家一直在否认另一个mob，而???也讨厌被人否认，整个对话的过程他都在不断的强调自己的存在。</p><blockquote><p>mob:你的想法太不正常了</p></blockquote><blockquote><p>???:什么叫正常，你又要否认我本身吗</p></blockquote><p>而”蕾只把我和龙套当成要好的朋友“很明显的是他将自己和mob区分开了。???想要认同，但他不被认同，同时他却未能认同另一个自己。自称不会被驯化的另一个mob，他只是不想被人当作一个会被否认的“特殊的存在”罢了。</p><blockquote><p>你并不特殊，每个人都有两面性。我也有，所以你不必烦恼。不对，烦恼一下倒也行，会烦恼其实也是理所当然的。我其实非常讨厌我隐藏起来的本性。但就是因为有这“虚假的一面”我才认识了你，你也是拥有这份力量…才有了今天的你吧。总之我想说，你其实，现在这样就可以了，现在的你就算没有我也不要紧了，别担心。是时候接纳了，接纳你自己。你能行…龙套一定能做到，我知道的。</p></blockquote><p>灵幻的这一番话表达了自己不认为另一个mob是特殊的，并且不是应当被否认的，从自己开始自我接纳，同时表达了对他接纳的意愿，mob的主人格也因此能够接纳他，他因此能够接纳师父和mob，一切也就回归了原样。<strong>不论哪一个自我，都是自己的一部分，都不是什么特殊的存在，都不是什么值得否定的存在。</strong></p><blockquote><p>你是说你要接纳我吗？</p></blockquote><blockquote><p>不…我希望你也能接纳我。就像大家接纳了我一样。</p></blockquote><p>即便是自认为最黑暗的部分，也只是自己的一部分，都不是什么特殊的、值得自己否定的存在，试着去接受它们吧。</p><h1 id="mob"><a href="#mob" class="headerlink" title="mob"></a>mob</h1><p>灵能百分百的剧情都是围绕着mob的成长展开的。最初的mob不善言辞，没有自己的想法，习惯性的压抑情感，无法接纳另一个情绪化的自己。在他第一次失控之后就开始抑制自己的情感，他对自己，或者说另一个自己感到畏惧。随着他与灵幻相遇开始发生了一些改变，而当他与更多的人相遇后，他逐渐开始找到自己所迷失的东西，开始有自己的想法和意见。但即便如此，他仍未能接纳另一个自我，他仍在压抑自己的情感，对于mob来说压抑情感和接纳另一个自我是相连在一起的事情。</p><p>而在最终的结局， 灵幻的一番话让他接纳了自己，将他从失控的状态中拉回。此时的mob是影山茂夫100%，正因为他接纳了另一个自己，他不再抑制自己的情感，他才得以完整。也正是从这里开始他恢复了自己的情感流露，在表白失败以后直接哭了出来，在ed为灵幻的生日喝彩时他甚至放声大笑了起来，而在前面的剧情中mob几乎都未有这样的情感表现。</p><h1 id="灵幻"><a href="#灵幻" class="headerlink" title="灵幻"></a>灵幻</h1><p>提到灵幻，我想一开始给观众留下的印象就是利用mob的欺诈师，但灵幻对于mob的整个成长旅途来说是最重要的角色。整个剧情部分我觉得可以说是以灵幻接受了mob的烦恼咨询开始，而最后又以灵幻引导mob接受另一个自己结束。one老师并没有这么用俗套的按时间顺序开场，而是mob即将爆发时将灵幻接受mob的咨询插入到回忆之中，这样的安排使得角色的行为更加合理，同时这个时候插入回忆会给我们观众留下更深刻的印象。他除了灵能力和超能力外几乎什么都能做到，而mob则是超能力最强但除了超能力外什么都做不到，这样的两个人完全是一对。正是这样的灵幻，在mob的成长中给出了方向，大多数情况能够敏感的察觉到mob的情绪。他开导了迷茫的mob，他告诉mob不需要看空气配合别人，遇到不愿意的事情可以逃避，教给mob接受自己。</p><p>在三季的boss战中每次灵幻的台词都让人十分感动。在第一季进攻爪支部的时候，其他人都在逼迫mob使用超能力，但只有灵幻察觉到了他不愿在这个时候使用。“住手，龙套，这么做你只会更加痛苦。不愿意的时候，逃跑也没关系”，用着这样的话语成功让mob从杀意转换为了逃避。第二季mob独自和爪的boss对峙时，灵幻独自赶了过去，对mob说出”还是觉得不应该让你独自来“这样的话。第三季面对另一个mob的时候，“你其实…现在这样的你就好，现在的你就算没有我也不要紧了，别担心。是时候接纳了，接纳你自己。你能行…mob一定能做到，我知道的“，这样引导mob接纳情绪化的自己。</p><p>除了灵幻对mob引导的情节外，还有二人产生矛盾的情节，他未能及时发现mob的快速成长所带来的变化，而mob选择了暂时不去灵幻那里。这段时间随着剧情推动，我们一点点看到了灵幻不为人知的过去，同时看到了这个除了除灵不论遇到什么都能临机应变的人的另一面。平凡的毕业开始工作，后来自己开始独自靠“除灵”赚钱。他其实是非常孤单的，mob和朋友们去卡拉OK，开始有人陪伴，有自己的生活，mob的身边热闹起来，不再是只有师父了。对于灵幻来说只有mob能真的陪伴着他，即便是他被套路之前人们也只是图求利益接近他，当他想诉说些什么却也无人能够倾听，被套路之后则是更不会有人愿意接近他了。这些都充分体现出了mob对于灵幻的重要性，mob对他来说不仅仅是一个利用来除灵的人，而是一个真诚的朋友，一个陪伴自己的人。</p><p>而在灵幻被套路后在记者发布会上记者提及到他作文中写的毕业期望的主题是“想成为什么”，他开始回忆起自己为什么要成为灵能力者，紧接着又从另一个角度讲述了他和mob相遇的故事。</p><blockquote><p>当时，我对那个少年产生了憧憬，我也想抓住些什么，想成为特别的人</p></blockquote><p>他做到了所想的事情，他抓住了他和mob之间的连接，成为了对于mob来说最为特别且不可或缺的人。灵幻虽然作为mob改变的推动者，但我想他也是被这场相遇改变的人。灵幻是一个圆滑处事的人，是会欺骗、利用mob的人，但他在面对另一个mob的暴走时却放弃了一切，没有选择圆滑的放弃，即便冒着生命危险，即便讲出自己欺骗的真相后mob可能会彻底离开，他也要将自己的想法传达给mob，就想要阻止他，我想这也是一种改变，他不再是那个只会圆滑处事的人了，而是重视朋友的人。</p><h1 id="小酒窝"><a href="#小酒窝" class="headerlink" title="小酒窝"></a>小酒窝</h1><p>除了灵幻，最重要的角色非小酒窝莫属。灵幻对于mob来可以说是最重要的，而小酒窝几乎是陪伴他最久的。小酒窝初登场是作为教主的身份，他一直怀有想要通过宗教成为神的愿望。从最初的想要利用mob，但逐渐开始帮助mob，不知不觉中小酒窝和mob已经成为了能够互相信任的朋友。小酒窝其实只是世间众多迷茫者中的一员，即便成为灵那么久，依然不知道自己想要的什么，在到神树篇之前他未曾察觉到自己只是想要朋友罢了。小酒窝或许也算是受到mob的影响所改变，也许正因为mob开始信任他，mob把他当作一个普通的人对待，他开始信任mob，真正发自内心而不是以利用为目地的去帮助mob。</p><p>小酒窝的出场，除了日常穿梭于各种剧情之中，以及被几大战力担当除灵，就是神树篇了。在神树篇之外几乎很少刻画小酒窝的想法和明显的变化，只有他的行动，而在神树篇中通过各种细节来刻画出他的想法，他的变化，将这个角色完整的表现了出来。</p><p>在mob进入神树的前一晚，他还在邀请mob一起，即便他已经有了足够的力量，但他本质上只是想和mob，和这个非常要好的朋友在一起做这件事情。这里他的台词我觉得非常巧妙。</p><p>不论是发出邀请时特意用的是“咱们”</p><blockquote><p>咱们是时候站上顶点了，一起去吧</p></blockquote><p>还是在mob拒绝以后，说出了这样的话</p><blockquote><p>你小子，想把本大爷排除在外吗</p></blockquote><p>这一切其实全都在表现他想要和mob一起的愿望，但他本人未曾察觉，而此时的mob由于忘乎所以也未注意到这一切。</p><p>但即便闹了矛盾，但不论是开场先吐槽，还是一直不忍心用全力攻击mob，又或者发出神之光线后的担心，他还是我们熟悉的那个小酒窝。即便说着要一决胜负，看到mob的衣服后还是吐槽了起来，开始为mob担心。他自己也没有意识到，自己在和mob相处的过程中渐渐的将mob看做了朋友，一个需要担心的人。</p><p>脱离了忘乎所以的mob，看到小酒窝对衣服的吐槽，发现他还是熟悉的小酒窝，决定100%信任小酒窝。并诚恳的道歉。而此时的小酒窝，才真正意识到自己想要的事情。</p><p>mob：</p><blockquote><p>对不起，小酒窝…这是你一直想做的事…一直不懈追寻的东西，你却在愿望眼看就要实现的时候，向我发出了邀请。你有能力这样独自实现愿望，却还特意来邀请我，这才是…最重要的事情。你不是在打坏主意，你只是想实现自己的愿望，和我一起。是你信赖来了我，谢谢你</p></blockquote><blockquote><p>你想做什么，我都会认真听的，作为你的朋友。</p></blockquote><p>小酒窝：</p><blockquote><p>之前一直没发现，本大爷其实…只是想要朋友。</p></blockquote><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>或许这部作品不温不火，但是我觉得它是我心目中的神作。</p><h3 id="原作"><a href="#原作" class="headerlink" title="原作"></a>原作</h3><p>我对原作的评价是one老师的剧情有趣、富有深度同时又浅显易懂，他想表达的事物已经切实传达到了我们这里。同时one老师笔下的角色都很有特点，某个积累了两年全勤记录的不良，我想大家都会在得知全勤记录的时候感受到这个角色的反差，花泽的各种奇特造型（包括两次被剃头以及多次出现的超高头发），篇幅所限这些角色就不再每个都聊一遍了。</p><p>有的人吐槽one老师的画风，这个因人而异，对我而言不论是原作十分简单的画风还是tv动画中对原作的模仿都觉得挺有趣的。但我觉得这是一部不应被画风所限制的作品，one老师是真的想要传达给读者些什么，将更多的精力放在讲故事中。现在的时代大多是一些惊险刺激的作品，又或者迎合宅宅们口味的作品，像这种专注于通过故事传达给读者些什么的作品已经很少了。</p><h3 id="TV表现"><a href="#TV表现" class="headerlink" title="TV表现"></a>TV表现</h3><p>tv动画通过漫画做不到的方式增强了表现力，声优的精彩演绎，bgm的完美结合，通过与剧情密切相关的歌词，op的独特动画。众多因素结合调动了观众更多的感官，对观众的情绪施加了更强烈的影响。在最后灵幻冲到mob面前时，配上第一季op的歌词，每一个画面几乎都与歌词契合，我甚至有理由怀疑这是制作组早就计划好的事情。</p><p>最终的结尾与最初的op相呼应，更加显现出第一季作为基础的地位。第一季虽然相对平淡。但是如果没有一开始的铺垫，我们不会感受到后面的精彩。<br>随着三季动画的播出，我们也跟着一起见证了mob的成长，而在剧情中一直见证着这一切的人则一定是灵幻。在第三季op中最后那一段灵幻站起来拍着逐渐长大的mob的肩膀，已经看过前两季的我从这里的画面联想到他们之间强烈的联系，情感也随之迸发。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>告白篇最终灵幻与mob的那段真的非常棒，让我忍不住想为这部作品写点什么，也便有了本文。但我想绝不仅是因为这一个结尾部分非常精彩，这一部分情绪感受很大程度由前面所有内容的铺垫而来。自己未想过能为这部作品写这么多东西，也许是真的有所感触。还有很多值得写的和深挖的内容，情感，mob与朋友们的联系，其他的角色等等，但作者水平受限便写到这里停下了。我一直在寻求改变，一直在寻求灵幻一样的存在，我能够感受到mob改变路上的迷茫，同时我也真心为one老师笔下的mob所经历的成长而感到高兴，我想这些都是让我感受到剧情中强烈情感的原因。</p><p>同样描述角色成长的京吹却未能像灵能百分百一样这么强烈的打动我，也许京吹更多的是校园的青春，也许是如我在京吹的感想中所说：“整部番一切都距离我的现实过于遥远，无法引起什么共鸣”，虽然京吹更加接近现实，但对我来说那种多人一起努力的青春场景远比灵能中的幻想世界更加遥远。我最喜欢的另外两部作品是魔法少女小圆，另一部是利兹与青鸟。这两部作品靠的是极致的情感吸引了我，而灵能则是整个mob成长经历的一点一滴，在最后将这些积累的东西全部爆发出来。</p><p>希望读者和我都能像mob一样不断的改变与成长，试着接纳不同的自己，最终做到</p><p><strong>自我100%</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/MobPsycho100/i</summary>
      
    
    
    
    <category term="Animate" scheme="https://fusionbolt.github.io/categories/Animate/"/>
    
    
    <category term="MobPsycho100" scheme="https://fusionbolt.github.io/tags/MobPsycho100/"/>
    
  </entry>
  
  <entry>
    <title>基于xv6 riscv实现学习os 其零：helloworld</title>
    <link href="https://fusionbolt.github.io/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/"/>
    <id>https://fusionbolt.github.io/2022/11/13/xv6-riscv-os/xv6-riscv-os-0/</id>
    <published>2022-11-13T13:32:18.000Z</published>
    <updated>2022-11-13T13:51:45.329Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/xv6-riscv-os-0/30933181.jpg"                      alt="30933181"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">学习os的时间开始了! pixiv:30933181</center> <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个系列的目的还是以讲解xv6-riscv的代码以及记录我在做的事情为主，也会掺杂许多mini-riscv-os的代码介绍（关于xv6-riscv和mini-riscv-os的链接请看参考），并非教程倾向（但也会尽可能讲解一些基础知识），<strong>很多细节不会讲到</strong>。如果想要更详细的教程我建议你查看参考资料中引用的内容，在这一期我会列出一部参考的项目。</p><p>compiler的坑还没走多远，我又要开新的坑了，这是我很久之前想做但不敢做的事情。以前也做过一些尝试，比如说《30天自制os》以及6.828，前者讲的相对比较容易理解一些，但是当时的我缺少实践，后者难度较高，看不懂课后习题只能去查看别人的实现，东抄西抄总算抄完了前四章的内容，最后只留下了一些概念的印象。对我来说学会什么东西只有通过具体去实现，自己很难从什么概念去理解某个东西，也因此之前学的很多知识其实都是非常肤浅无用的。</p><p>实现os这件事情看起来是挺吓人的，本身复杂的概念和各种实现，同时需要许多前置知识。同时大多数os的开始都是离谱的x86bootloader，我想这个应该劝退了非常多的人。但最近发现做一个最简易的os或许并没有那么可怕，搜了一些项目，最简单的功能很少的系统只有一两千行代码，相对比较容易学习，同时riscv的bootloader部分没有乱七八糟的历史遗留，十分简洁，不会再因为这个劝退别人。也在这里感谢他们的付出。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li>mini-riscv-os是针对riscv32，而xv6针对的是riscv64，导致一些汇编上、编译选项以及一些其他的内容会有所不同</li><li>代码引用会直接使用项目名/路径的格式</li></ol><p>此后不再赘述</p><h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1><h2 id="交叉编译工具链"><a href="#交叉编译工具链" class="headerlink" title="交叉编译工具链"></a>交叉编译工具链</h2><p>参考链接</p><p><a class="link"   href="https://pdos.csail.mit.edu/6.828/2019/tools.html" >https://pdos.csail.mit.edu/6.828/2019/tools.html<i class="fas fa-external-link-alt"></i></a></p><p>我是在mac（M1）下开发的，homebrew在安装riscv-tools的时候会提示需要安装一些依赖。在我配置的时候遇到了flock这个依赖搞不定的问题，发现直接brew install flock安装的flock是其他东西，因此需要卸载flock并且使用brew tap的命令，安装好依赖再去按riscv-tools</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall flock</span><br><span class="line">brew tap discoteq/discoteq</span><br><span class="line">brew install flock</span><br><span class="line">brew install riscv-tools</span><br></pre></td></tr></table></figure><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p>这个没什么好说的，直接用包管理安装就是</p><h1 id="启动所需代码"><a href="#启动所需代码" class="headerlink" title="启动所需代码"></a>启动所需代码</h1><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><ol><li>设置栈的起始地址</li><li>跳转到c代码中</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>mini-riscv-os/01-HelloOs/start.s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.equ STACK_SIZE, 8192</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    # setup stacks per hart</span><br><span class="line">    csrr t0, mhartid                # read current hart id</span><br><span class="line">    slli t0, t0, 10                 # shift left the hart id by 1024</span><br><span class="line">    la   sp, stacks + STACK_SIZE    # set the initial stack pointer </span><br><span class="line">                                    # to the end of the stack space</span><br><span class="line">    add  sp, sp, t0                 # move the current hart stack pointer</span><br><span class="line">                                    # to its place in the stack space</span><br><span class="line"></span><br><span class="line">    # park harts with id != 0</span><br><span class="line">    csrr a0, mhartid                # read current hart id</span><br><span class="line">    bnez a0, park                   # if we&#x27;re not on the hart 0</span><br><span class="line">                                    # we park the hart</span><br><span class="line"></span><br><span class="line">    j    os_main                    # hart 0 jump to c</span><br><span class="line"></span><br><span class="line">park:</span><br><span class="line">    wfi</span><br><span class="line">    j park</span><br><span class="line"></span><br><span class="line">stacks:</span><br><span class="line">    .skip STACK_SIZE * 4            # allocate space for the harts stacks</span><br></pre></td></tr></table></figure><p>csrr是从csr（Control and Status Register）寄存器中read值，而其中的csrr reg, mhartid则是将hart id读到对应的reg中。hart是riscv中硬件线程的最小单位，在riscv的spec中是这样描述的</p><blockquote><p>A RISC-V compatible core might support multiple RISC-V-compatible hardware threads, or harts, through<br>multithreading.</p></blockquote><p>这里的代码判断如果hart id不是0就跳到park这个循环中。实质上是只开启了一个hart</p><p>xv6-riscv/kernel/entry.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># qemu -kernel loads the kernel at 0x80000000</span><br><span class="line">        # and causes each hart (i.e. CPU) to jump there.</span><br><span class="line">        # kernel.ld causes the following code to</span><br><span class="line">        # be placed at 0x80000000.</span><br><span class="line">.section .text</span><br><span class="line">.global _entry</span><br><span class="line">_entry:</span><br><span class="line">        # set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0</span><br><span class="line">        li a0, 1024*4</span><br><span class="line">        csrr a1, mhartid</span><br><span class="line">        addi a1, a1, 1</span><br><span class="line">        mul a0, a0, a1</span><br><span class="line">        add sp, sp, a0</span><br><span class="line">        # jump to start() in start.c</span><br><span class="line">        call start</span><br><span class="line">spin:</span><br><span class="line">        j spin</span><br></pre></td></tr></table></figure><p>xv6的启动代码中考虑了多个hart启动的情况，给每一个hard都设置stack的起始地址。而stack的起始地址是写在其他的c代码中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry.S needs one stack per CPU.</span></span><br><span class="line">__attribute__ ((aligned (<span class="number">16</span>))) <span class="keyword">char</span> stack0[<span class="number">4096</span> * NCPU];</span><br></pre></td></tr></table></figure><h2 id="c代码"><a href="#c代码" class="headerlink" title="c代码"></a>c代码</h2><p>在c代码中打印出一个血统纯正的helloworld。这里其实隐含了很多的内容，但是暂且知道这样做就可以打印出helloworld即可。</p><p>对于xv6来说在进入os的main之前有许多设置状态的内容，这里暂且不讨论。</p><p>mini-riscv-os/01-HelloOs/os.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART        0x10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_THR    (uint8_t*)(UART+0x00) <span class="comment">// THR:transmitter holding register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_LSR    (uint8_t*)(UART+0x05) <span class="comment">// LSR:line status register</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART_LSR_EMPTY_MASK 0x40          <span class="comment">// LSR Bit 6: Transmitter empty; both the THR and LSR are empty</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lib_putc</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> ((*UART_LSR &amp; UART_LSR_EMPTY_MASK) == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> *UART_THR = ch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lib_puts</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (*s) <span class="built_in">lib_putc</span>(*s++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">os_main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">lib_puts</span>(<span class="string">&quot;hello, world\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ldscript"><a href="#ldscript" class="headerlink" title="ldscript"></a>ldscript</h2><p>这里主要是需要指定这么几项内容</p><ol><li>对于qemu来说，启动之后会读位于0x80000000这个地址的内容，因此我们需要将我们的内容放到这个地址开始。</li><li>指定OUTPUT_ARCH( “riscv” )</li><li>指定汇编入口地址，比如ENTRY( _entry )</li></ol><p>xv6-riscv/kernel/entry.S</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line">ENTRY( _entry )</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">   * ensure that entry.S / _entry is at 0x80000000,</span><br><span class="line">   * where qemu&#x27;s -kernel jumps.</span><br><span class="line">   */</span><br><span class="line">  . = 0x80000000;</span><br><span class="line"></span><br><span class="line">  .text : &#123;</span><br><span class="line">    *(.text .text.*)</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line">    _trampoline = .;</span><br><span class="line">    *(trampsec)</span><br><span class="line">    . = ALIGN(0x1000);</span><br><span class="line">    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;);</span><br><span class="line">    PROVIDE(etext = .);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .rodata : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.rodata .rodata.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .data : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sdata .sdata.*) /* do not need to distinguish this from .data */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.data .data.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .bss : &#123;</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.sbss .sbss.*) /* do not need to distinguish this from .bss */</span><br><span class="line">    . = ALIGN(16);</span><br><span class="line">    *(.bss .bss.*)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PROVIDE(end = .);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="makefile"><a href="#makefile" class="headerlink" title="makefile"></a>makefile</h2><p>mini-riscv-os/01-HelloOs/Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CC = riscv64-unknown-elf-gcc</span><br><span class="line">CFLAGS = -nostdlib -fno-builtin -mcmodel=medany -march=rv32ima -mabi=ilp32</span><br><span class="line"></span><br><span class="line">QEMU = qemu-system-riscv32</span><br><span class="line">QFLAGS = -nographic -smp 4 -machine virt -bios none</span><br><span class="line"></span><br><span class="line">OBJDUMP = riscv64-unknown-elf-objdump</span><br><span class="line"></span><br><span class="line"><span class="section">all: os.elf</span></span><br><span class="line"></span><br><span class="line"><span class="section">os.elf: start.s os.c</span></span><br><span class="line"><span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -T os.ld -o os.elf <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">qemu: <span class="variable">$(TARGET)</span></span></span><br><span class="line">@qemu-system-riscv32 -M ? | grep virt &gt;/dev/null || exit</span><br><span class="line">@echo <span class="string">&quot;Press Ctrl-A and then X to exit QEMU&quot;</span></span><br><span class="line"><span class="variable">$(QEMU)</span> <span class="variable">$(QFLAGS)</span> -kernel os.elf</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.elf</span><br></pre></td></tr></table></figure><p>这里没什么好讲的，绝大多数选项都用不到，唯一要注意的是-march的值</p><p>riscv是一种模块化的指令集，不同的名字代表支持的扩展指令集不同，关于详情参考</p><p><a class="link"   href="https://en.wikipedia.org/wiki/RISC-V#ISA_base_and_extensions" >RISC-V#ISA_base_and_extensions<i class="fas fa-external-link-alt"></i></a></p><p>之后直接通过make命令编译出elf之后通过qemu启动就好</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://github.com/cccriscv/mini-riscv-os" >https://github.com/cccriscv/mini-riscv-os<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/mit-pdos/xv6-riscv" >https://github.com/mit-pdos/xv6-riscv<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://riscv.org/technical/specifications/" >Specifications - RISC-V International<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/xv6-riscv-os-0</summary>
      
    
    
    
    <category term="os" scheme="https://fusionbolt.github.io/categories/os/"/>
    
    
    <category term="xv6-riscv" scheme="https://fusionbolt.github.io/tags/xv6-riscv/"/>
    
    <category term="mini-riscv-os" scheme="https://fusionbolt.github.io/tags/mini-riscv-os/"/>
    
    <category term="bootloader" scheme="https://fusionbolt.github.io/tags/bootloader/"/>
    
    <category term="riscv" scheme="https://fusionbolt.github.io/tags/riscv/"/>
    
  </entry>
  
  <entry>
    <title>虞美人草</title>
    <link href="https://fusionbolt.github.io/2022/10/16/Reading/papaver-rhoeas/"/>
    <id>https://fusionbolt.github.io/2022/10/16/Reading/papaver-rhoeas/</id>
    <published>2022-10-16T14:12:51.000Z</published>
    <updated>2022-10-16T14:15:33.016Z</updated>
    
    <content type="html"><![CDATA[<p>从小野身上的阴影中看到了自己。从差劲的过去与环境中脱离，只想要斩断过去，但是斩的断吗，不可能的，每个人都不可能断绝和过去的联系；小野与井上家相处的态度，小野认为自己的生活和井上家父女二人相差甚远，尽管还怀有恩情，但是对他们产生了鄙视；小野为了利益，不惜逐渐失去真诚，破坏承诺，选择去追求藤尾。这些内容相关的描述大多让我感同身受，不断的触动着我我内心黑暗的部分。我一直在迷茫，不知如此不真诚的自我有多少是该修正的，又要如何修正这些部分。小野最后受宗近所助解开了心结，那身为读者的我们如果也是这样该怎么做呢？写这些内容的时候偶然刷到诺贝尔奖获得者被爆出性侵少女，我对于小野这个角色所蕴含的意义多了一点想法。身为银表持有者，几乎代表了高学识的人们，但即便是这样的人们，也未必都是追寻道义的。许多人像小野一样，为了利益和欲望去做一些违反道义的事情，甚至是违反合理的法律，而大多数人不会像小野一样有人劝阻，我想作者一定是有对这样的人的批判在的。</p><p>而甲野与其完全相反，即便继承许多财产却依旧不为所动，坚持道义，有一种看透一切超脱于一切的感觉，但过于上帝视角，让人难以有代入感，或许也是因此作者给他设定为哲学专业，以及通过甲野相关的许多内容道出真理。宗近看似性格和甲野相差甚远，但从他对待不同人的态度可以看出对于道义他也是有着自己的坚持方式与追求。宗近和他家人对话的描述和小野与井上家相处的对比真的是非常强烈，宗近和他父亲以及他妹妹的谈话中充满了真诚，他是真的在关注他的家人，关注朋友。宗近与小野相交的剧情描写的不多，但每次相交小野都不会占上风，不论是买东西回家时小野感到被宗近的贬低，还是最后宗近的劝说，小野在这个真诚的人的眼前感到无力，只能感到他的耀眼，只能羡慕他的真诚。</p><p>藤尾母亲的虚荣、狡猾，为了面子无聊的伪装，无论哪一个行为决策都将她的这些特点描绘的淋漓尽致。描绘出了一个非常现实的形象，尤其是为了面子在意周围邻居看法这一面，特别像我们家长那一辈人，他们和亲戚以及邻里的关系更密切，他们也更重视这些所谓的外人看法，总是为了无聊的面子和外人看法做出一些毫无意义的事情；又或者为了利益层层计算这一点，现实中有太多这样的例子了，争夺家产，或者只是单纯的设下计谋以谋取利益。最后讲到藤尾自身，所有的主要角色都和她有着很强的关联，她更像是串联起这一切角色的线索。而到了故事的最后，通过藤尾的死来结束这一故事。藤尾更像是她母亲扭曲下的牺牲品，性格的塑造离不开她母亲，正如最后宗近所说：”您平素的想法确实有问题“，也正是因为这些产生了藤尾这样扭曲的性格，产生了这样的结局。</p><p>结局甲野的日记诉说着人们只看着不遵循道义的眼前利益，却忘了抛弃道德的代价，只看着美好的生却忘却了可怕的死，或许这和这和《快乐的死》中提到的非快乐的事情才能体现出快乐的事情略微相似，无论是好的还是坏的我们都不能忽视。在故事中小野即便打算找浅井回绝和小夜子的婚事，但他依然内心不安，甚至想要不遵守与藤尾的约定，也正如宗近所说，如果他这样选择下去了他一辈子都会置于痛苦中，而这就是他的代价。藤尾的母亲日常狡猾的话术，对于物质以及虚荣的执着，最终得到的就是甲野的抛弃与藤尾的死亡。宗近最后回复甲野的那句“此地只流行喜剧”真的是太嘲讽了，此时此地规定都已变成了这样，而社会上大多数人们的想法也是这样。大家在乎的是眼下的利益、是喜剧、是生，而不是更远的道义、悲剧、死亡。人们内心的黑暗普遍存在，《海边的卡夫卡》中有这样一段话</p><blockquote><p>外部世界的黑暗固然彻底消失，而心的黑暗却几乎原封不动地剩留了下来。我们称为自我或意识的东西如冰山一样，其大部分仍沉在黑暗领域，这种乖离有时会在我们身上制造出深刻的矛盾和混乱。</p></blockquote><p>只有真的去追求道义的人才会点亮这些黑暗，而这样的人又是很少的。另外社会上只有“喜剧”才被允许接纳和存在，只有“喜剧”才被允许传播，尤其是在这里。幸福的人千篇一律，不幸的人各不相同，而不同的悲剧带给我们各不相同的生的意义以及不同的教导，我们看不到这些悲剧那么我们迟早有一天会重复踏入这些悲剧之中。</p><p>道义这件事情，总觉得是一个难以谈论的话题。追求道义的人是极少的，做少数选择的人在生存上更加困难，同时有的人追求的又或者持有的是虚假的道义。在我眼里人类这一抽象存在是恶的，人的内心也确实普遍存在着许多黑暗，追求道义的过程我想也是点亮内心的过程。在这里似乎隐含了我对于不追求道义的人一些不接受，或许这个行为本身就是不够道义的。而追寻道义本身也是困难的，许多时候需要付出些什么，放弃眼前的利益这件事情又是违背人性的，而道义的边界似乎也模糊不定，这部分边界几乎是由环境的文化所决定。我为追求道义这件事感到苦恼，要做到怎样的地步，我又要如何战胜自己黑暗的人性，不断怀疑自己是否在虚假的寻求它。为此痛苦，为此迷茫，独自行走在茫茫人海中，不想追随人流，却也不知自己要去向哪里。希望有一天我能找到自己的答案。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从小野身上的阴影中看到了自己。从差劲的过去与环境中脱离，只想要斩断过去，但是斩的断吗，不可能的，每个人都不可能断绝和过去的联系；小野与井上家相处的态度，小野认为自己的生活和井上家父女二人相差甚远，尽管还怀有恩情，但是对他们产生了鄙视；小野为了利益，不惜逐渐失去真诚，破坏承诺</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="夏目漱石" scheme="https://fusionbolt.github.io/tags/%E5%A4%8F%E7%9B%AE%E6%BC%B1%E7%9F%B3/"/>
    
  </entry>
  
  <entry>
    <title>快乐的死</title>
    <link href="https://fusionbolt.github.io/2022/10/15/Reading/a-happy-death-albert-camus/"/>
    <id>https://fusionbolt.github.io/2022/10/15/Reading/a-happy-death-albert-camus/</id>
    <published>2022-10-15T10:26:03.000Z</published>
    <updated>2022-10-15T10:26:47.239Z</updated>
    
    <content type="html"><![CDATA[<p>这本书的后续发展和我预想的偏差比较大。还没开始读的时候，看到杀死富豪携带一大笔财产这件事情，想到的第一件事情就是有钱了依然不会快乐，我想主人公会拿这笔钱去娱乐，娱乐很久最后开始觉得无聊与没有意义，后来通过什么事件发现了快乐的真相，之后过上了快乐的日子。不过现在来想如果真的是这样的展开那可能就没意思了。</p><p>对主人公梅尔索来说他觉得痛苦，母亲已经去世，没有人陪伴，即便有玛尔特但他并不爱她，他也不爱其他情人；他觉得自己没有钱，每天还要这样工作八小时；无所事事的过着每一天，每周都是在消磨时间，正如文中他所说的“又熬完了一个星期天”。这样的他看到他的租户卡多纳的惨状，推动了他现在就想要获取快乐的想法，因此他动手了。他认为拿到那笔钱自己就能脱离这种现状，有了钱不必再去每天花费时间工作，有钱就自由了。</p><p>除了不用工作以及最后买了房子之外，似乎并没有什么地方体现出这笔钱的价值，哪怕描写钱对于快乐的帮助没有那么大这件事情都不存在，也许是因为我被自己的想法所束缚住了。关于钱的观念借扎格尔斯也提到过一些，比如他说的“大多数有钱人完全不知快乐为何物。但这不是问题所在。有钱，就是有时间。”以及“我想说清楚一点，不要觉得我在说金钱能带来快乐。我的意思是，对某个阶层的人来说，在有时间的前提下，快乐是可能的，而有钱，就能摆脱金钱的困扰”。但写到这我想作者后续的内容很少提及拿到的那笔钱也许正是对于这些观点的体现。有了钱，他不需要浪费时间去工作，而钱又无法带来快乐，因此没有什么体现出钱的重要性的地方。</p><p>作者没有采取表现出钱带不来快乐这一方面，而是着重在了其他方面。最重要的就是孤独。从他踏上行程后第一部分就在描写他独自一人在外的孤单，试图摆脱也未成功。即便在后面远离熟识的人们选择独自居住的时候依然会保持和新村子中居民的联系，和以往熟识的人们见面。</p><p>这本书借由扎格尔斯表达的内容除了对金钱的态度外似乎一直在强调要有追寻快乐的心，也许是想要表达不论环境如何关键是自己的心态与看法。后面作者还说到“要懂得让自己的心顺应每天的节奏，而不是非要每天的节奏顺应每天的心意”，追寻快乐，去做些什么固然重要，但是不是说一定要去达到了什么目的、做到了或者改变了什么才是快乐的，而是自己的心意如何去看待与解释周围一切，通过这种角度尽可能让自己的快乐程度多一分。</p><p>翻开书的第一页就是“要不计代价地追求快乐，抵抗这个用愚蠢和暴力将我们包围的世界。”（不知道其他译本是否是这样）但是他为什么最后一个人去住了呢，和卡特琳娜的对话仿佛是在说如果没有和快乐相反的经历无法体现快乐的经历一样。也许这是非常重要的一个观点，他说“我在意的，是有一定质量的快乐。只有当快乐和它相反的事物呈现出持久而激烈的对峙时，我才能够品尝到快乐的滋味”。只有他自身孤独的瞬间才会让他觉得和别人在一起是多么美好，快乐本身是由相反的事物衬托出来的。</p><p>说了那么多废话，最关键的结论大概是我们不应去追求什么理想的没有痛苦的世界，而是基于此时此刻，基于自己现在的人生，改变自己的看法，接纳与快乐相反的那一部分。真实的世界就存在于那里，但我们眼中的世界是由我们自己塑造的。</p><p>我被这本书的书名以及内容概要吸引而来，大概为了看到想要看到的东西以及为了明白些东西。那么我得到了什么呢，好像没有什么，这也无妨。那么读着这本书的我，感到快乐吗？遇到好事自然会快乐，但无法说整体的基调是快乐的。不算快乐。那痛苦吗？除了会对身体的不适感到痛苦之外，其他情绪上的好像也无所谓，或者做不到想做的事情就会难过，但那更像是踢到了石头一样的痛苦，也因此无法说整体基调是痛苦的。我对此似乎也不会在意，只是像个机器，按照命令做一切事情。</p><p>自己精神上对于快乐的追求好像没有那么强烈，我很喜欢jojo里吉良吉影的态度，“不需要疯狂的喜悦，相反也就没有深沉的绝望”，这句话也算是印证了上面提到的快乐是由相反的事物衬托的，对我个人来说这样的平静是最好的。</p><p>解读出来这些也都只是大道理，无法引起什么感受。只有道理本身或许也不会产生什么影响，尽情去生活、阅读与思考，也许有一天一切都会连接起来，震撼到心灵。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书的后续发展和我预想的偏差比较大。还没开始读的时候，看到杀死富豪携带一大笔财产这件事情，想到的第一件事情就是有钱了依然不会快乐，我想主人公会拿这笔钱去娱乐，娱乐很久最后开始觉得无聊与没有意义，后来通过什么事件发现了快乐的真相，之后过上了快乐的日子。不过现在来想如果真的是</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="加缪" scheme="https://fusionbolt.github.io/tags/%E5%8A%A0%E7%BC%AA/"/>
    
  </entry>
  
  <entry>
    <title>工作踩坑小结</title>
    <link href="https://fusionbolt.github.io/2022/10/02/Problem/some-work-problem/"/>
    <id>https://fusionbolt.github.io/2022/10/02/Problem/some-work-problem/</id>
    <published>2022-10-02T09:26:12.000Z</published>
    <updated>2022-10-02T09:27:44.010Z</updated>
    
    <content type="html"><![CDATA[<p>前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>一开始闹了一个小乌龙，工具链支持到c++17的标准，但是同事之前指定了14的标准，差点就要把filesystem相关的代码全改掉了。但是后来依然编译不过，在需要系统调用的标准库处报了错误，这才想到裸机并没有这种东西，最后还是加条件判断宏全部处理掉了…</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h2><p>裸机的启动代码中有一些汇编，其中JAL跳转指令在链接的时候报了错</p><p>startup.S:120:(.text+0xbe): relocation truncated to fit: R_RISCV_JAL against symbol `SystemInit’ defined in .text.SystemInit section in</p><p><a class="link"   href="https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean" >https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean<i class="fas fa-external-link-alt"></i></a></p><p>先说结论，JAL指令的立即数字段的长度是固定的，而所要跳转的地址超出了JAL这个字段所能代表的长度。</p><p>最初猜想是否和我的lib大小有关系，尝试删掉了部分代码缩小了接近一半的体积后果然可行。但是依靠这种方法解决是不可行的，代码体积无法再简化了，而且以后lib体积只会增大。参考链接中设置mcmodel，然而依然报错。</p><p>接着尝试修改链接顺序，因为符号的顺序是和链接的顺序相关的，想要将对应的符号放到链接的最前面，但是需要跳转到我的lib中的符号，又不方便再去调整lib中的顺序。</p><p>最后在同事的提醒下修改了链接脚本，将这些报错的text section放到了最前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">  . = ALIGN(0x8) ;</span><br><span class="line">  __stext = . ;</span><br><span class="line">  KEEP(*startup.o(*.text*))</span><br><span class="line">  KEEP(*startup.o(*.vectors*))</span><br><span class="line">  /* avoid link failed when lib too large */</span><br><span class="line">  *(.text.SystemInit)</span><br><span class="line">  *(.text.trap_c)</span><br><span class="line">  *(.text.vTaskSwitchContext)</span><br><span class="line">  *(.text.startup.main)</span><br><span class="line">*(.text)</span><br><span class="line">  *(.text*)</span><br><span class="line">  *(.text.*)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conda的环境问题"><a href="#conda的环境问题" class="headerlink" title="conda的环境问题"></a>conda的环境问题</h1><p>在使用某个python库的时候提示了Could not find a suitable hostfxr library，一直以为hostfxr相关的库版本错了，直到我点进这个源码看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_hostfxr</span>(<span class="params">dotnet_root: <span class="built_in">str</span></span>):</span></span><br><span class="line">    hostfxr_name = _get_dll_name(<span class="string">&quot;hostfxr&quot;</span>)</span><br><span class="line">    hostfxr_path = os.path.join(dotnet_root, <span class="string">&quot;host&quot;</span>, <span class="string">&quot;fxr&quot;</span>, <span class="string">&quot;?.*&quot;</span>, hostfxr_name)</span><br><span class="line">    <span class="keyword">for</span> hostfxr_path <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">sorted</span>(glob.glob(hostfxr_path))):</span><br><span class="line">        <span class="built_in">print</span>(hostfxr_path)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> ffi.dlopen(hostfxr_path)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;Could not find a suitable hostfxr library in <span class="subst">&#123;dotnet_root&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>一看血压直接拉满，抛了异常一律视为没找到。手动改成打印错误信息才发现是dlopen的时候所加载的glibcxx版本不对，由于是在conda环境下因此去修改conda的链接。不是第一次被conda坑了…</p><h1 id="优化与调试"><a href="#优化与调试" class="headerlink" title="优化与调试"></a>优化与调试</h1><p>这算是我第一次实际遇到因为优化产生的问题。由于最近在调试内存分配相关模块的问题，我想要手动malloc/new一块内存复现问题。此处为代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_malloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;na\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nb\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nc\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="keyword">int</span> *d = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nd\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用的是裸机专用的工具链，因此内存的分配和释放都会调用工具链中的代码，我在其中打了log，但是发现new的时候并没有打印log。</p><p>没有调试器，想了半天怎么也想不明白，最后查看反汇编发现画风是这样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/some-work-problem/Untitled.png"                      alt="Untitled"                ></p><p>指定编译选项的部分都是其他同事编写的，我一开始也没往这里想。看了半天最后发现原来malloc被优化掉了。b和d很直接，是unused的代码，但是a和c都被free了却依然被优化掉。</p><p>关于这个问题好奇搜了一下，搜到这个回答</p><p><a class="link"   href="https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2" >https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2<i class="fas fa-external-link-alt"></i></a></p><p>the optimizer knows malloc and considers it is a function with no side-effects，多半是编译器内部针对特定符号编写的优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。&lt;/p&gt;
&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;p&gt;一开始闹了一个小乌龙，工具链支持到c++1</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CrossCompiling" scheme="https://fusionbolt.github.io/tags/CrossCompiling/"/>
    
    <category term="Conda" scheme="https://fusionbolt.github.io/tags/Conda/"/>
    
  </entry>
  
  <entry>
    <title>NuttX mm模块在64位环境下的问题</title>
    <link href="https://fusionbolt.github.io/2022/10/02/Problem/nuttx-mm-in-64/"/>
    <id>https://fusionbolt.github.io/2022/10/02/Problem/nuttx-mm-in-64/</id>
    <published>2022-10-02T08:03:03.000Z</published>
    <updated>2022-10-02T08:08:51.683Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录一下最近折磨了我很久的一个问题。最近在基于某一套裸机工具链做交叉编译并且在某个模拟器上执行代码，模拟器上几乎没法断点，没法用调试器，只能手工加log的方式。加上打log本身非常拖累运行速度，几乎一秒一个字符，所以这个问题来来回回拖了好几天才解决。</p><p>提供的工具链中内存分配和释放相关的代码是基于开源的nuttx做了一点点修改，不涉及代码隐私问题，因此这里也会直接贴对应的代码。nuttx是为32位设计的系统，直接拿来64位的环境自然会有不少问题。</p><p>nuttx源码</p><p><a class="link"   href="https://github.com/projectara/nuttx/tree/master/nuttx/include/nuttx/mm" >https://github.com/projectara/nuttx/tree/master/nuttx/include/nuttx/mm<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/projectara/nuttx/tree/master/nuttx/mm/mm_heap" >https://github.com/projectara/nuttx/tree/master/nuttx/mm/mm_heap<i class="fas fa-external-link-alt"></i></a></p><h1 id="最小可复现代码与初定位"><a href="#最小可复现代码与初定位" class="headerlink" title="最小可复现代码与初定位"></a>最小可复现代码与初定位</h1><p>模拟器上执行代码的时候遇到vector的第三次push_back就会死循环在某个地方，写了一个vector push_back的用例来测试，依然会死循环卡住。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vector_pushback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 1\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 2\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 3\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的用例，自然不可能是我代码写错了。后来想到模拟器或许能dump pc，拿到pc后再去反汇编代码中看（全部都是静态链接塞进去），发现在这里死循环了</p><p>mm_mallinfo.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (node = heap-&gt;mm_heapstart[region];</span><br><span class="line">           node &lt; heap-&gt;mm_heapend[region];</span><br><span class="line">     node = (struct mm_allocnode_s *)((<span class="keyword">char</span> *)node + node-&gt;size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  printf(&quot;node=%p size=%d pre=%d (%c)\n&quot;, node,</span></span><br><span class="line"><span class="comment">//         node-&gt;size, (node-&gt;preceding &amp; ~MM_ALLOC_BIT),</span></span><br><span class="line"><span class="comment">//         (node-&gt;preceding &amp; MM_ALLOC_BIT) ? &#x27;A&#x27; : &#x27;F&#x27;);</span></span><br><span class="line">  <span class="keyword">if</span> ((node-&gt;preceding &amp; MM_ALLOC_BIT) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    uordblks += node-&gt;size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ordblks++;</span><br><span class="line">    fordblks += node-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;size &gt; mxordblk)</span><br><span class="line">    &#123;</span><br><span class="line">      mxordblk = node-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这个for循环的更新和判断条件，第一反应想到的就是size在某个地方为0了，导致不断在原地打转，因此我打印了heap的start和end，以及开启了循环内的打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heapstart:<span class="number">00000000001</span>C9B30</span><br><span class="line">heapend:<span class="number">000000001</span>EFFFFE8</span><br><span class="line">...</span><br><span class="line">node=<span class="number">00000000001</span>CAF08 size=<span class="number">0000000000000410</span> pre=<span class="number">00000000000011</span>D0 (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB318 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000410</span> (F)</span><br><span class="line">node=<span class="number">00000000001</span>CB328 size=<span class="number">00000000001</span>C75C8 pre=<span class="number">0000000000000000</span> (F)</span><br><span class="line">node=<span class="number">00000000003928F</span>0 size=<span class="number">0000000000000000</span> pre=<span class="number">0000000000000000</span> (F)</span><br></pre></td></tr></table></figure><p>可以看到遍历到某个node的时候size就变成了空。但我这个时候注意力全都放在了size为空这件事情上，因为这个工程同事之前接触到free出错的情况，就让同事来帮忙看，这才意识到原来0 size node之前的node的size和pre也都不对劲。</p><p>之后通过打各种log，将直接产生问题的地方定位到了free中，同时也就能在出错之前打印出原本正确的node信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node=<span class="number">00000000001</span>CAF08 size=<span class="number">0000000000000410</span> pre=<span class="number">00000000000011</span>D0 (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB318 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000410</span> (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB328 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000010</span> (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB338 size=<span class="number">000000001</span>EE34CB0 pre=<span class="number">0000000000000010</span> (F)</span><br></pre></td></tr></table></figure><p>注意这里坏掉的是1CB328，也就是倒数第二个结点</p><p>再看一下关于free的主要逻辑。源代码比较长，由于在这个例子中未进行merge，因此省略了对应的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *mem, <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>)caller;</span><br><span class="line">  <span class="comment">//mvdbg(&quot;Freeing %p\n&quot;, mem);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protect against attempts to free a NULL reference */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mem)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the memory chunk into a free node */</span></span><br><span class="line"></span><br><span class="line">  node = (struct mm_freenode_s *)((<span class="keyword">uint64_t</span>)mem - SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  node-&gt;preceding &amp;= ~MM_ALLOC_BIT;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the merged node to the nodelist */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addfreechunk</span>(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显关键在于mm_addfreechunk。但是在看这个函数之前，我们先看一下heap和各种node是怎样的。</p><h1 id="heap与node"><a href="#heap与node" class="headerlink" title="heap与node"></a>heap与node</h1><p>heap的成员很多，我们在这里只放出我们这里需要关注的几个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_heap_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span> *<span class="title">mm_heapstart</span>[<span class="title">CONFIG_MM_REGIONS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span> *<span class="title">mm_heapend</span>[<span class="title">CONFIG_MM_REGIONS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> <span class="title">mm_nodelist</span>[<span class="title">MM_NNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后我们先来看一下初始化全局堆的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_heap_initialize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mm_initialize</span>(&amp;g_mmheap, &amp;__heap_start, (<span class="keyword">uint64_t</span>)(&amp;__heap_end) - (<span class="keyword">uint64_t</span>)(&amp;__heap_start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_initialize</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *heapstart,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">size_t</span> heapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//mlldbg(&quot;Heap: start=%p size=%u\n&quot;, heapstart, heapsize);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following two lines have cause problems for some older ZiLog</span></span><br><span class="line"><span class="comment">   * compilers in the past (but not the more recent).  Life is easier if we</span></span><br><span class="line"><span class="comment">   * just the suppress them altogther for those tools.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ZILOG__</span></span><br><span class="line">  <span class="comment">//CHECK_ALLOCNODE_SIZE;</span></span><br><span class="line">  <span class="comment">//CHECK_FREENODE_SIZE;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up global variables */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  heap-&gt;mm_nregions = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the node array */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(heap-&gt;mm_nodelist, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct mm_freenode_s) * MM_NNODES);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MM_NNODES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      heap-&gt;mm_nodelist[i<span class="number">-1</span>].flink = &amp;heap-&gt;mm_nodelist[i];</span><br><span class="line">      heap-&gt;mm_nodelist[i].blink   = &amp;heap-&gt;mm_nodelist[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the malloc semaphore to one (to support one-at-</span></span><br><span class="line"><span class="comment">   * a-time access to private data sets).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_seminitialize</span>(heap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the initial region of memory to the heap */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addregion</span>(heap, heapstart, heapsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化nodelist，添加一个region。（目前的代码中只有一个region</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_addregion</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *heapstart,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">size_t</span> heapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> heapbase;</span><br><span class="line">  <span class="keyword">uintptr_t</span> heapend;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  <span class="keyword">int</span> IDX = heap-&gt;mm_nregions;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDX 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the MCU handles wide addresses but the memory manager is configured</span></span><br><span class="line"><span class="comment">   * for a small heap, then verify that the caller is  not doing something</span></span><br><span class="line"><span class="comment">   * crazy.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_SMALL) &amp;&amp; !defined(CONFIG_SMALL_MEMORY)</span></span><br><span class="line">  <span class="comment">//DEBUGASSERT(heapsize &lt;= MMSIZE_MAX+1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust the provide heap start and size so that they are both aligned</span></span><br><span class="line"><span class="comment">   * with the MM_MIN_CHUNK size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  heapbase = <span class="built_in">MM_ALIGN_UP</span>((<span class="keyword">uintptr_t</span>)heapstart);</span><br><span class="line">  heapend  = <span class="built_in">MM_ALIGN_DOWN</span>((<span class="keyword">uintptr_t</span>)heapstart + (<span class="keyword">uintptr_t</span>)heapsize);</span><br><span class="line">  heapsize = heapend - heapbase;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//mlldbg(&quot;Region %d: base=%p size=%u\n&quot;, IDX+1, heapstart, heapsize);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the size of this region to the total size of the heap */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapsize += heapsize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create two &quot;allocated&quot; guard nodes at the beginning and end of</span></span><br><span class="line"><span class="comment">   * the heap.  These only serve to keep us from allocating outside</span></span><br><span class="line"><span class="comment">   * of the heap.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * And create one free node between the guard nodes that contains</span></span><br><span class="line"><span class="comment">   * all available memory.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapstart[IDX]            = (struct mm_allocnode_s *)heapbase;</span><br><span class="line">  heap-&gt;mm_heapstart[IDX]-&gt;size      = SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  heap-&gt;mm_heapstart[IDX]-&gt;preceding = MM_ALLOC_BIT;</span><br><span class="line"></span><br><span class="line">  node                        = (struct mm_freenode_s *)(heapbase + SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  node-&gt;size                  = heapsize - <span class="number">2</span>*SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  node-&gt;preceding             = SIZEOF_MM_ALLOCNODE;</span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapend[IDX]              = (struct mm_allocnode_s *)(heapend - SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  heap-&gt;mm_heapend[IDX]-&gt;size        = SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  heap-&gt;mm_heapend[IDX]-&gt;preceding   = node-&gt;size | MM_ALLOC_BIT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> IDX</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  heap-&gt;mm_nregions++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the single, large free node to the nodelist */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addfreechunk</span>(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapstart和heapend分别保存了一个指向heap开始和结尾的allocnode的地址，初始化的时候中间有一个非常大的空闲的freenode，而随着之后内存的分配，中间会有越来越多的node。</p><p>注意allocnode和freenode的异同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> size;           <span class="comment">/* Size of this chunk */</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> preceding;      <span class="comment">/* Size of the preceding chunk */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> size;                   <span class="comment">/* Size of this chunk */</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> preceding;              <span class="comment">/* Size of the preceding chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">flink</span>;</span> <span class="comment">/* Supports a doubly linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">blink</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显而易见，allocnode和freenode存储的时候都是以一个size和preceding开始，只是free的后面还会跟两个指针。</p><p>其中的preceding保存了前一个chunk的size，同时也标记了当前的块是被分配的状态还是被释放的状态，allocnode和freenode的处理方式都是不相同的。</p><p>我们再回到初始化的部分，可以看到start和end的size是SIZEOF_MM_ALLOCNODE，中间空闲的node size为heapsize - 2 * SIZEOF_MM_ALLOCNODE，也就是说<strong>这个size是算入了保存内存信息的空间</strong>。</p><h1 id="mm-addfreechunk"><a href="#mm-addfreechunk" class="headerlink" title="mm_addfreechunk"></a>mm_addfreechunk</h1><p>我们再回来看mm_addfreechunk。我在这个函的前后从heapstart开始出发采用size递增的方式遍历，经过addfreechunk之后就开始死循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_addfreechunk</span><span class="params">(struct mm_heap_s *heap, struct mm_freenode_s *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Convert the size to a nodelist index */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ndx = <span class="built_in">mm_size2ndx</span>(node-&gt;size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now put the new node int the next */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (prev = &amp;heap-&gt;mm_nodelist[ndx], next = heap-&gt;mm_nodelist[ndx].flink;</span><br><span class="line">       next &amp;&amp; next-&gt;size &amp;&amp; next-&gt;size &lt; node-&gt;size;</span><br><span class="line">       prev = next, next = next-&gt;flink);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Does it go in mid next or at the end? */</span></span><br><span class="line"></span><br><span class="line">  prev-&gt;flink = node;</span><br><span class="line">  node-&gt;blink = prev;</span><br><span class="line">  node-&gt;flink = next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The new node goes between prev and next */</span></span><br><span class="line"></span><br><span class="line">      next-&gt;blink = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数逻辑也比较简单，找到对应的节点，修改flink和blink，只是看着这段逻辑很难想到为什么会引起那么奇怪的问题。</p><p>不过我一开始以错误的思路打下了一个log反而利于我想明白问题。最初理解node排布之后，我手动采用了node + size的方式访问到了这种方式访问到的最后一个node。我在mm_addfreechunk之前获取了最后一个node，并在前后打印该node的信息，发现并没有什么异常。后来晚上回家的路上突然意识到这样打印是有问题的，mm_addfreechunk会改变连接关系。但是这后来给了我一个提示，原来end node所在的地址没有被写掉。</p><h1 id="内存排布与解决方案"><a href="#内存排布与解决方案" class="headerlink" title="内存排布与解决方案"></a>内存排布与解决方案</h1><p>最后我开始画了内存图，想明白了原因。</p><p>回看最早出现死循环的地方，每次循环的递增是通过node = (struct mm_allocnode_s *)((char *)node + node-&gt;size))来做的，也就是说所有的node是排布在heapstart和heapend中间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start     <span class="number">328</span>            <span class="number">338</span>            free                 end</span><br><span class="line">|size|prec|size|prec|data|size|prec|data|size|prec|data      |size|prec|</span><br></pre></td></tr></table></figure><p>倒数第二个结点(338)坏掉，是因为倒数第三个结点(328)数据写越界了。这块空间被释放掉以后那么起始地址就会被视为一个freenode，在后面mm_addfreechunk修改对应的flink和blink的时候，由于除了size和preceding的数据大小小于了两个指针的大小，因此覆写了下一个内存块开头的部分。</p><p>那么我们实际上需要保证每次分配给数据的大小需要大于等于两个指针的大小。</p><p>mm_malloc.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> ndx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_DETECT_ERROR)</span></span><br><span class="line">  <span class="keyword">size_t</span> real_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Handle bad sizes */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_DETECT_ERROR)</span></span><br><span class="line">  size = (size + <span class="number">3</span>) &amp; ~<span class="number">3</span>;</span><br><span class="line">  real_size = size;</span><br><span class="line">  size += MDBG_SZ_HEAD + MDBG_SZ_TAIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust the size to account for (1) the size of the allocated node and</span></span><br><span class="line"><span class="comment">   * (2) to make sure that it is an even multiple of our granule size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  size = <span class="built_in">MM_ALIGN_UP</span>(size + SIZEOF_MM_ALLOCNODE);</span><br></pre></td></tr></table></figure><p>这里最后实际alloc的size是MM_ALIGN_UP以后的大小</p><p>mm.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_SMALL) &amp;&amp; UINTPTR_MAX &lt;= UINT32_MAX</span></span><br><span class="line"><span class="comment">/* Two byte offsets; Pointers may be 2 or 4 bytes;</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 8 or 12 bytes.</span></span><br><span class="line"><span class="comment"> * REVISIT: We could do better on machines with 16-bit addressing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MIN_SHIFT    4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   15  <span class="comment">/* 32 Kb */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_HAVE_LONG_LONG)</span></span><br><span class="line"><span class="comment">/* Four byte offsets; Pointers may be 4 or 8 bytes</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 16 or 24 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> UINTPTR_MAX &lt;= UINT32_MAX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> MM_MIN_SHIFT  4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">elif</span> UINTPTR_MAX &lt;= UINT64_MAX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> MM_MIN_SHIFT  5  <span class="comment">/* 32 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   22  <span class="comment">/*  4 Mb */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* Four byte offsets; Pointers must be 4 bytes.</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 16 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MIN_SHIFT    4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   22  <span class="comment">/*  4 Mb */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All other definitions derive from these two */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_MIN_CHUNK     (1 &lt;&lt; MM_MIN_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_MAX_CHUNK     (1 &lt;&lt; MM_MAX_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_NNODES        (MM_MAX_SHIFT - MM_MIN_SHIFT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_GRAN_MASK     (MM_MIN_CHUNK-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_ALIGN_UP(a)   (((a) + MM_GRAN_MASK) &amp; ~MM_GRAN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_ALIGN_DOWN(a) ((a) &amp; ~MM_GRAN_MASK)</span></span><br></pre></td></tr></table></figure><p>根据这里的代码可以得知我们只需要修改对应的MM_MIN_SHIFT即可解决问题</p><p>解决问题以后发现在这段代码的正上方也有相关的注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Chunk Header Definitions *************************************************/</span></span><br><span class="line"><span class="comment">/* These definitions define the characteristics of allocator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MM_MIN_SHIFT is used to define MM_MIN_CHUNK.</span></span><br><span class="line"><span class="comment"> * MM_MIN_CHUNK - is the smallest physical chunk that can</span></span><br><span class="line"><span class="comment"> *   be allocated.  It must be at least a large as</span></span><br><span class="line"><span class="comment"> *   sizeof(struct mm_freenode_s).  Larger values may</span></span><br><span class="line"><span class="comment"> *   improve performance slightly, but will waste memory</span></span><br><span class="line"><span class="comment"> *   due to quantization losses.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MM_MAX_SHIFT is used to define MM_MAX_CHUNK</span></span><br><span class="line"><span class="comment"> * MM_MAX_CHUNK is the largest, contiguous chunk of memory</span></span><br><span class="line"><span class="comment"> *   that can be allocated.  It can range from 16-bytes to</span></span><br><span class="line"><span class="comment"> *   4Gb.  Larger values of MM_MAX_SHIFT can cause larger</span></span><br><span class="line"><span class="comment"> *   data structure sizes and, perhaps, minor performance</span></span><br><span class="line"><span class="comment"> *   losses.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这个文件访问了很多次，但是每次都是为了访问特定的声明和定义，没有在意到其他地方的注释。不过自己潜入代码中去了解，自己去思考原因也算是一个增加经验的机会。就算提早看到了这个注释可能因为缺少很多信息也不会想到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随手记录一下最近折磨了我很久的一个问题。最近在基于某一套裸机工具链做交叉编译并且在某个模拟器上执行代码，模拟器上几乎没法断点，没法用调试器，只能手工加log的方式。加上打log本身非常拖累运行速度，几乎一秒一个字符，所以这个问题来来回回拖了好几天才解决。&lt;/p&gt;
&lt;p&gt;提供</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Memory" scheme="https://fusionbolt.github.io/tags/Memory/"/>
    
    <category term="Baremetal" scheme="https://fusionbolt.github.io/tags/Baremetal/"/>
    
    <category term="NuttX" scheme="https://fusionbolt.github.io/tags/NuttX/"/>
    
  </entry>
  
  <entry>
    <title>游颐和园</title>
    <link href="https://fusionbolt.github.io/2022/09/17/Life/TourTheSummerPalace/"/>
    <id>https://fusionbolt.github.io/2022/09/17/Life/TourTheSummerPalace/</id>
    <published>2022-09-17T15:10:57.000Z</published>
    <updated>2022-09-17T15:15:10.499Z</updated>
    
    <content type="html"><![CDATA[<p>下午从新建宫门入了颐和园，上次来已经是去年冬天的事情了，与上次不同的是十七孔桥现在不再设置栏杆，遂带着好奇心走向桥的另一端。到了对面看也没看到什么特别的，也没什么好拍的。倒是看到了许多经典十七孔桥照片的视角，但非金光穿洞日这些地方不太值得拍。</p><p>走着走着开始感觉热了起来，身上出了很多汗，来的也不是个好时候，几乎可以说是一天中最热的时间段，北京这个日子甚至还能到30度。但之后走到了一处三面被树木环绕一面朝湖的阴凉地，此时微风携带着湖水的清凉吹过来，甚是舒服。也许是这阵清凉的感觉激起了我调动更多感官去感受周围一切的想法。我开始触摸岩石，建筑，体会它们的纹理与摸上去时手的触感。看起来尖锐的岩石摸上去并不扎手，大多锋利的边缘都已经被时间所打磨的光滑，像极了经历了几年工作后脱发的程序员群体们（bushi）。自己多久没有摸过这些东西了呢？每天的手接触的都是冷酷无情的机械设备，这样的我与自然完全断开了联系。</p><p>由于包比较重，体验了没多久便找了个地方坐下休息一会，由于没什么事情做就开始发呆。看着湖中一艘艘小船驶过，脑袋里的新想法似有似无，但脑袋里想的事情哪怕是自己也很捉摸不透，就放任它在混沌中产生新的混沌吧。</p><p>没多久又决定走回了起始点，向着北边的东门走去。路上回想着去年冬天拍的视角都是怎样的，想要拍一组对比的照片，之前拍的照片没有发过，而群晖的quickconnect太慢加上没有折腾内网穿透也就无法访问家里的照片查看，最后只有凭借着记忆多拍了几张。回来发现好多之前觉得不好看都删掉了，就剩下这组对比，视角差的还挺大，不过意思传达到了，有机会再补吧（下次一定！）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5702.jpg"                      alt="DSCF5702.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF0406.jpg"                      alt="DSCF0406.jpg"                ></p><p>拍的过程中刚才调动感官的想法再次冒了出来，开始像个新生儿一样带着好奇心触摸各种事物。树干带给我的印象是粗糙且潮湿，后者大概是因为在湖边吧；而树叶带给我的感觉是柔软但边缘有些不平整的毛刺，不同种类的树叶摸起来的感觉自然也不同，但没有太多的印象了。接着是感受着太阳烘烤下岩石的温暖，以及各种地面与建筑表面。看到了小时候经常看到的一种墙面，多久没有这样仔细触摸过这样的石墙了呢，不过这倒也不是什么问题。还仔细觉察脚踩到地面的感觉，鹅卵石地面与普通的水泥地有着各自独特的感觉，由于隔着鞋子需要更加注意才能体会到，不过最关键的还是去觉察那个部位的感觉，如果没有觉察那么习惯了以后很容易就会忽略掉这些感受。</p><p>回到走向东门这个话题，本来此行就是为了桂花来的。中秋前两天忙着各种地方拍月亮，第三天累的只想休息，也就没来看桂花，明年可能会来吧。这里我所看到的有金桂和银桂两种，银桂只有一个小花苞，大概花期还要点时间，遗憾的是金桂大都凋谢的差不多了，万幸的是气味多少还残留一点。本着来都来了的优良传统，我想再好好找找再走，果不其然最后找到了一株还有一些花朵残留的金桂，兴奋的我赶紧放下背包赶紧收拾东西准备开拍。要去拍的时候发现有几个大爷大妈们拿着手机在拍，拍遮挡视线倒是也没啥问题，等一会有位置再拍就好，只是都把手机怼到了树枝里面，树枝的强烈颤动导致许多花都掉了下来。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5714.jpg"                      alt="DSCF5714.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5722.jpg"                      alt="DSCF5722.jpg"                ></p><p>还拍到了一只小蜜蜂！</p><p>拍完桂花则是向着东北角出发，尽管来过两三次但一直没有走过那边的路线。在看路线施工告示的时候一个老奶奶和阿姨跟我讲这里的路现在是怎么回事，后面跟着老奶奶和阿姨进了谐趣园，听了很多有意思的故事，比如说谐趣园里面有一个特别大的柳树，曾经有一只白鹭每天来水池里捕食鱼类，有一位拍到下落、下水捕捞、飞走的照片，之后第二天开园的时候就来了得有两百多的人把谐趣园水池旁边的路围绕的水泄不通，一个个都架好了长枪短炮。白鹭也确实来了，但是看到人这么多也就一直在柳树上没再下过水，老奶奶等到了中午十一点多没来也就走了（前一天是这个时间拍到的）。在北京的人应该能想象，无论你去什么有名景点总有一些老大爷全副武装在拍些什么。</p><p>之后听老奶奶讲了很多关于谐趣园里的事情，这里建筑的风格、合适的拍照点、以及一些历史背景之类的。在园内几乎转了一圈，最后坐在了园内的走廊讲起了各种各样的事情。“什么也不做坐在这里喝杯茶、看看景、聊聊天就挺好的，按照我们老年人的想法是这样的”，对此我深表认同。这种宁静也未必一定要老年人才应该去享受，每日都市的喧嚣又快节奏的生活偶尔也需要这样安静的坐下来，不急于做些什么，只是看着周围漂亮的风景，和旁边的人聊聊天，大概此时周围的环境会像海绵一样吸收掉压力、焦虑与烦呐吧。谐趣园里面很多地方设计的也确实非常巧妙，景色也很不错，看到有人坐在走廊里读书。我想夏季的雨天在这里漫步一定非常惬意吧，听着雨击打池塘与地面的声音，看着满池子绽放的荷花与游动的鱼群，和旁边的人聊聊天或者看看书，这该是多么美妙的景象，明年如果还记得这件事情我一定要来体会一次。不过赶上休息日合适的时间下雨也确实是一件难事。</p><p>我的照片难以显现出这里的一些设计之巧妙，还是需要亲自体会才行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5744.jpg"                      alt="DSCF5744.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5755.jpg"                      alt="DSCF5755.jpg"                ></p><p>老奶奶还讲了很多关于圆明园的故事，说道圆明园今天有爱国教育活动免费，虽然早就得知了这件事但我想要避开人流，因此今天也就来了颐和园。即便圆明园很大，很多地方人多的话很多地方依然显得空，但是我更想要安静的地方。人也不需要那么多，有认识的人就够了。大概坐了半个多小时，老奶奶和阿姨与我告别了。我在园内又转了好久，拍了一些照片。幸运的是今天又拍到了停留在花朵上的蝴蝶，上一次拍到还是之前去玉渊潭的时候拍到的蝴蝶落在樱花上。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5740.jpg"                      alt="DSCF5740.jpg"                ></p><p>拍了几张后出了谐趣园右转，发现这里有许多猫。每天云吸猫的我当然不肯放过这样的好机会，于是准备装备开拍。但这个时候我有些冲动，看到一个小孩子要拿一根草去动猫我竟然动手制止了，我并没有用什么力气，也没想吓到他，但是也算是碰到他了，还说出了不要动猫这样的话，随后他的家长说道他也没有要去动猫，我也不该动手。此时的我算是十分的羞愧，不是他是否真的要去动猫，而是我居然动手了，只能连忙道歉，他们走后我内心还是一阵不安，为了刚才做的错事感到一阵情绪存在。也许是赎罪性质，我只是挂着相机，但是迟迟没有去拍。我蹲在猫猫面前，一直学着招财猫的手势向猫猫摆手了半天，当然不仅是这个时候，之后我拍猫的时候一直都在这样摆手，不知为什么总想要做出这样的行为。随后我觉得不应该为了这些事情烦恼，拍猫要紧，连忙拍起了猫猫。这只猫一开始我以为它不开心，但是最后发现大概是困了，做什么动作，哪怕是接近它都毫无反应，最后它就在那边睡了过去，我也只好不再打扰。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5772.jpg"                      alt="DSCF5772.jpg"                ></p><p>睡得可真香啊，在做什么样的梦呢</p><p>随后周围拍其他猫的时候发现有一个铁栅栏后面有更多的猫，并且对面是可抵达的，遂即决定赶过去拍猫。赶向铁栅栏后的路上，开始感觉到疲惫逐渐侵蚀我的身心。开始有点无力，有一点点晕，还毫无理由的产生了一些负面的想法。虽然没走多少步，但架不住包和里面的东西实在太重，上午去上钢琴课还背了一大堆课本，同时手里还在举着相机四处拍照。但我不想就这么离开，找了个地方坐下尝试恢复一波能量后就继续出发。</p><p>到了猫猫的聚集地，呆了半个多小时，拍了几张照片。拍照倒是没什么，有意思的是和猫猫的互动。和一只猫对视，我往后退一步，它就往前走一步。这个很难以照片的形式体现了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5804.jpg"                      alt="DSCF5804.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5835.jpg"                      alt="DSCF5835.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5843.jpg"                      alt="DSCF5843.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5844.jpg"                      alt="DSCF5844.jpg"                ></p><p>猫猫也拍完了，我走向出口的路上坐在了一个延伸出的木台阶上，看着眼前翠绿的世界，就这么静静的坐着，除了偶尔听一下歌词的内容之外什么也不去想，什么也不去做。我很喜欢这里，宁静，有树有湖，让人感到安心，如果小雨天在这里散步该有多棒</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5789.jpg"                      alt="DSCF5789.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5846.jpg"                      alt="DSCF5846.jpg"                ></p><p>随后边走边随便拍几张，最后终于出了北门。饿的不行，便直冲离这最近的一家速食店，此时不得不说KFC虽然其他方面不行，但是店是真的多，这周围甚至都没看到其他能吃饭的店铺。KFC旁边的自动售货机买了一瓶脉动，象征性补充一下流失的其他物质，身体缺水的情况还是不太想直接去喝可乐，之后在KFC随便吃了点就坐上了回家的地铁。坐地铁的过程中倒是没什么好说的，离这也不远，大概五六站的路程，只是上车的时候正赶上日落的时间，出地铁时周围已是一片漆黑，不由得让人想要感叹时间流逝之快。</p><p>今天比预想的逛的要久，非常累，明天大概会去圆明园吧，并且会更累。主要是听说那边现在有花海，我还没有亲身经历过什么花海，之前去过北京植物园但是并没有见到数量多到花海程度的花，毕竟植物园更关键的是多样性。</p><p>以下是宝可梦爱好者的专享内容。</p><p>虽然前面说道想要体会各种感官，但今天一下午都没有摘下耳机。下午基本上就是宝可梦dp相关的几首音乐反复听，原本是想找最终对战白菜姐的bgm，但是偶然搜到了动画的op，倒是也很好听就一起加入了清单。对战白菜姐的bgm就没什么可讲的了，讲讲op的部分吧。</p><p>dp的动画主题曲给我印象最深刻的是这么两个地方：一个是跨越天冠山，另一个是超越时间与空间。</p><p>高いテンガン山　越えていこう</p><p>天冠山对于这作游戏来说是十分重要的，全部的游戏主线剧情，甚至整个地图我都觉得是围绕着天冠山设计的。而天冠山内部的剧情又相对比较难打，跨越这座山给我的感觉不仅是单独的征服一座山，而是克服诸多困难。尽管登山本身是如此，但是只是说跨越山对于我一个不爬山的人来说真的没有什么感觉。</p><p>時空を超えて 僕らは会える、まぶしいみんなの顔</p><p>本身dp的两个封面神就是代表时间与空间，而超越时空的相会又是十分珍贵的。后面还有きらめく瞳　ダイヤかパール这样的歌词，很容易就会联想到“友情是珍珠，回忆是钻石”这句话。不得不说dp不仅是神兽设定B格很高，而且动画本身的立意也很深刻。</p><p>一直在听的除了上面提到的两首还有对战赤日的bgm，这首bgm给了我许多不一样的感觉，略低沉的开头让我联想到了对战之前黑暗的世界，想到了对战时黑暗的背景，同时联想到了赤日的角色性格。</p><p>这几首都非常好听，况且这一作的宝可梦对我来说也是最喜欢的。</p><p>对战dp神以及三蘑菇的bgm其实也很棒，但今天下午并没有反复听。听这一下午搞得我很想收藏ost</p><p>最后放一下三首歌的Spotify的链接吧，其他的bgm都可以在专辑中找到</p><p>op：together</p><p><a class="link"   href="https://open.spotify.com/track/5eO5Bnv3wLgW9qawRpYfFR?si=421e89091bcb494a" >https://open.spotify.com/track/5eO5Bnv3wLgW9qawRpYfFR?si=421e89091bcb494a<i class="fas fa-external-link-alt"></i></a></p><p>白菜姐对战时的bgm</p><p><a class="link"   href="https://open.spotify.com/track/0u18DUjJSoq9gDQhxJBgxD?si=d257af05927d4c9d" >https://open.spotify.com/track/0u18DUjJSoq9gDQhxJBgxD?si=d257af05927d4c9d<i class="fas fa-external-link-alt"></i></a></p><p>对战赤日的bgm</p><p>[<a class="link"   href="https://open.spotify.com/track/25ns1GhXoBMo7XFfFtcJbU?si=a949e8cbdac54081%5D" >https://open.spotify.com/track/25ns1GhXoBMo7XFfFtcJbU?si=a949e8cbdac54081]<i class="fas fa-external-link-alt"></i></a>(</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下午从新建宫门入了颐和园，上次来已经是去年冬天的事情了，与上次不同的是十七孔桥现在不再设置栏杆，遂带着好奇心走向桥的另一端。到了对面看也没看到什么特别的，也没什么好拍的。倒是看到了许多经典十七孔桥照片的视角，但非金光穿洞日这些地方不太值得拍。&lt;/p&gt;
&lt;p&gt;走着走着开始感觉</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="颐和园" scheme="https://fusionbolt.github.io/tags/%E9%A2%90%E5%92%8C%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>吹响吧！上低音号</title>
    <link href="https://fusionbolt.github.io/2022/08/24/Animate/Sound-Enphonium/"/>
    <id>https://fusionbolt.github.io/2022/08/24/Animate/Sound-Enphonium/</id>
    <published>2022-08-24T05:35:08.000Z</published>
    <updated>2022-08-28T05:36:39.357Z</updated>
    
    <content type="html"><![CDATA[<p>整部番一切都距离我的现实过于遥远，无法引起什么共鸣，但是依然能够感受到各个剧情所表达出的情感：努力过后取得成果的兴奋，失败的遗憾与不甘心等等，仿佛自己也是其中的一员一样。日常生活中点点细节的衬托，人物的台词和表情，无一例外都在推动着情感的变化，有的是直白的，有的是非常隐晦的。同时两季+剧场版充足的分量讲述了十分多的故事，包含了高中生活中的方方面面，或许对于各种各样的观众都会多少找到一些自身的影子，不论是兴趣爱好与升学的矛盾、角色的成长、角色的不甘心还是努力的成功与失败等等，包含了太多太多真实的人生，这也让整个故事更加让人感同身受。</p><p>这部动画个人最喜欢的地方当然还是久美子和丽奈的互动。印象最深刻的是选拔的时候，久美子认为丽奈和别人不同，丽奈不能淹没在人群中，这部分的喊声将情绪全部带动起来。即便丽奈赢了要成为坏人久美子也会陪她一起，那句“我背叛你你可以杀了我”以及后面的台词简直是神来之笔，将两个之间的感情全部展现的淋漓尽致。</p><p>随着各种故事的开展，每个角色都在不断成长，久美子的性格成长是最显著的，最开始被丽奈说“久美子性格真是差劲呢”，后面经历了各种各样的事情以后逐渐变的成熟，这种方面也是有些让人羡慕。同时各个角色的形象也逐渐变的饱满，最初看起来非常高冷的丽奈，但是在剧情的发展过程中不断展现出各种各样的性格，对久美子”爱的告白“，选拔的剧情，后面为了和老师说话早去练习（还被久美子说”丽奈的这一点真是可爱“），以及后面的大胆表白，都是我印象比较深刻的地方。</p><p>有的作品天马行空，完全脱离现实，满足了人们的幻想；有的作品完全是贴近现实，引发情感冲动。京吹自然是后者，这两种不能说绝对的谁好谁坏，只是不同方面罢了。看京吹的时候注意力很难不放在可爱的角色上，看到可爱的角色们互动自然也会很开心，看同样为百合动画的Lycoris是这样的。但对于京吹来说，即便观众的注意力会被角色的可爱所吸引，但是接近现实的剧情更容易触动观众的内心，观众更会不自觉的把自己代入到其中的角色中，感受角色的想法，过于现实反而让人有感触，不像一些过于虚构的动画一样。不过最后总会从动画的幻想回到现实，这个时候会对自己所欠缺的开始感到羡慕、难过、渴求，或者说开始感受到更强烈的感受。而观众所感受到的这种强烈的感觉，我觉得也是京吹这部动画的魅力之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整部番一切都距离我的现实过于遥远，无法引起什么共鸣，但是依然能够感受到各个剧情所表达出的情感：努力过后取得成果的兴奋，失败的遗憾与不甘心等等，仿佛自己也是其中的一员一样。日常生活中点点细节的衬托，人物的台词和表情，无一例外都在推动着情感的变化，有的是直白的，有的是非常隐晦的</summary>
      
    
    
    
    <category term="Animate" scheme="https://fusionbolt.github.io/categories/Animate/"/>
    
    
    <category term="京阿尼" scheme="https://fusionbolt.github.io/tags/%E4%BA%AC%E9%98%BF%E5%B0%BC/"/>
    
  </entry>
  
  <entry>
    <title>世界尽头与冷酷仙境</title>
    <link href="https://fusionbolt.github.io/2022/08/21/Reading/Hard-Boiled-Wonderland/"/>
    <id>https://fusionbolt.github.io/2022/08/21/Reading/Hard-Boiled-Wonderland/</id>
    <published>2022-08-21T05:30:13.000Z</published>
    <updated>2022-08-28T05:34:12.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冷酷仙境"><a href="#冷酷仙境" class="headerlink" title="冷酷仙境"></a>冷酷仙境</h1><p>冷酷仙境的人们有心却又无法交心，心仿佛摆设一样。名为冷酷仙境，我不是很能明白名字的用意，也许是有了心因此相比于世界尽头算是仙境，但是人们之间无法交心因此是冷酷的。</p><p>其中情感外壳非常坚固的主人公的这段想法让我印象十分深刻</p><blockquote><p>也许，我想。任何人都不会紧紧搂抱我，我也不会紧紧搂抱别人。我就这样一年老似一年，像贴在海底岩石的海参一样孤单单地一年年衰老下去。</p></blockquote><p>紧紧搂抱是多么温暖的一件事情，但是却寻求不到。不会有人来抱着自己，自己也不会去抱别人。海底是那么的黑暗，陪伴自己的却只有冰冷的岩石，独自贴在上面又是多么的孤单的一件事情。即便是在海洋这种充满了生物的环境，在这么隐蔽的地方就不会被看到，也不会有人愿意来这里看，最终只会只身孤单下去，直到死去。即便有人会来到这里，自己却习惯了贴在岩石之上，因为长时间在这样的环境之中内心已经开始形成了一层层的外壳来保护自己，因此不愿去和他人接触，不愿去拥抱他人。</p><p>同时前后文中女郎的回应同样让我印象深刻</p><blockquote><p>在又黑暗又孤寂难过渴望别人拥抱的时候周围却没有人拥抱自己</p></blockquote><blockquote><p>即使花钱买很多很多女郎同床，即使同很多很多萍水相逢的女孩睡觉，也都不是实实在在的，谁都不会紧紧搂抱你的身体</p></blockquote><p>冷酷仙境的世界即便大家都有心，都能够正常生活，却无法找到和自己紧紧搂抱的人。人虽然正常的生存在这里，能够与他人产生交集，却无法与他人产生些什么深入的联系，无法产生爱意，即便身处人流之中却依然感到十分孤单，因为没有建立起密切联系的人。</p><p>冷酷仙境就是这样孤单的世界。</p><h1 id="世界尽头"><a href="#世界尽头" class="headerlink" title="世界尽头"></a>世界尽头</h1><p>世界尽头的人们进入了小镇后心会逐渐消失。名为世界尽头的深意，除了故事中提到的人进来了就要失去影子并且无法再出去之外，我觉得如果人没有了心那么也就到了其世界的尽头了。</p><p>这个世界这样能够运行很奇怪吧，本应当和人一体的影子逐渐和人分离，后面就会渐渐变得虚弱，最终死去，此时人也就彻底失去了心。人们即便没有心却依然这样生存着，每个人做事情也没有什么原因，没有什么自己的想法，只是因为要做这件事情。</p><p>心没了，情感自然也就没了所在之处。而这样的人并非不会产生情感而是都被独角兽吸去了。独角兽们带着情感逝去，被看门人斩下带有情感的头骨，再转生，像情感本身一样不断的诞生与消亡。</p><p>从记忆中就没有心的图书管理员不会对现状感到任何异样与奇怪，未曾感受过温暖也不知温暖为何物。而没有心的她也无法对主人公的想法产生任何回应，就像大校所说的：即便能和她在一起，能同她睡，但她没有心依然无法回应你。人的心意无法传达到，无法感受到她人的心意都是非常悲伤的事情。</p><p>世界尽头就是这样的“墓穴”。</p><h1 id="世界尽头与冷酷仙境"><a href="#世界尽头与冷酷仙境" class="headerlink" title="世界尽头与冷酷仙境"></a>世界尽头与冷酷仙境</h1><p>不论是冷酷仙境中的主角和女郎，还是世界尽头的人们，大家都以各自的形式缺少爱与温暖，但是对他们来说这个样子都是可以生存的。是可以生存，但是仅仅如此罢了。这样的世界该是多么孤独与悲伤啊。明知是这样孤独与悲伤的故事，却又无法从心底唤起什么情感，可能我像图书管理员一样早已没了影子，又或许我已经不知什么时候成为了世界尽头的居民吧，回过神的时候自己的影子就已经不知何时被看门人分离了，而它现在也只能虚弱的躺在床上。</p><p>不论是心还是情感对于人都是非常重要的。冷酷仙境中的人们有心但未能对他人真正产生情感，而世界尽头的人们更是直接失去了心。不论是哪一方，在旁观者的角度来看都是那么的孤单和悲伤。</p><p>最后两个世界交汇的方式着实有点意外，也许这个结局是在暗示一直将自己包裹在坚固外壳中的孤独者的最终归宿就是在世界尽头中与自己的影子分离，最终彻底失去自己的心。写到这里多少有些感伤了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冷酷仙境&quot;&gt;&lt;a href=&quot;#冷酷仙境&quot; class=&quot;headerlink&quot; title=&quot;冷酷仙境&quot;&gt;&lt;/a&gt;冷酷仙境&lt;/h1&gt;&lt;p&gt;冷酷仙境的人们有心却又无法交心，心仿佛摆设一样。名为冷酷仙境，我不是很能明白名字的用意，也许是有了心因此相比于世界尽头算是仙</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="村上春树" scheme="https://fusionbolt.github.io/tags/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>利兹与青鸟</title>
    <link href="https://fusionbolt.github.io/2022/08/15/Animate/LizAndTheBlueBird/"/>
    <id>https://fusionbolt.github.io/2022/08/15/Animate/LizAndTheBlueBird/</id>
    <published>2022-08-15T15:47:45.000Z</published>
    <updated>2022-12-29T15:18:34.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利兹与青鸟"><a href="#利兹与青鸟" class="headerlink" title="利兹与青鸟"></a>利兹与青鸟</h1><p>一个充满了爱但是结局让人心情复杂的故事。</p><p>第一遍的时候没有完全看明白最关键的点：青鸟为什么就这么飞走了，霙为什么在体会青鸟的心情以后就能够理解这一切了。当我在没有想明白这件事情的时候一口气写下了最初的版本，但是为了更仔细的了解这部番我又重新看了一遍关键的部分，发现许多地方和我想的完全不一样。第一次看的时候我的注意力全都在霙作为孤单的利兹的一面，霙的占有欲，霙对于希美深沉的爱意，同时掺入了我自身自私的想法。而第二遍则是开始寻找问题的答案，开始专注于故事所表现出的核心想法。</p><p>一些想法既然已经写下，即便是错误的也会保留在文中，对比想法的变化我想也是有什么意义的，不过即便无意义也无妨。</p><h1 id="利兹与青鸟-1"><a href="#利兹与青鸟-1" class="headerlink" title="利兹与青鸟"></a>利兹与青鸟</h1><h2 id="第一遍"><a href="#第一遍" class="headerlink" title="第一遍"></a>第一遍</h2><p>我不能接受这个结局因此感觉心情复杂，尽管能够理解利兹觉得自己限制了青鸟，想要让青鸟有更好的生活，因此放飞了青鸟。</p><p>两个人是相爱的，都是由于爱做出了各自的选择。那么爱是什么呢？爱是对方着想为对方付出，体谅对方的想法吗？我不明白，只有从各种有限的文字中得知这样的知识。顺着这个想法想下去，这也就是我不能完全理解的原因。</p><p>不论是否放飞都是对对方的爱。放飞是为了对方着想，为了对方有更好的生活；但既然知道彼此相爱，那么也应该尊重对方爱自己的想法，对方爱自己也是不想和自己分离。</p><p>最后放飞的过程我不知为何觉得甚至有些半强迫性，我知道自己的这个想法不太对，其中也有讲到青鸟太过于爱利兹，因此只能照着利兹说的做，这种事情太奇怪了吧？</p><p>但也不是说一定要禁锢住青鸟的意思，维持一定的关系并不一定会禁锢。但是按照这个故事来说，利兹和青鸟完全是彻底分离，可能不太会有机会再见了。这也是我觉得最难过，最不能理解的原因，相爱却要<strong>永久</strong>分离。自己不能认同和接受这样的故事结局，如果我是利兹的话也许会在其中掺杂了更多的自私<del>（糟糕的性格）</del>，不想要放飞青鸟。</p><p>这件事情上利兹自己肯定是最不愿意的，有了陪伴自己的人，自己不需要再只身一人了，结果现在又要回到过去孤独的生活。剧中还有这样的一句话：神啊，为什么要教给我打开牢笼的方法。她不想放飞青鸟，却又因为爱她选择了放手。</p><p>关于青鸟，想起之前看过这样一句话：别为其他人擅作主张。这或许是看待这个故事的另一个角度，这个角度多少有些阴暗。我想这个故事的设定中利兹并没有充分倾听青鸟的想法，青鸟的内心也是不愿意和利兹这样分离。尽管爱她，觉得是为了她好，但这样完全分离对青鸟真的是好的吗？</p><p>不管怎么说，这种问题也没有什么绝对的对与错，只是每个人的想法不同。对于故事中来说两种想法是冲突的，而这种事情放到实际来说可能又是并不矛盾的。或许也不必较真，毕竟只是一个简单的童话，但这就是我的想法。</p><h2 id="第二遍"><a href="#第二遍" class="headerlink" title="第二遍"></a>第二遍</h2><p>回看台词，利兹最后要放飞青鸟的时候说了这样的话</p><blockquote><p>我只是囚禁住你的鸟笼罢了，你拥有翅膀，拥有一片无垠的蓝天。我没有权利剥夺你的翅膀，来吧，离开这里，飞到更高更远的地方去吧，请让我目送你美丽的身影离去吧，<strong>这就是我表达爱的方式</strong>。我爱你</p></blockquote><p>利兹对于青鸟的爱是不限制不约束她</p><p>而青鸟为什么就这么飞走了呢，引用霙的话来说</p><blockquote><p>因为利兹这么说她才接受，青鸟无法改变利兹的选择，因为青鸟太喜欢利兹了，就算再伤心，也不得不飞走</p></blockquote><p>老师问：那么，青鸟是不幸的吗?</p><blockquote><p>我不知道，但是青鸟衷心渴望利兹幸福，只有这点肯定没错。<strong>青鸟表达爱的唯一方式，就是展翅而去</strong></p></blockquote><p>我想了半天，觉得这里是青鸟不想要让利兹觉得自己被利兹囚禁住了而难过。我不知道这样的理解是否是正确，不过不论如何飞走是青鸟对于利兹的爱。</p><p>即便我能够理解一些这样的心情，但我依然不喜欢这个结局。</p><h1 id="霙"><a href="#霙" class="headerlink" title="霙"></a>霙</h1><p>我非常喜欢这个角色，角色的立绘本身就很可爱，不过更多的是被她那十分强烈的感情所吸引。</p><h2 id="爱意"><a href="#爱意" class="headerlink" title="爱意"></a>爱意</h2><p>霙最触动我的情感是对于希美那种“我的眼中只有你”的感情。这种想法可能会有些沉重，沉重到让人承担不住，但是感情本身的炽热我觉得是非常打动人心的。因为“什么都爱等同于什么都不爱”，一个人爱的总量是有限的，分给越少的人，那么每个人得到的爱则更多，而一个人将所有的爱集中到唯一一个人身上，那必然非常强烈。</p><p>前半段基本上都在表现出霙对于希美的爱。从霙和希美两个人单独开始，到出现了更多角色的时候开始展现出了霙不想被希美夺走的心情。霙一直在注视着和希美，注视着她和其他人开心聊天的场景，注视的同时又在期待着希美和她一起聊天，听到她和其他人计划出去吃饭，期待着希美邀请她一起吃饭。</p><p>除了这些看着比较明显的表达方式，还有一些细节：看着希美所说的利兹与青鸟的故事，希美提到想要参加比赛的时候，又去借书认真了解这个故事。希美提到最喜欢的拥抱并且只说完”最喜欢“三个字的时候，希美说可爱这个词的时候，都有一个镜头给到了霙，霙那种眼神很明显就是在期待希美这样对自己说。</p><p>只是她的眼里只有希美，后辈第一次邀请霙的时候她并不是那么高冷，所以不愿接受邀请；在京吹中她只将希美作为了自己唯一的朋友，忽视了周围所有的其他人（可怜的优子）。但是即便开始有了一些朋友，霙的爱依然都在希美身上，依然那么强烈。</p><h2 id="不安"><a href="#不安" class="headerlink" title="不安"></a>不安</h2><p>霙一直在不安，这种不安让人心疼。京吹中有这样的台词</p><blockquote><p>在吹奏乐社每天都过得很开心，但对希美来说我只是朋友之一，许多朋友里的一个。只有我不知道，她甚至从来没有和我商量过，我不敢知道我在她心中其实不值得一提的事实。<br>我不懂，我为什么还要留在吹奏乐社</p></blockquote><blockquote><p>那…那你为什么没有放弃呢</p></blockquote><blockquote><p>乐器…只有乐器是我和希美之间唯一的联系了。因为我…只剩希美这个朋友了。如果连她也拒绝我</p></blockquote><p>在吹奏社开心是因为希美的存在，她也正是因为希美进入了吹奏乐社。</p><p>每一句台词都在显现出霙的不安，甚至害怕，这看着让人非常难受，能够体会到那种心都要碎了的感觉，因此会感觉非常压抑，这种强烈的感觉又会让这个角色在心中留下十分深刻的印象。</p><p>霙说过“正赛不要到来就好了”，而这句我觉得也对应了“只有乐器是我和希美之间唯一的联系了”这句话，担心没有乐器的联系两个人就要彻底分离了。</p><h1 id="希美"><a href="#希美" class="headerlink" title="希美"></a>希美</h1><p>写了这部分感觉内容有点偏向负面…但是并不是说讨厌这个角色。本来也没想写希美这部分的，但是我觉得从希美的角度也能够突出霙的心情。</p><p>印象比较深刻的有这些片段：希美每次和霙一起走的时候都离着霙好远；霙想要在希美旁边一起看书的时候结果希美无意识走开了；希美提到要拥抱的时候霙是非常想要，但是霙刚要伸出手的时候希美就说了一句逗你的，然后就走开了；霙想要靠在希美身上但是被无意识的躲开了。</p><p>而希美也未明确对霙表达过些什么，就像高一退部的时候觉得没必要说就没说了。也正是因为希美是这样的人，霙的不安越来越强烈，甚至在希美退部以后产生了那么强烈的反应。</p><p>不过不论怎么说，希美也是对霙怀有感情的，本身的角色设定和描写来说也很难突出希美对霙的感情究竟到了多么强烈。而希美感情的表现在后面才开始。希美自己的未来意向也是空白；在前面合奏的时候感情过于强烈，没有和霙的相互聆听，合奏的时候画面不断失焦的表现手法；希美和霙的眼神交流；以及希美最后对于霙的放手。</p><h1 id="希美和霙"><a href="#希美和霙" class="headerlink" title="希美和霙"></a>希美和霙</h1><p>这里的剧情一开始只是觉得霙就是利兹，而希美就是青鸟，但是万万没想到最后双方互为利兹与青鸟。</p><p>最初希美作为青鸟一样帮助霙摆脱孤单，霙像利兹一样想要希美留在自己身边。</p><p>但是到后面却发现是希美作为利兹一样限制住了霙的一切，想要放飞青鸟般的霙。</p><p>霙最后像青鸟一样，表达出了自己的爱意给对方。而希美最后也像利兹一样，没有过多说什么，只是放手。</p><p>最后的霙表达出了自己对希美的全部情感（霙最后说一连串喜欢的时候镜头拉伸简直绝了…），而希美只是说了一句喜欢听你的双簧管，我想这也是希美作为利兹的一种放飞方式。但不论怎么说都过于让人难过，希美对于霙的情感一定是存在的，而她为了放飞霙，却只能选择将这份情感封存到心底。</p><p>两个人从互相禁锢，再到相互放手，放飞对方。而在这一切的事情彼此全部讲明白以后，有这样一个镜头</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/LizAndTheBlueBird/Untitled.png"                      alt="Untitled"                ></p><p>也许是在暗示两个人互为彼此的利兹与青鸟，此时两个人都已经作为青鸟被作为利兹的对方放飞了</p><p>一开始有一个比较奇怪的问题，在这之后的霙如果在某段关系中成为了利兹，是否也会选择放飞青鸟呢？一开始提出这个问题，写到这个部分的时候才反应过来霙和希美的关系中霙本身也是利兹，她已经放飞了青鸟。</p><p>剧情从两个人早上一起上学镜头开始，到黄昏两个人一起回家的镜头结束。早上上学的时候两个人的距离非常远，而结束的时候两个人则是在一起行走。同时开头是disjoint，结局是joint。这里我没有明白，是因为两个人的心意相通了吗</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/LizAndTheBlueBird/Untitled%201.png"                      alt="Untitled"                ></p><p>在看第一遍的时候看到一个想法我觉得蛮棒的：她们就像是在同一个家，但是出门做不同的工作一样。但是对于利兹和青鸟的故事我觉得并不是这样，对于希美和霙如果后面是这样的关系那我觉得真的是再好不过。</p><p>但是回看的时候注意到这段剧情</p><p>希美：其实我觉得，利兹放走的青鸟相见利兹时就随时来见面不就好了</p><p>夏纪：那利兹的一片苦心不是都白费了吗</p><p>第一遍的时候我就没有想明白一个问题。回看的时候发现这是一个非常重要的点。</p><p>为什么利兹的苦心就白费了，是因为青鸟爱着利兹因此会经常回到利兹的身边，实际上还是以某种形式禁锢了青鸟吗</p><h1 id="爱到底是什么"><a href="#爱到底是什么" class="headerlink" title="爱到底是什么"></a>爱到底是什么</h1><p>这是关于爱的故事，但是越看下去我越不明白，爱到底是什么？</p><p>随便说几个词倒是简单，比如说不求回报的付出，为他人着想，但这最极致的情感使用这种文字来描述太空洞了。我只知道每个人表达爱的方式各不相同，就像利兹表达爱的方式是放手，而青鸟表达爱的方式是不想让利兹难过因此选择飞走。</p><p>对于利兹和青鸟来说，她们用了各自的方式表达了各自的爱意，但是她们真正的幸福到底是什么呢？</p><p>当我写到这个问题思路开始有些变化。爱有许多不同的方式，不同的角度，也有不同的目的。有的是为了他人好，有的是为了双方幸福，不同的选择之间没有绝对的好与坏。</p><p>剧中几乎没有提到幸福这个词，唯一提到幸福的位置应该就是霙回答老师的时候所说的</p><blockquote><p>我不知道，但是青鸟衷心渴望利兹幸福，只有这点肯定没错</p></blockquote><p>我开始发现自己关注点过多放在了爱上却没有考虑幸福这个目的本身，可能我的潜意识里更多觉得爱还是为了幸福而存在。我觉得她们在一起的时候是幸福的，也就因此无法接受这样的结局。她们依然会彼此相爱，但是彼此永久分离，这样她们真的会幸福吗？</p><p>有一个有些无聊的假设，如果利兹没有想到过自己是在禁锢着青鸟，那么利兹对于青鸟的爱意算是什么样的呢？这样的她们最终是幸福的吗？</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>一开始是期待着看到甜甜的糖去的，但是当我看到青鸟第一次离开利兹的时候就感觉要不对劲。第一遍看完过于代入霙的心情却又站在霙作为利兹的立场掺杂了许多私心，整体看完最大的感受是十分压抑，几乎要哭了出来。当我第二遍看明白了整个剧情的时候整个人已经陷入了情绪之中，我不明白爱到底是什么。</p><p>当我写完了这篇感受，尤其是写完了爱与幸福这一段，我仿佛脱离了出来，尽管我依然不明白爱到底应该是怎样的。但爱与幸福真正的答案是什么呢，或许并没有什么真正具有普适性的答案，人与人之间是完全不同的，而每两个人之间产生的关系更是大不相同。</p><p>写到这里我就不继续补充内容了，因为我的情感部分已经写了进去，并且已经开始往里添加不想要的原作细节了。过于追求内容的长度，反应过来的时候就已经开始回看里面的对话并且进行分析了不少。尽管这一部有很多细节值得反复推敲，但写下这篇文章的意义不是为了分析，而是要将自己的感受彻底表达出来。内容非常混乱，观点也因为自身经历和情感的匮乏导致非常幼稚，但这就是我现在最真实的想法。</p><h1 id="和朋友探讨的几次回复"><a href="#和朋友探讨的几次回复" class="headerlink" title="和朋友探讨的几次回复"></a>和朋友探讨的几次回复</h1><p>出于隐私考虑就不放上朋友说的内容了，对话也有轻微改动</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>看到你提到人为的细节的问题，利兹与青鸟里面的细节真的太多了，分析都能分析上好几天，各种对应。“一帧帧的解读只会让人越陷越深，所有的解读最多都只是锦上添花”这个我也有感觉…我在最后也写到开始陷入解读的细节中了</p><p>先不说自己无聊的部分，看到感想觉得你和自己看待整部剧的视角相差甚远。至少在这部中你更像是观众，你也写了“而回顾时却感觉到制作团队有意带着我们，以一个第三视角的距离去看”，而我基本上是在想霙的想法。你花费很大的篇幅在讲动画中各种描写各种环境的精彩，而我总在无聊的思考人生。一半原因是动画过于现实，另一半则是现在的自己大概就是这样无聊吧，功利且情感麻木。如果硬要为自己这样的行为再找个什么借口，那就是最后总要从动画中醒来吧。</p><p>在未写完的京吹感想中我有这样一段评价</p><blockquote><p>这部番更加接近现实，人更会不自觉的把自己代入到其中的角色中，感受角色的想法，过于现实反而让人有感触，不像一些过于虚构的动画一样。不过最后总会从动画的幻想回到现实，这个时候会对自己所欠缺的开始感到羡慕、难过、渴求，或者说开始感受到更强烈的共鸣。而观众所感受到的这种强烈的感觉，我觉得也是京吹这部动画的魅力之一。</p></blockquote><p>我还是对于这种环境的描写与衬托没有那么敏感，几乎没读什么文学作品，以及这也象征了我内心的空洞与虚无吧。讲一个我今天回想起两三年前做过的梦，我想这个梦就是当时真实的自己。本来可能会写到《世》的感想中，现在就写到这里</p><blockquote><p>自己不知怎么在一个无底洞中，周围什么都没有，只有一片漆黑。一直不断的向下坠落，没有疼痛，没有害怕，什么都没有，但是我一点都没有感到难过。渐渐的没有了时间和空间概念，只知道自己向下坠落，不知道该做什么遂开始观察自身的感受，但是也是一片虚无，但又十分宁静。<br>现在看来从入睡到做梦就像是《世》中主人公进入了第三世界一样，但是在我的第三世界中什么都没有，没有任何环境，没有自己的心，而这样的我有点像在世界尽头的居民一样，只不过除了自己以外的所有事物都消失了罢了。<br>醒来以后也是出奇的平静，梦本身很清晰，而内容又让人印象深刻，使我至今无法忘记。</p></blockquote><p>现在的我变成了什么样子，我也不知道，真正看清自己是非常困难的事情。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>你提到了好多我没有想到的角度</p><p>“因为害怕孤单与分离所以拒绝了周围人的爱”</p><p>说到这里我发现自己的关注点有大问题…我的关注点更倾向于mizore对于nozomi特殊的情感上，我写的感想中mizore相关的大部分也是基于这个来写的…这个根本问题就错了，过于关注了特殊的情感而忽略了其他爱别人的形式</p><p>现在想想后面给后辈做簧片的时候已经开始对周围的人产生关心了，不过特殊的情感依然是全部对于nozomi的。这个时候mizore慢慢开始走了出来，爱意不再那么沉重，剩下的只有炽热，但这份炽热并不会让人窒息。</p><p>自我救赎与自我毁灭也不是很明白，因为倾注了自我，将自我交给nozomi来决定，进而自我就毁灭掉了吗？记得mizore说过这么一句话：希美的决定就是我的决定，也许就是这个意思吧。</p><p>nozomi的嫉妒我也没考虑过，更别说发挥到mizore身上这一点。只知道这里肯定是不甘心的，为什么只给了mizore发而没有给自己。那么利兹是否也一样有一些嫉妒呢，嫉妒青鸟能够飞上天空，这个我觉得没有什么表现的地方。甚至她的控制力也是没有想到，因为mizore交了新朋友所以会觉得远离了一些。</p><p>表白的那一段nozomi躲躲闪闪我之前还以为是在压抑自己对于mizore的爱，没有考虑到她其他的复杂情绪。最后那句我喜欢mizore的双簧管，我之前只是觉得是nozomi放手的一种做法，不需要说那么多爱意。</p><p>一直觉得关于nozomi的描写没有显得对于mizore有多么强烈的爱，一直觉得她们就是彼此那么相爱的只是nozomi的部分没有刻画出来，觉得是因为nozomi本身就是一个“直男”的角色，但我没有想过nozomi对于mizore不会是那种特殊的爱，只是好朋友之上但又没有那么特殊与强烈</p><p>我想mizore在渐渐走出来的时候爱或许已经没有了沉重的部分，而是只剩下了炽热，最后也直接A了上去</p><p>nozomi的放手我觉得还是很好明白，这个表现的比较明显了。那么如果nozomi不再自卑，结局又是否会完全不一样呢？</p><p>用nozomi和mizore称呼哈哈哈哈确实这个叫法更好懂，我刚开始写的时候还在纠结nozomi要不要直接用伞哥称呼，mizore就直接用mizore。mizore我一开始还纳闷为什么翻译出来的字是那么少见的，打开日语输入法发现日语中mizore对应的汉字就是这个样子的</p><p>以及优子妈妈真的是操碎了心</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>想到如果nozomi不是这个样子的话，mizore不知道什么时候才能从这个样子中走出来。mizore走出来以后的爱或许不再沉重，是可接受的吧。即便像姐姐像前辈一样照顾mizore，mizore的特殊情感可能依然无法得到回应。</p><p>我回家以后又看了最后那段。因为嫉妒mizore，所以nozomi觉得自己应该被轻视吗，这里我还在奇怪为什么要这么说。nozomi看脚的细节，加上nozomi一直不敢正眼看mizore，多少能够体会那种卑微的感受…最后吸气声那里也太细节了。不过即便这样，nozomi的解脱我还是无法感同身受</p><p>最后还是我之前说的，不同视角差别非常大这件事情。看到你在描述mizore的自我毁灭我就已经因为这段剧情开始觉得压抑，也许这就是我最初感到压抑的本质吧，我能体会那种处于和他人的关系中不安的心情，而这种理解就像你对于nozomi感同身受一样</p><p>你讲的扬起的尘土最后却仍要回到路上，尽管明白空中回旋的过程并不是毫无意义的，但是依然会对最后落地的事实感到伤感</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;利兹与青鸟&quot;&gt;&lt;a href=&quot;#利兹与青鸟&quot; class=&quot;headerlink&quot; title=&quot;利兹与青鸟&quot;&gt;&lt;/a&gt;利兹与青鸟&lt;/h1&gt;&lt;p&gt;一个充满了爱但是结局让人心情复杂的故事。&lt;/p&gt;
&lt;p&gt;第一遍的时候没有完全看明白最关键的点：青鸟为什么就这么飞走了</summary>
      
    
    
    
    <category term="Animate" scheme="https://fusionbolt.github.io/categories/Animate/"/>
    
    
    <category term="利兹与青鸟" scheme="https://fusionbolt.github.io/tags/%E5%88%A9%E5%85%B9%E4%B8%8E%E9%9D%92%E9%B8%9F/"/>
    
  </entry>
  
  <entry>
    <title>书店之旅</title>
    <link href="https://fusionbolt.github.io/2022/07/30/Life/BookshopTour/"/>
    <id>https://fusionbolt.github.io/2022/07/30/Life/BookshopTour/</id>
    <published>2022-07-30T15:24:15.000Z</published>
    <updated>2022-12-28T15:48:16.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逛逛逛"><a href="#逛逛逛" class="headerlink" title="逛逛逛"></a>逛逛逛</h1><h2 id="三联韬奋书店"><a href="#三联韬奋书店" class="headerlink" title="三联韬奋书店"></a>三联韬奋书店</h2><p>店面挺大</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/1C979D3B-528B-4C0D-9DEA-F6423AF38CEA_1_102_o.jpeg"                      alt="1C979D3B-528B-4C0D-9DEA-F6423AF38CEA_1_102_o.jpeg"                ></p><p>刚出地铁大老远就能看到，里面设施感觉有些年头了。人也不多，看到了几个小孩子在看儿童绘本，整体上略显冷清</p><p>不过这个小坡我有点喜欢</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/8647A89A-C376-442D-84BA-8DBE3A6F9D92.jpg"                      alt="49CECC4F-135E-4FB3-A717-9223B2032E98.jpg"                ></p><h2 id="商务印书馆涵芬楼"><a href="#商务印书馆涵芬楼" class="headerlink" title="商务印书馆涵芬楼"></a>商务印书馆涵芬楼</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/49CECC4F-135E-4FB3-A717-9223B2032E98.jpg"                      alt="49CECC4F-135E-4FB3-A717-9223B2032E98.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/2A12CEEC-41B4-493A-9475-F6A905B28941.jpg"                      alt="2A12CEEC-41B4-493A-9475-F6A905B28941.jpg"                ></p><p>已经不能用冷清来形容了，因为加上我一共只有三个顾客，而因为人少这家店的店员基本上都在看手机。可能是因为没什么人，一个角落的灯一直在闪烁也没有任何维修。但这家店一墙的相同配色书籍让人印象十分深刻，虽然我个人还是觉得各种各样不同风格包装的书籍塞到一起更好看</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/FE93023E-43CA-428B-8737-1C55A0732F69.jpg"                      alt="FE93023E-43CA-428B-8737-1C55A0732F69.jpg"                ></p><p>这两家店里各种xxx谈xxxx的看着也有点烦了，明明只是一个书店却都得塞这样的东西到显眼的位置，也能理解书店的无奈，但是真的讨厌…</p><p>不过这引发了我的思考，书店里的书究竟应该是怎样的存在呢，难得一定要文学才算书吗，说来十分惭愧我潜意识中或许有这样的误区，将读书这件事情赋予了无聊的外部意义，却忽视了读书这件事情本身，这应当是非常单纯的一件事情。也许是“喜欢读书的人大多都是文学作品爱好者”的印象（并非负面评价）导致了这样的想法</p><h2 id="万圣书店"><a href="#万圣书店" class="headerlink" title="万圣书店"></a>万圣书店</h2><p>最后一家的位置非常不起眼，里面却最有书店味。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/ED79F1AC-4FAE-464C-8989-289649305B60.jpg"                      alt="ED79F1AC-4FAE-464C-8989-289649305B60.jpg"                ></p><p>和其他店铺在同一座楼，在店前面就贴着许多书相关的海报。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/5C41555F-056B-4ACC-AE02-8E6854EB1EEB.jpg"                      alt="5C41555F-056B-4ACC-AE02-8E6854EB1EEB.jpg"                ></p><p>也许因为旁边就是清北，这里的人相对来说多了非常多，并且具备了现代化书店的标配：咖啡馆。咖啡馆里倒是并没有多少在看书的人，一些人在戴着耳机用电脑学习，一些人在和一起来的人交流。这家书店不仅人多，也有许多结伴而行的，难免会有一些羡慕。</p><p>不要抱猫逗猫那张有被可爱到</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/7E622EC3-D81B-4DD8-8C5C-400AE7B8E722.jpg"                      alt="7E622EC3-D81B-4DD8-8C5C-400AE7B8E722.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/FD8247C7-FC4D-4905-9104-AC02318E644A.jpg"                      alt="FD8247C7-FC4D-4905-9104-AC02318E644A.jpg"                ></p><p>店铺内相比前两家狭窄了许多，但是由于很好的利用了垂直空间书籍摆的非常满，空间狭窄加上肉眼所见范围全都是书给人一种在书堆中的沉浸感。去的时候正巧有一个工作人员在爬梯子整理高处的书，更有书店的感觉了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/67D8ECF2-8107-4FD4-A683-8BC0C7E23FF7.jpg"                      alt="67D8ECF2-8107-4FD4-A683-8BC0C7E23FF7.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/323C7613-486A-4F3A-8F75-186E41E6DC77.jpg"                      alt="323C7613-486A-4F3A-8F75-186E41E6DC77.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/749E091F-36A8-4F8B-974B-E5D95181CFB5_1_201_a.jpg"                      alt="749E091F-36A8-4F8B-974B-E5D95181CFB5_1_201_a.jpg"                ></p><p>只可惜逛到这家的时候身体略有不适，无心过多感受氛围，但是确实留下了很不错的印象。最后走的时候注意到上下楼的台阶边缘容易发出异响，可能多少有点影响店内的体验，不过这个应该就不是书店的管辖范畴了</p><p>出了书店看到了超大的棉花糖</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/C242E391-8EAB-46C1-8966-4FE34122443B.jpg"                      alt="C242E391-8EAB-46C1-8966-4FE34122443B.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/166F236B-4D98-4506-9704-FF87520E50D4.jpg"                      alt="166F236B-4D98-4506-9704-FF87520E50D4.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/29905B8B-1BAC-4BB3-8206-1D19390B9A4D.jpg"                      alt="29905B8B-1BAC-4BB3-8206-1D19390B9A4D.jpg"                ></p><h2 id="零碎的想法"><a href="#零碎的想法" class="headerlink" title="零碎的想法"></a>零碎的想法</h2><p>对于前两家店，一进店里就有非常浓重的书味，戴着口罩都能明显闻到，也许算是一种人少的体现？而对于最后一家则是有一种香气，大概是用了什么香薰，而味道也不会太浓重，能够让人安心的在店内看书。</p><p>在这几家店逛的时候多少有些无聊，因为是本着看书店来的，而朋友推荐的书打算买纸质版了，也就断绝了在店内看书的想法。因为无聊发出了疑问，人们为什么会逛书店呢？最初的想法是也许不知道该读什么。但对于网络发达信息爆炸的现代，人们更多的是面对不会看的超长书单（当然我自己也是这样），很少会有人去书店。现在独自逛书店在店内看书的又是怎样的人呢？也许是喜欢书店的氛围人们，也许正因为如此前两家没有氛围的店都没什么人，而他们想必大多是非常感性的人，带着自己的思绪在书海中遨游。</p><p>逛的时候看到琳琅满目的书多少有点心动，想要多看一下不同的书都在讲着些怎样的内容，产生了一些好奇，又想到还有那么多的事情要做多少有点不知所措，总之后面也会提到，每周会专门拿出时间心无旁骛的读书！</p><h1 id="回忆"><a href="#回忆" class="headerlink" title="回忆"></a>回忆</h1><p>在路上想起了承载我儿时回忆的新华书店。我妈喜欢逛街，每次逛街我就去书店里呆着吹空调。很小的时候会在那边看走迷宫的图画书，后来大一些了会去看冒险小虎队。很多书都是没有试读版的，因此实际能看的书好像也没有多少，也许是我当时的关注点过于狭窄。那个年代网购还没有这么流行，大家都是去书店买书，每次去书店不论收银台还是各个书架前都有不少人</p><p>家里有电脑后都在家里打游戏了，很久没有去，几年前经过的时候发现一层的店面一大部分变成了甜点店，不知楼上如何（原来是五层的店）。还记得每一层的内容都不一样，一层记得是什么都有，二楼更偏向一些专业性强的书籍，三楼就是我常去的地方，四楼貌似都是词典之类，五层都是卖一些点读机什么的</p><p>印象里在这家店小时候只买过三本课外书的样子，一本是宝可梦386图鉴，两本冒险小虎队，这也非常的儿童了（可我就是个孩子嘛），还当时跟家里要一本课外书都得要磨很久很久才能同意</p><p>回想一下除此之外自己所拥有的书，还有好几本不记得怎么来的冒险小虎队；有一本奇怪的植物书，不记得来源了，不过我记得第一次看到猪笼草就是在这里面，还有猴面包树这个东西；还有一本花了十块钱买的什么科普，不过也没有看过；还有一本从亲戚那里得到的水浒传，但是由于非白话文看的没什么兴趣，最后被我拿来夹叶子标本了。说起来距离当年夹入银杏叶标本已经有8个年头了，时间过的真快啊，前两年也拿出来看过几次，已经完全干了！可能还有一些其他的书，已经完全失去了印象，小时候的记忆残留的不太多。高中开始会网购了，后来开始悄悄存钱买各种二次元画册！（不是涩涩的那种x）</p><p>我的童年和读书没有太多的缘分。小时候读不懂各种课文和文章，因为没什么经历，生活只有学校和家两点一线，没有旅游没有故事，朴素的不能再朴素的生活，早期这方面也没什么启蒙。唯有这两年才开始产生一些想法什么的，开始渐渐能够理解一些感受了，不过这也没什么不好，努力去了解并且理解也是一个有成就感的过程。</p><p>嘲讽的是大学开始就会买各种乱七八糟的书，最后读了的也寥寥无几。最早肯定还是各种大部头专业书了，一开始确实读完了一些，之后随着成长渐渐开始买一些工具书，再后来开始读各种范围之外的</p><h1 id="喜好"><a href="#喜好" class="headerlink" title="喜好"></a>喜好</h1><p>我讨厌读书吗？其实也没有，小时候不喜欢语文课文，但那都是因为读不懂。沉浸阅读故事时的感觉真的很棒，有的书看完前面就非常想往后看（柳比歇夫传记《奇特的一生》），有的书也会有不舍感（乔布斯传记《成为乔布斯》）。那读了多少呢？想想看也没读多少，但我觉得无妨，现在开始就好了。其实也不必太过在意数量，而是要专心读下去</p><p>我在想也许读书这一“喜好”是自己给自己强加的，但自己并不讨厌。读书的过程会有各种消极情绪，但这都不是读书本身带给我的，而是我想要赶快读完的焦虑，认为读完了就等于学会了的天真，以及一直在功利性的阅读导致充斥了过多杂念，这些导致读书这个行为变了味</p><p>想到这我觉得自己好像没什么喜欢的东西，大部分自称喜欢的东西都是自己强加的罢了，而不喜欢的东西大部分又是自己不会的。不过现在在做的事情即便自己强加给自己也不会讨厌它们，也能做的开心，说的功利点现在工作的方向还有不少钱拿也能感受到一些成就感，最初可能也是强加给自己的想法，但我觉得这样也够了，这个过程中难过的只有我自己在不懂时的不知所措，我现在并不讨厌学习什么东西，反而认为学习这件事情是每天都必须要做的</p><p>回想童年或许能够找到自己喜欢的东西，我小的时候就喜欢画画，暑假拿着买来的宝可梦图鉴从第一只就开始临摹，少说也有好几十张吧，还能找到一些照片，本体还放在家里完好的保存。没有机会去进一步学习加上有点笨，画的都不怎么样。不过不管怎么样我都很开心，高中晚自习难过的时候就会不写作业偷偷画画。后来高中毕业后，我整个人也不知道为什么全变了，也渐渐的没法画了。画的时候想的是自己画的好烂，觉得自己不行，几乎再也没动过笔</p><p>想起一个小插曲：高中学美术的同学问过我为什么要画这些，我说我喜欢。现在看起来自己有点小蠢，不知道在ta们看来是怎样的，不过这个事情也无需在意</p><h1 id="想要读"><a href="#想要读" class="headerlink" title="想要读"></a>想要读</h1><p>扯的有点远，我对喜欢的事情与爱好的一些想法是这样的，继续回到读书吧。</p><p>开始觉得周末花点时间什么也不考虑的读一会书也许不错，读这些的时候不会再期望学到什么，读明白什么，而是想用身心去感受。就像此时此刻写下这些想法一样，没有什么太多的原因和理由，没有什么太多的杂念，而是专注于当下的行为</p><p>也不要什么电子书了，太过容易分神、会想要乱画一通、会想要截图发出来，并且电子书会有一种把书中感情都剥夺走的感觉，不会有那种握着纸张的触感，不会有真正翻页的声音，不会有费力要看靠近装订线的时候（这个更多的是书本排版设计有问题就是了。第一次阅读更想专心体会心中的感受，而不是这些无关紧要的杂物</p><p>不过不管怎么说，只有三个字：想要读，想要不带杂念的阅读，希望能做到吧</p><h1 id="搞笑小插曲"><a href="#搞笑小插曲" class="headerlink" title="搞笑小插曲"></a>搞笑小插曲</h1><p>这人今天超级蠢，因为写想法太专心了导致两次地铁坐过站，还有一次差点坐反（最后一秒反应过来冲出来了）。不过这正说明我在专心写出我的想法，感受到了自己的这种专注力倒也不错。（这两天学习都没见过有这么专注，可能因为我挺享受这种将自己的想法写下来的过程吧</p><p>写完这段之后我第三次坐过了，自己都笑了出来</p><p>知春路出发，目的地是海淀黄庄，一开始在知春路差点坐反，之后坐过到了苏州街，从苏州街出发又坐过到了知春里</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/BookshopTour/image-20221228234649169.png"                      alt="image-20221228234649169"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;逛逛逛&quot;&gt;&lt;a href=&quot;#逛逛逛&quot; class=&quot;headerlink&quot; title=&quot;逛逛逛&quot;&gt;&lt;/a&gt;逛逛逛&lt;/h1&gt;&lt;h2 id=&quot;三联韬奋书店&quot;&gt;&lt;a href=&quot;#三联韬奋书店&quot; class=&quot;headerlink&quot; title=&quot;三联韬奋书店&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="书店" scheme="https://fusionbolt.github.io/tags/%E4%B9%A6%E5%BA%97/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其四：PassManager的改进与迁移现状</title>
    <link href="https://fusionbolt.github.io/2022/07/17/llvm-pass/llvm-pass-4/"/>
    <id>https://fusionbolt.github.io/2022/07/17/llvm-pass/llvm-pass-4/</id>
    <published>2022-07-17T08:54:17.000Z</published>
    <updated>2022-07-17T08:55:26.664Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-4/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">仪式召唤！降临吧，青眼混沌极龙！这样闹剧也就结束了，混沌的极限爆裂！</center> <p>这一期我们来做一下之前遗漏的AM和PM的对比分析、新的PM机制相比legacy PM做了哪些改进以及LLVM中PM的现状</p><h1 id="PassManager和AnalysisManager"><a href="#PassManager和AnalysisManager" class="headerlink" title="PassManager和AnalysisManager"></a>PassManager和AnalysisManager</h1><p>之前虽然单独讲过PassManager（简称PM）以及AnalysisManager（简称AM），但是没有将这两者放到一起对比，在这里我们简单对比一下PM、AM以及对应的Pass，通过对比我们能够更深入的理解普通Pass和Analysis的异同。这里算是一个回顾也就不再贴代码了，如果忘记了可以参考前面几篇，其中都包含了详细的代码</p><h2 id="显然的相同点"><a href="#显然的相同点" class="headerlink" title="显然的相同点"></a>显然的相同点</h2><p>这里的相同点更多的是代码实现方式上，而不是Pass（这段统称Analysis和Pass为Pass）自身性质之间的差异</p><p>Pass自身都采取了ConceptBase的实现方式，PM添加一个Pass的时候通过将这个Pass保存到一个相应的Model中，之后通过Model来执行Pass</p><h2 id="addPass"><a href="#addPass" class="headerlink" title="addPass"></a>addPass</h2><p>Manager的使用首先从添加Pass开始，对于两者来说都是保存了一个XXXModel在Manager中，但是对于普通Pass来说传入的参数是一个Pass的实例，而一个Analysis传入的是一个AnalysisBuilder，也就说Analysis的构建实际上是通过这个builder延迟执行的，如果这个Analysis存在的话则不会再重复构造</p><p>这样的差异是由于对于一个Analysis来说只需要存有一个实例即可，每次做分析都会找到这个analysis进行分析，同时analysis不需要考虑顺序的问题，在普通Pass需要的时候进来找到对应Pass跑就可以了。对于普通Pass则会添加多个实例到整个流程中，普通Pass的执行顺序是依靠于添加的Pass实例的顺序</p><p>还有一个差异是PM允许添加一个作为Pass的PM（换个说法PM也是一个符合条件的Pass），实际的行为则是将另一个PM的所有pass添加进来，这和上面提到的传参方式的差异本质是相同的</p><h2 id="执行Pass"><a href="#执行Pass" class="headerlink" title="执行Pass"></a>执行Pass</h2><p>PM执行的入口是run，这里没什么特别的，只要不是被指定skip的pass都会执行（执行Pass之前会有callback进行判断）</p><p>AM执行的入口是getResult，由于AM不仅需要保存实例还需要缓存之前分析的结果，因此每次getResult都需要分析是否存在缓存再决定是否执行Analysis，也就是说并非一定会执行。</p><h1 id="新PM改进了什么"><a href="#新PM改进了什么" class="headerlink" title="新PM改进了什么"></a>新PM改进了什么</h1><p>接下来的内容以这个链接内容的解读为主，许多地方会讲的比较粗略，不明白的请优先参考原文</p><p><a class="link"   href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/" >https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/<i class="fas fa-external-link-alt"></i></a></p><p>这个链接中主要提到了这么几个问题</p><h2 id="Pass和Analysis分离"><a href="#Pass和Analysis分离" class="headerlink" title="Pass和Analysis分离"></a>Pass和Analysis分离</h2><p>在legacy Pass架构中普通Pass和Analysis都是相同的Pass，而在新架构中从类型以及实际执行上区分开了两者</p><blockquote><p>With the legacy PM, each pass declares which analyses it requires and preserves, and the pass manager schedules those analyses as passes to be run if they aren’t currently cached or have been invalidated. Declaring ahead of time which analyses a pass may need is unnecessary boilerplate, and a pass might not end up using all analyses in all cases.</p></blockquote><p>legacy Pass主要有以下这么两类问题</p><ol><li><p>执行不必要的分析</p><p>执行Pass的时候可能还没到需要信息的地方就提前停下了，也就是说这些Analysis并没有被用上，又或者说根据分支结构有些修改没有执行（即不会影响某些分析结果），会导致实际没有修改的部分的分析又重新跑了一遍</p></li><li><p>Pass编写上十分麻烦</p><ol><li>手动指定依赖的analysis又蠢又麻烦</li><li>还要写各种构造函数初始化</li></ol></li></ol><p>除了作者提到的这些之外，我觉得还有两个重要的点</p><ol><li><p>Pass的顺序</p><p>这里的顺序主要还是指的普通Pass和Analysis之间。在legacy PM中主要是通过每次addPass的时候进行一次schedule来解决普通Pass依赖analysis的情况，而在新Pass中则是需要的时候再根据是否有缓存再实际跑分析，不需要考虑analysis应该什么时候执行的问题</p></li><li><p>新的Pass很大程度的简化了各个和Pass相关部分的实现。不需要再手动指定是否为Analysis或者CFGPass了，直接通过类型来做区分而不是记录在PassInfo中，Pass自身的元信息记录内容以及记录方式都简化了许多，而用到这些信息的代码也会精简很多</p></li></ol><h2 id="获取Analysis信息"><a href="#获取Analysis信息" class="headerlink" title="获取Analysis信息"></a>获取Analysis信息</h2><blockquote><p>Since the legacy PM modelled analyses as passes to be scheduled and run, we can’t efficiently access analyses to arbitrary functions.For a function analysis, the corresponding analysis pass will only contain the info for the current function, which is created during the latest run of the analysis pass. We can manually create analyses for other functions, but they won’t be cached anywhere</p></blockquote><p>这里主要还是说legacy PM中analysis视为一个普通pass的话无法缓存结果。这些都是通过AM管理analysis以及缓存结果来实现的。AM最重要的意义我认为一个是不需要再通过各种schedule的方式来管理执行analysis的时间，另一个则是缓存机制来减少不必要的分析</p><h2 id="CGSCC-Pass"><a href="#CGSCC-Pass" class="headerlink" title="CGSCC Pass"></a>CGSCC Pass</h2><p>这部分我不太了解，目前还没有了解过CGSCC相关的代码，直接看一下原文吧</p><blockquote><p>However, the legacy CGSCC pass manager only stored the functions in the current SCC in memory and did not have a persistent call graph data structure to use as keys to cache analyses. So we need to keep the whole graph in memory to have something to use as a key. And if we have a persistent call graph, we need to make sure it is up to date if passes change its structure.</p></blockquote><h2 id="Pass结构关系"><a href="#Pass结构关系" class="headerlink" title="Pass结构关系"></a>Pass结构关系</h2><blockquote><p>When adding passes to the legacy pass manager, the nesting of different pass types is implicit.For example, adding function passes after a module pass implicitly creates a function pass manager over a contiguous list of function passes.</p></blockquote><p>对于legacy PM来说每次添加的Pass都是一个Pass基类，看不到任何类型之间的关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassManager::add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">  PM-&gt;<span class="built_in">add</span>(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PM-&gt;add</span></span><br><span class="line"><span class="comment">/// \copydoc PassManager::add()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">schedulePass</span>(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在新pm中normal pass都是有着严格的类型限制，PM和Pass级别不同的时候使用各种adaptor显式转换的，而analysis则是通过各种proxy来处理</p><p>这是上期里我们看过的图，这就是整个PM中保存的Pass结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    R(ModulePassManager)</span><br><span class="line">    R--&gt;MP(ModulePass)</span><br><span class="line">    R--&gt;FP(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FP--&gt;FPS(FunctionPass)</span><br><span class="line">    R--&gt;FPTemp(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FPTemp--&gt;LPP(FunctionToLoopPassAdator)</span><br><span class="line">    LPP--&gt;LPPS(LoopPass)</span><br></pre></td></tr></table></figure><h2 id="避免过多的全局变量"><a href="#避免过多的全局变量" class="headerlink" title="避免过多的全局变量"></a>避免过多的全局变量</h2><blockquote><p>The legacy pass manager relies on many global flags and registries. This is supported by macros generating functions and variables to initialize passes, and any users of the legacy pass manager must make sure to call a function to initialize these passes. But we need some way for a pass manager builder to be aware of all passes for testing purposes.</p></blockquote><p>在旧的Pass架构中存在过多的全局变量与registries，每个Pass都需要通过宏来注册，进而产生全局变量以及initialize函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">initializeFlattenCFGLegacyPassPassOnce</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">initializeAAResultsWrapperPassPass</span>(Registry);</span><br><span class="line">  PassInfo *PI =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassInfo</span>(<span class="string">&quot;Flatten the CFG&quot;</span>, <span class="string">&quot;flattencfg&quot;</span>, &amp;FlattenCFGLegacyPass::ID,</span><br><span class="line">                   PassInfo::<span class="built_in">NormalCtor_t</span>(callDefaultCtor&lt;FlattenCFGLegacyPass&gt;),</span><br><span class="line">                   <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  Registry.<span class="built_in">registerPass</span>(*PI, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> llvm::once_flag InitializeFlattenCFGLegacyPassPassFlag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llvm::initializeFlattenCFGLegacyPassPass</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  llvm::<span class="built_in">call_once</span>(InitializeFlattenCFGLegacyPassPassFlag,</span><br><span class="line">                  initializeFlattenCFGLegacyPassPassOnce, std::<span class="built_in">ref</span>(Registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的架构中通过传递PassManager以及使用PassBuilder统一来注册Pass到PM中来解决这个问题（实际LLVMRunPasses的情况）</p><h2 id="out-of-tree-passes"><a href="#out-of-tree-passes" class="headerlink" title="out of tree passes"></a>out of tree passes</h2><p>我对legacy的注册out of tree passes的情况不太了解，看官方的example中是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legacy PM Registration */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">RegisterBye</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    llvm::PassManagerBuilder::EP_VectorizerStart,</span></span></span><br><span class="line"><span class="params"><span class="function">    [](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="params"><span class="function">       llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> LegacyBye()); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">RegisterByeLTO</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    llvm::PassManagerBuilder::EP_ModuleOptimizerEarly,</span></span></span><br><span class="line"><span class="params"><span class="function">    [](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="params"><span class="function">       llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> LegacyBye()); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>新 PM的注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* New PM Registration */</span></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getByePluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Bye&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerVectorizerStartEPCallback</span>(</span><br><span class="line">                [](llvm::FunctionPassManager &amp;PM, OptimizationLevel Level) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, llvm::FunctionPassManager &amp;PM,</span><br><span class="line">                   ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;goodbye&quot;</span>) &#123;</span><br><span class="line">                    PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_BYE_LINK_INTO_TOOLS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getByePluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个简单的例子看起来写的更麻烦的了，复杂的情况使用callback的形式或许会更方便实现。比起写法上来说，更大的差异是不再需要一大堆global成员了，以及legacy中还要对LTO以及非LTO做处理，但是对于新PM来说LTO也是依靠的PassBuilder来注册Pass，也就是说不需要再对两处进行注册。</p><p>新PM的注册是通过在PassBuiler中注册callback形式实现的。在文章中提到了这样一句</p><blockquote><p>Although there is a global list of functions, there is no mutable global state since each pass manager builder can parse pass pipelines without going through a global registry.</p></blockquote><h2 id="parallelize"><a href="#parallelize" class="headerlink" title="parallelize"></a>parallelize</h2><p>这篇文章的后面提到了并行相关的问题。对于SCC的Pass来说是比较容易并行的，但是对于其他的就不一样了。比如说这里</p><blockquote><p>Some passes only use analyses if they are cached, so parallelization can <strong>cause non-determinism since a module analysis may or may not exist based on other parallel pipelines</strong>.The new PM <strong>only allows function passes to access cached module analyses and does not allow running them</strong>. This has the downside of needing to make sure that certain higher-level analyses are present before running a lower-level pipeline, e.g. making sure GlobalsAA has been computed before running a function pipeline.</p></blockquote><p>一个Module的analysis可能基于其他并行的pipeline，所以会导致不确定性。因此新的PM只允许获取cached的module analyses。比如说上期提到的ModuleAnalysisManagerFunctionProxy并非直接getResult获取结果，而是直接getCachedResult。我觉得这里说的可能更类似于多线程读一个只读变量的情况，但是我不知道自己的理解是否存在问题，如有不对还请指正</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getModuleAAResultImpl</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AAResults &amp;AAResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;MAMProxy = AM.getResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *R =</span><br><span class="line">          MAMProxy.<span class="keyword">template</span> getCachedResult&lt;AnalysisT&gt;(*F.<span class="built_in">getParent</span>())) &#123;</span><br><span class="line">    AAResults.<span class="built_in">addAAResult</span>(*R);</span><br><span class="line">    MAMProxy</span><br><span class="line">        .<span class="keyword">template</span> registerOuterAnalysisInvalidation&lt;AnalysisT, AAManager&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>注：以下内容的实效性不强</p><h2 id="部分迁移"><a href="#部分迁移" class="headerlink" title="部分迁移"></a>部分迁移</h2><blockquote><p>Currently the new PM applies only to the middle-end optimization pipeline working with LLVM IR. The backend codegen pipeline still works only with the legacy PM, mostly because most codegen passes don’t work on LLVM IR, but rather machine IR (MIR), and nobody has yet put in the time to create the new PM infrastructure for MIR passes and to migrate all of the backends to use the new PM. Migrating to the new PM for the codegen pipeline likely won’t unlock performance gains since there are almost no interprocedural codegen passes. However, it would clean up a lot of technical debt.</p></blockquote><p>根据这段所讲，目前codegen的部分还没有完成迁移，只做了少部分的处理。但是许多Pass依然是旧的形式，现在的代码中也能看到许多为了兼容legacy Pass的形式</p><p>在旧的架构中codegen是通过加到legacy PM中的</p><p>以下代码来自llvm的教程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TheTargetMachine-&gt;<span class="built_in">addPassesToEmitFile</span>(pass, dest, <span class="literal">nullptr</span>, FileType)) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;TheTargetMachine can&#x27;t emit a file of this type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pass.<span class="built_in">run</span>(*TheModule);</span><br></pre></td></tr></table></figure><p>LLVM目前的CodeGen这里的PassBuilder基本成形（新架构注册Pass相关的转换为了PassBuilder的形式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line">Error CodeGenPassBuilder&lt;Derived&gt;::<span class="built_in">buildPipeline</span>(</span><br><span class="line">    ModulePassManager &amp;MPM, MachineFunctionPassManager &amp;MFPM,</span><br><span class="line">    raw_pwrite_stream &amp;Out, raw_pwrite_stream *DwoOut,</span><br><span class="line">    CodeGenFileType FileType) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="function">AddIRPass <span class="title">addIRPass</span><span class="params">(MPM, Opt.DebugPM)</span></span>;</span><br><span class="line">  <span class="built_in">addISelPasses</span>(addIRPass);</span><br><span class="line"></span><br><span class="line">  <span class="function">AddMachinePass <span class="title">addPass</span><span class="params">(MFPM)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">addCoreISelPasses</span>(addPass))</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">derived</span>().<span class="built_in">addMachinePasses</span>(addPass))</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Err);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addAsmPrinter</span>(</span><br><span class="line">      addPass, [<span class="keyword">this</span>, &amp;Out, DwoOut, FileType](MCContext &amp;Ctx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;TM.<span class="built_in">createMCStreamer</span>(Out, DwoOut, FileType, Ctx);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addPass</span>(<span class="built_in">FreeMachineFunctionPass</span>());</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些addPass的变量我觉得是一种为了兼容临时过渡的形式，在使用的时候是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">void</span> CodeGenPassBuilder&lt;Derived&gt;::<span class="built_in">addISelPasses</span>(AddIRPass &amp;addPass) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (TM.<span class="built_in">useEmulatedTLS</span>())</span><br><span class="line">    <span class="built_in">addPass</span>(<span class="built_in">LowerEmuTLSPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addPass</span>(<span class="built_in">PreISelIntrinsicLoweringPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addIRPasses</span>(addPass);</span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addCodeGenPrepare</span>(addPass);</span><br><span class="line">  <span class="built_in">addPassesToHandleExceptions</span>(addPass);</span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addISelPrepare</span>(addPass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h2><p>在LLVM14的Release Notes中看到</p><blockquote><p>Using the legacy pass manager for the optimization pipeline is deprecated and will be removed after LLVM 14. In the meantime, only minimal effort will be made to maintain the legacy pass manager for the optimization pipeline.</p></blockquote><p>看起来的意思是LLVM15都要移植完并且删除，LLVM15的文档还在施工初期，其中也并没有什么有价值的信息，codegen这部分不知道会不会也要全部移植完</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>除了核心功能之外，还有一些Test目前依然是使用Legacy PM的形式</p><p>比如说TimePassesTest中这段测试的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clear and generate report again.</span></span><br><span class="line">TimePassesStr.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">reportAndResetTimings</span>(&amp;ReportStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since we did not run any passes since last print, report should be empty.</span></span><br><span class="line"><span class="built_in">EXPECT_TRUE</span>(TimePassesStr.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now run just a single pass to populate timers again.</span></span><br><span class="line">legacy::PassManager PM2;</span><br><span class="line">PM2.<span class="built_in">add</span>(<span class="keyword">new</span> llvm::<span class="built_in">Pass2</span>());</span><br><span class="line">PM2.<span class="built_in">run</span>(M);</span><br></pre></td></tr></table></figure><h1 id="本系列结束"><a href="#本系列结束" class="headerlink" title="本系列结束"></a>本系列结束</h1><p>正如本文开始的召唤台词“这样闹剧也就结束了”所说，这个系列到此也就结束了，在这里扯点感想啥的吧。结束的比预想的要早，一开始列出的大纲有一些不是很大的组件都被合并进了各期中。一共五期，也就意味着过去了28天，真的是不知不觉就过去了…</p><p>内容上我不可能讲的面面俱到，但是我想如果你读完了这个系列的话会对整个新PM的结构，各个组件之间的关系有了一个了解。如果你还存有什么疑惑或者想法欢迎和我进行交流。</p><p>后续一定会开新的系列，欢迎持续关注我的博客/推特。之后的方向不出意外应该就是Pass里的具体实现，可能会从某一个DefaultPipeline为线索开始。更新频率不敢保证，就我这段时间学习的过程来说，Pass内部实现的代码非常长，加上相关联的知识点也非常多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-4/Un</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其三：PassBuilder</title>
    <link href="https://fusionbolt.github.io/2022/07/10/llvm-pass/llvm-pass-3/"/>
    <id>https://fusionbolt.github.io/2022/07/10/llvm-pass/llvm-pass-3/</id>
    <published>2022-07-10T11:45:23.000Z</published>
    <updated>2022-07-17T08:54:55.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLVM-Pass-其三：PassBuilder"><a href="#LLVM-Pass-其三：PassBuilder" class="headerlink" title="LLVM Pass 其三：PassBuilder"></a>LLVM Pass 其三：PassBuilder</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">出来吧，罪青眼白龙！（为什么这张卡台词这么简单</center> <p>在前面几期中我们讲了新Pass，PassManager，Analysis是怎么样的，这期我们来讲一下PassBuilder以及实际许多Pass是如何组织起来的。</p><p>PassBuilder相关的源文件有这几个</p><p>include/llvm/Passes/PassBuilder.h</p><p>lib/Passes/PassBuilder.cpp</p><p>lib/Passes/PassBuilderPipelines.cpp</p><h1 id="PassBuilder结构"><a href="#PassBuilder结构" class="headerlink" title="PassBuilder结构"></a>PassBuilder结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class provides access to building LLVM&#x27;s passes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Its members provide the baseline state available to passes during their</span></span><br><span class="line"><span class="comment">/// construction. The \c PassRegistry.def file specifies how to construct all</span></span><br><span class="line"><span class="comment">/// of the built-in passes, and those may reference these members during</span></span><br><span class="line"><span class="comment">/// construction.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassBuilder</span> &#123;</span></span><br><span class="line">  TargetMachine *TM;</span><br><span class="line">  PipelineTuningOptions PTO;</span><br><span class="line">  Optional&lt;PGOOptions&gt; PGOOpt;</span><br><span class="line">  PassInstrumentationCallbacks *PIC;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个TargetMachine</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%201.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%202.png"                      alt="Untitled"                ></p><p>可以看到由这么几类成员构成</p><ol><li>存放基本信息的成员，包括TargetMachine以及各种保存的callback等</li><li>registerXXXAnalysis / registerXXXCallback</li><li>buildXXXpipeline</li><li>parseXXXPass / parseXXXPasePipeline</li></ol><h1 id="PassBuilder的使用"><a href="#PassBuilder的使用" class="headerlink" title="PassBuilder的使用"></a>PassBuilder的使用</h1><p>我们从PassBuilder的使用开始理顺里面的流程。PassBuilder有两处主要的使用位置，一处是在lto中调用，另一处是这次主要讲解的LLVMRunPasses</p><p>这个函数对应的头文件是include/llvm-c/Transforms/PassBuilder.h</p><p>而LLVMRunPasses的实现在lib/Passes/PassBuilderBindings.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LLVMErrorRef <span class="title">LLVMRunPasses</span><span class="params">(LLVMModuleRef M, <span class="keyword">const</span> <span class="keyword">char</span> *Passes,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMTargetMachineRef TM,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMPassBuilderOptionsRef Options)</span> </span>&#123;</span><br><span class="line">  TargetMachine *Machine = <span class="built_in">unwrap</span>(TM);</span><br><span class="line">  LLVMPassBuilderOptions *PassOpts = <span class="built_in">unwrap</span>(Options);</span><br><span class="line">  <span class="keyword">bool</span> Debug = PassOpts-&gt;DebugLogging;</span><br><span class="line">  <span class="keyword">bool</span> VerifyEach = PassOpts-&gt;VerifyEach;</span><br><span class="line"></span><br><span class="line">  Module *Mod = <span class="built_in">unwrap</span>(M);</span><br><span class="line">  PassInstrumentationCallbacks PIC;</span><br><span class="line">  <span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line">  LoopAnalysisManager LAM;</span><br><span class="line">  FunctionAnalysisManager FAM;</span><br><span class="line">  CGSCCAnalysisManager CGAM;</span><br><span class="line">  ModuleAnalysisManager MAM;</span><br><span class="line">  PB.<span class="built_in">registerLoopAnalyses</span>(LAM);</span><br><span class="line">  PB.<span class="built_in">registerFunctionAnalyses</span>(FAM);</span><br><span class="line">  PB.<span class="built_in">registerCGSCCAnalyses</span>(CGAM);</span><br><span class="line">  PB.<span class="built_in">registerModuleAnalyses</span>(MAM);</span><br><span class="line">  PB.<span class="built_in">crossRegisterProxies</span>(LAM, FAM, CGAM, MAM);</span><br><span class="line"></span><br><span class="line">  <span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">  SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach) &#123;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">VerifierPass</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">run</span>(*Mod, MAM);</span><br><span class="line">  <span class="keyword">return</span> LLVMErrorSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑非常清晰</p><ol><li>先对每一种Analysis注册，之后注册Proxies</li><li>注册callback</li><li>parsePassPieline开始添加Pass到MPM中</li></ol><p>接下来我们对这三部分操作逐一讲解</p><h1 id="注册Analyses"><a href="#注册Analyses" class="headerlink" title="注册Analyses"></a>注册Analyses</h1><p>首先我们回顾一下之前讲过的Pass注册方式。LLVM内部的Pass注册需要在PassRegistry.def中以宏的方式写下，之后在include这个文件的前面定义这些宏，之后再include这个文件完成整个流程</p><h2 id="registerXXXAnalyses"><a href="#registerXXXAnalyses" class="headerlink" title="registerXXXAnalyses"></a>registerXXXAnalyses</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::registerModuleAnalyses</span><span class="params">(ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  MAM.registerPass([&amp;] &#123; return CREATE_PASS; &#125;);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModuleAnalysisRegistrationCallbacks)</span><br><span class="line">    <span class="built_in">C</span>(MAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单的注册一遍Analysis之后执行一下ModuleAnalysisRegistrationCallbacks</p><p>除了Module，Function，Loop之类的实现基本上一致，这里不再重复贴代码了</p><h2 id="crossRegisterProxies"><a href="#crossRegisterProxies" class="headerlink" title="crossRegisterProxies"></a>crossRegisterProxies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::crossRegisterProxies</span><span class="params">(LoopAnalysisManager &amp;LAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       FunctionAnalysisManager &amp;FAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       CGSCCAnalysisManager &amp;CGAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerModuleProxy</span>(FAM); &#125;);</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerModuleProxy</span>(CGAM); &#125;);</span><br><span class="line">  CGAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerCGSCCProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerFunctionProxy</span>(CGAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerFunctionProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">LoopAnalysisManagerFunctionProxy</span>(LAM); &#125;);</span><br><span class="line">  LAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerLoopProxy</span>(FAM); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是给各种的AnalysisManager注册了一个XXXXAnalysisManagerXXXProxy，而这些类型本质上是一个给proxy指定了部分模板参数的别名。比如说FunctionAnalysisManagerModuleProxy这个类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FunctionAnalysisManagerModuleProxy =</span><br><span class="line">    InnerAnalysisManagerProxy&lt;FunctionAnalysisManager, Module&gt;;</span><br></pre></td></tr></table></figure><p>和普通Pass使用adaptor不同的是一个Function的Manager注册了到Module的Proxy，而Module也注册了一个到Function的Proxy。注意这里的是Outer，而不再是Inner了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure><h2 id="InnerAnalysisManagerProxy"><a href="#InnerAnalysisManagerProxy" class="headerlink" title="InnerAnalysisManagerProxy"></a>InnerAnalysisManagerProxy</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%203.png"                      alt="Untitled"                ></p><p>对于Proxy来说功能也是类似于adaptor，用于在不同范围的IRUnit之间转换处理。Inner和adaptor一样，将一个小范围的pass的应用在大的范围上（Function的analysis应用到整个Module上）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAnalysisManagerProxy</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;</span><br><span class="line">          InnerAnalysisManagerProxy&lt;AnalysisManagerT, IRUnitT&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面addPass的行为以及类型声明可以看到Proxy也是一个Analysis，对于一个Analysis最主要的就是run以及Result里的行为了。</p><p>这里run的逻辑就是将InnerAM塞到InnerAnalysisManagerProxy::Result中返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">           ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Result</span>(*InnerAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(AnalysisManagerT &amp;InnerAM)</span> : InnerAM(&amp;InnerAM) &#123;</span>&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="function">AnalysisManagerT &amp;<span class="title">getManager</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *InnerAM; &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AnalysisManagerT *InnerAM;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的Result并不是一个具体的什么值，而是一个AnalysisManagerT的包装，这样做避免了每个AnalysisManager中塞入不必要的invalidate。</p><p>在实际使用的时候都是要先获取proxy的result再从中getManager，最后从AnalysisManager中获取某个具体的Analysis</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LazyCallGraph <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">    FunctionAnalysisManager &amp;FAM =</span><br><span class="line">        AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">    <span class="keyword">auto</span> GetTLI = [&amp;FAM](Function &amp;F) -&gt; TargetLibraryInfo &amp; &#123;</span><br><span class="line">      <span class="keyword">return</span> FAM.getResult&lt;TargetLibraryAnalysis&gt;(F);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LazyCallGraph</span>(M, GetTLI);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>对于一个Result来说invalidate的行为是最关键的。Result类内部本身并没有定义invalidate的行为，但是通过各种偏特化的形式定义不同IRUnit类型对应的invalidate方式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%204.png"                      alt="Untitled"                ></p><p>复杂的invalidate逻辑（已删去所有注释），这不是本期重点因此不赘述，整体逻辑应当和上一期的invalidate一致，如果要理顺这些可以看上一期作为参考</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> FunctionAnalysisManagerModuleProxy::Result::<span class="built_in">invalidate</span>(</span><br><span class="line">    Module &amp;M, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span><br><span class="line">    ModuleAnalysisManager::Invalidator &amp;Inv) &#123;</span><br><span class="line">  <span class="keyword">if</span> (PA.<span class="built_in">areAllPreserved</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// This is still a valid proxy.</span></span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.getChecker&lt;FunctionAnalysisManagerModuleProxy&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!PAC.<span class="built_in">preserved</span>() &amp;&amp; !PAC.preservedSet&lt;AllAnalysesOn&lt;Module&gt;&gt;()) &#123;</span><br><span class="line">    InnerAM-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> AreFunctionAnalysesPreserved =</span><br><span class="line">      PA.allAnalysesInSetPreserved&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    Optional&lt;PreservedAnalyses&gt; FunctionPA;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *OuterProxy =</span><br><span class="line">            InnerAM-&gt;getCachedResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F))</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;OuterInvalidationPair :</span><br><span class="line">           OuterProxy-&gt;<span class="built_in">getOuterInvalidations</span>()) &#123;</span><br><span class="line">        AnalysisKey *OuterAnalysisID = OuterInvalidationPair.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;InnerAnalysisIDs = OuterInvalidationPair.second;</span><br><span class="line">        <span class="keyword">if</span> (Inv.<span class="built_in">invalidate</span>(OuterAnalysisID, M, PA)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!FunctionPA)</span><br><span class="line">            FunctionPA = PA;</span><br><span class="line">          <span class="keyword">for</span> (AnalysisKey *InnerAnalysisID : InnerAnalysisIDs)</span><br><span class="line">            FunctionPA-&gt;<span class="built_in">abandon</span>(InnerAnalysisID);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (FunctionPA) &#123;</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, *FunctionPA);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AreFunctionAnalysesPreserved)</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, PA);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OuterAnalysisManagerProxy"><a href="#OuterAnalysisManagerProxy" class="headerlink" title="OuterAnalysisManagerProxy"></a>OuterAnalysisManagerProxy</h2><p>这个与上面提到的InnerAnalysisManagerProxy相反。将一个大范围的Analysis应用到一个小范围的IRUnit上。比如说这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure><p>除了Result之外的逻辑和InnerAnalysisManagerProxy基本上一致，但是Proxy保存的则是一个const AnalysisManagerT<em>，也就是说是一个只读的包装。Inner的Result是用来存放一个AnalysisManager，而Outer的Result则和外层的Manager一样保存的是一个const AnalysisManagerT</em>，也就是说是一个只读的包装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span> : OuterAM(&amp;OuterAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Get a cached analysis. If the analysis can be invalidated, this will</span></span><br><span class="line">    <span class="comment">/// assert.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> PassT::Result *<span class="title">getCachedResult</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">if</span> (Res)</span><br><span class="line">        OuterAM-&gt;<span class="keyword">template</span> verifyNotInvalidated&lt;PassT&gt;(IR, Res);</span><br><span class="line">      <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Method provided for unit testing, not intended for general use.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cachedResultExists</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">return</span> Res != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// When invalidation occurs, remove any registered invalidation events.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IRUnitT &amp;IRUnit, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Loop over the set of registered outer invalidation mappings and if any</span></span><br><span class="line">      <span class="comment">// of them map to an analysis that is now invalid, clear it out.</span></span><br><span class="line">      SmallVector&lt;AnalysisKey *, <span class="number">4</span>&gt; DeadKeys;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;KeyValuePair : OuterAnalysisInvalidationMap) &#123;</span><br><span class="line">        AnalysisKey *OuterID = KeyValuePair.first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;InnerIDs = KeyValuePair.second;</span><br><span class="line">        llvm::<span class="built_in">erase_if</span>(InnerIDs, [&amp;](AnalysisKey *InnerID) &#123;</span><br><span class="line">          <span class="keyword">return</span> Inv.<span class="built_in">invalidate</span>(InnerID, IRUnit, PA);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (InnerIDs.<span class="built_in">empty</span>())</span><br><span class="line">          DeadKeys.<span class="built_in">push_back</span>(OuterID);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> OuterID : DeadKeys)</span><br><span class="line">        OuterAnalysisInvalidationMap.<span class="built_in">erase</span>(OuterID);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The proxy itself remains valid regardless of anything else.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register a deferred invalidation event for when the outer analysis</span></span><br><span class="line">    <span class="comment">/// manager processes its invalidations.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OuterAnalysisT, <span class="keyword">typename</span> InvalidatedAnalysisT&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerOuterAnalysisInvalidation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AnalysisKey *OuterID = OuterAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line">      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> &amp;InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];</span><br><span class="line">      <span class="comment">// Note, this is a linear scan. If we end up with large numbers of</span></span><br><span class="line">      <span class="comment">// analyses that all trigger invalidation on the same outer analysis,</span></span><br><span class="line">      <span class="comment">// this entire system should be changed to some other deterministic</span></span><br><span class="line">      <span class="comment">// data structure such as a `SetVector` of a pair of pointers.</span></span><br><span class="line">      <span class="keyword">if</span> (!llvm::<span class="built_in">is_contained</span>(InvalidatedIDList, InvalidatedID))</span><br><span class="line">        InvalidatedIDList.<span class="built_in">push_back</span>(InvalidatedID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Access the map from outer analyses to deferred invalidation requiring</span></span><br><span class="line">    <span class="comment">/// analyses.</span></span><br><span class="line">    <span class="keyword">const</span> SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt; &amp;</span><br><span class="line">    <span class="built_in">getOuterInvalidations</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> OuterAnalysisInvalidationMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> AnalysisManagerT *OuterAM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A map from an outer analysis ID to the set of this IR-unit&#x27;s analyses</span></span><br><span class="line">    <span class="comment">/// which need to be invalidated.</span></span><br><span class="line">    SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt;</span><br><span class="line">        OuterAnalysisInvalidationMap;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OuterAnalysisManagerProxy</span>(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span><br><span class="line">      : <span class="built_in">OuterAM</span>(&amp;OuterAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Run the analysis pass and create our proxy result object.</span></span><br><span class="line">  <span class="comment">/// Nothing to see here, it just forwards the \c OuterAM reference into the</span></span><br><span class="line">  <span class="comment">/// result.</span></span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">             ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(*OuterAM);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要注意这里的设计是不能修改OuterAM的因此只能获取cached的result，并且有一套自己的analysis Invalidation机制，这里就不展开讲解了。</p><p>我们来实际看一下使用的场合。目前实际有效的getResult的场合只搜到了这一处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getModuleAAResultImpl</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AAResults &amp;AAResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;MAMProxy = AM.getResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *R =</span><br><span class="line">          MAMProxy.<span class="keyword">template</span> getCachedResult&lt;AnalysisT&gt;(*F.<span class="built_in">getParent</span>())) &#123;</span><br><span class="line">    AAResults.<span class="built_in">addAAResult</span>(*R);</span><br><span class="line">    MAMProxy</span><br><span class="line">        .<span class="keyword">template</span> registerOuterAnalysisInvalidation&lt;AnalysisT, AAManager&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我觉得是分析需要在Function内部做，但是全局变量的存在使得Function仍然需要一个全局范围内的别名分析</p><h2 id="AnalysisManager结构"><a href="#AnalysisManager结构" class="headerlink" title="AnalysisManager结构"></a>AnalysisManager结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">FAM(FunctionAnalysisManager)</span><br><span class="line">LAM(LoopAnalysisManager)</span><br><span class="line">CGAM(CGSCCAnalysisManager)</span><br><span class="line">MAM(ModuleAnalysisManager)</span><br><span class="line">FAMP(FunctionAnalysisManagerModuleProxy)</span><br><span class="line">    CGAMP(CGSCCAnalysisManagerModuleProxy)</span><br><span class="line">    CGAFP(CGSCCAnalysisManagerFunctionProxy)</span><br><span class="line">    MCGAP(ModuleAnalysisManagerCGSCCProxy)</span><br><span class="line">MAFP(ModuleAnalysisManagerFunctionProxy)</span><br><span class="line">LAFP(LoopAnalysisManagerFunctionProxy)</span><br><span class="line">FLAP(FunctionAnalysisManagerLoopProxy)</span><br><span class="line">    MAM --&gt;  FAMP --&gt; FAM</span><br><span class="line">MAM --&gt; CGAMP --&gt; CGAM</span><br><span class="line">    CGAM --&gt; MCGAP --&gt; MAM</span><br><span class="line">FAM --&gt; CGAFP --&gt; CGAM</span><br><span class="line">FAM --&gt; MAFP --&gt; MAM</span><br><span class="line">FAM --&gt; LAFP --&gt; LAM</span><br><span class="line">LAM --&gt; FLAP --&gt; FAM</span><br></pre></td></tr></table></figure><p>感觉画出来的图非常奇怪…</p><p>至此Analysis的部分就已经处理结束了</p><h1 id="Callbacks-and-Instrumentation"><a href="#Callbacks-and-Instrumentation" class="headerlink" title="Callbacks and Instrumentation"></a>Callbacks and Instrumentation</h1><p>Analysis之后则是添加各种callback。而这里则是通过StandardInstrumentations来注册callback到PIC（PassInstrumentCallbacks）中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PassInstrumentationCallbacks PIC;</span><br><span class="line"><span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br></pre></td></tr></table></figure><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>include/llvm/IR/PassInstrumentation.h</p><p>先不说StandardInstrumentations，和PassInstrument相关的有这么两个类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%205.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%206.png"                      alt="Untitled"                ></p><p>两个类的关系也非常简单，PassInstrumentation中保存了一个实际持有各种callback的PassInstrumentationCallbacks对象。里面保存的各种callbacks的作用从成员名就能看出，这里不再赘述细节</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>而获取PassInstrumentation则是通过PassInstrumentationAnalysis这个analysis获取的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassInstrumentationAnalysis</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"></span><br><span class="line">  PassInstrumentationCallbacks *Callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// PassInstrumentationCallbacks object is shared, owned by something else,</span></span><br><span class="line">  <span class="comment">/// not this analysis.</span></span><br><span class="line">  <span class="built_in">PassInstrumentationAnalysis</span>(PassInstrumentationCallbacks *Callbacks = <span class="literal">nullptr</span>)</span><br><span class="line">      : <span class="built_in">Callbacks</span>(Callbacks) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> Result = PassInstrumentation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManagerT &amp;, ExtraArgTs &amp;&amp;...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PassInstrumentation</span>(Callbacks);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如说我们之前讲过的PassManager中的代码（删掉了许多无关的代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">    PassInstrumentation PI =</span><br><span class="line">        detail::getAnalysisResult&lt;PassInstrumentationAnalysis&gt;(</span><br><span class="line">            AM, IR, std::tuple&lt;ExtraArgTs...&gt;(ExtraArgs...));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!PI.runBeforePass&lt;IRUnitT&gt;(*P, IR))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">      PreservedAnalyses PassPA;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(P-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">        PassPA = P-&gt;<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Call onto PassInstrumentation&#x27;s AfterPass callbacks immediately after</span></span><br><span class="line">      <span class="comment">// running the pass.</span></span><br><span class="line">      PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="StandardInstrumentations"><a href="#StandardInstrumentations" class="headerlink" title="StandardInstrumentations"></a>StandardInstrumentations</h2><p>StandardInstrumentations里面提供了注册standard pass instrumentations的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardInstrumentations</span> &#123;</span></span><br><span class="line">  PrintIRInstrumentation PrintIR;</span><br><span class="line">  PrintPassInstrumentation PrintPass;</span><br><span class="line">  TimePassesHandler TimePasses;</span><br><span class="line">  OptNoneInstrumentation OptNone;</span><br><span class="line">  OptBisectInstrumentation OptBisect;</span><br><span class="line">  PreservedCFGCheckerInstrumentation PreservedCFGChecker;</span><br><span class="line">  IRChangedPrinter PrintChangedIR;</span><br><span class="line">  PseudoProbeVerifier PseudoProbeVerification;</span><br><span class="line">  InLineChangePrinter PrintChangedDiff;</span><br><span class="line">  DotCfgChangeReporter WebsiteChangeReporter;</span><br><span class="line">  VerifyInstrumentation Verify;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> VerifyEach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StandardInstrumentations</span>(<span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach = <span class="literal">false</span>,</span><br><span class="line">                           PrintPassOptions PrintPassOpts = <span class="built_in">PrintPassOptions</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all the standard instrumentation callbacks. If \p FAM is nullptr</span></span><br><span class="line">  <span class="comment">// then PreservedCFGChecker is not enabled.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FunctionAnalysisManager *FAM = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">TimePassesHandler &amp;<span class="title">getTimePasses</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TimePasses; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提供了一些基本的Instrumentation，通过StandardInstrumentations::registerCallbacks来将这些callback注册到PIC中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StandardInstrumentations::<span class="built_in">StandardInstrumentations</span>(</span><br><span class="line">    <span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach, PrintPassOptions PrintPassOpts)</span><br><span class="line">    : <span class="built_in">PrintPass</span>(DebugLogging, PrintPassOpts), <span class="built_in">OptNone</span>(DebugLogging),</span><br><span class="line">      <span class="built_in">PrintChangedIR</span>(PrintChanged == ChangePrinter::PrintChangedVerbose),</span><br><span class="line">      <span class="built_in">PrintChangedDiff</span>(</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose,</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffQuiet),</span><br><span class="line">      <span class="built_in">WebsiteChangeReporter</span>(PrintChanged ==</span><br><span class="line">                            ChangePrinter::PrintChangedDotCfgVerbose),</span><br><span class="line">      <span class="built_in">Verify</span>(DebugLogging), <span class="built_in">VerifyEach</span>(VerifyEach) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardInstrumentations::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC, FunctionAnalysisManager *FAM)</span> </span>&#123;</span><br><span class="line">  PrintIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintPass.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  TimePasses.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptNone.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptBisect.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (FAM)</span><br><span class="line">    PreservedCFGChecker.<span class="built_in">registerCallbacks</span>(PIC, *FAM);</span><br><span class="line">  PrintChangedIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PseudoProbeVerification.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach)</span><br><span class="line">    Verify.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintChangedDiff.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  WebsiteChangeReporter.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看其中一个的实现（比较长，故省略了一部分，基本上都是在register各种callback</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debug logging for transformation and analysis passes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintPassInstrumentation</span> &#123;</span></span><br><span class="line">  <span class="function">raw_ostream &amp;<span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrintPassInstrumentation</span>(<span class="keyword">bool</span> Enabled, PrintPassOptions Opts)</span><br><span class="line">      : <span class="built_in">Enabled</span>(Enabled), <span class="built_in">Opts</span>(Opts) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span> Enabled;</span><br><span class="line">  PrintPassOptions Opts;</span><br><span class="line">  <span class="keyword">int</span> Indent = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">raw_ostream &amp;<span class="title">PrintPassInstrumentation::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Opts.Indent) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(Indent &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dbgs</span>().<span class="built_in">indent</span>(Indent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dbgs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPassInstrumentation::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Enabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;StringRef&gt; SpecialPasses;</span><br><span class="line">  <span class="keyword">if</span> (!Opts.Verbose) &#123;</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassManager&quot;</span>);</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassAdaptor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (!Opts.SkipAnalyses) &#123;</span><br><span class="line">    PIC.<span class="built_in">registerAnalysisInvalidatedCallback</span>([<span class="keyword">this</span>](StringRef PassID, Any IR) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Invalidating analysis: &quot;</span> &lt;&lt; PassID &lt;&lt; <span class="string">&quot; on &quot;</span> &lt;&lt; <span class="built_in">getIRName</span>(IR)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    PIC.<span class="built_in">registerAnalysesClearedCallback</span>([<span class="keyword">this</span>](StringRef IRName) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Clearing all analysis results for: &quot;</span> &lt;&lt; IRName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的注册了各个阶段的callback</p><h1 id="ParsePipeline"><a href="#ParsePipeline" class="headerlink" title="ParsePipeline"></a>ParsePipeline</h1><p>在Analysis和callbacks都处理好以后开始执行parsePassPipeline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parsePassPipeline"><a href="#parsePassPipeline" class="headerlink" title="parsePassPipeline"></a>parsePassPipeline</h2><p>PassBuilder的成员函数和ParsePipeline相关的有两类，一个是ParseXXXPassPipeline，另一个是ParseXXXPass</p><p>这里我们就先不关心pipeline里面是怎样的形式以及parser的过程了，重点在于通过看这个pipeline了解整个PassManager的构建过程。从parsePassPipeline开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parsePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StringRef PipelineText)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> Pipeline = <span class="built_in">parsePipelineText</span>(PipelineText);</span><br><span class="line">  <span class="keyword">if</span> (!Pipeline || Pipeline-&gt;<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid pipeline &#x27;&#123;0&#125;&#x27;&quot;</span>, PipelineText).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(MPM, *Pipeline))</span><br><span class="line">    <span class="keyword">return</span> Err;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parseModulePassPipeline"><a href="#parseModulePassPipeline" class="headerlink" title="parseModulePassPipeline"></a>parseModulePassPipeline</h2><p>关于parseModulePassPipeline</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ArrayRef&lt;PipelineElement&gt; Pipeline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;Element : Pipeline) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePass</span>(MPM, Element))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePass</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> PipelineElement &amp;E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;Name = E.Name;</span><br><span class="line">  <span class="keyword">auto</span> &amp;InnerPipeline = E.InnerPipeline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First handle complex passes like the pass managers which carry pipelines.</span></span><br><span class="line">  <span class="keyword">if</span> (!InnerPipeline.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">      ModulePassManager NestedMPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">      FunctionPassManager FPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                    Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal passes can&#x27;t have pipelines.</span></span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid use of &#x27;&#123;0&#125;&#x27; pass as module pipeline&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Manually handle aliases for pre-configured pipeline fragments.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startsWithDefaultPipelineAliasPrefix</span>(Name)) &#123;</span><br><span class="line">    SmallVector&lt;StringRef, <span class="number">3</span>&gt; Matches;</span><br><span class="line">    <span class="keyword">if</span> (!DefaultAliasRegex.<span class="built_in">match</span>(Name, &amp;Matches))</span><br><span class="line">      <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">          formatv(<span class="string">&quot;unknown default pipeline alias &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">          <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(Matches.<span class="built_in">size</span>() == <span class="number">3</span> &amp;&amp; <span class="string">&quot;Must capture two matched strings!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    OptimizationLevel L = StringSwitch&lt;OptimizationLevel&gt;(Matches[<span class="number">2</span>])</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O0&quot;</span>, OptimizationLevel::O0)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O1&quot;</span>, OptimizationLevel::O1)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O2&quot;</span>, OptimizationLevel::O2)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O3&quot;</span>, OptimizationLevel::O3)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Os&quot;</span>, OptimizationLevel::Os)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Oz&quot;</span>, OptimizationLevel::Oz);</span><br><span class="line">    <span class="keyword">if</span> (L == OptimizationLevel::O0 &amp;&amp; Matches[<span class="number">1</span>] != <span class="string">&quot;thinlto&quot;</span> &amp;&amp;</span><br><span class="line">        Matches[<span class="number">1</span>] != <span class="string">&quot;lto&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildO0DefaultPipeline</span>(L, Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span> ||</span><br><span class="line">                                                Matches[<span class="number">1</span>] == <span class="string">&quot;lto-pre-link&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is consistent with old pass manager invoked via opt, but</span></span><br><span class="line">    <span class="comment">// inconsistent with clang. Clang doesn&#x27;t enable loop vectorization</span></span><br><span class="line">    <span class="comment">// but does enable slp vectorization at Oz.</span></span><br><span class="line">    PTO.LoopVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line">    PTO.SLPVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildPerModuleDefaultPipeline</span>(L));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally expand the basic registered passes from the .inc file.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">...                                 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">      formatv(<span class="string">&quot;unknown module pass &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">      <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数实在太长了，省略掉了大部分。</p><ol><li>pipeline非空的情况下继续parseXXXPipeline。通过parseModulePipeline调用parseModulePass我们可以猜到每个parseXXPipeline都会调用对应的parseXXParse</li><li>根据优化等级以及一些lto选项添加一些buildXXXDefaultPipeline‘</li><li>展开PassRegistry中的定义</li></ol><p>在详细展开这些之前我们先来讲解一下上面出现的各种createXXAdaptor</p><h2 id="Adaptor"><a href="#Adaptor" class="headerlink" title="Adaptor"></a>Adaptor</h2><p>各种adaptor被用于将IRUnit范围更小的Pass应用到更大的IRUnit上，比如说这里的Function的范围比一个Module要小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionPassT&gt;</span><br><span class="line"><span class="function">ModuleToFunctionPassAdaptor</span></span><br><span class="line"><span class="function"><span class="title">createModuleToFunctionPassAdaptor</span><span class="params">(FunctionPassT &amp;&amp;Pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">bool</span> EagerlyInvalidate = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::PassModel&lt;Function, FunctionPassT, PreservedAnalyses,</span><br><span class="line">                        FunctionAnalysisManager&gt;;</span><br><span class="line">  <span class="comment">// Do not use make_unique, it causes too many template instantiations,</span></span><br><span class="line">  <span class="comment">// causing terrible compile times.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ModuleToFunctionPassAdaptor</span>(</span><br><span class="line">      std::unique_ptr&lt;ModuleToFunctionPassAdaptor::PassConceptT&gt;(</span><br><span class="line">          <span class="keyword">new</span> <span class="built_in">PassModelT</span>(std::forward&lt;FunctionPassT&gt;(Pass))),</span><br><span class="line">      EagerlyInvalidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleToFunctionPassAdaptor</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> PassInfoMixin&lt;ModuleToFunctionPassAdaptor&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;PassConceptT&gt; Pass;</span><br><span class="line">  <span class="keyword">bool</span> EagerlyInvalidate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里和一个常规Pass都差不多，主要是run有比较大的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">ModuleToFunctionPassAdaptor::run</span><span class="params">(Module &amp;M,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  FunctionAnalysisManager &amp;FAM =</span><br><span class="line">      AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">  PassInstrumentation PI = AM.getResult&lt;PassInstrumentationAnalysis&gt;(M);</span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    <span class="keyword">if</span> (F.<span class="built_in">isDeclaration</span>())</span><br><span class="line">      <span class="keyword">continue</span>; <span class="function">execution completely <span class="keyword">if</span> asked <span class="title">to</span> <span class="params">(callback returns</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// false).</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!PI.runBeforePass&lt;Function&gt;(*Pass, F))</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    PreservedAnalyses PassPA;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      TimeTraceScope TimeScope(Pass-&gt;name(), F.getName());</span></span></span><br><span class="line"><span class="params"><span class="function">      PassPA = Pass-&gt;run(F, FAM);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PI.runAfterPass(*Pass, F, PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    FAM.invalidate(F, EagerlyInvalidate ? PreservedAnalyses::none() : PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    PA.intersect(std::move(PassPA));</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserveSet&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserve&lt;FunctionAnalysisManagerModuleProxy&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> PA;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><p>首先是获取AnalysisManager（AM）这里的AM也是通过上面所讲过的Proxy获取的。由于是Function范围的Pass应用到Module的范围上，很自然要遍历大的IR中的所有Function。大体逻辑有点类似于一个PassManager。</p><h2 id="parseModulePass与更小范围的IR的parseXXPassPipeline"><a href="#parseModulePass与更小范围的IR的parseXXPassPipeline" class="headerlink" title="parseModulePass与更小范围的IR的parseXXPassPipeline"></a>parseModulePass与更小范围的IR的parseXXPassPipeline</h2><p>根据上面的内容所说，parsePassPipeline会进入到parseModulePipeline中。而在parseModulePass中有这样的处理代码，也就是说可能会嵌套Module，也可能去处理IRUnit范围更小的相关Pass，并通过adaptor来加入到ModulePassManager中。其他的parseXXXPass也是有类似的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseCGSCCPassPipeline</span>(CGPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">    FunctionPassManager FPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                  Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createRepeatedPass</span>(*Count, std::<span class="built_in">move</span>(NestedMPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="BuildXXPipeline"><a href="#BuildXXPipeline" class="headerlink" title="BuildXXPipeline"></a>BuildXXPipeline</h2><p>相关的逻辑也很简单，就是在这个函数中按照顺序和各种选项添加Pass，返回了一个构建好的ModulePassManager。还记得吗，一个PassManager（PM）添加Pass时可以传另一个PM，此时的行为是直接将传入PM的Pass添加到被添加的PM的Pass列表中。</p><p>我们来看一下buildO0DefaultPipeline就好了，这里面不需要根据pipeline的text判断是否添加Pass，用一个非常不严谨的说法是这里面添加的逻辑和你是否指定了里面的Pass没有关系，不像之前的函数都是要先parse pipeline text之后根据parse得到的结果判断某个Pass是否要被添加</p><p>这部分的实现都在PassBuilderPipelines.cpp中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ModulePassManager <span class="title">PassBuilder::buildO0DefaultPipeline</span><span class="params">(OptimizationLevel Level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">bool</span> LTOPreLink)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Level == OptimizationLevel::O0 &amp;&amp;</span><br><span class="line">         <span class="string">&quot;buildO0DefaultPipeline should only be used with O0&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Build a minimal pipeline based on the semantics required by LLVM,</span></span><br><span class="line">  <span class="comment">// which is just that always inlining occurs. Further, disable generating</span></span><br><span class="line">  <span class="comment">// lifetime intrinsics to avoid enabling further optimizations during</span></span><br><span class="line">  <span class="comment">// code generation.</span></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">AlwaysInlinerPass</span>(</span><br><span class="line">      <span class="comment">/*InsertLifetimeIntrinsics=*/</span><span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PTO.MergeFunctions)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">MergeFunctionsPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EnableMatrix)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(</span><br><span class="line">        <span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">LowerMatrixIntrinsicsPass</span>(<span class="literal">true</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CGSCCOptimizerLateEPCallbacks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : CGSCCOptimizerLateEPCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(CGPM, Level);</span><br><span class="line">    <span class="keyword">if</span> (!CGPM.<span class="built_in">isEmpty</span>())</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ModulePassManager CoroPM;</span><br><span class="line">  CoroPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">CoroEarlyPass</span>()));</span><br><span class="line">  CGSCCPassManager CGPM;</span><br><span class="line">  CGPM.<span class="built_in">addPass</span>(<span class="built_in">CoroSplitPass</span>());</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (LTOPreLink)</span><br><span class="line">    <span class="built_in">addRequiredLTOPreLinkPasses</span>(MPM);</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">AnnotationRemarksPass</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MPM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展开Registry"><a href="#展开Registry" class="headerlink" title="展开Registry"></a>展开Registry</h2><p>展开PassRegistry中的定义，有这么几类</p><h3 id="直接添加ModulePass"><a href="#直接添加ModulePass" class="headerlink" title="直接添加ModulePass"></a>直接添加ModulePass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><p>有的还需要传入参数构造Pass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS_WITH_PARAMS(NAME, CLASS, CREATE_PASS, PARSER, PARAMS)      \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (checkParametrizedPassName(Name, NAME)) &#123;                                 \</span></span><br><span class="line"><span class="meta">    auto Params = parsePassParameters(PARSER, Name, NAME);                     \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (!Params)                                                               \</span></span><br><span class="line"><span class="meta">      return Params.takeError();                                               \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS(Params.get()));                                    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="通过adaptor的形式传入PassManager"><a href="#通过adaptor的形式传入PassManager" class="headerlink" title="通过adaptor的形式传入PassManager"></a>通过adaptor的形式传入PassManager</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS)                                       \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(CREATE_PASS));               \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><p>不仅是一层，甚至会有多层Adaptor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_PASS(NAME, CREATE_PASS)                                           \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(                             \</span></span><br><span class="line"><span class="meta">        createFunctionToLoopPassAdaptor(CREATE_PASS, false, false)));          \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="AnalysisPass"><a href="#AnalysisPass" class="headerlink" title="AnalysisPass"></a>AnalysisPass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == <span class="meta-string">&quot;require&lt;&quot;</span> NAME <span class="meta-string">&quot;&gt;&quot;</span>) &#123;                                           \</span></span><br><span class="line"><span class="meta">    MPM.addPass(                                                               \</span></span><br><span class="line"><span class="meta">        RequireAnalysisPass&lt;                                                   \</span></span><br><span class="line"><span class="meta">            std::remove_reference<span class="meta-string">&lt;decltype(CREATE_PASS)&gt;</span>::type, Module&gt;());    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;                                  </span></span><br><span class="line">                                          \</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;invalidate&lt;&quot;</span> NAME <span class="string">&quot;&gt;&quot;</span>) &#123;                                        \</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(InvalidateAnalysisPass&lt;                                        \</span><br><span class="line">                std::remove_reference&lt;<span class="keyword">decltype</span>(CREATE_PASS)&gt;::type&gt;());        \</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();                                                   \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="PassManager中Pass的结构"><a href="#PassManager中Pass的结构" class="headerlink" title="PassManager中Pass的结构"></a>PassManager中Pass的结构</h2><p>实际还有CGSCC以及Loop之类的Pass，这里就挑出三个有代表性的结构展示关系了</p><p>一个是顶级的ModulePass，一个是一层adaptor，另一个是多层adaptor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    R(ModulePassManager)</span><br><span class="line">    R--&gt;MP(ModulePass)</span><br><span class="line">    R--&gt;FP(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FP--&gt;FPS(FunctionPass)</span><br><span class="line">    R--&gt;FPTemp(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FPTemp--&gt;LPP(FunctionToLoopPassAdator)</span><br><span class="line">    LPP--&gt;LPPS(LoopPass)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="用户自定义添加Pass的方式"><a href="#用户自定义添加Pass的方式" class="headerlink" title="用户自定义添加Pass的方式"></a>用户自定义添加Pass的方式</h1><p>最后介绍一下讲解一下如何添加自己的Pass到LLVM中。在llvm官方的仓库里example目录中有这么一段代码</p><p>examples/Bye/Bye.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* New PM Registration */</span></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getByePluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Bye&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerVectorizerStartEPCallback</span>(</span><br><span class="line">                [](llvm::FunctionPassManager &amp;PM, OptimizationLevel Level) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, llvm::FunctionPassManager &amp;PM,</span><br><span class="line">                   ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;goodbye&quot;</span>) &#123;</span><br><span class="line">                    PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_BYE_LINK_INTO_TOOLS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getByePluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassPluginLibraryInfo</span> &#123;</span></span><br><span class="line">  <span class="comment">/// The API version understood by this plugin, usually \c</span></span><br><span class="line">  <span class="comment">/// LLVM_PLUGIN_API_VERSION</span></span><br><span class="line">  <span class="keyword">uint32_t</span> APIVersion;</span><br><span class="line">  <span class="comment">/// A meaningful name of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginName;</span><br><span class="line">  <span class="comment">/// The version of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginVersion;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The callback for registering plugin passes with a \c PassBuilder</span></span><br><span class="line">  <span class="comment">/// instance</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*RegisterPassBuilderCallbacks)(PassBuilder &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里我们先不考虑PassPlugin相关的具体细节。通过这种插件的方式可以给LLVM添加一些自己实现的Pass，可以看到有一个传入PassBuilder的lambda，之后通过注册各种callback来实现。LLVM也一定有某种机制找到对应的Plugin之后调用其callback</p><p>除此之外上面提及过的PassBuilder的构造函数有这么一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PassBuilder::<span class="built_in">PassBuilder</span>(TargetMachine *TM, PipelineTuningOptions PTO,</span><br><span class="line">                         Optional&lt;PGOOptions&gt; PGOOpt,</span><br><span class="line">                         PassInstrumentationCallbacks *PIC)</span><br><span class="line">    : <span class="built_in">TM</span>(TM), <span class="built_in">PTO</span>(PTO), <span class="built_in">PGOOpt</span>(PGOOpt), <span class="built_in">PIC</span>(PIC) &#123;</span><br><span class="line">  <span class="keyword">if</span> (TM)</span><br><span class="line">    TM-&gt;<span class="built_in">registerPassBuilderCallbacks</span>(*<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如果你是调用LLVM进行生成代码而不是给llvm添加一个自己的Pass的话应该在自己继承的TargetMachine中实现registerPassBuilderCallbacks方法，而在这个方法中也应当是通过传入的PassBuilder添加各种callback的形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLVM-Pass-其三：PassBuilder&quot;&gt;&lt;a href=&quot;#LLVM-Pass-其三：PassBuilder&quot; class=&quot;headerlink&quot; title=&quot;LLVM Pass 其三：PassBuilder&quot;&gt;&lt;/a&gt;LLVM Pass 其三：P</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
    <category term="PassBuilder" scheme="https://fusionbolt.github.io/tags/PassBuilder/"/>
    
  </entry>
  
</feed>
