<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2023-08-06T11:04:39.945Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时间的洪流</title>
    <link href="https://fusionbolt.github.io/2023/08/06/flood-of-time/"/>
    <id>https://fusionbolt.github.io/2023/08/06/flood-of-time/</id>
    <published>2023-08-06T11:03:32.000Z</published>
    <updated>2023-08-06T11:04:39.945Z</updated>
    
    <content type="html"><![CDATA[<p>时间，一个再熟悉不过的词语，但是我们对其又非常陌生。</p><p>做什么事情都需要时间，发呆需要时间，写这些内容需要时间，看这些内容也需要时间，即便什么都不做，也需要时间。关于时间的话题也有很多，比如最常听到的珍惜时间，但我不打算讲这些听的耳朵出茧的大道理。</p><p>时间在我眼里是自我的一部分。时间由自我来掌控，同时通过对待时间的态度和方式显现出了一部分的自我。生活中有几句经常能听到的话：没时间啊，有时间就好了；能不上班就好了，那样就有时间做自己的事情了，这样的话本质都是类似的。但绝大部分情况下只是自我欺骗，或者说是某件事情对自己来说并没有那么重要，你的自我控制了你去做其他事情。</p><p>我之前经常会因为时间过的太快而焦虑，进一步观察其实是觉得自己没做什么正经事情，但我也没什么想做的事情，这样的我在回看过去的时间时焦虑感是不可避免的。或许当我找到属于自己在时间这一无尽的洪流中漂流的方式时，能够不再会为了体会到这种被迫漂流的感觉而感到害怕和无助，因为我知道这种漂流方式是自己主动选择的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间，一个再熟悉不过的词语，但是我们对其又非常陌生。&lt;/p&gt;
&lt;p&gt;做什么事情都需要时间，发呆需要时间，写这些内容需要时间，看这些内容也需要时间，即便什么都不做，也需要时间。关于时间的话题也有很多，比如最常听到的珍惜时间，但我不打算讲这些听的耳朵出茧的大道理。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
  </entry>
  
  <entry>
    <title>mold源码阅读十六 回顾整个流程</title>
    <link href="https://fusionbolt.github.io/2023/08/05/mold-16-summary/"/>
    <id>https://fusionbolt.github.io/2023/08/05/mold-16-summary/</id>
    <published>2023-08-05T10:17:42.000Z</published>
    <updated>2023-08-05T10:31:28.965Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-16-summary/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:80173499</center> <h1 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h1><p>在以往十六期的博客中，我们沿着mold中的main函数一路追寻了下去，直到结束。</p><p>首先我们熟悉了<a class="link"   href="https://homura.live/2023/02/12/mold/mold-0/" >文件结构以及项目目录<i class="fas fa-external-link-alt"></i></a>等，<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#read-file" >查看了如何读取不同类型的文件<i class="fas fa-external-link-alt"></i></a>，其中最关键的是<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#ObjectFile" >obj<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/05/mold/mold-2-read-shared-files/" >dso<i class="fas fa-external-link-alt"></i></a>，lto三种，分析了不同类型的差异及其特有的处理方式。同时在查看如何解析elf的过程中了解elf头，了解了<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#InputFile" >mold对象的构造<i class="fas fa-external-link-alt"></i></a>，以及elf中信息查找段、符号等的方式。</p><p>当我们收集齐输入的文件信息后就要开始对这些文件进行处理。首先做的是<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#dso-uniquely" >dso去重，避免多个同名dso导致的错误<i class="fas fa-external-link-alt"></i></a>。接下来是最重要部分：符号信息解析。符号相关的过程有许多包括<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#%E7%AC%A6%E5%8F%B7%E5%86%B3%E8%AE%AE" >符号决议<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/#compute-import-export" >符号的导入导出<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/" >动态链接的符号的版本确定<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/06/19/mold/mold-9-unresolve-symbol/#claim-unresolved-symbols" >处理未解析的符号<i class="fas fa-external-link-alt"></i></a>等等。之后还对<a class="link"   href="https://homura.live/2023/04/16/mold/mold-4-mergeable-section/" >mergeable的段进行合并<i class="fas fa-external-link-alt"></i></a>。</p><p>处理完符号相关的信息后开始<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#create-output-sections" >创建输出文件<i class="fas fa-external-link-alt"></i></a>，准备将许多input section合成一个output section。此时需要对于常见synthetic<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#add-synthetic-symbols" >符号<i class="fas fa-external-link-alt"></i></a>与段的构造，并且将它们放到输出的文件中。在实际输出文件之前还需要确定文件内部布局，主要对<a class="link"   href="https://homura.live/2023/06/24/mold/mold-10-sort-section/" >段排序<i class="fas fa-external-link-alt"></i></a>，其中包括chunks之间排序，以及output section内部保存的input section的顺序。</p><p>当文件布局确定后我们就可以<a class="link"   href="https://homura.live/2023/07/02/mold/mold-11-rel-and-dynsym/" >创建rel相关的段，将符号写入对应的符号表<i class="fas fa-external-link-alt"></i></a>，计算段内的一些信息，对部分<a class="link"   href="https://homura.live/2023/05/20/mold/mold-7-before-create-output-section/#Create-Synthetic-Sections" >synthetic段构造<i class="fas fa-external-link-alt"></i></a>等等。之后<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#compute-section-headers" >更新section对应的shdr<i class="fas fa-external-link-alt"></i></a>，以及<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/" >更新段的虚拟地址<i class="fas fa-external-link-alt"></i></a>，对<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#fix-synthetic-symbols" >synthetic符号的值进行修正<i class="fas fa-external-link-alt"></i></a>等。通过这些操作来确定下文件载入内存中的布局。</p><p>最后再将这些<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#copy-chunks" >拷贝到输出文件<i class="fas fa-external-link-alt"></i></a>中。在拷贝的同时还做了许多操作，比如说段的重定位，填写ehdr以及其他synthetic段中的信息。</p><p>在整个过程中也有许多检查，比如符号重复定义或者未定义。还有许多优化，例如对<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#gc-sections" >section进行标记来回收无用段<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#set-virtual-addresses-by-order" >安排输出段的位置<i class="fas fa-external-link-alt"></i></a>使得相同读写权限的段尽可能在一个页内，<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#icf-sections" >消除重复的ehframe项<i class="fas fa-external-link-alt"></i></a>，段压缩等等。</p><p>以上就是链接器mold的概况。</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>最初会开始看链接器的实现是因为感到好奇，加上之前每次遇到链接相关的问题第一反应是头大，觉得解决不了。后来看到mold这个链接器，其中的代码量还在我能串一遍理解的范畴，因此开始了读代码的过程。读的时候做着记录，后来想着干脆开一个系列博客，我在读的时候经常容易跳过某些细节，写博客的过程中会强制自己对这些细节进行强制思考。</p><p>经过了十六期的文章后，整个mold的链接过程基本上就全部过了一遍，而我对于链接器工作的整个流程有了更详细的认知。以前对于链接的模糊印象就是简单的相似段合并，符号解析（但是不知道符号解析具体是在做什么），生成可执行文件或者library，但现在我对于这些部分有了更多的了解，并且还知道了链接过程不止有这些，还有包括synthetic的符号和段的处理，虚拟地址计算，重定位操作等等。</p><p>除此之外还看到了许多未曾想到的东西，在看到一些处理过程后，对动态链接以及加载的过程也有了更多的了解，还有一些之前从未想过能如何联系到一起的想法，比如说相同attribute的段放在一起，避免单独成页，减少运行时的内存等。</p><p>虽然学到了很多东西但是还是有很多地方其实是一知半解，阅读源码远不如实际写来困难，虽然能够大致讲出整个链接器的结构是怎样的，但是对链接器来说最重要的还是各种边边角角的细节，或者意想不到的东西都会在写的过程中出现。我现在在造各种轮子玩，想自己做出各种东西并且串联起来，或许会有一天也会需要造自己的linker吧。</p><p>在源码通读的过程可能花了过久的时间，有些低效。但很多东西我一开始确实没意识到，很多问题都没有提出，不过查看了前面的这些过程后，现在开始阅读不仅是了解了有什么，还让我能够提出一些问题。</p><p>在博客内容写作的过程也不太熟练，最近也是为自己博客写作感到焦虑。不论是内容详细程度，以及排版，内容划分做的都不太好。在学习的时候看到maskray聚聚的文章，多少受到了一些启发，意识到自己过于注重于原来的代码怎么写，对于代码背后的原理关注的相对较少，这其实才是要学习的本质内容，又不是学习代码技巧。在后面几期也在有意识的进行改正，之后写其他阅读代码的博客时也会继续试着这样来做。</p><p>排版上试了不同的方案，比如说最早是放一段读一段，后来又尝试一次讲完一个流程然后贴整段代码，之后再对其中需要更加深入的细节加入小标题来做。不过感觉怎么都很别扭，markdown似乎没什么办法分成代码和文字两列，最后还是觉得先讲清楚流程再放代码了。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>如果后续勤快的话还会继续更新一些东西，除了这样通读外，还想针对特定主题进行贯穿一遍，而且还有一些没有详细看细节但是比较重要的东西。（总觉得说出这样的话就会懒得更了…）</p><p>比如说各种synthetic的符号更详细的介绍， 梳理做的各种优化，header的生成，为动态链接做的准备（got，plt等），数据压缩与解压，为重定位所做的各种操作，最终产物的地址计算与关联等等，这些其实都还比较模糊，没有一个确切的印象，需要单独串联起来理解整个过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-16-summar</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十六 回顾整个流程</title>
    <link href="https://fusionbolt.github.io/2023/08/05/mold/mold-16-summary/"/>
    <id>https://fusionbolt.github.io/2023/08/05/mold/mold-16-summary/</id>
    <published>2023-08-05T10:17:42.000Z</published>
    <updated>2023-08-05T10:31:22.234Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-16-summary/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:80173499</center> <h1 id="内容回顾"><a href="#内容回顾" class="headerlink" title="内容回顾"></a>内容回顾</h1><p>在以往十六期的博客中，我们沿着mold中的main函数一路追寻了下去，直到结束。</p><p>首先我们熟悉了<a class="link"   href="https://homura.live/2023/02/12/mold/mold-0/" >文件结构以及项目目录<i class="fas fa-external-link-alt"></i></a>等，<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#read-file" >查看了如何读取不同类型的文件<i class="fas fa-external-link-alt"></i></a>，其中最关键的是<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#ObjectFile" >obj<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/05/mold/mold-2-read-shared-files/" >dso<i class="fas fa-external-link-alt"></i></a>，lto三种，分析了不同类型的差异及其特有的处理方式。同时在查看如何解析elf的过程中了解elf头，了解了<a class="link"   href="https://homura.live/2023/02/26/mold/mold-1-read-input-files/#InputFile" >mold对象的构造<i class="fas fa-external-link-alt"></i></a>，以及elf中信息查找段、符号等的方式。</p><p>当我们收集齐输入的文件信息后就要开始对这些文件进行处理。首先做的是<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#dso-uniquely" >dso去重，避免多个同名dso导致的错误<i class="fas fa-external-link-alt"></i></a>。接下来是最重要部分：符号信息解析。符号相关的过程有许多包括<a class="link"   href="https://homura.live/2023/04/09/mold/mold-3-symbol-resolve/#%E7%AC%A6%E5%8F%B7%E5%86%B3%E8%AE%AE" >符号决议<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/#compute-import-export" >符号的导入导出<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/" >动态链接的符号的版本确定<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/06/19/mold/mold-9-unresolve-symbol/#claim-unresolved-symbols" >处理未解析的符号<i class="fas fa-external-link-alt"></i></a>等等。之后还对<a class="link"   href="https://homura.live/2023/04/16/mold/mold-4-mergeable-section/" >mergeable的段进行合并<i class="fas fa-external-link-alt"></i></a>。</p><p>处理完符号相关的信息后开始<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#create-output-sections" >创建输出文件<i class="fas fa-external-link-alt"></i></a>，准备将许多input section合成一个output section。此时需要对于常见synthetic<a class="link"   href="https://homura.live/2023/06/10/mold/mold-8-create-output-section/#add-synthetic-symbols" >符号<i class="fas fa-external-link-alt"></i></a>与段的构造，并且将它们放到输出的文件中。在实际输出文件之前还需要确定文件内部布局，主要对<a class="link"   href="https://homura.live/2023/06/24/mold/mold-10-sort-section/" >段排序<i class="fas fa-external-link-alt"></i></a>，其中包括chunks之间排序，以及output section内部保存的input section的顺序。</p><p>当文件布局确定后我们就可以<a class="link"   href="https://homura.live/2023/07/02/mold/mold-11-rel-and-dynsym/" >创建rel相关的段，将符号写入对应的符号表<i class="fas fa-external-link-alt"></i></a>，计算段内的一些信息，对部分<a class="link"   href="https://homura.live/2023/05/20/mold/mold-7-before-create-output-section/#Create-Synthetic-Sections" >synthetic段构造<i class="fas fa-external-link-alt"></i></a>等等。之后<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#compute-section-headers" >更新section对应的shdr<i class="fas fa-external-link-alt"></i></a>，以及<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/" >更新段的虚拟地址<i class="fas fa-external-link-alt"></i></a>，对<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#fix-synthetic-symbols" >synthetic符号的值进行修正<i class="fas fa-external-link-alt"></i></a>等。通过这些操作来确定下文件载入内存中的布局。</p><p>最后再将这些<a class="link"   href="https://homura.live/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/#copy-chunks" >拷贝到输出文件<i class="fas fa-external-link-alt"></i></a>中。在拷贝的同时还做了许多操作，比如说段的重定位，填写ehdr以及其他synthetic段中的信息。</p><p>在整个过程中也有许多检查，比如符号重复定义或者未定义。还有许多优化，例如对<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#gc-sections" >section进行标记来回收无用段<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://homura.live/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/#set-virtual-addresses-by-order" >安排输出段的位置<i class="fas fa-external-link-alt"></i></a>使得相同读写权限的段尽可能在一个页内，<a class="link"   href="https://homura.live/2023/05/07/mold/mold-6-section-size-reduce/#icf-sections" >消除重复的ehframe项<i class="fas fa-external-link-alt"></i></a>，段压缩等等。</p><p>以上就是链接器mold的概况。</p><h1 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h1><p>最初会开始看链接器的实现是因为感到好奇，加上之前每次遇到链接相关的问题第一反应是头大，觉得解决不了。后来看到mold这个链接器，其中的代码量还在我能串一遍理解的范畴，因此开始了读代码的过程。读的时候做着记录，后来想着干脆开一个系列博客，我在读的时候经常容易跳过某些细节，写博客的过程中会强制自己对这些细节进行强制思考。</p><p>经过了十六期的文章后，整个mold的链接过程基本上就全部过了一遍，而我对于链接器工作的整个流程有了更详细的认知。以前对于链接的模糊印象就是简单的相似段合并，符号解析（但是不知道符号解析具体是在做什么），生成可执行文件或者library，但现在我对于这些部分有了更多的了解，并且还知道了链接过程不止有这些，还有包括synthetic的符号和段的处理，虚拟地址计算，重定位操作等等。</p><p>除此之外还看到了许多未曾想到的东西，在看到一些处理过程后，对动态链接以及加载的过程也有了更多的了解，还有一些之前从未想过能如何联系到一起的想法，比如说相同attribute的段放在一起，避免单独成页，减少运行时的内存等。</p><p>虽然学到了很多东西但是还是有很多地方其实是一知半解，阅读源码远不如实际写来困难，虽然能够大致讲出整个链接器的结构是怎样的，但是对链接器来说最重要的还是各种边边角角的细节，或者意想不到的东西都会在写的过程中出现。我现在在造各种轮子玩，想自己做出各种东西并且串联起来，或许会有一天也会需要造自己的linker吧。</p><p>在源码通读的过程可能花了过久的时间，有些低效。但很多东西我一开始确实没意识到，很多问题都没有提出，不过查看了前面的这些过程后，现在开始阅读不仅是了解了有什么，还让我能够提出一些问题。</p><p>在博客内容写作的过程也不太熟练，最近也是为自己博客写作感到焦虑。不论是内容详细程度，以及排版，内容划分做的都不太好。在学习的时候看到maskray聚聚的文章，多少受到了一些启发，意识到自己过于注重于原来的代码怎么写，对于代码背后的原理关注的相对较少，这其实才是要学习的本质内容，又不是学习代码技巧。在后面几期也在有意识的进行改正，之后写其他阅读代码的博客时也会继续试着这样来做。</p><p>排版上试了不同的方案，比如说最早是放一段读一段，后来又尝试一次讲完一个流程然后贴整段代码，之后再对其中需要更加深入的细节加入小标题来做。不过感觉怎么都很别扭，markdown似乎没什么办法分成代码和文字两列，最后还是觉得先讲清楚流程再放代码了。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>如果后续勤快的话还会继续更新一些东西，除了这样通读外，还想针对特定主题进行贯穿一遍，而且还有一些没有详细看细节但是比较重要的东西。（总觉得说出这样的话就会懒得更了…）</p><p>比如说各种synthetic的符号更详细的介绍， 梳理做的各种优化，header的生成，为动态链接做的准备（got，plt等），数据压缩与解压，为重定位所做的各种操作，最终产物的地址计算与关联等等，这些其实都还比较模糊，没有一个确切的印象，需要单独串联起来理解整个过程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-16-summar</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>初探黑塞文学</title>
    <link href="https://fusionbolt.github.io/2023/07/30/first-look-at-hesse-literature/"/>
    <id>https://fusionbolt.github.io/2023/07/30/first-look-at-hesse-literature/</id>
    <published>2023-07-30T12:10:13.000Z</published>
    <updated>2023-07-30T12:10:30.583Z</updated>
    
    <content type="html"><![CDATA[<p>黑塞的作品中我最早有所了解的是《在轮下》，从b站up主黄鸭兄的视频中了解了整个故事，当时觉得从内容到立意都挺有意思。后来看到黄鸭兄视频中提到《荒原狼》的内容，其中魔剧院中从人驯服狼到狼驯服人的场景震撼到了我，因此选择了这本书作为自己接触黑塞文学的开始。书中从开始到结尾都远超预期，处处让我惊叹，剧情本身的安排，对主人公心理的描写，以及最后的魔剧院的部分，全部引诱着我沉迷于黑塞的故事世界，使我对黑塞的作品充满了好感。</p><p>后来想要接触到更多黑塞的作品，看到《悉达多》是其代表作，遂开始读了起来，读完后觉得非常有黑塞的风格，同时开始坚定的认为黑塞的作品就是我想要看到的，黑塞的故事所传达的精神内核就是我想要追寻的。之后朋友回给我的一封邮件中提及到《德米安》，他在大学时也看了许多黑塞的作品，我也不由分说的开始阅读了起来。不出意外，这本书同样也让我感到非常满足。</p><p>黑塞的作品中那种强有力的吸引力到底是什么？对我来说或许是从中表现出的对自我的剖析与追求，对人生的探索，在人群中仍然抱有强烈的自我，等等。词汇匮乏的我难以用一个词语概括这一切，只能粗略的认为它们都属于精神的世界，属于人类的内核，我对这些内容产生的更多是感受，看到相似的内容会觉得“这个东西一定也是属于同一类”。</p><p>看到个别书评提到黑塞的一些书籍都是翻译的功劳之类的，但翻译只是片面的文字描述罢了，而且翻译不论怎么做都要忠实于作者的原意，黑塞的作品中所展现出的灵魂是不会被不同的文字形式所覆写。就像我最初开始接触荒原狼一样，并不是因为文笔是如何的，而是黑塞笔下的故事本身向我伸出了无形的手，而我甘愿被其所拉入黑塞的故事世界。</p><p>不同的人对一本书的评价是不同的，除去每个人角度不同外的原因外，作品的喜好也是因人而异的。对我来说黑塞的作品正是我最喜欢的，同时其传达的内容也是我所追求的。有的人比较喜欢那些比较正面、能鼓励人心的故事，曾看到有人说喜欢西西弗的故事，被其勇气所感染，但我却不会被这种故事所打动。我更喜欢探寻人类的灵魂，或者发掘更多隐藏在故事背后的真相，这样的故事更多是在讲述着什么，而不是着重于赞扬与批判，这种判别是不可避免的，但上升到更显眼的层面似乎就开始有点变质了。</p><p>黑塞的作品还有不少未看，希望这些能给我带来更多的满足与惊喜，也希望能够发现其他笔下故事能带给我类似感受的作家，借此更加深入自我的内核，同时去感受这些作家们的精神世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;黑塞的作品中我最早有所了解的是《在轮下》，从b站up主黄鸭兄的视频中了解了整个故事，当时觉得从内容到立意都挺有意思。后来看到黄鸭兄视频中提到《荒原狼》的内容，其中魔剧院中从人驯服狼到狼驯服人的场景震撼到了我，因此选择了这本书作为自己接触黑塞文学的开始。书中从开始到结尾都远超</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="黑塞" scheme="https://fusionbolt.github.io/tags/%E9%BB%91%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>红与黑</title>
    <link href="https://fusionbolt.github.io/2023/07/30/Reading/the-red-and-black/"/>
    <id>https://fusionbolt.github.io/2023/07/30/Reading/the-red-and-black/</id>
    <published>2023-07-30T06:12:37.000Z</published>
    <updated>2023-07-30T06:13:47.424Z</updated>
    
    <content type="html"><![CDATA[<p>一个穷苦人家的孩子，凭借着自己过人的本领从一个木匠的儿子开始不断向上爬，获取名誉与金钱，但是黑暗一直伴随着他。他在穷苦环境中产生的黑，无论再多名誉与金钱的红都无法掩盖，这是我眼中的红与黑。于连从一个木匠儿子，到市长家的老师，到学院的尖子生，再到侯爵的助手，一路几乎是顺风顺水。一切离不开他的才智，但也和他的性格息息相关，虽然他会自负，虚伪，但他的性格除了穷苦环境中产生的那些黑，但还有正面的红色：忍耐，理智，坚毅。不论好坏全都推动了他顺利前进，但也推动了他走向悲剧。</p><p>在故事结束后作者写下了“献给幸运的少数人”，在我看来是很有吸引力的留言，我想这一定与作者所在的时代背景有关，身处漩涡中的人难以看清漩涡的全貌，那个时代能接触到思想教育的人绝大多数也是受限的，身陷其中的，这样的时代或许很难有作者的知音。</p><p>再来说说这是一个怎样的时代，我对于当时的历史并不了解，但作者的故事中已经完全被那个时代的颜色所填满，其中最显眼混杂在其中的则是出身、权利与地位、金钱这几种妖艳的色彩，之所以妖艳，是因为带来的不仅只有所谓的美好。于连作为一个对此鄙夷的角色，在他攀爬的过程成为了见证者，但他虽然融入上流社会却并没有染上上流社会的恶习，他虽然在获得更高的权利和地位但他所求的事情似乎并不和那些上流社会的人相同。但是纵使他再怎么对此厌恶，他作为个人再怎么厉害，他仍然是一个无力推翻时代洪流的弱小者，他仍然无法抹消出身的卑微。</p><p>对于于连来讲，除了他那隐藏在内心中的黑暗性格外，一直围绕着他的就是他的出身，不只是周围的看法，乃至他自己都一直困在这片思维洼地中。不过这是时代的悲剧，出身至上的时代注定了如此。而他的这个思维也是让他走向悲剧的根源，他对于拉穆尔小姐不断出现的想法还是“他这样出身的人征服了她”。</p><p>可想而知，这样的时代与于连这样的主角搭配，注定了悲剧的发生。但有些意外的是“我们的英雄”最后以这样的形式迎来悲剧的判决。也许此时他已经不再是那个他了，也许他的本性正如此，他选择了枪击报复他其实还爱着的瑞那夫人。更曲折的是拉穆尔小姐明明已经通过权利使得有避免死刑的希望，最后却还是被已经上任、手握权利且曾为瑞那夫人争风吃醋的瓦勒诺确定了死刑，最后还是被他所讨厌的事物所压倒了。</p><p>于连一切变化的开始似乎源于对于瑞那夫人的爱，虽然这份爱源于扭曲的征服欲，但他的人生最终又因为瑞那夫人崩塌，不论是给拉穆尔侯爵的信，还是因为瓦勒诺曾经是情敌，只是他并没有怨恨，反而最后发觉了自己对瑞那夫人的心意。此外与拉穆尔小姐的偷情，也是他最终结局的原因之一，但这些全部起始于他强烈的自尊，以及他无法摆脱自己底层出身这一泥沼，这两段感情的起点都是他认为自己这样的人征服了这么高贵的人。</p><p>现在的时代尽管完全不同，但人们的追求依然没有改变：金钱、地位、阶级等，而人们贪婪，黑暗的本性从未消失，于连一样的人一定存在。如果作者生活在现在的时代，或许也会写出相似内核的故事，从底向上，最后坠落。最后也许是因为犯法，也许是被出卖，我贫瘠的想象力很难想到有什么寓意深刻的结局，这些人们会如何在高空中的钢丝绳上坠落呢，但不论如何一定是会掉下来的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个穷苦人家的孩子，凭借着自己过人的本领从一个木匠的儿子开始不断向上爬，获取名誉与金钱，但是黑暗一直伴随着他。他在穷苦环境中产生的黑，无论再多名誉与金钱的红都无法掩盖，这是我眼中的红与黑。于连从一个木匠儿子，到市长家的老师，到学院的尖子生，再到侯爵的助手，一路几乎是顺风顺水</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="司汤达" scheme="https://fusionbolt.github.io/tags/%E5%8F%B8%E6%B1%A4%E8%BE%BE/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十五 最后的收尾工作</title>
    <link href="https://fusionbolt.github.io/2023/07/29/mold/mold-15-end/"/>
    <id>https://fusionbolt.github.io/2023/07/29/mold/mold-15-end/</id>
    <published>2023-07-29T12:11:48.000Z</published>
    <updated>2023-07-29T12:14:51.438Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-15-end/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:92983280</center> <p>这一期没什么比较硬的重点知识，仅做为补全整个过程来补充，可以轻松愉快的食用。</p><h1 id="write-dependency"><a href="#write-dependency" class="headerlink" title="write dependency"></a>write dependency</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --dependency-file</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.dependency_file.<span class="built_in">empty</span>())</span><br><span class="line">  <span class="built_in">write_dependency_file</span>(ctx);</span><br></pre></td></tr></table></figure><p>将所有依赖，也就是链接过程中所有读取的文件，并且写入到文件中。可以用于确认某个文件是否被加入到链接过程中。</p><blockquote><p>–dependency-file=FILE      Write Makefile-style dependency rules to FILE</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write Makefile-style dependency rules to a file specified by</span></span><br><span class="line"><span class="comment">// --dependency-file. This is analogous to the compiler&#x27;s -M flag.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_dependency_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;std::string&gt; deps;</span><br><span class="line">  std::unordered_set&lt;std::string&gt; seen;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool)</span><br><span class="line">    <span class="keyword">if</span> (!mf-&gt;parent)</span><br><span class="line">      <span class="keyword">if</span> (std::string path = <span class="built_in">path_clean</span>(mf-&gt;name); seen.<span class="built_in">insert</span>(path).second)</span><br><span class="line">        deps.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">  std::ofstream out;</span><br><span class="line">  out.<span class="built_in">open</span>(ctx.arg.dependency_file);</span><br><span class="line">  <span class="keyword">if</span> (out.<span class="built_in">fail</span>())</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;--dependency-file: cannot open &quot;</span> &lt;&lt; ctx.arg.dependency_file</span><br><span class="line">               &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">errno_string</span>();</span><br><span class="line"></span><br><span class="line">  out &lt;&lt; ctx.arg.output &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::string &amp;s : deps)</span><br><span class="line">    out &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s;</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string &amp;s : deps)</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">  out.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="clean-lto-object"><a href="#clean-lto-object" class="headerlink" title="clean lto object"></a>clean lto object</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.has_lto_object)</span><br><span class="line">  <span class="built_in">lto_cleanup</span>(ctx);</span><br></pre></td></tr></table></figure><p>清理lto相关的文件，lto相关的操作都是类似于插件的形式执行的，以适配不同编译器产生的lto文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lto_cleanup</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;lto_cleanup&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cleanup_hook)</span><br><span class="line">    <span class="built_in">cleanup_hook</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个cleanup_hook也是在前面注册插件的时候要注册的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> PluginStatus <span class="title">register_cleanup_hook</span><span class="params">(CleanupHandler fn)</span> </span>&#123;</span><br><span class="line">  LOG &lt;&lt; <span class="string">&quot;register_cleanup_hook\n&quot;</span>;</span><br><span class="line">  cleanup_hook = fn;</span><br><span class="line">  <span class="keyword">return</span> LDPS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="print-map"><a href="#print-map" class="headerlink" title="print map"></a>print map</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.print_map)</span><br><span class="line">    <span class="built_in">print_map</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>–Map FILE Write map file to a given file</p></blockquote><p>收集信息并建立了section到symbol的map，之后遍历所有的chunk，进行打印。</p><ol><li>首先会打印一行chunk的信息</li><li>如果不是osec那么会继续打印下一个chunk，否则之后会接着打印osec内部的所有members的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_map</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::ostream *out = &amp;std::cout;</span><br><span class="line">  std::unique_ptr&lt;std::ofstream&gt; file;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.Map.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    file = <span class="built_in">open_output_file</span>(ctx);</span><br><span class="line">    out = file.<span class="built_in">get</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a section-to-symbol map.</span></span><br><span class="line">  Map&lt;E&gt; map = <span class="built_in">get_map</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print a mapfile.</span></span><br><span class="line">  *out &lt;&lt; <span class="string">&quot;               VMA       Size Align Out     In      Symbol\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *osec : ctx.chunks) &#123;</span><br><span class="line">    *out &lt;&lt; std::showbase</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; (u64)osec-&gt;shdr.sh_addr &lt;&lt; std::dec</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">11</span>) &lt;&lt; (u64)osec-&gt;shdr.sh_size</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; (u64)osec-&gt;shdr.sh_addralign</span><br><span class="line">         &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; osec-&gt;name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (osec-&gt;<span class="built_in">kind</span>() != OUTPUT_SECTION)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    std::span&lt;InputSection&lt;E&gt; *&gt; members = ((OutputSection&lt;E&gt; *)osec)-&gt;members;</span><br><span class="line">    <span class="function">std::vector&lt;std::string&gt; <span class="title">bufs</span><span class="params">(members.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">      InputSection&lt;E&gt; *mem = members[i];</span><br><span class="line">      std::ostringstream ss;</span><br><span class="line">      opt_demangle = ctx.arg.demangle;</span><br><span class="line">      u64 addr = osec-&gt;shdr.sh_addr + mem-&gt;offset;</span><br><span class="line"></span><br><span class="line">      ss &lt;&lt; std::showbase</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; addr &lt;&lt; std::dec</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">11</span>) &lt;&lt; (u64)mem-&gt;sh_size</span><br><span class="line">         &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">6</span>) &lt;&lt; (<span class="number">1</span> &lt;&lt; (u64)mem-&gt;p2align)</span><br><span class="line">         &lt;&lt; <span class="string">&quot;         &quot;</span> &lt;&lt; *mem &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">typename</span> Map&lt;E&gt;::const_accessor acc;</span><br><span class="line">      <span class="keyword">if</span> (map.<span class="built_in">find</span>(acc, mem))</span><br><span class="line">        <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : acc-&gt;second)</span><br><span class="line">          ss &lt;&lt; std::showbase</span><br><span class="line">             &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">18</span>) &lt;&lt; std::hex &lt;&lt; sym-&gt;<span class="built_in">get_addr</span>(ctx) &lt;&lt; std::dec</span><br><span class="line">             &lt;&lt; <span class="string">&quot;          0     0                 &quot;</span></span><br><span class="line">             &lt;&lt; *sym &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">      bufs[i] = ss.<span class="built_in">str</span>();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::string &amp;str : bufs)</span><br><span class="line">      *out &lt;&lt; str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Map&lt;E&gt; <span class="title">get_map</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  Map&lt;E&gt; map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file || sym-&gt;<span class="built_in">get_type</span>() == STT_SECTION)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(file == &amp;isec-&gt;file);</span><br><span class="line">        <span class="keyword">typename</span> Map&lt;E&gt;::accessor acc;</span><br><span class="line">        map.<span class="built_in">insert</span>(acc, &#123;isec, &#123;&#125;&#125;);</span><br><span class="line">        acc-&gt;second.<span class="built_in">push_back</span>(sym);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>(map.<span class="built_in">range</span>(), [](<span class="keyword">const</span> <span class="keyword">typename</span> Map&lt;E&gt;::range_type &amp;range) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = range.<span class="built_in">begin</span>(); it != range.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">      std::vector&lt;Symbol&lt;E&gt; *&gt; &amp;vec = it-&gt;second;</span><br><span class="line">      <span class="built_in">sort</span>(vec, [](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123; <span class="keyword">return</span> a-&gt;value &lt; b-&gt;value; &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Show stats numbers</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.stats)</span><br><span class="line">  <span class="built_in">show_stats</span>(ctx);</span><br></pre></td></tr></table></figure><p>在链接的过程中对于许多操作都会使用一个Counter记录数量，比如说符号的个数等，这里就是打印那些记录的信息</p><blockquote><p>–stats                     Print input statistics</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_stats</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *obj : ctx.objs) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">defined</span><span class="params">(<span class="string">&quot;defined_syms&quot;</span>)</span></span>;</span><br><span class="line">    defined += obj-&gt;first_global - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">undefined</span><span class="params">(<span class="string">&quot;undefined_syms&quot;</span>)</span></span>;</span><br><span class="line">    undefined += obj-&gt;symbols.<span class="built_in">size</span>() - obj-&gt;first_global;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;sec : obj-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!sec || !sec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> Counter <span class="title">alloc</span><span class="params">(<span class="string">&quot;reloc_alloc&quot;</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> Counter <span class="title">nonalloc</span><span class="params">(<span class="string">&quot;reloc_nonalloc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC)</span><br><span class="line">        alloc += sec-&gt;<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        nonalloc += sec-&gt;<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">comdats</span><span class="params">(<span class="string">&quot;comdats&quot;</span>)</span></span>;</span><br><span class="line">    comdats += obj-&gt;comdat_groups.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">removed_comdats</span><span class="params">(<span class="string">&quot;removed_comdat_mem&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (ComdatGroupRef&lt;E&gt; &amp;ref : obj-&gt;comdat_groups)</span><br><span class="line">      <span class="keyword">if</span> (ref.group-&gt;owner != obj-&gt;priority)</span><br><span class="line">        removed_comdats += ref.members.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_cies</span><span class="params">(<span class="string">&quot;num_cies&quot;</span>)</span></span>;</span><br><span class="line">    num_cies += obj-&gt;cies.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_unique_cies</span><span class="params">(<span class="string">&quot;num_unique_cies&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : obj-&gt;cies)</span><br><span class="line">      <span class="keyword">if</span> (cie.is_leader)</span><br><span class="line">        num_unique_cies++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">num_fdes</span><span class="params">(<span class="string">&quot;num_fdes&quot;</span>)</span></span>;</span><br><span class="line">    num_fdes +=  obj-&gt;fdes.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_bytes</span><span class="params">(<span class="string">&quot;total_input_bytes&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool)</span><br><span class="line">    num_bytes += mf-&gt;size;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_input_sections</span><span class="params">(<span class="string">&quot;input_sections&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    num_input_sections += file-&gt;sections.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_output_chunks</span><span class="params">(<span class="string">&quot;output_chunks&quot;</span>, ctx.chunks.size())</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_objs</span><span class="params">(<span class="string">&quot;num_objs&quot;</span>, ctx.objs.size())</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">num_dsos</span><span class="params">(<span class="string">&quot;num_dsos&quot;</span>, ctx.dsos.size())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Counter <span class="title">thunk_bytes</span><span class="params">(<span class="string">&quot;thunk_bytes&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">for</span> (std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk : osec-&gt;thunks)</span><br><span class="line">          thunk_bytes += thunk-&gt;<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter::<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;sec : ctx.merged_sections)</span><br><span class="line">    sec-&gt;<span class="built_in">print_stats</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter is used to collect statistics numbers.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Counter</span>(std::string_view name, i64 value = <span class="number">0</span>) : <span class="built_in">name</span>(name), <span class="built_in">values</span>(value) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::mutex mu;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mu)</span></span>;</span><br><span class="line">    instances.<span class="built_in">push_back</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter &amp;<span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">      values.<span class="built_in">local</span>()++;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Counter &amp;<span class="keyword">operator</span>+=(<span class="keyword">int</span> delta) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled)</span><br><span class="line">      values.<span class="built_in">local</span>() += delta;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function">i64 <span class="title">get_value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  std::string_view name;</span><br><span class="line">  tbb::enumerable_thread_specific&lt;i64&gt; values;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> std::vector&lt;Counter *&gt; instances;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Counter::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">sort</span>(instances, [](Counter *a, Counter *b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a-&gt;<span class="built_in">get_value</span>() &gt; b-&gt;<span class="built_in">get_value</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Counter *c : instances)</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">20</span>) &lt;&lt; std::right &lt;&lt; c-&gt;name</span><br><span class="line">              &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c-&gt;<span class="built_in">get_value</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MergedSection&lt;E&gt;::<span class="built_in">print_stats</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  i64 used = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; map.nbuckets; i++)</span><br><span class="line">    <span class="keyword">if</span> (map.keys[i])</span><br><span class="line">      used++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="keyword">this</span>-&gt;name</span><br><span class="line">               &lt;&lt; <span class="string">&quot; estimation=&quot;</span> &lt;&lt; estimator.<span class="built_in">get_cardinality</span>()</span><br><span class="line">               &lt;&lt; <span class="string">&quot; actual=&quot;</span> &lt;&lt; used;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h1><p>之前在各个过程中都会创建许多timer，在这个过程中把timer收集到的时间信息全部打印出来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.perf)</span><br><span class="line">  <span class="built_in">print_timer_records</span>(ctx.timer_records);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_timer_records</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    tbb::concurrent_vector&lt;std::unique_ptr&lt;TimerRecord&gt;&gt; &amp;records)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = records.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    records[i]-&gt;<span class="built_in">stop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; records.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    TimerRecord &amp;inner = *records[i];</span><br><span class="line">    <span class="keyword">if</span> (inner.parent)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">      TimerRecord &amp;outer = *records[j];</span><br><span class="line">      <span class="keyword">if</span> (outer.start &lt;= inner.start &amp;&amp; inner.end &lt;= outer.end) &#123;</span><br><span class="line">        inner.parent = &amp;outer;</span><br><span class="line">        outer.children.<span class="built_in">push_back</span>(&amp;inner);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;     User   System     Real  Name\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;TimerRecord&gt; &amp;rec : records)</span><br><span class="line">    <span class="keyword">if</span> (!rec-&gt;parent)</span><br><span class="line">      <span class="built_in">print_rec</span>(*rec, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; std::flush;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="on-complete"><a href="#on-complete" class="headerlink" title="on_complete"></a>on_complete</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (on_complete)</span><br><span class="line">    <span class="built_in">on_complete</span>();</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(_WIN32) &amp;&amp; !defined(__APPLE__)</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.fork)</span><br><span class="line">    on_complete = fork_child();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>因为退出一个大量内存占用的程序很慢，因此这里会fork一个子进程来进行实际的清理工作，主进程直接退出，能够提升结束的速度，让用户不可见的清理操作放到后台执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MOLD_X86_64</span></span><br><span class="line"><span class="comment">// Exiting from a program with large memory usage is slow --</span></span><br><span class="line"><span class="comment">// it may take a few hundred milliseconds. To hide the latency,</span></span><br><span class="line"><span class="comment">// we fork a child and let it do the actual linking work.</span></span><br><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">fork_child</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">pipe</span>(pipefd) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// Parent</span></span><br><span class="line">    <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">read</span>(pipefd[<span class="number">0</span>], buf, <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">      _exit(<span class="built_in">WEXITSTATUS</span>(status));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">      <span class="built_in">raise</span>(<span class="built_in">WTERMSIG</span>(status));</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Child</span></span><br><span class="line">  <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [=] &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[] = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    [[maybe_unused]] <span class="keyword">int</span> n = <span class="built_in">write</span>(pipefd[<span class="number">1</span>], buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">assert</span>(n == <span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="on-exit"><a href="#on-exit" class="headerlink" title="on_exit"></a>on_exit</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx.arg.quick_exit)</span><br><span class="line">  _exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; &amp;fn : ctx.on_exit)</span><br><span class="line">  <span class="built_in">fn</span>();</span><br><span class="line"></span><br><span class="line">ctx.<span class="built_in">checkpoint</span>();</span><br></pre></td></tr></table></figure><p>直接exit或者调用exit的清理的函数</p><blockquote><p>–quick-exit Use quick_exit to exit (default)<br>–no-quick-exit</p></blockquote><p>在mold中有的只有一处，在icf_sections中创建的map需要在这里销毁，但是也可能在lto的过程中注册了其他的exit函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Since free&#x27;ing the map is slow, postpone it.</span></span><br><span class="line">ctx.on_exit.<span class="built_in">push_back</span>([=] &#123; <span class="keyword">delete</span> map; &#125;);</span><br></pre></td></tr></table></figure><p>最后在返回之前会再调用checkpoint检查是否有错误。</p><p>至此，整个mold的链接过程已经完全结束了。下一期会进行一个总结，并且记录一下一些自己的想法</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-15-end/Un</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十四 固定文件layout以及创建输出</title>
    <link href="https://fusionbolt.github.io/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/"/>
    <id>https://fusionbolt.github.io/2023/07/26/mold/mold-14-fix-file-layout-and-create-output/</id>
    <published>2023-07-25T16:07:02.000Z</published>
    <updated>2023-07-29T12:12:18.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mold源码阅读十四-fix-file-layout-and-create-output"><a href="#mold源码阅读十四-fix-file-layout-and-create-output" class="headerlink" title="mold源码阅读十四 fix file layout and create output"></a>mold源码阅读十四 fix file layout and create output</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:92848682</center> <p>上一期主要讲解了shdr计算更新的部分以及osec offset的设置，这期则是做链接最后的工作。上期在对段shrink的时候也提到部分synthetic的符号值还未固定，本期就会从这部分的值提起，之后则是对debug_section进行压缩，同时文件的大小也会产生变化，到了这里整个文件内部的layout以及文件的大小也就固定了。</p><p>接下来就是创建output file，将数据实际拷贝到对应的输出buffer中，实际apply relocate，以及一些其他的操作，此时链接的产物已经完成了。</p><h1 id="fix-synthetic-symbols"><a href="#fix-synthetic-symbols" class="headerlink" title="fix_synthetic_symbols"></a>fix_synthetic_symbols</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set actual addresses to linker-synthesized symbols.</span></span><br><span class="line"><span class="built_in">fix_synthetic_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要的任务是设置synthetic符号的值以及对应的origin。设置值的过程大部分都是设置对应chunk的shdr，origin则是标识符号来源，其他细节暂且不进行介绍，后面会单独一期详细查看所有synthetic的符号以及synthetic的section在整个链接过程中的行为，符号的具体作用等。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fix_synthetic_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> start = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk, i64 bias = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + bias;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> stop = [](Symbol&lt;E&gt; *sym, <span class="keyword">auto</span> &amp;chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym &amp;&amp; chunk) &#123;</span><br><span class="line">      sym-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">      sym-&gt;value = chunk-&gt;shdr.sh_addr + chunk-&gt;shdr.sh_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; sections;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;<span class="built_in">kind</span>() != HEADER &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      sections.<span class="built_in">push_back</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> find = [&amp;](std::string name) -&gt; Chunk&lt;E&gt; * &#123;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections)</span><br><span class="line">      <span class="keyword">if</span> (chunk-&gt;name == name)</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __bss_start</span></span><br><span class="line">  <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.bss&quot;</span>))</span><br><span class="line">    <span class="built_in">start</span>(ctx.__bss_start, chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr &amp;&amp; (ctx.ehdr-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">    ctx.__ehdr_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__ehdr_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">    ctx.__executable_start-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__executable_start-&gt;value = ctx.ehdr-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.__dso_handle) &#123;</span><br><span class="line">    ctx.__dso_handle-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx.__dso_handle-&gt;value = sections[<span class="number">0</span>]-&gt;shdr.sh_addr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __rel_iplt_start and __rel_iplt_end. These symbols need to be</span></span><br><span class="line">  <span class="comment">// defined in a statically-linked non-relocatable executable because</span></span><br><span class="line">  <span class="comment">// such executable lacks the .dynamic section and thus there&#x27;s no way</span></span><br><span class="line">  <span class="comment">// to find ifunc relocations other than these symbols.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We don&#x27;t want to set values to these symbols if we are creating a</span></span><br><span class="line">  <span class="comment">// static PIE due to a glibc bug. Static PIE has a dynamic section.</span></span><br><span class="line">  <span class="comment">// If we set values to these symbols in a static PIE, glibc attempts</span></span><br><span class="line">  <span class="comment">// to run ifunc initializers twice, with the second attempt with wrong</span></span><br><span class="line">  <span class="comment">// function addresses, causing a segmentation fault.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn &amp;&amp; ctx.arg.is_static &amp;&amp; !ctx.arg.pie) &#123;</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_start, ctx.reldyn);</span><br><span class="line">    <span class="built_in">stop</span>(ctx.__rel_iplt_end, ctx.reldyn);</span><br><span class="line"></span><br><span class="line">    ctx.__rel_iplt_start-&gt;value -=</span><br><span class="line">      <span class="built_in">get_num_irelative_relocs</span>(ctx) * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __&#123;init,fini&#125;_array_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (chunk-&gt;shdr.sh_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SHT_INIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__init_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__init_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_PREINIT_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__preinit_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__preinit_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SHT_FINI_ARRAY:</span><br><span class="line">      <span class="built_in">start</span>(ctx.__fini_array_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__fini_array_end, chunk);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _end, _etext, _edata and the like</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._end, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._etext, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.etext, chunk);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != SHT_NOBITS &amp;&amp;</span><br><span class="line">        (chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      <span class="built_in">stop</span>(ctx._edata, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.edata, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _DYNAMIC</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._DYNAMIC, ctx.dynamic);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _GLOBAL_OFFSET_TABLE_. I don&#x27;t know why, but for the sake of</span></span><br><span class="line">  <span class="comment">// compatibility with existing code, it must be set to the beginning of</span></span><br><span class="line">  <span class="comment">// .got.plt instead of .got only on i386 and x86-64.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_x86&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">start</span><span class="params">(ctx._GLOBAL_OFFSET_TABLE_, ctx.gotplt)</span></span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">start</span>(ctx._GLOBAL_OFFSET_TABLE_, ctx.got);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _PROCEDURE_LINKAGE_TABLE_. We need this on SPARC.</span></span><br><span class="line">  <span class="built_in">start</span>(ctx._PROCEDURE_LINKAGE_TABLE_, ctx.plt);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _TLS_MODULE_BASE_. This symbol is used to obtain the address of</span></span><br><span class="line">  <span class="comment">// the TLS block in the TLSDESC model. I believe GCC and Clang don&#x27;t</span></span><br><span class="line">  <span class="comment">// create a reference to it, but Intel compiler seems to be using</span></span><br><span class="line">  <span class="comment">// this symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx._TLS_MODULE_BASE_) &#123;</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">    ctx._TLS_MODULE_BASE_-&gt;value = ctx.tls_begin;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __GNU_EH_FRAME_HDR</span></span><br><span class="line">  <span class="built_in">start</span>(ctx.__GNU_EH_FRAME_HDR, ctx.eh_frame_hdr);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RISC-V&#x27;s __global_pointer$</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__global_pointer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.sdata&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__global_pointer, chunk, <span class="number">0x800</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.__global_pointer-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.__global_pointer-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ARM32&#x27;s __exidx_&#123;start,end&#125;</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.__exidx_start) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.ARM.exidx&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.__exidx_start, chunk);</span><br><span class="line">      <span class="built_in">stop</span>(ctx.__exidx_end, chunk);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// PPC64&#x27;s &quot;.TOC.&quot; symbol.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.TOC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.got&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Chunk&lt;E&gt; *chunk = <span class="built_in">find</span>(<span class="string">&quot;.toc&quot;</span>)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(ctx.TOC, chunk, <span class="number">0x8000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.TOC-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">      ctx.TOC-&gt;value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// __start_ and __stop_ symbols</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;std::string&gt; name = <span class="built_in">get_start_stop_name</span>(ctx, *chunk)) &#123;</span><br><span class="line">      <span class="built_in">start</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__start_&quot;</span> + *name)), chunk);</span><br><span class="line">      <span class="built_in">stop</span>(<span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__stop_&quot;</span> + *name)), chunk);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.physical_image_base) &#123;</span><br><span class="line">        u64 paddr = <span class="built_in">to_paddr</span>(ctx, chunk-&gt;shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *x = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_start_&quot;</span> + *name));</span><br><span class="line">        x-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        x-&gt;value = paddr;</span><br><span class="line"></span><br><span class="line">        Symbol&lt;E&gt; *y = <span class="built_in">get_symbol</span>(ctx, <span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_stop_&quot;</span> + *name));</span><br><span class="line">        y-&gt;<span class="built_in">set_output_section</span>(chunk);</span><br><span class="line">        y-&gt;value = paddr + chunk-&gt;shdr.sh_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --defsym=sym=value symbols</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; *sym = ctx.arg.defsyms[i].first;</span><br><span class="line">    std::variant&lt;Symbol&lt;E&gt; *, u64&gt; val = ctx.arg.defsyms[i].second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u64 *addr = std::get_if&lt;u64&gt;(&amp;val)) &#123;</span><br><span class="line">      sym-&gt;origin = <span class="number">0</span>;</span><br><span class="line">      sym-&gt;value = *addr;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; *sym2 = std::get&lt;Symbol&lt;E&gt; *&gt;(val);</span><br><span class="line">    <span class="keyword">if</span> (!sym2-&gt;file) &#123;</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--defsym: undefined symbol: &quot;</span> &lt;&lt; *sym2;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sym-&gt;value = sym2-&gt;value;</span><br><span class="line">    sym-&gt;origin = sym2-&gt;origin;</span><br><span class="line">    sym-&gt;visibility = sym2-&gt;visibility.<span class="built_in">load</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// --section-order symbols</span></span><br><span class="line">  <span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">    <span class="keyword">if</span> (ord.type == SectionOrder::SYMBOL)</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;<span class="built_in">set_output_section</span>(sections[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="compress-debug-sections"><a href="#compress-debug-sections" class="headerlink" title="compress_debug_sections"></a>compress_debug_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --compress-debug-sections is given, compress .debug_* sections</span></span><br><span class="line"><span class="comment">// using zlib.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.compress_debug_sections != COMPRESS_NONE)</span><br><span class="line">  filesize = <span class="built_in">compress_debug_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>压缩了所有debug相关的section，由于压缩了section，段的size发生改变，offset也会随之改变，因此之后还需要更新相关表的shdr，最后还会返回新的file size。具体的压缩过程这里就不详细看了。</p><blockquote><p>–compress-debug-sections [none,zlib,zlib-gabi,zstd]<br>                                        Compress .debug_* sections</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">compress_debug_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compress_debug_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;chunk = *ctx.chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((chunk.shdr.sh_flags &amp; SHF_ALLOC) || chunk.shdr.sh_size == <span class="number">0</span> ||</span><br><span class="line">        !chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Chunk&lt;E&gt; *comp = <span class="keyword">new</span> CompressedSection&lt;E&gt;(ctx, chunk);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(comp);</span><br><span class="line">    ctx.chunks[i] = comp;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.shstrtab-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.ehdr)</span><br><span class="line">    ctx.ehdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompressedSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">u8 *<span class="title">get_uncompressed_data</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> uncompressed.<span class="built_in">get</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ElfChdr&lt;E&gt; chdr = &#123;&#125;;</span><br><span class="line">  std::unique_ptr&lt;Compressor&gt; compressed;</span><br><span class="line">  std::unique_ptr&lt;u8[]&gt; uncompressed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">CompressedSection&lt;E&gt;::<span class="built_in">CompressedSection</span>(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(chunk.name.<span class="built_in">starts_with</span>(<span class="string">&quot;.debug&quot;</span>));</span><br><span class="line">  <span class="keyword">this</span>-&gt;name = chunk.name;</span><br><span class="line"></span><br><span class="line">  uncompressed.<span class="built_in">reset</span>(<span class="keyword">new</span> u8[chunk.shdr.sh_size]);</span><br><span class="line">  chunk.<span class="built_in">write_to</span>(ctx, uncompressed.<span class="built_in">get</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.compress_debug_sections) &#123;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZLIB:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZLIB;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZlibCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COMPRESS_ZSTD:</span><br><span class="line">    chdr.ch_type = ELFCOMPRESS_ZSTD;</span><br><span class="line">    compressed.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">ZstdCompressor</span>(uncompressed.<span class="built_in">get</span>(), chunk.shdr.sh_size));</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chdr.ch_size = chunk.shdr.sh_size;</span><br><span class="line">  chdr.ch_addralign = chunk.shdr.sh_addralign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr = chunk.shdr;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags |= SHF_COMPRESSED;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="built_in"><span class="keyword">sizeof</span></span>(chdr) + compressed-&gt;compressed_size;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shndx = chunk.shndx;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We don&#x27;t need to keep the original data unless --gdb-index is given.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.gdb_index)</span><br><span class="line">    uncompressed.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="create-output-file"><a href="#create-output-file" class="headerlink" title="create output file"></a>create output file</h1><p>到这个位置，所有memory以及file中的layout都就固定了，因此开始准备创建输出文件并且将chunks拷贝到output file中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create an output file</span></span><br><span class="line">ctx.output_file =</span><br><span class="line">  OutputFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">open</span>(ctx, ctx.arg.output, filesize, <span class="number">0777</span>);</span><br><span class="line">ctx.buf = ctx.output_file-&gt;buf;</span><br></pre></td></tr></table></figure><p>这里的filesize是上一期的set_osec中最后得到的offset（如果经过压缩过debug_section那么就是上面压缩后的filesize），0777则是文件的权限</p><h1 id="copy-chunks"><a href="#copy-chunks" class="headerlink" title="copy chunks"></a>copy chunks</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy input sections to the output file and apply relocations.</span></span><br><span class="line"><span class="built_in">copy_chunks</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里遍历了所有chunk并且每个都拷贝到输出文件中。但是先拷贝了非rel的段，之后才拷贝所有rel段，因为在copy output section的时候会apply relocate，在rel_offset的位置写入数据，而在后面rel段copy_buf的时候还可能向同样的地址写入数据。</p><p>这里会介绍一下一些主要的copy_chunk的实现（RelSection，OutputSection），其他synthetic符号的细节等到之后的文章再看细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy chunks to an output file</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_chunks</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;copy_chunks&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> copy = [&amp;](Chunk&lt;E&gt; &amp;chunk) &#123;</span><br><span class="line">    std::string name = chunk.name.<span class="built_in">empty</span>() ? <span class="string">&quot;(header)&quot;</span> : std::<span class="built_in">string</span>(chunk.name);</span><br><span class="line">    <span class="function">Timer <span class="title">t2</span><span class="params">(ctx, name, &amp;t)</span></span>;</span><br><span class="line">    chunk.<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For --relocatable and --emit-relocs, we want to copy non-relocation</span></span><br><span class="line">  <span class="comment">// sections first. This is because REL-type relocation sections (as</span></span><br><span class="line">  <span class="comment">// opposed to RELA-type) stores relocation addends to target sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type != (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_type == (is_rela&lt;E&gt; ? SHT_RELA : SHT_REL))</span><br><span class="line">      <span class="built_in">copy</span>(*chunk);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">report_undef_errors</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">fixup_arm_exidx_section</span><span class="params">(ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rel的查找过程"><a href="#rel的查找过程" class="headerlink" title="rel的查找过程"></a>rel的查找过程</h2><p>不论是否为rel的output section，都需要有一个定位rel具体位置的过程。首先会先找到所在的osec，一个osec由多个输入的isec组成，每个isec根据其offset在osec中定位，找到具体的isec后则是找到相关的所有rel段</p><h2 id="OutputSection"><a href="#OutputSection" class="headerlink" title="OutputSection"></a>OutputSection</h2><p>对nobits的output section写入数据</p><ol><li>拷贝InputSections的内容到output file中<ol><li>copy数据本身</li><li>apply relocate</li></ol></li><li>清理掉trail padding（设置为0）</li><li>处理thunk</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_type != SHT_NOBITS)</span><br><span class="line">    <span class="built_in">write_to</span>(ctx, ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">auto</span> clear = [&amp;](u8 *loc, i64 size) &#123;</span><br><span class="line">    <span class="comment">// As a special case, .init and .fini are filled with NOPs because the</span></span><br><span class="line">    <span class="comment">// runtime executes the sections as if they were a single function.</span></span><br><span class="line">    <span class="comment">// .init and .fini are superceded by .init_array and .fini_array and</span></span><br><span class="line">    <span class="comment">// being actively used only on s390x though.</span></span><br><span class="line">    <span class="keyword">if</span> (is_s390x&lt;E&gt; &amp;&amp; (<span class="keyword">this</span>-&gt;name == <span class="string">&quot;.init&quot;</span> || <span class="keyword">this</span>-&gt;name == <span class="string">&quot;.fini&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; size; i += <span class="number">2</span>)</span><br><span class="line">        *(ub16 *)(loc + i) = <span class="number">0x0700</span>; <span class="comment">// nop</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">memset</span>(loc, <span class="number">0</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="comment">// Copy section contents to an output file</span></span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *members[i];</span><br><span class="line">    isec.<span class="built_in">write_to</span>(ctx, buf + isec.offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear trailing padding</span></span><br><span class="line">    u64 this_end = isec.offset + isec.sh_size;</span><br><span class="line">    u64 next_start = (i == members.<span class="built_in">size</span>() - <span class="number">1</span>) ?</span><br><span class="line">      (u64)<span class="keyword">this</span>-&gt;shdr.sh_size : members[i + <span class="number">1</span>]-&gt;offset;</span><br><span class="line">    <span class="built_in">clear</span>(buf + this_end, next_start - this_end);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(thunks,</span><br><span class="line">                           [&amp;](std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk) &#123;</span><br><span class="line">      thunk-&gt;<span class="built_in">copy_buf</span>(ctx);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%201.png"                      alt="Untitled"                ></p><p>根据osec→shdr.sh_addr以及isec.offset定位到具体的isec，并对每一个isec进行write_to</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">write_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_type == SHT_NOBITS || sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Copy data</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">copy_contents_riscv</span>(ctx, buf);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">uncompress_to</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Apply relocations</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.relocatable) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC)</span><br><span class="line">      <span class="built_in">apply_reloc_alloc</span>(ctx, buf);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">apply_reloc_nonalloc</span>(ctx, buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="copy数据"><a href="#copy数据" class="headerlink" title="copy数据"></a>copy数据</h3><p>针对非压缩的数据则直接copy，对于压缩后的数据则进行解压</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">uncompress_to</span>(Context&lt;E&gt; &amp;ctx, u8 *buf) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">shdr</span>().sh_flags &amp; SHF_COMPRESSED) || uncompressed) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, contents.<span class="built_in">data</span>(), contents.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (contents.<span class="built_in">size</span>() &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;))</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: corrupted compressed section&quot;</span>;</span><br><span class="line"></span><br><span class="line">  ElfChdr&lt;E&gt; &amp;hdr = *(ElfChdr&lt;E&gt; *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  std::string_view data = contents.<span class="built_in">substr</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(ElfChdr&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (hdr.ch_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZLIB: &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size = sh_size;</span><br><span class="line">    <span class="keyword">if</span> (::<span class="built_in">uncompress</span>(buf, &amp;size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != Z_OK)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: uncompress failed&quot;</span>;</span><br><span class="line">    <span class="built_in">assert</span>(size == sh_size);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> ELFCOMPRESS_ZSTD:</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ZSTD_decompress</span>(buf, sh_size, (u8 *)data.<span class="built_in">data</span>(), data.<span class="built_in">size</span>()) != sh_size)</span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: ZSTD_decompress failed&quot;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unsupported compression type: 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; hdr.ch_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply-reloc-alloc"><a href="#apply-reloc-alloc" class="headerlink" title="apply reloc alloc"></a>apply reloc alloc</h3><p>这个过程也是因架构而异的，下面的代码来自rv</p><p>针对每个rel段的位置填写对应符号的地址，因为ElfRel本身不携带这个信息，对应的参数只有r_offset, r_type, r_sym，rela还会多一个r_addend。但根据rel类型的不同计算的方式也有些许的差异。具体的不同rel的计算方式要参考官方的文档，比如说rv的</p><p><a class="link"   href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc" >https://github.com/riscv-non-isa/riscv-elf-psabi-doc/blob/master/riscv-elf.adoc<i class="fas fa-external-link-alt"></i></a></p><p>针对每个rel写入的loc的位置如图所示为osec→shdr.sh_addr + isec.offset + r_offset，不过注意这里的r_offset根据架构不同，可能会进行特殊处理，比如说下面rv的实现中有一个rel.r_offset - get_r_delta(i)的过程（之前shrink过程导致这里需要再处理delta的值）</p><p>另外apply_reloc_noalloc的过程也是类似，不再重复展示</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%202.png"                      alt="Untitled"                ></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">apply_reloc_alloc</span>(Context&lt;E&gt; &amp;ctx, u8 *base) &#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = <span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *dynrel = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.reldyn)</span><br><span class="line">    dynrel = (ElfRel&lt;E&gt; *)(ctx.buf + ctx.reldyn-&gt;shdr.sh_offset +</span><br><span class="line">                           file.reldyn_offset + <span class="keyword">this</span>-&gt;reldyn_offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_r_delta = [&amp;](i64 idx) &#123;</span><br><span class="line">    <span class="keyword">return</span> extra.r_deltas.<span class="built_in">empty</span>() ? <span class="number">0</span> : extra.r_deltas[idx];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel = rels[i];</span><br><span class="line">    <span class="keyword">if</span> (rel.r_type == R_NONE || rel.r_type == R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *file.symbols[rel.r_sym];</span><br><span class="line">    i64 r_offset = rel.r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    i64 removed_bytes = <span class="built_in">get_r_delta</span>(i + <span class="number">1</span>) - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">    u8 *loc = base + r_offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](i64 val, i64 lo, i64 hi) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val &lt; lo || hi &lt;= val)</span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: relocation &quot;</span> &lt;&lt; rel &lt;&lt; <span class="string">&quot; against &quot;</span></span><br><span class="line">                   &lt;&lt; sym &lt;&lt; <span class="string">&quot; out of range: &quot;</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; is not in [&quot;</span></span><br><span class="line">                   &lt;&lt; lo &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; hi &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S   sym.get_addr(ctx)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A   rel.r_addend</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P   (get_addr() + r_offset)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> G   (sym.get_got_idx(ctx) * sizeof(Word<span class="meta-string">&lt;E&gt;</span>))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GOT ctx.got-&gt;shdr.sh_addr</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rel.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32:</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(E::is_64)</span></span></span><br><span class="line"><span class="function">        *<span class="params">(U32&lt;E&gt; *)</span>loc </span>= S + A;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_64:</span><br><span class="line">      <span class="built_in">assert</span>(E::is_64);</span><br><span class="line">      <span class="built_in">apply_dyn_absrel</span>(ctx, sym, rel, loc, S, A, P, dynrel);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">12</span>), <span class="number">1</span> &lt;&lt; <span class="number">12</span>);</span><br><span class="line">      <span class="built_in">write_btype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_JAL: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">20</span>), <span class="number">1</span> &lt;&lt; <span class="number">20</span>);</span><br><span class="line">      <span class="built_in">write_jtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      u32 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + rel.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; jal</span></span><br><span class="line">        *(ul32 *)loc = (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0b1101111</span>;</span><br><span class="line">        <span class="built_in">write_jtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.j</span></span><br><span class="line">        *(ul16 *)loc = <span class="number">0b101&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (removed_bytes == <span class="number">6</span> &amp;&amp; rd == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// auipc + jalr -&gt; c.jal</span></span><br><span class="line">        <span class="built_in">assert</span>(!E::is_64);</span><br><span class="line">        *(ul16 *)loc = <span class="number">0b001&#x27;00000000000&#x27;01</span>;</span><br><span class="line">        <span class="built_in">write_cjtype</span>(loc, S + A - P);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span>);</span><br><span class="line">        u64 val = sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>() ? <span class="number">0</span> : S + A - P;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">        <span class="built_in">write_itype</span>(loc + <span class="number">4</span>, val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = G + GOT + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_gottp_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20:</span><br><span class="line">      *(ul32 *)loc = sym.<span class="built_in">get_tlsgd_addr</span>(ctx) + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">      <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().<span class="built_in">is_undef_weak</span>()) &#123;</span><br><span class="line">        <span class="comment">// Calling an undefined weak symbol does not make sense.</span></span><br><span class="line">        <span class="comment">// We make such call into an infinite loop. This should</span></span><br><span class="line">        <span class="comment">// help debugging of a faulty program.</span></span><br><span class="line">        *(ul32 *)loc = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *(ul32 *)loc = S + A - P;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">check</span>(val, -(<span class="number">1LL</span> &lt;&lt; <span class="number">31</span>), <span class="number">1LL</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(removed_bytes == <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(x0)` if the address is</span></span><br><span class="line">      <span class="comment">// accessible relative to the zero register. If the upper 20 bits</span></span><br><span class="line">      <span class="comment">// are all zero, the corresponding LUI might have been removed.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">      <span class="built_in">assert</span>(removed_bytes == <span class="number">0</span> || removed_bytes == <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">if</span> (removed_bytes == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">write_utype</span>(loc, S + A - ctx.tp_addr);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_LO12_S: &#123;</span><br><span class="line">      i64 val = S + A - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (rel.r_type == R_RISCV_TPREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Rewrite `lw t1, 0(t0)` with `lw t1, 0(tp)` if the address is</span></span><br><span class="line">      <span class="comment">// directly accessible using tp. tp is x4.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        <span class="built_in">set_rs1</span>(loc, <span class="number">4</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD8:</span><br><span class="line">      loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ADD64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc += S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB8:</span><br><span class="line">      loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB64:</span><br><span class="line">      *(U64&lt;E&gt; *)loc -= S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_ALIGN: &#123;</span><br><span class="line">      <span class="comment">// A R_RISCV_ALIGN is followed by a NOP sequence. We need to remove</span></span><br><span class="line">      <span class="comment">// zero or more bytes so that the instruction after R_RISCV_ALIGN is</span></span><br><span class="line">      <span class="comment">// aligned to a given alignment boundary.</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// We need to guarantee that the NOP sequence is valid after byte</span></span><br><span class="line">      <span class="comment">// removal (e.g. we can&#x27;t remove the first 2 bytes of a 4-byte NOP).</span></span><br><span class="line">      <span class="comment">// For the sake of simplicity, we always rewrite the entire NOP sequence.</span></span><br><span class="line">      i64 padding_bytes = rel.r_addend - removed_bytes;</span><br><span class="line">      <span class="built_in">assert</span>((padding_bytes &amp; <span class="number">1</span>) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      i64 i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt;= padding_bytes - <span class="number">4</span>; i += <span class="number">4</span>)</span><br><span class="line">        *(ul32 *)(loc + i) = <span class="number">0x0000&#x27;0013</span>; <span class="comment">// nop</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt; padding_bytes)</span><br><span class="line">        *(ul16 *)(loc + i) = <span class="number">0x0001</span>;      <span class="comment">// c.nop</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_BRANCH: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">8</span>), <span class="number">1</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line">      <span class="built_in">write_cbtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_RVC_JUMP: &#123;</span><br><span class="line">      i64 val = S + A - P;</span><br><span class="line">      <span class="built_in">check</span>(val, -(<span class="number">1</span> &lt;&lt; <span class="number">11</span>), <span class="number">1</span> &lt;&lt; <span class="number">11</span>);</span><br><span class="line">      <span class="built_in">write_cjtype</span>(loc, val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SUB6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((*loc - (S + A)) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET6:</span><br><span class="line">      *loc = (*loc &amp; <span class="number">0b1100&#x27;0000</span>) | ((S + A) &amp; <span class="number">0b0011&#x27;1111</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET8:</span><br><span class="line">      *loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET16:</span><br><span class="line">      *(U16&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_SET32:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_32_PCREL:</span><br><span class="line">      *(U32&lt;E&gt; *)loc = S + A - P;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S:</span><br><span class="line">      <span class="comment">// These relocations are handled in the next loop.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> S</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> P</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> G</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GOT</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Handle PC-relative LO12 relocations. In the above loop, pcrel HI20</span></span><br><span class="line">  <span class="comment">// relocations overwrote instructions with full 32-bit values to allow</span></span><br><span class="line">  <span class="comment">// their corresponding pcrel LO12 relocations to read their values.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_I:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_LO12_S: &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file.symbols[rels[i].r_sym];</span><br><span class="line">      <span class="built_in">assert</span>(sym.<span class="built_in">get_input_section</span>() == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)(base + sym.value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rels[i].r_type == R_RISCV_PCREL_LO12_I)</span><br><span class="line">        <span class="built_in">write_itype</span>(loc, val);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">write_stype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restore the original instructions pcrel HI20 relocations overwrote.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rels[i].r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_PCREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GOT_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TLS_GD_HI20: &#123;</span><br><span class="line">      u8 *loc = base + rels[i].r_offset - <span class="built_in">get_r_delta</span>(i);</span><br><span class="line">      u32 val = *(ul32 *)loc;</span><br><span class="line">      <span class="built_in">memcpy</span>(loc, contents.<span class="built_in">data</span>() + rels[i].r_offset, <span class="number">4</span>);</span><br><span class="line">      <span class="built_in">write_utype</span>(loc, val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-14-fix-file-layout-and-create-output/Untitled%203.png"                      alt="Untitled"                ></p><p>rel会先计算r_offset，值为对应osec的地址 + isec.offset + r_offset（来自输入的elf文件），r_type则保留，这个计算方式和上面apply_reloc的过程完全一致</p><p>之后的处理过程如下</p><ol><li><p>针对section外的符号直接获取其index，以及addend的信息并且设置值</p></li><li><p>section的符号则获取到对应的osec的shndx，设置addend为对应section的offset + get_addend()。其中get_addend的过程因架构而异。</p><ol><li>针对SectionFragment则符号更改为output_section.shndx，原始符号或许是指向合并为fragment之前，由于已经merge到了一起，因此只能指向fragment所在的osec</li><li>针对普通section则直接设置为对应osec的shndx</li></ol></li><li><p>设置r_addend</p><ol><li><p>rela直接设置前面计算的addend</p></li><li><p>如果是relocatable，那么会根据rel的type在base + rel.r_offset的位置写入addend的值。这个base与上面的r_offset不同，但实际上都是指向最初计算的r_offset的位置，只是这里要写入文件，因此要以文件的buf为起点，而不是0。关于write_addend也是类似于get_addend，</p><p>relocatable的情况最后write_addend的位置，也就是之前apply_reloc_alloc写入信息的位置，针对没有addend的情况只能将信息覆盖到这里</p></li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelocSection&lt;E&gt;::<span class="built_in">copy_buf</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">auto</span> write = [&amp;](ElfRel&lt;E&gt; &amp;out, InputSection&lt;E&gt; &amp;isec, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;out, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(out));</span><br><span class="line">    out.r_offset = isec.output_section-&gt;shdr.sh_addr + isec.offset + rel.r_offset;</span><br><span class="line">    out.r_type = rel.r_type;</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().st_type == STT_SECTION) &#123;</span><br><span class="line">      i64 addend;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">        out.r_sym = frag-&gt;output_section.shndx;</span><br><span class="line">        addend = frag-&gt;offset + sym.value + <span class="built_in">get_addend</span>(isec, rel);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        InputSection&lt;E&gt; *target = sym.<span class="built_in">get_input_section</span>();</span><br><span class="line">        OutputSection&lt;E&gt; *osec = target-&gt;output_section;</span><br><span class="line">        out.r_sym = osec-&gt;shndx;</span><br><span class="line">        addend = <span class="built_in">get_addend</span>(isec, rel) + target-&gt;offset;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">        out.r_addend = addend;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.relocatable) &#123;</span><br><span class="line">        u8 *base = ctx.buf + isec.output_section-&gt;shdr.sh_offset + isec.offset;</span><br><span class="line">        <span class="built_in">write_addend</span>(base + rel.r_offset, addend, rel);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym.sym_idx)</span><br><span class="line">        out.r_sym = sym.<span class="built_in">get_output_sym_idx</span>(ctx);</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">        out.r_addend </span>= rel.r_addend;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)output_section.members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    ElfRel&lt;E&gt; *buf = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset) + offsets[i];</span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *output_section.members[i];</span><br><span class="line">    std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; rels.<span class="built_in">size</span>(); j++)</span><br><span class="line">      <span class="built_in">write</span>(buf[j], isec, rels[j]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i64 Symbol&lt;E&gt;::<span class="built_in">get_output_sym_idx</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  i64 i = file-&gt;output_sym_indices[sym_idx];</span><br><span class="line">  <span class="built_in">assert</span>(i != <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_local</span>(ctx))</span><br><span class="line">    <span class="keyword">return</span> file-&gt;local_symtab_idx + i;</span><br><span class="line">  <span class="keyword">return</span> file-&gt;global_symtab_idx + i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gdb-index"><a href="#gdb-index" class="headerlink" title="gdb_index"></a>gdb_index</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Some part of .gdb_index couldn&#x27;t be computed until other debug</span></span><br><span class="line"><span class="comment">// sections are complete. We have complete debug sections now, so</span></span><br><span class="line"><span class="comment">// write the rest of .gdb_index.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.gdb_index)</span><br><span class="line">  ctx.gdb_index-&gt;<span class="built_in">write_address_areas</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要是gdb_index写入实际地址，因为在这里符号的地址都已经确定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GdbIndexSection&lt;E&gt;::<span class="built_in">write_address_areas</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;GdbIndexSection::write_address_areas&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  u8 *base = ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    std::string_view name = chunk-&gt;name;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_info&quot;</span>)</span><br><span class="line">      ctx.debug_info = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_abbrev&quot;</span>)</span><br><span class="line">      ctx.debug_abbrev = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_ranges&quot;</span>)</span><br><span class="line">      ctx.debug_ranges = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_addr&quot;</span>)</span><br><span class="line">      ctx.debug_addr = chunk;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">&quot;.debug_rnglists&quot;</span>)</span><br><span class="line">      ctx.debug_rnglists = chunk;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_info);</span><br><span class="line">  <span class="built_in">assert</span>(ctx.debug_abbrev);</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">    ul64 start;</span><br><span class="line">    ul64 end;</span><br><span class="line">    ul32 attr;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read address ranges from debug sections and copy them to .gdb_index.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;debug_info)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Entry *begin = (Entry *)(base + header.areas_offset + file-&gt;area_offset);</span><br><span class="line">    Entry *e = begin;</span><br><span class="line">    u64 offset = file-&gt;debug_info-&gt;offset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; file-&gt;compunits.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      std::vector&lt;u64&gt; addrs = <span class="built_in">read_address_areas</span>(ctx, *file, offset);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; addrs.<span class="built_in">size</span>(); j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// Skip an empty range</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == addrs[j + <span class="number">1</span>])</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Gdb crashes if there are entries with address 0.</span></span><br><span class="line">        <span class="keyword">if</span> (addrs[j] == <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert</span>(e &lt; begin + file-&gt;num_areas);</span><br><span class="line">        e-&gt;start = addrs[j];</span><br><span class="line">        e-&gt;end = addrs[j + <span class="number">1</span>];</span><br><span class="line">        e-&gt;attr = file-&gt;compunits_idx + i;</span><br><span class="line">        e++;</span><br><span class="line">      &#125;</span><br><span class="line">      offset += file-&gt;compunits[i].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill trailing null entries with dummy values because gdb</span></span><br><span class="line">    <span class="comment">// crashes if there are entries with address 0.</span></span><br><span class="line">    u64 filler;</span><br><span class="line">    <span class="keyword">if</span> (e == begin)</span><br><span class="line">      filler = ctx.etext-&gt;<span class="built_in">get_addr</span>(ctx) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      filler = e[<span class="number">-1</span>].start;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; e &lt; begin + file-&gt;num_areas; e++) &#123;</span><br><span class="line">      e-&gt;start = filler;</span><br><span class="line">      e-&gt;end = filler;</span><br><span class="line">      e-&gt;attr = file-&gt;compunits_idx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-reldyn"><a href="#sort-reldyn" class="headerlink" title="sort reldyn"></a>sort reldyn</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dynamic linker works better with sorted .rela.dyn section,</span></span><br><span class="line"><span class="comment">// so we sort them.</span></span><br><span class="line">ctx.reldyn-&gt;<span class="built_in">sort</span>(ctx);</span><br></pre></td></tr></table></figure><p>对rel段排序，这么做的原理如注释所描述</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is the reason why we sort dynamic relocations. Quote from</span></span><br><span class="line"><span class="comment">// https://www.airs.com/blog/archives/186:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   The dynamic linker in glibc uses a one element cache when processing</span></span><br><span class="line"><span class="comment">//   relocs: if a relocation refers to the same symbol as the previous</span></span><br><span class="line"><span class="comment">//   relocation, then the dynamic linker reuses the value rather than</span></span><br><span class="line"><span class="comment">//   looking up the symbol again. Thus the dynamic linker gets the best</span></span><br><span class="line"><span class="comment">//   results if the dynamic relocations are sorted so that all dynamic</span></span><br><span class="line"><span class="comment">//   relocations for a given dynamic symbol are adjacent.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   Other than that, the linker sorts together all relative relocations,</span></span><br><span class="line"><span class="comment">//   which don&#x27;t have symbols. Two relative relocations, or two relocations</span></span><br><span class="line"><span class="comment">//   against the same symbol, are sorted by the address in the output</span></span><br><span class="line"><span class="comment">//   file. This tends to optimize paging and caching when there are two</span></span><br><span class="line"><span class="comment">//   references from the same page.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We group IFUNC relocations at the end of .rel.dyn because we want to</span></span><br><span class="line"><span class="comment">// apply all the other relocations before running user-supplied ifunc</span></span><br><span class="line"><span class="comment">// resolver functions.</span></span><br></pre></td></tr></table></figure><p>大意如下：</p><ol><li>glibc的linker有一个cache，如果一个relocation和前面的relocation引用了相同符号，那么会直2接引用值，而不是重新查找。</li><li>linker会将所有没有符号的relative relocation排序，两个relative relocation或者两个针对同一个符号的relocation会按照文件地址排序。存在同一页面的两个引用时可以优化分页和缓存</li></ol><p>对于一个符号有多个relocation的情况，比如说一个全局变量被不同代码段引用多次，那么每个引用都需要生成一个条目。另外没有符号的relative relocation，是指重定位的记录中不包含符号，只包含偏移，比如说基于pc的相对寻址。</p><p>mold在.rel.dyn的末尾对IFUNC重定位进行分组,因为希望在运行用户提供的ifunc解析函数之前应用所有其他重定位。</p><p>排序规则基于如下三个方面</p><ol><li>根据r_type计算的rank</li><li>r_sym：重定位的符号在符号表中的索引</li><li>r_offset：重定位的位置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> RelDynSection&lt;E&gt;::<span class="built_in">sort</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_dynamic_relocs&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  ElfRel&lt;E&gt; *begin = (ElfRel&lt;E&gt; *)(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset);</span><br><span class="line">  ElfRel&lt;E&gt; *end = (ElfRel&lt;E&gt; *)((u8 *)begin + <span class="keyword">this</span>-&gt;shdr.sh_size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_rank = [](u32 r_type) &#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> E::R_RELATIVE: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">case</span> E::R_IRELATIVE: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_sort</span>(begin, end, [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;a, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(a.r_type), a.r_sym, a.r_offset) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(<span class="built_in">get_rank</span>(b.r_type), b.r_sym, b.r_offset);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="clear-padding"><a href="#clear-padding" class="headerlink" title="clear_padding"></a>clear_padding</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Zero-clear paddings between sections</span></span><br><span class="line"><span class="built_in">clear_padding</span>(ctx);</span><br></pre></td></tr></table></figure><p>将bss外的段中所有padding的空间设置为0，上一期只是设置offset来保证padding，但是padding范围内的值是未定的，在osec写到文件后再来将这部分空间置零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">         size          padding</span><br><span class="line">  |                     |         |</span><br><span class="line">offset                       next_offset</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_padding</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;clear_padding&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> zero = [&amp;](Chunk&lt;E&gt; *chunk, i64 next_start) &#123;</span><br><span class="line">    i64 pos = chunk-&gt;shdr.sh_offset + chunk-&gt;shdr.sh_size;</span><br><span class="line">    <span class="built_in">memset</span>(ctx.buf + pos, <span class="number">0</span>, next_start - pos);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; chunks = ctx.chunks;</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;shdr.sh_type == SHT_NOBITS;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="built_in">zero</span>(chunks[i - <span class="number">1</span>], chunks[i]-&gt;shdr.sh_offset);</span><br><span class="line">  <span class="built_in">zero</span>(chunks.<span class="built_in">back</span>(), ctx.output_file-&gt;filesize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="buildid"><a href="#buildid" class="headerlink" title="buildid"></a>buildid</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .note.gnu.build-id section contains a cryptographic hash of the</span></span><br><span class="line"><span class="comment">// entire output file. Now that we wrote everything except build-id,</span></span><br><span class="line"><span class="comment">// we can compute it.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.buildid)</span><br><span class="line">  ctx.buildid-&gt;<span class="built_in">write_buildid</span>(ctx);</span><br></pre></td></tr></table></figure><p>计算文件哈希，这对于elf来说并非必要的部分，但是有哈希可以用于校验文件是否完整是否有问题等，无需重新计算。</p><p>实际写入到header后的位置，因此写入地址是shdr.sh_offset + HEADER_SIZE。对于几种实现算法这里不再讨论。</p><blockquote><p>–build-id [none,md5,sha1,sha256,uuid,HEXSTRING]<br>                                     Generate build ID<br>–no-build-id</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuildIdSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BuildIdSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.note.gnu.build-id&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_NOTE;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">write_buildid</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">constexpr</span> i64 HEADER_SIZE = <span class="number">16</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> BuildIdSection&lt;E&gt;::<span class="built_in">write_buildid</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;build_id&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.build_id.kind) &#123;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HEX:</span><br><span class="line">    <span class="built_in">write_vector</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE,</span><br><span class="line">                 ctx.arg.build_id.value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::HASH:</span><br><span class="line">    <span class="comment">// Modern x86 processors have purpose-built instructions to accelerate</span></span><br><span class="line">    <span class="comment">// SHA256 computation, and SHA256 outperforms MD5 on such computers.</span></span><br><span class="line">    <span class="comment">// So, we always compute SHA256 and truncate it if smaller digest was</span></span><br><span class="line">    <span class="comment">// requested.</span></span><br><span class="line">    <span class="built_in">compute_sha256</span>(ctx, <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">case</span> BuildId::UUID: &#123;</span><br><span class="line">    std::array&lt;u8, 16&gt; uuid = <span class="built_in">get_uuid_v4</span>();</span><br><span class="line">    <span class="built_in">memcpy</span>(ctx.buf + <span class="keyword">this</span>-&gt;shdr.sh_offset + HEADER_SIZE, uuid.<span class="built_in">data</span>(), <span class="number">16</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="close-file"><a href="#close-file" class="headerlink" title="close file"></a>close file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Close the output file. This is the end of the linker&#x27;s main job.</span></span><br><span class="line">ctx.output_file-&gt;<span class="built_in">close</span>(ctx);</span><br></pre></td></tr></table></figure><p>至此文件已经成功输出，只剩下最后的一些收尾工作，就留到下期再讲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mold源码阅读十四-fix-file-layout-and-create-output&quot;&gt;&lt;a href=&quot;#mold源码阅读十四-fix-file-layout-and-create-output&quot; class=&quot;headerlink&quot; title=&quot;mold</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="rel" scheme="https://fusionbolt.github.io/tags/rel/"/>
    
  </entry>
  
  <entry>
    <title>赶雨</title>
    <link href="https://fusionbolt.github.io/2023/07/22/Life/catch-the-rain/"/>
    <id>https://fusionbolt.github.io/2023/07/22/Life/catch-the-rain/</id>
    <published>2023-07-22T09:01:10.000Z</published>
    <updated>2023-07-22T09:02:35.666Z</updated>
    
    <content type="html"><![CDATA[<p>清晨七点四十左右，一如既往的在没睡够的情况下就醒来了，听着窗外激烈的雨声，随机看了下天气预报，多个平台的预告基本上都是十点十一点左右停雨。躺在床上犹豫了一下，随即爬了起来收拾东西去颐和园拍雨中的荷花。洗漱以及略微吃了点东西后开始打滴滴，或许是雨天的缘故没有人接单，还要排队许久，等不下去的我又打开了高德地图，这里有更多的平台可以选，随着不断等待与加价，最终总算打到了车。一出门感受到的是与季节不符的冷风，但急着赶时间也就没有回去加衣服。上车后，看着窗外的雨，心里只有祈祷雨能继续下着，并且能下的大些，但天气并不能如我所愿，到目的地后雨已经很小了。</p><p>下车后，首先映入眼帘的是打翻了的调色盘一般的人群，各种颜色的伞和雨衣密密麻麻的排在一起。今天有许多郊游的学生以及旅游团，不知是否周末的早上都是如此，我还是第一次这么早来北京的景点。入口的里外都是这样满满的人，靠近后只会感到吵闹与拥堵，但不过也没有时间和心思去关注这些，趁着还在下小雨直奔目的地谐趣园。</p><p>此时的谐趣园虽然也有一些零零散散的人，但相对于外面显得格外安静。有不少老法师举着相机在拍荷花，也有用手机在旁边拍摄以及录制视频的人。在寻找机位的时候，还看到有一个摄影师在拍一个看起来六七十的并且穿着旗袍的老奶奶，看起来非常开心。另外还遇到一个老法师来问我关于网上卖照片的事情，他说他的照片总是审核不过，平台说尺寸太小需要更大分辨率等等。之后则是安心的当了一阵老法师，可惜的是雨天换镜头不方便就没带长焦，减少了几分老法师的成分。</p><p>以下分享的照片很多裁剪以及除雾等处理后会更合适，这里就懒得裁了，（别说裁了，我都懒得分类入库了，卡里还有上千张照片），总之不要在意那么多细节</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6940.jpg"                      alt="DSCF6940.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6954.jpg"                      alt="DSCF6954.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6952.jpg"                      alt="DSCF6952.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6948.jpg"                      alt="DSCF6948.jpg"                ></p><p>拍了一阵觉得也没什么可拍的了，便赶向了我最喜欢的一片“秘境”。这里的人总是最少的，以树林为依靠，以湖水为伴，格外有氛围，我喜欢天气凉爽的时候坐在这附近看书，但是人多的时候体验还是比较差的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6964.jpg"                      alt="DSCF6964.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6969.jpg"                      alt="DSCF6969.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6978.jpg"                      alt="DSCF6978.jpg"                ></p><p>喜欢坐在这看书</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6979.jpg"                      alt="DSCF6979.jpg"                ></p><p>在这里拍了一阵，打算到十七孔桥的位置，原路返回的过程中看到了一只猫，偶然拍到了我认为很棒的照片。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6983.jpg"                      alt="DSCF6983.jpg"                ></p><p>之后则是穿越人群，一路走过去。此时没有太多想拍的，因此更多的注意力放到了对周围的环境，对清新空气的感受上。多久没感受到这种雨后的清新空气了呢，虽然前两天也有在下雨，但是却未曾有这样的感受，也许平时一直在紧绷着神经吧。但我也并没有花费更多的注意力在身体和环境交互的感受上，而是继续寻找着下一个拍摄目标，毕竟这才是我今天最初的目的。路途中看到/听到各种各样的人：和旅伴走散了的旅者，生气的斥责孩子的家长，同样目的的老法师，专心解说的导游，等等。</p><p>没多久看到了这样的荷花，但没带长焦只能进行裁剪了，此时的我又萌生了几千块买一个备用机挂长焦的想法，就不用换镜头了。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6987.jpg"                      alt="DSCF6987.jpg"                ></p><p>焦段的极限了，需要稍微裁减一下才行，起码旁边两朵花不能在画面里</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6995.jpg"                      alt="DSCF6995.jpg"                ></p><p>远处朦胧的景色，有一种别样的风味</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF6990.jpg"                      alt="DSCF6990.jpg"                ></p><p>雨天的佛香阁</p><p>这个时候已经很困了，决定打道回府。看到这里的船还开着，能够避免回头再走一遍，加上从未体验过，选择了付款坐船。由于是雨天的缘故，座位都被雨水浸湿，勉强擦干了坐下。在船上感受到凌烈的“寒风”，但没多久注意力便放到了观看周围的景色上，有没有什么可以拍摄的目标。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7011.jpg"                      alt="DSCF7011.jpg"                ></p><p>路途也不远，没多久也就到了目的地。之后走走停停，看到了一处小的荷花，但是在下一个船坞里。不得已买了船票，但是告诉我不能提前进船坞里面等，而且船来了要立刻坐，不允许等待，结果最后只拍了一张照片，实在是让人很生气。最后到了北宫门的苏州街这里，人还是蛮多的，不论是从上面进入颐和园的人，还是下面在狭窄的道路上观光的人。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7019.jpg"                      alt="DSCF7019.jpg"                ></p><p>费半天劲才拍到的一个荷花</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/catch-the-rain/DSCF7027.jpg"                      alt="DSCF7027.jpg"                ></p><p>游船的目的地</p><p>在这附近想拍那种雨滴拉线的效果，奈何雨滴太小了，只有偶尔房檐滴下的大雨滴才能拍出，而这雨滴又没法和荷花拍到一起，最后还是放弃了。</p><p>走之前在这里倒是看到一个小插曲，一个游客问旁边卖伞的人价格，听到价格后回答这个价格美团上都能买到两个了，之后轻微争论了两句觉得不值就走了。在出了北门到了地铁站前，看到几步路就有一个卖伞、雨衣的，不知他们能否卖出去。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;清晨七点四十左右，一如既往的在没睡够的情况下就醒来了，听着窗外激烈的雨声，随机看了下天气预报，多个平台的预告基本上都是十点十一点左右停雨。躺在床上犹豫了一下，随即爬了起来收拾东西去颐和园拍雨中的荷花。洗漱以及略微吃了点东西后开始打滴滴，或许是雨天的缘故没有人接单，还要排队许</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="颐和园" scheme="https://fusionbolt.github.io/tags/%E9%A2%90%E5%92%8C%E5%9B%AD/"/>
    
    <category term="摄影" scheme="https://fusionbolt.github.io/tags/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十三 计算shdr以及osec offset</title>
    <link href="https://fusionbolt.github.io/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/"/>
    <id>https://fusionbolt.github.io/2023/07/15/mold/mold-13-compute-shdr-and-set-osec-offsets/</id>
    <published>2023-07-15T12:02:55.000Z</published>
    <updated>2023-07-15T12:04:27.230Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-13-compute-shdr-and-set-osec-offsets/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:94763079</center> <p>本期的内容主要是更新section header以及set output section offsets相关。当这些操作结束后，虚拟地址会固定，因此输出文件的memory layout就固定下来了。</p><h1 id="create-reloc-sections"><a href="#create-reloc-sections" class="headerlink" title="create_reloc_sections"></a>create_reloc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --emit-relocs is given, we&#x27;ll copy relocation sections from input</span></span><br><span class="line"><span class="comment">// files to an output file.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.emit_relocs)</span><br><span class="line">  <span class="built_in">create_reloc_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要做了2件事情</p><ol><li>这里将relocation段从input拷贝到output中，即设置所有OutputSection中reloc_sec</li><li>加入到chunks中</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_reloc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;create_reloc_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create .rela.* sections</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.chunks.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      osec-&gt;reloc_sec.<span class="built_in">reset</span>(<span class="keyword">new</span> RelocSection&lt;E&gt;(ctx, *osec));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>, end = ctx.chunks.<span class="built_in">size</span>(); i &lt; end; i++)</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = ctx.chunks[i]-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      <span class="keyword">if</span> (RelocSection&lt;E&gt; *x = osec-&gt;reloc_sec.<span class="built_in">get</span>())</span><br><span class="line">        ctx.chunks.<span class="built_in">push_back</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RelocSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  OutputSection&lt;E&gt; &amp;output_section;</span><br><span class="line">  std::vector&lt;i64&gt; offsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中构造rel段的过程主要还是填写shdr的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line">RelocSection&lt;E&gt;::<span class="built_in">RelocSection</span>(Context&lt;E&gt; &amp;ctx, OutputSection&lt;E&gt; &amp;osec)</span><br><span class="line">  : <span class="built_in">output_section</span>(osec) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_rela&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rela&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_RELA;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="built_in">save_string</span>(ctx, <span class="string">&quot;.rel&quot;</span> + std::<span class="built_in">string</span>(osec.name));</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_REL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_INFO_LINK;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_entsize = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute an offset for each input section</span></span><br><span class="line">  offsets.<span class="built_in">resize</span>(osec.members.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> scan = [&amp;](<span class="keyword">const</span> tbb::blocked_range&lt;i64&gt; &amp;r, i64 sum, <span class="keyword">bool</span> is_final) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = r.<span class="built_in">begin</span>(); i &lt; r.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">      InputSection&lt;E&gt; &amp;isec = *osec.members[i];</span><br><span class="line">      <span class="keyword">if</span> (is_final)</span><br><span class="line">        offsets[i] = sum;</span><br><span class="line">      sum += isec.<span class="built_in">get_rels</span>(ctx).<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  i64 num_entries = tbb::<span class="built_in">parallel_scan</span>(</span><br><span class="line">    tbb::blocked_range&lt;i64&gt;(<span class="number">0</span>, osec.members.<span class="built_in">size</span>()), <span class="number">0</span>, scan, std::<span class="built_in">plus</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = num_entries * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfRel&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造RelocSection的时候需要计算出rel的数量。每个OutputSection由多个InputSection组成，每个InputSection中又有多个rel段，这里遍历扫描计算出sum的数量。</p><p>这里构造的时候有rel和rela两种情况，它们有如下几种区别</p><ol><li>rel只是简单的保存了需要被resolve的地址</li><li>rela保存了额外信息，其中的a是append。具体什么信息</li></ol><blockquote><p><em>SHT_RELA The section holds relocation entries with explicit addends, such as type</em><br><em>Elf32_Rela for the 32-bit class of object files. An object file may have</em><br><em>multiple relocation sections. See “Relocation’’ below for details.</em></p></blockquote><p>另外RelocSection的shdr flag为SHF_INFO_LINK，意义如下</p><blockquote><p>This section headers sh_info field holds a section header table index.</p></blockquote><p>设置sh_info的过程则是在后续compute_section_headers中</p><h1 id="compute-section-headers"><a href="#compute-section-headers" class="headerlink" title="compute_section_headers"></a>compute_section_headers</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the section header values for all sections.</span></span><br><span class="line"><span class="built_in">compute_section_headers</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要做了这么几件事</p><ol><li>所有输出段更新shdr</li><li>移除所有空的chunk</li><li>重新设置所有chunk的index（因为上面移除了chunk，index发生了改变）</li><li>SymtabShndxSection的处理</li><li>再次更新所有的shdr</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_headers</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update sh_size for each chunk.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove empty chunks.</span></span><br><span class="line">  std::<span class="built_in">erase_if</span>(ctx.chunks, [](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk-&gt;<span class="built_in">kind</span>() != OUTPUT_SECTION &amp;&amp; chunk-&gt;shdr.sh_size == <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set section indices.</span></span><br><span class="line">  i64 shndx = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.chunks.<span class="built_in">size</span>(); i++)</span><br><span class="line">    <span class="keyword">if</span> (ctx.chunks[i]-&gt;<span class="built_in">kind</span>() != HEADER)</span><br><span class="line">      ctx.chunks[i]-&gt;shndx = shndx++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab &amp;&amp; SHN_LORESERVE &lt;= shndx) &#123;</span><br><span class="line">    SymtabShndxSection&lt;E&gt; *sec = <span class="keyword">new</span> SymtabShndxSection&lt;E&gt;;</span><br><span class="line">    sec-&gt;shndx = shndx++;</span><br><span class="line">    sec-&gt;shdr.sh_link = ctx.symtab-&gt;shndx;</span><br><span class="line">    ctx.symtab_shndx = sec;</span><br><span class="line">    ctx.chunks.<span class="built_in">push_back</span>(sec);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(sec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.shdr)</span><br><span class="line">    ctx.shdr-&gt;shdr.sh_size = shndx * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfShdr&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Some types of section header refer other section by index.</span></span><br><span class="line">  <span class="comment">// Recompute the section header to fill such fields with correct values.</span></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    chunk-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.symtab_shndx) &#123;</span><br><span class="line">    i64 symtab_size = ctx.symtab-&gt;shdr.sh_size / <span class="built_in"><span class="keyword">sizeof</span></span>(ElfSym&lt;E&gt;);</span><br><span class="line">    ctx.symtab_shndx-&gt;shdr.sh_size = symtab_size * <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="update-shdr"><a href="#update-shdr" class="headerlink" title="update_shdr"></a>update_shdr</h2><p>大多数synthetic的chunk都有自己的实现，一些类型的section header通过index引用了其他段，因此需要重新计算shdr中对应字段的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk represents a contiguous region in an output file.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chunk</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说OutputPhdr，在这里就需要update</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputPhdr&lt;E&gt;::<span class="built_in">update_shdr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  phdrs = <span class="built_in">create_phdr</span>(ctx);</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = phdrs.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(ElfPhdr&lt;E&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除空的chunk"><a href="#移除空的chunk" class="headerlink" title="移除空的chunk"></a>移除空的chunk</h2><p>这里选择了空的非OutputSection进行移除，判断是否为OutputSection则是根据ChunkKind</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> HEADER, OUTPUT_SECTION, SYNTHETIC &#125; ChunkKind;</span><br></pre></td></tr></table></figure><p>其中HEADER是用于output的phdr，ehdr，shdr，chunk默认是SYNTHETIC，也就是说相当于最终只是删除一些空的synthetic的段</p><h2 id="重新更新索引"><a href="#重新更新索引" class="headerlink" title="重新更新索引"></a>重新更新索引</h2><p>在普通的根据chunk的序列设置索引后有一个SHN_LORESERVE的判断，和SHN_LORESERVE相关的信息有这些</p><p><a class="link"   href="https://man7.org/linux/man-pages/man5/elf.5.html" >https://man7.org/linux/man-pages/man5/elf.5.html<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">e_shnum</span><br><span class="line">              This member holds the number of entries in the section</span><br><span class="line">              header table.  Thus the product of e_shent size and e_shnum</span><br><span class="line">              gives the section header table&#x27;s size in bytes.  If a file</span><br><span class="line">              has no section header table,e_shnum holds the value of</span><br><span class="line">              zero.</span><br><span class="line"></span><br><span class="line">              If the number of entries in the section header table is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), e_shnum</span><br><span class="line">              holds the value zero and the real number of entries in the</span><br><span class="line">              section header table is held in the sh_size member of the</span><br><span class="line">              initial entry in section header table.  Otherwise, the</span><br><span class="line">sh_size member of the initial entry in the section header</span><br><span class="line">              table holds the value zero.</span><br><span class="line"></span><br><span class="line">e_shstrndx</span><br><span class="line">              This member holds the section header table index of the</span><br><span class="line">              entry associated with the section name string table.  If</span><br><span class="line">              the file has no section name string table, this member</span><br><span class="line">              holds the value SHN_UNDEF.</span><br><span class="line"></span><br><span class="line">              If the index of section name string table section is</span><br><span class="line">              larger than or equal to SHN_LORESERVE(0xff00), this</span><br><span class="line">              member holds SHN_XINDEX(0xffff) and the real index of the</span><br><span class="line">              section name string table section is held in thesh_link</span><br><span class="line">              member of the initial entry in section header table.</span><br><span class="line">              Otherwise, thesh_link member of the initial entry in</span><br><span class="line">              section header table contains the value zero.</span><br></pre></td></tr></table></figure><p>e_shnum和e_shstrndx是在EHDR中的信息。首先是shnum，当shdr table，也就是说section的数量超过SHN_LORESERVE的时候，e_shnum会设置为0，实际的数量会保存在shdr table的初始条目中的sh_size的字段里，其他情况这个条目的sh_size的字段是0。</p><p>这里创建了一个SymtabShndxSection，也就是”symtab_shndx”段，这个段保留了特殊的symbol table section index arrry，指向与符号表关联的shdr的索引。</p><blockquote><p><code>.symtab_shndx</code></p><p>This section holds the special symbol table section index array, as described above. The section’s attributes will include the <code>SHF_ALLOC</code> bit if the associated symbol table section does; otherwise that bit will be off.</p></blockquote><p>这个section的sh_type为SHT_SYMTAB_SHNDX</p><blockquote><p><code>SHT_SYMTAB_SHNDX</code></p><p>This section is associated with a section of type <code>SHT_SYMTAB</code> and is required if any of the section header indexes referenced by that symbol table contain the escape value <code>SHN_XINDEX</code>. The section is an array of <code>Elf32_Word</code> values. Each value corresponds one to one with a symbol table entry and appear in the same order as those entries. The values represent the section header indexes against which the symbol table entries are defined. Only if corresponding symbol table entry’s <code>st_shndx</code> field contains the escape value <code>SHN_XINDEX</code> will the matching <code>Elf32_Word</code> hold the actual section header index; otherwise, the entry must be <code>SHN_UNDEF</code> (<code>0</code>).</p></blockquote><p>关于e_shstrndx，这里也设置了ctx中的symtab_shndx。不论是e_shnum还是e_shstrndx都是在后续的过程中实际计算或者使用其信息，等到后面讲的时候再联系前面这些来看。</p><p>创建了SymtabShndxSection后则是设置其基本信息，至此compute_section_headers的过程就结束了。</p><h1 id="set-osec-offsets"><a href="#set-osec-offsets" class="headerlink" title="set_osec_offsets"></a>set_osec_offsets</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign offsets to output sections</span></span><br><span class="line">i64 filesize = <span class="built_in">set_osec_offsets</span>(ctx);</span><br></pre></td></tr></table></figure><p>设置所有output section的offset，根据是否有section_order会选择不同的排列方式，导致output的offset是不同的。</p><p>主要分为如下几部分</p><ol><li>设置段的虚拟地址</li><li>设置段在文件中的offset</li><li>处理phdr并且返回文件的长度</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign virtual addresses and file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">set_osec_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;set_osec_offsets&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="built_in">set_virtual_addresses_regular</span>(ctx);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">set_virtual_addresses_by_order</span>(ctx);</span><br><span class="line"></span><br><span class="line">    i64 fileoff = <span class="built_in">set_file_offsets</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assigning new offsets may change the contents and the length</span></span><br><span class="line">    <span class="comment">// of the program header, so repeat it until converge.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.phdr)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line"></span><br><span class="line">    i64 sz = ctx.phdr-&gt;shdr.sh_size;</span><br><span class="line">    ctx.phdr-&gt;<span class="built_in">update_shdr</span>(ctx);</span><br><span class="line">    <span class="keyword">if</span> (sz == ctx.phdr-&gt;shdr.sh_size)</span><br><span class="line">      <span class="keyword">return</span> fileoff;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="virtual-address设置规则"><a href="#virtual-address设置规则" class="headerlink" title="virtual address设置规则"></a>virtual address设置规则</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function assigns virtual addresses to output sections. Assigning</span></span><br><span class="line"><span class="comment">// addresses is a bit tricky because we want to pack sections as tightly</span></span><br><span class="line"><span class="comment">// as possible while not violating the constraints imposed by the hardware</span></span><br><span class="line"><span class="comment">// and the OS kernel. Specifically, we need to satisfy the following</span></span><br><span class="line"><span class="comment">// constraints:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - Memory protection (readable, writable and executable) works at page</span></span><br><span class="line"><span class="comment">//   granularity. Therefore, if we want to set different memory attributes</span></span><br><span class="line"><span class="comment">//   to two sections, we need to place them into separate pages.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - The ELF spec requires that a section&#x27;s file offset is congruent to</span></span><br><span class="line"><span class="comment">//   its virtual address modulo the page size. For example, a section at</span></span><br><span class="line"><span class="comment">//   virtual address 0x401234 on x86-64 (4 KiB, or 0x1000 byte page</span></span><br><span class="line"><span class="comment">//   system) can be at file offset 0x3234 or 0x50234 but not at 0x1000.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We need to insert paddings between sections if we can&#x27;t satisfy the</span></span><br><span class="line"><span class="comment">// above constraints without them.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We don&#x27;t want to waste too much memory and disk space for paddings.</span></span><br><span class="line"><span class="comment">// There are a few tricks we can use to minimize paddings as below:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We want to place sections with the same memory attributes</span></span><br><span class="line"><span class="comment">//   contiguous as possible.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// - We can map the same file region to memory more than once. For</span></span><br><span class="line"><span class="comment">//   example, we can write code (with R and X bits) and read-only data</span></span><br><span class="line"><span class="comment">//   (with R bit) adjacent on file and map it twice as the last page of</span></span><br><span class="line"><span class="comment">//   the executable segment and the first page of the read-only data</span></span><br><span class="line"><span class="comment">//   segment. This doesn&#x27;t save memory but saves disk space.</span></span><br></pre></td></tr></table></figure><p>mold中不论是指定order还是不指定都是遵循基本的两条规则</p><ol><li>memory protection: 不同attr的section分配到不同的页中，为了满足每个段只有一个attr的条件</li><li>ELF spec requires: vaddr的地址的模要是page size，这里会在设置地址的时候进行align，也就是insert padding。</li></ol><p>这里提及的ticks:</p><ol><li>place sections with the same memory attributes contiguous as possible. 相同attr尽可能连续。（因为不同attr需要放入不同的页）</li><li>map the same file region to memory more than once. map两次，因此不会节约内存空间，但是会节约磁盘空间</li></ol><h2 id="set-virtual-addresses-regular"><a href="#set-virtual-addresses-regular" class="headerlink" title="set_virtual_addresses_regular"></a>set_virtual_addresses_regular</h2><p>在设置地址之前，需要先对tls chunk计算一个align。因为tls chunk需要满足如下条件</p><ol><li>tls块在vaddr中的起始地址地址需要对齐（普通内存块的要求是相同的）</li><li>当被拷贝到新线程区域时tls_begin的offset也必须对齐。更具体的说，tls会有多个块，而每个块都有一个tls_begin，实际上是这个值要求对齐。</li></ol><p>而mold的做法是选择其中最大的align值。</p><p>之后设置了起始地址image_base：默认0x200000</p><blockquote><p>-image-base ADDR Set the base address to a given value</p></blockquote><p>regular设置地址的过程有如下几种情况</p><ol><li>跳过不需要alloc的段，因为并不需要加载到内存中</li><li>relro_padding，一定是满足memory protection的。</li><li>指定section_start，不需要考虑memory protection，因为后面考虑这个的时候会和前一个的段进行比较。假设说连续两个都指定了start，即便不满足，那也是指定的行为。</li><li>满足memory protection的条件。当前chunk和下一个chunk都不是relro_padding的情况，如果两个chunk的attr不同，那么处理。处理后继续执行后面的代码</li><li>tbss：SHF_TLS &amp; SHT_NOBITS</li><li>剩余的情况就是简单的进行align然后更新addr信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_regular</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> i64 RELRO = <span class="number">1LL</span> &lt;&lt; <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_flags = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    i64 flags = <span class="built_in">to_phdr_flags</span>(ctx, chunk);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_relro</span>(ctx, chunk))</span><br><span class="line">      <span class="keyword">return</span> flags | RELRO;</span><br><span class="line">    <span class="keyword">return</span> flags;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign virtual addresses</span></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TLS chunks alignments are special: in addition to having their virtual</span></span><br><span class="line">  <span class="comment">// addresses aligned, they also have to be aligned when the region of</span></span><br><span class="line">  <span class="comment">// tls_begin is copied to a new thread&#x27;s storage area. In other words, their</span></span><br><span class="line">  <span class="comment">// offset against tls_begin also has to be aligned.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// A good way to achieve this is to take the largest alignment requirement</span></span><br><span class="line">  <span class="comment">// of all TLS sections and make tls_begin also aligned to that.</span></span><br><span class="line">  Chunk&lt;E&gt; *first_tls_chunk = <span class="literal">nullptr</span>;</span><br><span class="line">  u64 tls_alignment = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk-&gt;shdr.sh_flags &amp; SHF_TLS) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!first_tls_chunk)</span><br><span class="line">        first_tls_chunk = chunk;</span><br><span class="line">      tls_alignment = std::<span class="built_in">max</span>(tls_alignment, (u64)chunk-&gt;shdr.sh_addralign);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> alignment = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">return</span> chunk == first_tls_chunk ? tls_alignment : (u64)chunk-&gt;shdr.sh_addralign;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; chunks.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// .relro_padding is a padding section to extend a PT_GNU_RELRO</span></span><br><span class="line">    <span class="comment">// segment to cover an entire page. Technically, we don&#x27;t need a</span></span><br><span class="line">    <span class="comment">// .relro_padding section because we can leave a trailing part of a</span></span><br><span class="line">    <span class="comment">// segment an unused space. However, the `strip` command would delete</span></span><br><span class="line">    <span class="comment">// such an unused trailing part and make an executable invalid.</span></span><br><span class="line">    <span class="comment">// So we add a dummy section.</span></span><br><span class="line">    <span class="keyword">if</span> (chunks[i] == ctx.relro_padding) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_size = <span class="built_in">align_to</span>(addr, ctx.page_size) - addr;</span><br><span class="line">      addr += ctx.page_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle --section-start first</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> it = ctx.arg.section_start.<span class="built_in">find</span>(chunks[i]-&gt;name);</span><br><span class="line">        it != ctx.arg.section_start.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      addr = it-&gt;second;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">      addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">    <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">    <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; chunks[i - <span class="number">1</span>] != ctx.relro_padding) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">get_flags</span>(chunks[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">get_flags</span>(chunks[i]);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X)) &#123;</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          [[fallthrough]];</span><br><span class="line">        <span class="keyword">case</span> NOSEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> (addr % ctx.page_size != <span class="number">0</span>)</span><br><span class="line">            addr += ctx.page_size;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="built_in">unreachable</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TLS BSS sections are laid out so that they overlap with the</span></span><br><span class="line">    <span class="comment">// subsequent non-tbss sections. Overlapping is fine because a STT_TLS</span></span><br><span class="line">    <span class="comment">// segment contains an initialization image for newly-created threads,</span></span><br><span class="line">    <span class="comment">// and no one except the runtime reads its contents. Even the runtime</span></span><br><span class="line">    <span class="comment">// doesn&#x27;t need a BSS part of a TLS initialization image; it just</span></span><br><span class="line">    <span class="comment">// leaves zero-initialized bytes as-is instead of copying zeros.</span></span><br><span class="line">    <span class="comment">// So no one really read tbss at runtime.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// We can instead allocate a dedicated virtual address space to tbss,</span></span><br><span class="line">    <span class="comment">// but that would be just a waste of the address and disk space.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_tbss</span>(chunks[i])) &#123;</span><br><span class="line">      u64 addr2 = addr;</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        addr2 = <span class="built_in">align_to</span>(addr2, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">        chunks[i]-&gt;shdr.sh_addr = addr2;</span><br><span class="line">        addr2 += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">2</span> == chunks.<span class="built_in">size</span>() || !<span class="built_in">is_tbss</span>(chunks[i + <span class="number">1</span>]))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, <span class="built_in">alignment</span>(chunks[i]));</span><br><span class="line">    chunks[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += chunks[i]-&gt;shdr.sh_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="relro-padding"><a href="#relro-padding" class="headerlink" title="relro_padding"></a>relro_padding</h3><p>relro_padding用于确保RELRO页对齐，通常无需考虑，但是strip后会删除未使用的尾部空间，导致可执行文件无效。因此这里计算size的过程是用align的size减去当前的地址，之后addr直接递增一个page_size</p><p>关于PT_GNU_RELRO</p><blockquote><p>The array element specifies the location and size of a segment which may be made read-only after relocation shave been processed.</p></blockquote><h3 id="section-start"><a href="#section-start" class="headerlink" title="section_start"></a>section_start</h3><p>根据命令行参数指定对应段的地址为指定的位置，更新当前段地址，并且递增对应段的size。其中提到的命令行参数的介绍</p><blockquote><p>-Tbss=ADDR Set address to .bss<br>-Tdata Set address to .data<br>-Ttext Set address to .text</p></blockquote><h3 id="满足memory-protection"><a href="#满足memory-protection" class="headerlink" title="满足memory protection"></a>满足memory protection</h3><p>这里主要是针对相邻两个chunk的attr不同的情况。</p><p>根据链接选项可以分为三类</p><ol><li>SEPARATE_LOADABLE_SEGMENTS<ol><li>这里只是更新了当前的addr为根据page size进行align的值</li></ol></li><li>SEPARATE_CODE<ol><li>两个都不是PF_X（执行的权限）的情况下进行align</li></ol></li><li>NOSEPARATE_CODE<ol><li>如果当前的地址不是整除page size，那么直接增加一个page_size </li></ol></li></ol><h3 id="to-phdr-flags"><a href="#to-phdr-flags" class="headerlink" title="to_phdr_flags"></a>to_phdr_flags</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">to_phdr_flags</span><span class="params">(Context&lt;E&gt; &amp;ctx, Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All sections are put into a single RWX segment if --omagic</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.omagic)</span><br><span class="line">    <span class="keyword">return</span> PF_R | PF_W | PF_X;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> write = (chunk-&gt;shdr.sh_flags &amp; SHF_WRITE);</span><br><span class="line">  <span class="keyword">bool</span> exec = (chunk-&gt;shdr.sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .text is not readable if --execute-only</span></span><br><span class="line">  <span class="keyword">if</span> (exec &amp;&amp; ctx.arg.execute_only) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--execute-only is not compatible with writable section: &quot;</span></span><br><span class="line">                 &lt;&lt; chunk-&gt;name;</span><br><span class="line">    <span class="keyword">return</span> PF_X;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .rodata is merged with .text if --no-rosegment</span></span><br><span class="line">  <span class="keyword">if</span> (!write &amp;&amp; !ctx.arg.rosegment)</span><br><span class="line">    exec = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PF_R | (write ? PF_W : <span class="number">0</span>) | (exec ? PF_X : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于页来说attr只有三种，读，写，执行。</p><p>如果指定omagic那么所有段都会塞到一个segment里面，因此其attr都是RWX的</p><blockquote><p>-N, –omagic Do not page align data, do not make text readonly<br>–no-omagic</p></blockquote><p>之后则是根据shdr的flag判断是否可写可执行返回对应的flag</p><h3 id="tbss"><a href="#tbss" class="headerlink" title="tbss"></a>tbss</h3><p>这里是针对tbss(tls bss) section的处理，其判断逻辑为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_tbss</span><span class="params">(Chunk&lt;E&gt; *chunk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (chunk-&gt;shdr.sh_type == SHT_NOBITS) &amp;&amp; (chunk-&gt;shdr.sh_flags &amp; SHF_TLS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.bss的SHT为SHT_NOBITS，并且其Flag为SHF_ALLOC &amp; SHF_WRITE，因此这里只需要判断sh_type是否为SHT_NOBITS以及tls的判断条件就可以确定是否为tbss</p><blockquote><p>sh_offset: The byte offset from the beginning of the file to the first byte in the section. Section type SHT_NOBITS occupies no space in the file. Its sh_offset member locates the conceptual placement in the file.</p><p>sh_size: The section’s size in bytes. Unless the section type is SHT_NOBITS, the section occupies sh_size bytes in the file. A section of type SHT_NOBITS can have a nonzero size, but it occupies no space in the file.</p><p>SHT_NOBITS: Identifies a section that occupies no space in the file but otherwise resembles SHT_PROGBITS. Although this section contains no bytes, the sh_offset member contains the conceptual file offset.</p></blockquote><p>tbss会和后续的非tbss段重叠，因为STT_TLS segment包含了一个初始化image，运行时才会读取，运行时也不需要tbss的初始化image，会保留零初始的变化字节不变，所以运行时不会实际读取。尽管可以单独给tbss分配空间，但是会浪费地址和磁盘空间。</p><p>所以这里的代码单独创建了一个地址进行递增，不会影响到正常更新的地址。</p><h2 id="set-virtual-addresses-by-order"><a href="#set-virtual-addresses-by-order" class="headerlink" title="set_virtual_addresses_by_order"></a>set_virtual_addresses_by_order</h2><p>根据order的信息来设置地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span> NONE, SECTION, GROUP, ADDR, ALIGN, SYMBOL &#125; type = NONE;</span><br></pre></td></tr></table></figure><p>根据SectionOrder信息的不同有如下几种情况处理</p><ol><li>SECTION<ol><li>计算一个地址赋给对应section的sh_addr以及更新当前的addr</li></ol></li><li>GROUP<ol><li>针对group段所有成员做和SECTION情况下相同的操作</li></ol></li><li>ADDR<ol><li>当前地址设置为SectionOrder中的值</li></ol></li><li>ALIGN<ol><li>当前地址设置为根据给定value对齐后的地址</li></ol></li><li>SYMBOL<ol><li>特定符号的地址设置为当前的地址</li></ol></li></ol><p>针对section的过程具体分为如下几步</p><ol><li>判断相邻段的attr，不同则进行将section根据page size进行padding</li><li>根据对应段的align计算一个地址，赋给section并且更新shdr以及当前addr的信息</li><li>找到下一个alloc的段</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_virtual_addresses_by_order</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;c = ctx.chunks;</span><br><span class="line">  u64 addr = ctx.arg.image_base;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    i++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> assign_addr = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">      i64 flags1 = <span class="built_in">to_phdr_flags</span>(ctx, c[i - <span class="number">1</span>]);</span><br><span class="line">      i64 flags2 = <span class="built_in">to_phdr_flags</span>(ctx, c[i]);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Memory protection works at page size granularity. We need to</span></span><br><span class="line">      <span class="comment">// put sections with different memory attributes into different</span></span><br><span class="line">      <span class="comment">// pages. We do it by inserting paddings here.</span></span><br><span class="line">      <span class="keyword">if</span> (flags1 != flags2) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.z_separate_code) &#123;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_LOADABLE_SEGMENTS:</span><br><span class="line">          addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SEPARATE_CODE:</span><br><span class="line">          <span class="keyword">if</span> ((flags1 &amp; PF_X) != (flags2 &amp; PF_X))</span><br><span class="line">            addr = <span class="built_in">align_to</span>(addr, ctx.page_size);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addr = <span class="built_in">align_to</span>(addr, c[i]-&gt;shdr.sh_addralign);</span><br><span class="line">    c[i]-&gt;shdr.sh_addr = addr;</span><br><span class="line">    addr += c[i]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; !(c[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC));</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 j = <span class="number">0</span>; j &lt; ctx.arg.section_order.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">    SectionOrder &amp;ord = ctx.arg.section_order[j];</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ord.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SECTION:</span><br><span class="line">      <span class="keyword">if</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::GROUP:</span><br><span class="line">      <span class="keyword">while</span> (i &lt; c.<span class="built_in">size</span>() &amp;&amp; j == c[i]-&gt;sect_order)</span><br><span class="line">        <span class="built_in">assign_addr</span>();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ADDR:</span><br><span class="line">      addr = ord.value;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::ALIGN:</span><br><span class="line">      addr = <span class="built_in">align_to</span>(addr, ord.value);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SectionOrder::SYMBOL:</span><br><span class="line">      <span class="built_in">get_symbol</span>(ctx, ord.name)-&gt;value = addr;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">unreachable</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-file-offsets"><a href="#set-file-offsets" class="headerlink" title="set_file_offsets"></a>set_file_offsets</h2><p>在设置完段的虚拟地址后，需要设定段在文件中的offset</p><ol><li>不需要alloc的情况，仍然需要计算其align更新size。有一些段需要占用空间，但是不需要载入内存，因此前面设置虚拟地址的时候跳过了所有不需要alloc的段，这里计算offset的时候还是要考虑到的。</li><li>bss段不做处理直接跳过</li><li>对offset做一次align。因为有的段可能并没有完整填充一个page size的空间，前面设置虚拟地址的过程并没有使得所有的size都满足page align。</li><li>给alloc section设置尽可能连续的文件的offset，因此会从当前的chunk开始循环设置offset。这样连续加载提高了效率，并且减少碎片空间。不符合条件的情况如下<ol><li>非alloc或者是bss</li><li>如果是给定了start_section的段，这样就无法设置连续的offset了，需要单独处理。包含了两种情况<ol><li>start的位置在开始循环的first chunk之前</li><li>相邻两个chunk的size过大，超过了page_size</li></ol></li></ol></li><li>使用最后一个设置offset的chunk的信息更新offset</li><li>找到下一个alloc的并且非SHT_NOBITS的chunk的index，之后处理下一个chunk</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assign file offsets to output sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> i64 <span class="title">set_file_offsets</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; &amp;chunks = ctx.chunks;</span><br><span class="line">  u64 fileoff = <span class="number">0</span>;</span><br><span class="line">  i64 i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    Chunk&lt;E&gt; &amp;first = *chunks[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(first.shdr.sh_flags &amp; SHF_ALLOC)) &#123;</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">      first.shdr.sh_offset = fileoff;</span><br><span class="line">      fileoff += first.shdr.sh_size;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_type == SHT_NOBITS) &#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.shdr.sh_addralign &gt; ctx.page_size)</span><br><span class="line">      fileoff = <span class="built_in">align_to</span>(fileoff, first.shdr.sh_addralign);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      fileoff = <span class="built_in">align_with_skew</span>(fileoff, ctx.page_size, first.shdr.sh_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign ALLOC sections contiguous file offsets as long as they</span></span><br><span class="line">    <span class="comment">// are contiguous in memory.</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      chunks[i]-&gt;shdr.sh_offset =</span><br><span class="line">        fileoff + chunks[i]-&gt;shdr.sh_addr - first.shdr.sh_addr;</span><br><span class="line">      i++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (i &gt;= chunks.<span class="built_in">size</span>() ||</span><br><span class="line">          !(chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">          chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, addresses may not increase</span></span><br><span class="line">      <span class="comment">// monotonically.</span></span><br><span class="line">      <span class="keyword">if</span> (chunks[i]-&gt;shdr.sh_addr &lt; first.shdr.sh_addr)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      i64 gap_size = chunks[i]-&gt;shdr.sh_addr - chunks[i - <span class="number">1</span>]-&gt;shdr.sh_addr -</span><br><span class="line">                     chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If --start-section is given, there may be a large gap between</span></span><br><span class="line">      <span class="comment">// sections. We don&#x27;t want to allocate a disk space for a gap if</span></span><br><span class="line">      <span class="comment">// exists.</span></span><br><span class="line">      <span class="keyword">if</span> (gap_size &gt;= ctx.page_size)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fileoff = chunks[i - <span class="number">1</span>]-&gt;shdr.sh_offset + chunks[i - <span class="number">1</span>]-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt; chunks.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">           (chunks[i]-&gt;shdr.sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">           chunks[i]-&gt;shdr.sh_type == SHT_NOBITS)</span><br><span class="line">      i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fileoff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="riscv-resize-sections"><a href="#riscv-resize-sections" class="headerlink" title="riscv_resize_sections"></a>riscv_resize_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// On RISC-V, branches are encode using multiple instructions so</span></span><br><span class="line"><span class="comment">// that they can jump to anywhere in ±2 GiB by default. They may</span></span><br><span class="line"><span class="comment">// be replaced with shorter instruction sequences if destinations</span></span><br><span class="line"><span class="comment">// are close enough. Do this optimization.</span></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  filesize </span>= <span class="built_in">riscv_resize_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里主要是针对riscv跳转在2GB范围的限制做的优化，优化后重新计算shdr</p><p>做了如下几个步骤</p><ol><li>获取eflag，unix通常假设RV64GC是baseline，所以这里flag要加上C扩展的flag（EF_RISCV_RVC），而C扩展则是允许压缩指令集，使用2字节编码指令。</li><li>针对resizeable的section进行shrink</li><li>修正符号值</li><li>重新执行上一步的计算offset操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Shrink sections by interpreting relocations.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This operation seems to be optional, because by default longest</span></span><br><span class="line"><span class="comment">// instructions are being used. However, calling this function is actually</span></span><br><span class="line"><span class="comment">// mandatory because of R_RISCV_ALIGN. R_RISCV_ALIGN is a directive to the</span></span><br><span class="line"><span class="comment">// linker to align the location referred to by the relocation to a</span></span><br><span class="line"><span class="comment">// specified byte boundary. We at least have to interpret them to satisfy</span></span><br><span class="line"><span class="comment">// the alignment constraints.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">i64 <span class="title">riscv_resize_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;riscv_resize_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// True if we can use the 2-byte instructions. This is usually true on</span></span><br><span class="line">  <span class="comment">// Unix because RV64GC is generally considered the baseline hardware.</span></span><br><span class="line">  <span class="keyword">bool</span> use_rvc = <span class="built_in">get_eflags</span>(ctx) &amp; EF_RISCV_RVC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find all the relocations that can be relaxed.</span></span><br><span class="line">  <span class="comment">// This step should only shrink sections.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_resizable</span>(ctx, isec.<span class="built_in">get</span>()))</span><br><span class="line">        <span class="built_in">shrink_section</span>(ctx, *isec, use_rvc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fix symbol values.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file != file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>();</span><br><span class="line">      <span class="keyword">if</span> (!isec || isec-&gt;extra.r_deltas.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec-&gt;<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">      <span class="keyword">auto</span> it = std::<span class="built_in">lower_bound</span>(rels.<span class="built_in">begin</span>(), rels.<span class="built_in">end</span>(), sym-&gt;value,</span><br><span class="line">                                 [&amp;](<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r, u64 val) &#123;</span><br><span class="line">        <span class="keyword">return</span> r.r_offset &lt; val;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      sym-&gt;value -= isec-&gt;extra.r_deltas[it - rels.<span class="built_in">begin</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Re-compute section offset again to finalize them.</span></span><br><span class="line">  <span class="built_in">compute_section_sizes</span>(ctx);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">set_osec_offsets</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">u64 <span class="title">get_eflags</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> EF_ARM_EABI_VER5</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;ObjectFile&lt;E&gt; *&gt; objs = ctx.objs;</span><br><span class="line">    std::<span class="built_in">erase</span>(objs, ctx.internal_obj);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (objs.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    u32 ret = objs[<span class="number">0</span>]-&gt;<span class="built_in">get_ehdr</span>().e_flags;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; objs.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span> (objs[i]-&gt;<span class="built_in">get_ehdr</span>().e_flags &amp; EF_RISCV_RVC)</span><br><span class="line">        ret |= EF_RISCV_RVC;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V2&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> 2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resizable"><a href="#resizable" class="headerlink" title="resizable"></a>resizable</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_resizable</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC) &amp;&amp;</span><br><span class="line">         (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_EXECINSTR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SHF_EXECINSTR</p><blockquote><p>This section contains executable machine instructions.</p></blockquote><p>需要分配空间且包含可执行的指令的段才能进行resize。</p><h2 id="shrink"><a href="#shrink" class="headerlink" title="shrink"></a>shrink</h2><p>针对所有的rel进行操作，最终为了更新delta值（shrink的size），用于后续fix symbol value</p><ol><li><p>更新delta的值</p></li><li><p>R_RISCV_ALIGN是用于align的部分，指向nop指令，因此需要删除nop指令使得对齐到指定alignment</p></li><li><p>针对一些无法优化的情况进行跳过</p><ol><li><p>未开启relax选项</p><p>其中的relax选项是</p><blockquote><p>–relax Optimize instructions (default)<br>–no-relax</p></blockquote></li><li><p>搜寻到了最后一个re l</p></li><li><p>另外下一个rel如果不是RELAX的也无法进行优化</p></li></ol></li><li><p>跳过internal_obj，因为synthetic符号还没有最终值，只有确定值的情况才能进行shrink</p></li><li><p>针对不同rel type进行处理，添加不同的delta值。这里细节不再深究</p></li><li><p>减少当前input section的size并且更新deltas的值</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scan relocations to shrink sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shrink_section</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec, <span class="keyword">bool</span> use_rvc)</span> </span>&#123;</span><br><span class="line">  std::span&lt;<span class="keyword">const</span> ElfRel&lt;E&gt;&gt; rels = isec.<span class="built_in">get_rels</span>(ctx);</span><br><span class="line">  isec.extra.r_deltas.<span class="built_in">resize</span>(rels.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  i64 delta = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; rels.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r = rels[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[r.r_sym];</span><br><span class="line">    isec.extra.r_deltas[i] = delta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling R_RISCV_ALIGN is mandatory.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// R_RISCV_ALIGN refers NOP instructions. We need to eliminate some</span></span><br><span class="line">    <span class="comment">// or all of the instructions so that the instruction that immediately</span></span><br><span class="line">    <span class="comment">// follows the NOPs is aligned to a specified alignment boundary.</span></span><br><span class="line">    <span class="keyword">if</span> (r.r_type == R_RISCV_ALIGN) &#123;</span><br><span class="line">      <span class="comment">// The total bytes of NOPs is stored to r_addend, so the next</span></span><br><span class="line">      <span class="comment">// instruction is r_addend away.</span></span><br><span class="line">      u64 loc = isec.<span class="built_in">get_addr</span>() + r.r_offset - delta;</span><br><span class="line">      u64 next_loc = loc + r.r_addend;</span><br><span class="line">      u64 alignment = <span class="built_in">bit_ceil</span>(r.r_addend + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">assert</span>(alignment &lt;= (<span class="number">1</span> &lt;&lt; isec.p2align));</span><br><span class="line">      delta += next_loc - <span class="built_in">align_to</span>(loc, alignment);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handling other relocations is optional.</span></span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.relax || i == rels.<span class="built_in">size</span>() - <span class="number">1</span> ||</span><br><span class="line">        rels[i + <span class="number">1</span>].r_type != R_RISCV_RELAX)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Linker-synthesized symbols haven&#x27;t been assigned their final</span></span><br><span class="line">    <span class="comment">// values when we are shrinking sections because actual values can</span></span><br><span class="line">    <span class="comment">// be computed only after we fix the file layout. Therefore, we</span></span><br><span class="line">    <span class="comment">// assume that relocations against such symbols are always</span></span><br><span class="line">    <span class="comment">// non-relaxable.</span></span><br><span class="line">    <span class="keyword">if</span> (sym.file == ctx.internal_obj)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (r.r_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_CALL_PLT: &#123;</span><br><span class="line">      <span class="comment">// These relocations refer an AUIPC + JALR instruction pair to</span></span><br><span class="line">      <span class="comment">// allow to jump to anywhere in PC ± 2 GiB. If the jump target is</span></span><br><span class="line">      <span class="comment">// close enough to PC, we can use C.J, C.JAL or JAL instead.</span></span><br><span class="line">      i64 dist = <span class="built_in">compute_distance</span>(ctx, sym, isec, r);</span><br><span class="line">      <span class="keyword">if</span> (dist &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      std::string_view contents = isec.contents;</span><br><span class="line">      i64 rd = <span class="built_in">get_rd</span>(*(ul32 *)(contents.<span class="built_in">data</span>() + r.r_offset + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (rd == <span class="number">0</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc) &#123;</span><br><span class="line">        <span class="comment">// If rd is x0 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.J, saving 6 bytes.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rd == <span class="number">1</span> &amp;&amp; <span class="built_in">sign_extend</span>(dist, <span class="number">11</span>) == dist &amp;&amp; use_rvc &amp;&amp; !E::is_64) &#123;</span><br><span class="line">        <span class="comment">// If rd is x1 and the jump target is within ±2 KiB, we can use</span></span><br><span class="line">        <span class="comment">// C.JAL. This is RV32 only because C.JAL is RV32-only instruction.</span></span><br><span class="line">        delta += <span class="number">6</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(dist, <span class="number">20</span>) == dist) &#123;</span><br><span class="line">        <span class="comment">// If the jump target is within ±1 MiB, we can use JAL.</span></span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_HI20: &#123;</span><br><span class="line">      <span class="comment">// If the upper 20 bits are all zero, we can remove LUI.</span></span><br><span class="line">      <span class="comment">// The corresponding instructions referred by LO12_I/LO12_S</span></span><br><span class="line">      <span class="comment">// relocations will use the zero register instead.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx);</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_HI20:</span><br><span class="line">    <span class="keyword">case</span> R_RISCV_TPREL_ADD: &#123;</span><br><span class="line">      <span class="comment">// These relocations are used to materialize the upper 20 bits of</span></span><br><span class="line">      <span class="comment">// an address relative to the thread pointer as follows:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  lui  a5,%tprel_hi(foo)         # R_RISCV_TPREL_HI20 (symbol)</span></span><br><span class="line">      <span class="comment">//  add  a5,a5,tp,%tprel_add(foo)  # R_RISCV_TPREL_ADD (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Then thread-local variable `foo` is accessed with a 12-bit offset</span></span><br><span class="line">      <span class="comment">// like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(a5)     # R_RISCV_TPREL_LO12_S (symbol)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// However, if the offset is ±2 KiB, we don&#x27;t need to materialize</span></span><br><span class="line">      <span class="comment">// the upper 20 bits in a register. We can instead access the</span></span><br><span class="line">      <span class="comment">// thread-local variable directly with TP like this:</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">//  sw   t0,%tprel_lo(foo)(tp)</span></span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="comment">// Here, we remove `lui` and `add` if the offset is within ±2 KiB.</span></span><br><span class="line">      i64 val = sym.<span class="built_in">get_addr</span>(ctx) + r.r_addend - ctx.tp_addr;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">sign_extend</span>(val, <span class="number">11</span>) == val)</span><br><span class="line">        delta += <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isec.extra.r_deltas[rels.<span class="built_in">size</span>()] = delta;</span><br><span class="line">  isec.sh_size -= deltfa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt; <span class="keyword">requires</span> is_riscv&lt;E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InputSectionExtras</span>&lt;</span>E&gt; &#123;</span><br><span class="line">  std::vector&lt;i32&gt; r_deltas;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-13-comput</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="shdr" scheme="https://fusionbolt.github.io/tags/shdr/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十二 创建一些输出段</title>
    <link href="https://fusionbolt.github.io/2023/07/09/mold/mold-12-create-some-output-section/"/>
    <id>https://fusionbolt.github.io/2023/07/09/mold/mold-12-create-some-output-section/</id>
    <published>2023-07-09T08:35:19.000Z</published>
    <updated>2023-07-15T12:04:40.908Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-12-create-some-output-section/105296500_p0_master1200.jpg"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:105296500_p0</center> <h1 id="Fill-gnu-version-section-contents"><a href="#Fill-gnu-version-section-contents" class="headerlink" title="Fill gnu.version section contents"></a>Fill gnu.version section contents</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fill .gnu.version_d section contents.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.verdef)</span><br><span class="line">  ctx.verdef-&gt;<span class="built_in">construct</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fill .gnu.version_r section contents.</span></span><br><span class="line">ctx.verneed-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里对verdef和verneed段进行构造，实际写入内容。其中包含了字符串信息，因此还会将字符串写入dynstr中。</p><h2 id="verdef"><a href="#verdef" class="headerlink" title="verdef"></a>verdef</h2><p>对于VerdefSection中的contents是多组ElfVerDef + ElfVerdaux。前者是verdef的信息，后者则是指向对应字符串在dynstr中的offset。</p><p>需要将ctx.arg.version_definitions以及output自身的信息写入到verdef段中，因此这样的数据实际有ctx.arg.version_definitions.size() + 1组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| verdef | verdaux | verdef | verdaux |</span><br><span class="line">/                  /</span><br><span class="line">|     dynstr0    |    dynstr1    | ... | dynstrn |</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerdefSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">VerdefSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.gnu.version_d&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_GNU_VERDEF;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_shdr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;u8&gt; contents;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次写入的时候会先在当前位置写入ElfVerDef的信息，之后写入ElfVerdaux的信息，同时在这个过程中更新当前位置的指针。传入的verstr实际保存在ctx.dynstr中，而Verdaux中保存的是则是verstr在dynstr中的offset，而VerDef仅保存索引，hash等信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> VerdefSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;fill_verdef&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.version_definitions.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize .gnu.version</span></span><br><span class="line">  ctx.versym-&gt;contents.<span class="built_in">resize</span>(ctx.dynsym-&gt;symbols.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">  ctx.versym-&gt;contents[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a buffer for .gnu.version_d.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;) + <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdaux&lt;E&gt;)) *</span><br><span class="line">                  (ctx.arg.version_definitions.<span class="built_in">size</span>() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  u8 *buf = (u8 *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  u8 *ptr = buf;</span><br><span class="line">  ElfVerdef&lt;E&gt; *verdef = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> write = [&amp;](std::string_view verstr, i64 idx, i64 flags) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_info++;</span><br><span class="line">    <span class="keyword">if</span> (verdef)</span><br><span class="line">      verdef-&gt;vd_next = ptr - (u8 *)verdef;</span><br><span class="line"></span><br><span class="line">    verdef = (ElfVerdef&lt;E&gt; *)ptr;</span><br><span class="line">    ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">    verdef-&gt;vd_version = <span class="number">1</span>;</span><br><span class="line">    verdef-&gt;vd_flags = flags;</span><br><span class="line">    verdef-&gt;vd_ndx = idx;</span><br><span class="line">    verdef-&gt;vd_cnt = <span class="number">1</span>;</span><br><span class="line">    verdef-&gt;vd_hash = <span class="built_in">elf_hash</span>(verstr);</span><br><span class="line">    verdef-&gt;vd_aux = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdef&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">    ElfVerdaux&lt;E&gt; *aux = (ElfVerdaux&lt;E&gt; *)ptr;</span><br><span class="line">    ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerdaux&lt;E&gt;);</span><br><span class="line">    aux-&gt;vda_name = ctx.dynstr-&gt;<span class="built_in">add_string</span>(verstr);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::string_view basename = ctx.arg.soname.<span class="built_in">empty</span>() ?</span><br><span class="line">    ctx.arg.output : ctx.arg.soname;</span><br><span class="line">  <span class="built_in">write</span>(basename, <span class="number">1</span>, VER_FLG_BASE);</span><br><span class="line"></span><br><span class="line">  i64 idx = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">for</span> (std::string_view verstr : ctx.arg.version_definitions)</span><br><span class="line">    <span class="built_in">write</span>(verstr, idx++, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : std::span&lt;Symbol&lt;E&gt; *&gt;(ctx.dynsym-&gt;symbols).<span class="built_in">subspan</span>(<span class="number">1</span>))</span><br><span class="line">    ctx.versym-&gt;contents[sym-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)] = sym-&gt;ver_idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ver_idx的值是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static constexpr u32 VER_NDX_LOCAL = 0;</span><br><span class="line">static constexpr u32 VER_NDX_GLOBAL = 1;</span><br><span class="line">static constexpr u32 VER_NDX_LAST_RESERVED = 1;</span><br></pre></td></tr></table></figure><h2 id="verneed"><a href="#verneed" class="headerlink" title="verneed"></a>verneed</h2><p>这里的数据格式和vardef不太一样，content是一个Verneed接着多个Vednaux构成。每个Verneed表示一个文件的开始。由于这里是针对dynsym处理，因此实际Vednaux的数量和dynsym的数量相同。在分配空间的时候注释也有写到allocate large enought buffer，避免了每个文件一个dynsym的极端场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|verneed|vednaux|vednaux|...|verneed|vednaux|vednaux|vednaux|</span><br></pre></td></tr></table></figure><p>另外不在dso或者sym-&gt;ver_idx &lt;= VER_NDX_LAST_RESERVED的sym，这些符号并不需要填充verneed字段，因此会先被过滤掉。之后由于content是以一个文件为一个小组，为了后面添加信息方便会根据soname以及ver_idx进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> VerneedSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;fill_verneed&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.dynsym-&gt;symbols.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a list of versioned symbols and sort by file and version.</span></span><br><span class="line">  std::vector&lt;Symbol&lt;E&gt; *&gt; <span class="built_in">syms</span>(ctx.dynsym-&gt;symbols.<span class="built_in">begin</span>() + <span class="number">1</span>,</span><br><span class="line">                                ctx.dynsym-&gt;symbols.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">  std::<span class="built_in">erase_if</span>(syms, [](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">return</span> !sym-&gt;file-&gt;is_dso || sym-&gt;ver_idx &lt;= VER_NDX_LAST_RESERVED;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (syms.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">sort</span>(syms, [](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(((SharedFile&lt;E&gt; *)a-&gt;file)-&gt;soname, a-&gt;ver_idx) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(((SharedFile&lt;E&gt; *)b-&gt;file)-&gt;soname, b-&gt;ver_idx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize of .gnu.version</span></span><br><span class="line">  ctx.versym-&gt;contents.<span class="built_in">resize</span>(ctx.dynsym-&gt;symbols.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">  ctx.versym-&gt;contents[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allocate a large enough buffer for .gnu.version_r.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>((<span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerneed&lt;E&gt;) + <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVernaux&lt;E&gt;)) * syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill .gnu.version_r.</span></span><br><span class="line">  u8 *buf = (u8 *)&amp;contents[<span class="number">0</span>];</span><br><span class="line">  u8 *ptr = buf;</span><br><span class="line">  ElfVerneed&lt;E&gt; *verneed = <span class="literal">nullptr</span>;</span><br><span class="line">  ElfVernaux&lt;E&gt; *aux = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  u16 veridx = VER_NDX_LAST_RESERVED + ctx.arg.version_definitions.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || syms[i - <span class="number">1</span>]-&gt;file != syms[i]-&gt;file) &#123;</span><br><span class="line">      <span class="built_in">start_group</span>(syms[i]-&gt;file);</span><br><span class="line">      <span class="built_in">add_entry</span>(syms[i]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (syms[i - <span class="number">1</span>]-&gt;ver_idx != syms[i]-&gt;ver_idx) &#123;</span><br><span class="line">      <span class="built_in">add_entry</span>(syms[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.versym-&gt;contents[syms[i]-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)] = veridx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Resize .gnu.version_r to fit to its contents.</span></span><br><span class="line">  contents.<span class="built_in">resize</span>(ptr - buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理过程中根据如果是第一个符号或者连续两个符号不是相同的file就start_group。</p><p>要注意ctx.versym-&gt;contents又重新resize了一次，在后面遍历符号的时候又会再次写入，或许是因为verdef是根据选项来决定是否执行的。两次resize实际上size是相同的，而verneed中并非所有符号都会写入versym→content，部分被过滤的符号是没有再次写入的，也就是说被过滤的符号会保留verneed的部分。</p><p>接着来看一下start_group的部分。这个函数中会sh_info递增，处理verneed（关联一个file），并且aux置空。也就是说VerneedSection的sh_info存放的是ElfVerneed的数量。每个ElfVerneed关联了一个文件，以及aux的size。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start_group = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_info++;</span><br><span class="line">  <span class="keyword">if</span> (verneed)</span><br><span class="line">    verneed-&gt;vn_next = ptr - (u8 *)verneed;</span><br><span class="line"></span><br><span class="line">  verneed = (ElfVerneed&lt;E&gt; *)ptr;</span><br><span class="line">  ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(*verneed);</span><br><span class="line">  verneed-&gt;vn_version = <span class="number">1</span>;</span><br><span class="line">  verneed-&gt;vn_file = ctx.dynstr-&gt;<span class="built_in">find_string</span>(((SharedFile&lt;E&gt; *)file)-&gt;soname);</span><br><span class="line">  verneed-&gt;vn_aux = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVerneed&lt;E&gt;);</span><br><span class="line">  aux = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在add_entry中会递增当前的verneed的计数，将信息填写到ElfVernaux中，并且更新当前aux的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add_entry = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">  verneed-&gt;vn_cnt++;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aux)</span><br><span class="line">    aux-&gt;vna_next = <span class="built_in"><span class="keyword">sizeof</span></span>(ElfVernaux&lt;E&gt;);</span><br><span class="line">  aux = (ElfVernaux&lt;E&gt; *)ptr;</span><br><span class="line">  ptr += <span class="built_in"><span class="keyword">sizeof</span></span>(*aux);</span><br><span class="line"></span><br><span class="line">  std::string_view verstr = sym-&gt;<span class="built_in">get_version</span>();</span><br><span class="line">  aux-&gt;vna_hash = <span class="built_in">elf_hash</span>(verstr);</span><br><span class="line">  aux-&gt;vna_other = ++veridx;</span><br><span class="line">  aux-&gt;vna_name = ctx.dynstr-&gt;<span class="built_in">add_string</span>(verstr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="create-output-symtab"><a href="#create-output-symtab" class="headerlink" title="create_output_symtab"></a>create_output_symtab</h1><p>这个过程是用于创建symtab和strtab，创建的时候会实际选择哪些符号要写到文件中。我们熟悉的strip，如果添加了链接选项那么就是在这里开始生效的。</p><p>相关的链接选项在mold中有如下几个</p><blockquote><p>-s, –strip-all             Strip .symtab section</p></blockquote><blockquote><p>–retain-symbols-file FILE  Keep only symbols listed in FILE</p></blockquote><blockquote><p>discard_all</p></blockquote><p>strip大家都很熟悉了，就是去掉生成文件中的symtab段</p><p>retain-symbols-file则是会产生一个符号文件，包含程序的调试信息，也就是说生成的文件说不包含符号信息，所有符号都在符号文件中。</p><p>discard_all是丢弃目标程序中未直接使用的信息，其中就包含符号表和调试信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute .symtab and .strtab sizes for each file.</span></span><br><span class="line"><span class="built_in">create_output_symtab</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_output_symtab</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_symtab_size&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    chunk-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, [&amp;](SharedFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">compute_symtab_size</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk::compute_symtab_size</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some synethetic sections add local symbols to the output.</span></span><br><span class="line"><span class="comment">// For example, range extension thunks adds function_name@thunk</span></span><br><span class="line"><span class="comment">// symbol for each thunk entry. The following members are used</span></span><br><span class="line"><span class="comment">// for such synthesizing symbols.</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">compute_symtab_size</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>对于chunk来说，不是所有的都需要做这一步操作的。在mold中仅针对OutputSection，Got，Plt，PltGot这几个chunk来处理。</p><p>实际要做的就是遍历所有符号更新其strtab_size以及num_local_symtab（用于标记local符号的数量，也就是这个阶段要计算的symtab size），不论是哪一种chunk都是如此，下面就不再赘述，只贴代码了。</p><h3 id="OutputSection"><a href="#OutputSection" class="headerlink" title="OutputSection"></a>OutputSection</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute spaces needed for thunk symbols</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file || ctx.arg.relocatable)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">this</span>-&gt;strtab_size </span>= <span class="number">9</span>; <span class="comment">// for &quot;$t&quot;, &quot;$a&quot; and &quot;$d&quot; symbols</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;RangeExtensionThunk&lt;E&gt;&gt; &amp;thunk : thunks) &#123;</span><br><span class="line">      <span class="comment">// For ARM32, we emit additional symbol &quot;$t&quot;, &quot;$a&quot; and &quot;$d&quot; for</span></span><br><span class="line">      <span class="comment">// each thunk to mark the beginning of ARM code.</span></span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">this</span>-&gt;num_local_symtab +</span>= thunk-&gt;symbols.<span class="built_in">size</span>() * <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;num_local_symtab += thunk-&gt;symbols.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : thunk-&gt;symbols)</span><br><span class="line">        <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$thunk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里relocatable的段也不会算入symtab size中，因为地址并非固定，需要加载时重定位，如果把符号放入输出文件中，会使得重定位更加困难，并且加载时会失效。</p><p>need_thunk：</p><ol><li>输出段中代码间隔比较大，直接跳转无法到达的时候需要thunk来中专</li><li>跳转的src和dest指令集不兼容需要thunk翻译</li><li>地址随机化(ASLR: Address space layout randomization)时需要thunk动态计算目标地址</li><li>地址运行时才能确定时需要thunk计算地址</li></ol><p>基本上都是一些无法直接跳转的情况，也因此会引入新的符号。而thunk本质上是一个新的代码段，需要符号进行表示，用以被其他代码识别。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> needs_thunk = <span class="keyword">requires</span> &#123; E::thunk_size; &#125;;</span><br></pre></td></tr></table></figure><p>根据mold代码中的实现，目前需要thunk的是ARM32，ARM64，PPC64V1，PPC64V2</p><h3 id="got"><a href="#got" class="headerlink" title="got"></a>got</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GotSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : got_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$got&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : gottp_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$gottp&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : tlsgd_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsgd&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : tlsdesc_syms) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsdesc&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tlsld_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$tlsld&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PLT"><a href="#PLT" class="headerlink" title="PLT"></a>PLT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> PltSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = symbols.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : symbols)</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$plt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PLTGOT"><a href="#PLTGOT" class="headerlink" title="PLTGOT"></a>PLTGOT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> PltGotSection&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all || ctx.arg.retain_symbols_file)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;num_local_symtab = symbols.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">this</span>-&gt;strtab_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : symbols)</span><br><span class="line">    <span class="keyword">this</span>-&gt;strtab_size += sym-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="string">&quot;$pltgot&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="obj"><a href="#obj" class="headerlink" title="obj"></a>obj</h2><p>在obj中，主要计算了local和global符号的名字占用的空间，用于更新strtable_size，另外还会更新对应的output_sym_indices</p><p>要注意的是计算名字空间的时候，这里的名字需要使用null结尾，因此size还需要加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;output_sym_indices.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> is_alive = [&amp;](Symbol&lt;E&gt; &amp;sym) -&gt; <span class="keyword">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.gc_sections)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>())</span><br><span class="line">      <span class="keyword">return</span> frag-&gt;is_alive;</span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="keyword">return</span> isec-&gt;is_alive;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of local symbols</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.discard_all &amp;&amp; !ctx.arg.strip_all &amp;&amp; !ctx.arg.retain_symbols_file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>-&gt;first_global; i++) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_alive</span>(sym) &amp;&amp; <span class="built_in">should_write_to_local_symtab</span>(ctx, sym)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">        sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of global symbols.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file == <span class="keyword">this</span> &amp;&amp; <span class="built_in">is_alive</span>(sym) &amp;&amp;</span><br><span class="line">        (!ctx.arg.retain_symbols_file || sym.write_to_symtab)) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      <span class="comment">// Global symbols can be demoted to local symbols based on visibility,</span></span><br><span class="line">      <span class="comment">// version scripts etc.</span></span><br><span class="line">      <span class="keyword">if</span> (sym.<span class="built_in">is_local</span>(ctx))</span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_local_symtab++;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_global_symtab++;</span><br><span class="line">      sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于local symbol除了要判断alive之外，还有一个should_write_to_local_symtab的判断，除了更新size外还会更新write_to_symtab</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">should_write_to_local_symtab</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() == STT_SECTION)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Local symbols are discarded if --discard-local is given or they</span></span><br><span class="line">  <span class="comment">// are in a mergeable section. I *believe* we exclude symbols in</span></span><br><span class="line">  <span class="comment">// mergeable sections because (1) there are too many and (2) they are</span></span><br><span class="line">  <span class="comment">// merged, so their origins shouldn&#x27;t matter, but I don&#x27;t really</span></span><br><span class="line">  <span class="comment">// know the rationale. Anyway, this is the behavior of the</span></span><br><span class="line">  <span class="comment">// traditional linkers.</span></span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">name</span>().<span class="built_in">starts_with</span>(<span class="string">&quot;.L&quot;</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.discard_locals)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="keyword">if</span> (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_MERGE)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>-X, –discard-locals        Discard temporary local symbols</p></blockquote><p>本地符号以本地标签为前缀开头，这个标签通常为.L，这里主要是对discard_locals进行处理，另外属于SHF_MERGE的段也不会写到local，根据这里注释的意思是SHF_MERGE段段符号太多了，并且是merge以后的，所以其来源不重要，并且传统的链接器都是这么做的。（我对这块也不了解，只能按照注释所说的来看了）</p><p>还有一个sym.is_local的判断看起来比较疑惑。根据注释所描述，global sym会基于visibility和version scripts等因素变成local sym，比如说设置某个global sym的可见性为特定范围，或者对应的脚本。当全局符号降级为local的时候则不再对外可见，因此不再占用全局符号表的空间。</p><p>代码里的判断是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> Symbol&lt;E&gt;::<span class="built_in">is_local</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.relocatable)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">esym</span>().st_bind == STB_LOCAL;</span><br><span class="line">  <span class="keyword">return</span> !is_imported &amp;&amp; !is_exported;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于relocatable来说，如果st_bind为STB_LOCAL，那么这个符号一定是local的</p><p>对于非imported以及非exported的全局符号，通常是模块内部实现细节使用，不能外部访问。比如说有如下几种情况</p><ol><li>静态全局符号，只能模块内部可见（因为静态符号的作用域限定在模块内，因此会被认为是local符号，对全局静态变量的访问只需要通过内存地址，而不需要符号名进行绑定）</li><li>匿名全局符号，没有被显示的使用export或者extern等进行标记，并且对外部是不可见的。比如说在.c中定义了一个全局变量，但是外部无法访问到。</li><li>未使用的全局符号，不会被访问，同时会被优化掉</li></ol><p>因此这些情况属于local，记入num_local_symtab</p><p>关于imported和exported的计算过程，可以参考之前第五期的文章，其中有根据可见性来设置exported和imported的部分</p><p><a class="link"   href="https://homura.live/2023/04/29/mold/mold-5-symbol/" >https://homura.live/2023/04/29/mold/mold-5-symbol/<i class="fas fa-external-link-alt"></i></a></p><h2 id="dso"><a href="#dso" class="headerlink" title="dso"></a>dso</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> SharedFile&lt;E&gt;::<span class="built_in">compute_symtab_size</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.strip_all)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;output_sym_indices.<span class="built_in">resize</span>(<span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(), <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute the size of global symbols.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file == <span class="keyword">this</span> &amp;&amp; (sym.is_imported || sym.is_exported) &amp;&amp;</span><br><span class="line">        (!ctx.arg.retain_symbols_file || sym.write_to_symtab)) &#123;</span><br><span class="line">      <span class="keyword">this</span>-&gt;strtab_size += sym.<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>-&gt;output_sym_indices[i] = <span class="keyword">this</span>-&gt;num_global_symtab++;</span><br><span class="line">      sym.write_to_symtab = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的要点就是imported或者exported才需要计入num_global_symtab</p><h1 id="eh-frame-construct"><a href="#eh-frame-construct" class="headerlink" title="eh_frame_construct"></a>eh_frame_construct</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .eh_frame is a special section from the linker&#x27;s point of view,</span></span><br><span class="line"><span class="comment">// as its contents are parsed and reconstructed by the linker,</span></span><br><span class="line"><span class="comment">// unlike other sections that are regarded as opaque bytes.</span></span><br><span class="line"><span class="comment">// Here, we construct output .eh_frame contents.</span></span><br><span class="line">ctx.eh_frame-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><p>由于eh_frame在mold中自行做了parse的，因此需要再手动构造output中eh_frame的部分，在构造的过程中主要是消除重复的部分，另外各个段是由offset以及idx关联起来的，更新这些信息也是必要的工作。</p><p>关于mold自行parse eh_frame的部分可以参考第二期的内容<a class="link"   href="https://homura.live/2023/04/05/mold/mold-2-read-shared-files/" >https://homura.live/2023/04/05/mold/mold-2-read-shared-files/<i class="fas fa-external-link-alt"></i></a></p><p>在构造的过程主要由如下几部分组成</p><ol><li>确保输入存在eh_frame，不存在则无需构造</li><li>删除dead fed，重新设置offset</li><li>uniquify cie，重新设置offset</li><li>fde idx的更新</li><li>重新设置文件中存储的fde的offset</li><li>填充最后的null word</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EhFrameSection</span> :</span> <span class="keyword">public</span> Chunk&lt;E&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">EhFrameSection</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = <span class="string">&quot;.eh_frame&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_type = SHT_PROGBITS;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_flags = SHF_ALLOC;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">apply_reloc</span><span class="params">(Context&lt;E&gt; &amp;ctx, <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel, u64 offset, u64 val)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">copy_buf</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> EhFrameSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;eh_frame&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If .eh_frame is missing in all input files, we don&#x27;t want to</span></span><br><span class="line">  <span class="comment">// create an output .eh_frame section.</span></span><br><span class="line">  <span class="keyword">if</span> (std::<span class="built_in">all_of</span>(ctx.objs.<span class="built_in">begin</span>(), ctx.objs.<span class="built_in">end</span>(),</span><br><span class="line">                  [](ObjectFile&lt;E&gt; *file) &#123; <span class="keyword">return</span> file-&gt;cies.<span class="built_in">empty</span>(); &#125;)) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove dead FDEs and assign them offsets within their corresponding</span></span><br><span class="line">  <span class="comment">// CIE group.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    std::<span class="built_in">erase_if</span>(file-&gt;fdes, [](FdeRecord&lt;E&gt; &amp;fde) &#123; <span class="keyword">return</span> !fde.is_alive; &#125;);</span><br><span class="line"></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : file-&gt;fdes) &#123;</span><br><span class="line">      fde.output_offset = offset;</span><br><span class="line">      offset += fde.<span class="built_in">size</span>(*file);</span><br><span class="line">    &#125;</span><br><span class="line">    file-&gt;fde_size = offset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uniquify CIEs and assign offsets to them.</span></span><br><span class="line">  std::vector&lt;CieRecord&lt;E&gt; *&gt; leaders;</span><br><span class="line">  <span class="keyword">auto</span> find_leader = [&amp;](CieRecord&lt;E&gt; &amp;cie) -&gt; CieRecord&lt;E&gt; * &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; *leader : leaders)</span><br><span class="line">      <span class="keyword">if</span> (cie.<span class="built_in">equals</span>(*leader))</span><br><span class="line">        <span class="keyword">return</span> leader;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  i64 offset = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies) &#123;</span><br><span class="line">      <span class="keyword">if</span> (CieRecord&lt;E&gt; *leader = <span class="built_in">find_leader</span>(cie)) &#123;</span><br><span class="line">        cie.output_offset = leader-&gt;output_offset;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cie.output_offset = offset;</span><br><span class="line">        cie.is_leader = <span class="literal">true</span>;</span><br><span class="line">        offset += cie.<span class="built_in">size</span>();</span><br><span class="line">        leaders.<span class="built_in">push_back</span>(&amp;cie);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign FDE offsets to files.</span></span><br><span class="line">  i64 idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    file-&gt;fde_idx = idx;</span><br><span class="line">    idx += file-&gt;fdes.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    file-&gt;fde_offset = offset;</span><br><span class="line">    offset += file-&gt;fde_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .eh_frame must end with a null word.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = offset + <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="gdb-index"><a href="#gdb-index" class="headerlink" title="gdb index"></a>gdb index</h1><p>gdb-index是用于加速gdb的段，对应的链接选项</p><blockquote><p>–gdb-index                 Create .gdb_index for faster gdb startup</p></blockquote><p>这边就不具体详细介绍了，有兴趣的可以自行看一下资料</p><p><a class="link"   href="https://sourceware.org/gdb/onlinedocs/gdb/Index-Files.html" >https://sourceware.org/gdb/onlinedocs/gdb/Index-Files.html<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --gdb-index.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.gdb_index)</span><br><span class="line">  ctx.gdb_index-&gt;<span class="built_in">construct</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This page explains the format of .gdb_index:</span></span><br><span class="line"><span class="comment">// https://sourceware.org/gdb/onlinedocs/gdb/Index-Section-Format.html</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GdbIndexSection&lt;E&gt;::<span class="built_in">construct</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;GdbIndexSection::construct&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  std::<span class="keyword">atomic_bool</span> has_debug_info = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read debug sections</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;debug_info) &#123;</span><br><span class="line">      <span class="comment">// Read compilation units from .debug_info.</span></span><br><span class="line">      file-&gt;compunits = <span class="built_in">read_compunits</span>(ctx, *file);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Count the number of address areas contained in this file.</span></span><br><span class="line">      file-&gt;num_areas = <span class="built_in">estimate_address_areas</span>(ctx, *file);</span><br><span class="line">      has_debug_info = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!has_debug_info)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize `area_offset` and `compunits_idx`.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;area_offset =</span><br><span class="line">      ctx.objs[i]-&gt;area_offset + ctx.objs[i]-&gt;num_areas * <span class="number">20</span>;</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;compunits_idx =</span><br><span class="line">      ctx.objs[i]-&gt;compunits_idx + ctx.objs[i]-&gt;compunits.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read .debug_gnu_pubnames and .debug_gnu_pubtypes.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;gdb_names = <span class="built_in">read_pubnames</span>(ctx, *file);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Estimate the unique number of pubnames.</span></span><br><span class="line">  HyperLogLog estimator;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    HyperLogLog e;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names)</span><br><span class="line">      e.<span class="built_in">insert</span>(name.hash);</span><br><span class="line">    estimator.<span class="built_in">merge</span>(e);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Uniquify pubnames by inserting all name strings into a concurrent</span></span><br><span class="line">  <span class="comment">// hashmap.</span></span><br><span class="line">  map.<span class="built_in">resize</span>(estimator.<span class="built_in">get_cardinality</span>() * <span class="number">2</span>);</span><br><span class="line">  tbb::enumerable_thread_specific&lt;i64&gt; num_names;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names) &#123;</span><br><span class="line">      MapEntry *ent;</span><br><span class="line">      <span class="keyword">bool</span> inserted;</span><br><span class="line">      std::<span class="built_in">tie</span>(ent, inserted) = map.<span class="built_in">insert</span>(name.name, name.hash, &#123;file, name.hash&#125;);</span><br><span class="line">      <span class="keyword">if</span> (inserted)</span><br><span class="line">        num_names.<span class="built_in">local</span>()++;</span><br><span class="line"></span><br><span class="line">      ObjectFile&lt;E&gt; *old_val = ent-&gt;owner;</span><br><span class="line">      <span class="keyword">while</span> (file-&gt;priority &lt; old_val-&gt;priority &amp;&amp;</span><br><span class="line">             !ent-&gt;owner.<span class="built_in">compare_exchange_weak</span>(old_val, file));</span><br><span class="line"></span><br><span class="line">      ent-&gt;num_attrs++;</span><br><span class="line">      name.entry_idx = ent - map.values;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign offsets for names and attributes within each file.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (GdbIndexName &amp;name : file-&gt;gdb_names) &#123;</span><br><span class="line">      MapEntry &amp;ent = map.values[name.entry_idx];</span><br><span class="line">      <span class="keyword">if</span> (ent.owner == file) &#123;</span><br><span class="line">        ent.attr_offset = file-&gt;attrs_size;</span><br><span class="line">        file-&gt;attrs_size += (ent.num_attrs + <span class="number">1</span>) * <span class="number">4</span>;</span><br><span class="line">        ent.name_offset = file-&gt;names_size;</span><br><span class="line">        file-&gt;names_size += name.name.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute per-file name and attributes offsets.</span></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;attrs_offset =</span><br><span class="line">      ctx.objs[i]-&gt;attrs_offset + ctx.objs[i]-&gt;attrs_size;</span><br><span class="line"></span><br><span class="line">  ctx.objs[<span class="number">0</span>]-&gt;names_offset =</span><br><span class="line">    ctx.objs.<span class="built_in">back</span>()-&gt;attrs_offset + ctx.objs.<span class="built_in">back</span>()-&gt;attrs_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    ctx.objs[i + <span class="number">1</span>]-&gt;names_offset =</span><br><span class="line">      ctx.objs[i]-&gt;names_offset + ctx.objs[i]-&gt;names_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .gdb_index contains an on-disk hash table for pubnames and</span></span><br><span class="line">  <span class="comment">// pubtypes. We aim 75% utilization. As per the format specification,</span></span><br><span class="line">  <span class="comment">// It must be a power of two.</span></span><br><span class="line">  i64 num_symtab_entries =</span><br><span class="line">    std::max&lt;i64&gt;(<span class="built_in">bit_ceil</span>(num_names.<span class="built_in">combine</span>(std::<span class="built_in">plus</span>()) * <span class="number">4</span> / <span class="number">3</span>), <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now that we can compute the size of this section.</span></span><br><span class="line">  ObjectFile&lt;E&gt; &amp;last = *ctx.objs.<span class="built_in">back</span>();</span><br><span class="line">  i64 compunits_size = (last.compunits_idx + last.compunits.<span class="built_in">size</span>()) * <span class="number">16</span>;</span><br><span class="line">  i64 areas_size = last.area_offset + last.num_areas * <span class="number">20</span>;</span><br><span class="line">  i64 offset = <span class="built_in"><span class="keyword">sizeof</span></span>(header);</span><br><span class="line"></span><br><span class="line">  header.cu_list_offset = offset;</span><br><span class="line">  offset += compunits_size;</span><br><span class="line"></span><br><span class="line">  header.cu_types_offset = offset;</span><br><span class="line">  header.areas_offset = offset;</span><br><span class="line">  offset += areas_size;</span><br><span class="line"></span><br><span class="line">  header.symtab_offset = offset;</span><br><span class="line">  offset += num_symtab_entries * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">  header.const_pool_offset = offset;</span><br><span class="line">  offset += last.names_offset + last.names_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-12-create</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="eh_frame" scheme="https://fusionbolt.github.io/tags/eh-frame/"/>
    
    <category term="symtab" scheme="https://fusionbolt.github.io/tags/symtab/"/>
    
  </entry>
  
  <entry>
    <title>令人劝退的自我介绍</title>
    <link href="https://fusionbolt.github.io/2023/07/02/Other/dissuasive-self-presentation/"/>
    <id>https://fusionbolt.github.io/2023/07/02/Other/dissuasive-self-presentation/</id>
    <published>2023-07-02T08:43:16.000Z</published>
    <updated>2023-07-02T08:45:39.060Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/dissuasive-self-presentation/9A95282B-E661-465F-B8CE-4469BD319FC9_4_5005_c.jpeg"                      alt="9A95282B-E661-465F-B8CE-4469BD319FC9_4_5005_c.jpeg"                ></p><p>思来想去，还是决定写这篇详尽的自我介绍。这里不会介绍我的兴趣爱好，如果想看那些请到我的博客<a class="link"   href="https://homura.live/about/" >关于<i class="fas fa-external-link-alt"></i></a>页面。这里不是作为某种特殊角色的我，并非程序员，并非一个社畜，并非一个二十多岁的青年，而是仅仅作为一个人，关于这个人到底是什么样的，或者说关于这个人在我的眼里到底是什么样的。</p><p>首先是很孤单的人。总的来说我一直是一个比较孤单的人，但和每个人一样十分渴求亲密关系，甚至渴求的程度比大部分人还要强烈。这样的我却又讨厌人，认为大部分人和自己一样无聊，或者比我更无趣，因此对大部分人会普通交流但不会有太强烈的热情。加上在只有自己的世界生活习惯了，在没有特别大的热情的情况下，会不太适应一些场景下的交流，更别说去主动推进关系了。</p><p>比较自卑，没有信心，但有的时候又会有些自大。跟别人交流时，尤其是讨论问题时，无形中会认为自己就是对的，想要说服对方。除此之外在交流上很多时候比较有障碍，我个人经常觉得没什么可以说的，个人知识量和见识都很少，加上认为很多事情都无所谓，因此偶尔说不上话的时候会强行交流而说出一些不适当的话。</p><p>上面的这些因素也促成了我的赛博精神病，情绪到了不能控制的痛苦时，无法排解，因此会在社交平台上发一些很烦人的东西。原因也很简单，觉得很无助，但我也无法去依靠某个人，如果理解为网络精神乞丐那我也认，自己也是这么想的。</p><p>基于以上这些问题，我经常会在一些来不及思考自己说的话是否合适的情况说出不合适的话。</p><p>除此之外，我会关注自身的想法，近年来也开始逐渐关注感受，理性的想法和感性的感受缺一不可。关注的同时也会为自身的一些想法痛苦不已，很多时候也非常想去改正，只是很难。尽管在关注自己，但也不是很明白自己，对前路还是有些迷茫，不过这初入社会不久的人来说也是常态了。同时注重自己的想法，较少受到环境的影响，不在乎他人看法，除非特别在乎对方对自己的态度的情况下。脑袋里每天也会有各种乱七八糟的想法，其中一部分也会通过各种途径输出，目前输出频率最高的大概就是推特了。</p><p>这样的我，活着只是活着，对我目前来讲没什么目的和意义，对一切也毫无牵挂。如果一定要说一个活着的目的那就是顺着自己的心愿，尽可能去做想做的事情，要说我现在想做什么的话除了找到伴侣我还真没什么想做的，绝大部分事情其实都无所谓。几乎没有什么特别喜欢的事情，但同时也没什么特别讨厌的。尽管很多事情无所谓，自身的道德感却会重一些，一些情况下会给自己施加过多的道德约束，自身行为也会尽可能的符合自身认知中的道德标准，经常会使得自己徒增烦恼。</p><p>另外过于理想主义，讨厌这种现实世界，很多情况也不愿去接受。这种不愿接受有些孩子气了，但我也没有抛弃的念头，继续这样也没什么不好。但问题是也不愿接受现在这样无能的自己，对自己许多时候也过于严苛，也不认为他人能完全接受这样的自己。</p><p>尽管这么多问题，但我还是想成为一个更好的人，包括更能接纳自己，能力达到自己满意的程度，自己的一些问题都解决掉，等等，但是前方的路还要走非常非常远。虽然也在尝试去控制自己，但自己的一些本质问题无法改正的情况下还是很难做到的，这些都不是靠意志力就能做到的事情，许多时候人对于自己行为的掌控，远比自己所想象的要弱小很多。当然这不是在找借口，想要改变也是我的另一面。</p><p>不论好坏，不可避免的都会偏离现实。对于我来说，以自己看到或感知到的自己为主。对于读者来说，以读者所看到或感知到的我为主。别人的自我介绍都是表现出自己最好的一面，但这篇介绍却是有劝退的成分。看到了我是这样的人，如果你选择与我接触，那么希望你能做好心理预期，如果借此劝退，也无妨，避免双方留下不愉快的回忆。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/dissuasive-sel</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="自我" scheme="https://fusionbolt.github.io/tags/%E8%87%AA%E6%88%91/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十一  relr and dynsym</title>
    <link href="https://fusionbolt.github.io/2023/07/02/mold/mold-11-rel-and-dynsym/"/>
    <id>https://fusionbolt.github.io/2023/07/02/mold/mold-11-rel-and-dynsym/</id>
    <published>2023-07-02T08:04:13.000Z</published>
    <updated>2023-07-02T08:07:43.172Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-11-rel-and-dynsym/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">推特画师Lyytoaoitori</center> <h1 id="construct-relr"><a href="#construct-relr" class="headerlink" title="construct_relr"></a>construct_relr</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If --packed_dyn_relocs=relr was given, base relocations are stored</span></span><br><span class="line"><span class="comment">// to a .relr.dyn section in a compressed form. Construct a compressed</span></span><br><span class="line"><span class="comment">// relocations now so that we can fix section sizes and file layout.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.pack_dyn_relocs_relr)</span><br><span class="line">  <span class="built_in">construct_relr</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>-z pack-relative-relocs Alias for –pack-dyn-relocs=relr<br>-z nopack-relative-relocs</p></blockquote><p>将OutputSection以及Got中的relocations以压缩的形式存储到relr.dyn，在这之后rel段的大小和layout就固定了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_relr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;construct_relr&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      osec-&gt;<span class="built_in">construct_relr</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.got-&gt;<span class="built_in">construct_relr</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output-section"><a href="#output-section" class="headerlink" title="output section"></a>output section</h2><p>将output section中所有符合条件的rel段收集起来，最后再压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> OutputSection&lt;E&gt;::<span class="built_in">construct_relr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.pic)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span>-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_addralign % <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Skip it if it is a text section because .text doesn&#x27;t usually</span></span><br><span class="line">  <span class="comment">// contain any dynamic relocations.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;shdr.sh_flags &amp; SHF_EXECINSTR)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Collect base relocations</span></span><br><span class="line">  std::vector&lt;std::vector&lt;u64&gt;&gt; <span class="built_in">shards</span>(members.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)members.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    InputSection&lt;E&gt; &amp;isec = *members[i];</span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; isec.p2align) &lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r : isec.<span class="built_in">get_rels</span>(ctx))</span><br><span class="line">      <span class="keyword">if</span> (r.r_type == E::R_ABS &amp;&amp; (r.r_offset % <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (Symbol&lt;E&gt; &amp;sym = *isec.file.symbols[r.r_sym];</span><br><span class="line">            !sym.<span class="built_in">is_absolute</span>() &amp;&amp; !sym.is_imported)</span><br><span class="line">          shards[i].<span class="built_in">push_back</span>(isec.offset + r.r_offset);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compress them</span></span><br><span class="line">  std::vector&lt;u64&gt; pos = <span class="built_in">flatten</span>(shards);</span><br><span class="line">  relr = <span class="built_in">encode_relr</span>(pos, <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要讲的是开头是否为pic的判断</p><blockquote><p>–pie, –pic-executable Create a position independent executable<br>–no-pie, –no-pic-executable</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_flag</span>(<span class="string">&quot;pie&quot;</span>) || <span class="built_in">read_flag</span>(<span class="string">&quot;pic-executable&quot;</span>)) &#123;</span><br><span class="line">  ctx.arg.pic = <span class="literal">true</span>;</span><br><span class="line">  ctx.arg.pie = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">read_flag</span>(<span class="string">&quot;no-pie&quot;</span>) || <span class="built_in">read_flag</span>(<span class="string">&quot;no-pic-executable&quot;</span>)) &#123;</span><br><span class="line">  ctx.arg.pic = <span class="literal">false</span>;</span><br><span class="line">  ctx.arg.pie = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>有两个概念，pic和pie</p><p>pic：position-independent code</p><p>pie：position-independent executable</p><p>pic和pie是看似类似却是完全冲突的两个选项。</p><p>pie是生成位置无关的可执行程序，所有变量（静态和全局变量，或者说局部变量外的变量）的地址在executable中已经确定，由于这个位置确定因此不需要got表，尽管地址确定但是executable可以加载到任意地址，因为确定的是executable的内部偏移。</p><p>而pic通常是一个动态库，在运行时可以加载到任意位置，也就是说相对于加载这个pic库的executable的地址也是未知的，可能加载到前面，也可能加载到后面，确定的地址只有相对于这个pic库内部起始地址的偏移，因此需要利用got中的信息再计算具体加载后的地址。</p><p>看到这些内容也就明白为什么不是pic的话就返回了，因为pie的话并不需要进行重定位来支持动态加载</p><h2 id="got"><a href="#got" class="headerlink" title="got"></a>got</h2><p>got(global offset table)，保存了global符号的内存地址，比如说function或者全局变量，用于运行时重定位来解析这些地址。程序首次运行时got被初始化为未解析的地址，调用函数的时候通过rel.plt/rela.plt解析对应符号的地址，之后地址会被保存到got，供下次解析使用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> GotSection&lt;E&gt;::<span class="built_in">construct_relr</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(ctx.arg.pack_dyn_relocs_relr);</span><br><span class="line"></span><br><span class="line">  std::vector&lt;u64&gt; pos;</span><br><span class="line">  <span class="keyword">for</span> (GotEntry&lt;E&gt; &amp;ent : <span class="built_in">get_got_entries</span>(ctx))</span><br><span class="line">    <span class="keyword">if</span> (ent.<span class="built_in">is_relr</span>(ctx))</span><br><span class="line">      pos.<span class="built_in">push_back</span>(ent.idx * <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line"></span><br><span class="line">  relr = <span class="built_in">encode_relr</span>(pos, <span class="built_in"><span class="keyword">sizeof</span></span>(Word&lt;E&gt;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get-got-entries"><a href="#get-got-entries" class="headerlink" title="get_got_entries"></a>get_got_entries</h3><p>这个过程主要是从各个位置获取GotEntry</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GotEntry</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_relr</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> r_type == E::R_RELATIVE &amp;&amp; ctx.arg.pack_dyn_relocs_relr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  i64 idx = <span class="number">0</span>;</span><br><span class="line">  u64 val = <span class="number">0</span>;</span><br><span class="line">  i64 r_type = R_NONE;</span><br><span class="line">  Symbol&lt;E&gt; *sym = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于rel_type</p><blockquote><p>Relocation entries describe how to alter the following instruction and data fields (bit numbers appear in the lower box corners).</p></blockquote><p>这里提前引用部分elf spec中提到的在i386中下面会用到的几种rel type的含义</p><p>R*_386_GLOB_DAT*</p><blockquote><p><em>This relocation type is used to set a global offset table entry to the address of the specified symbol. The special relocation type allows one to determine the correspondence between symbols and global offset table entries.</em></p></blockquote><p><em>R_386_RELATIVE</em></p><blockquote><p><em>The link editor creates this relocation type for dynamic linking. Its offset member gives a location within a shared object that contains a value representing a relative address. The dynamic linker computes the corresponding virtual address by adding the virtual address at which the shared object was loaded to the relative address. Relocation entries for this type must specify 0 for the symbol table index.</em></p></blockquote><p>关于其他的rel type参考信息</p><p><a class="link"   href="https://docs.oracle.com/cd/E19683-01/817-3677/x-j1h4h/index.html" >https://docs.oracle.com/cd/E19683-01/817-3677/x-j1h4h/index.html<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>A R_386_TLS_TPOFF relocation is left outstanding against the GOT table for the runtime linker to fill in with the static TLS offset for symbol x.</p></blockquote><ol><li><p>ordinary symbols</p><ol><li><p>针对imported的符号：需要dynamic linker resolve，因此rel_type设置为GLOB_DAT。同时链接时地址未知，因此地址为0</p></li><li><p>ifunc的符号，通常需要dynamic linker fix up，因此rel_type为R_IRELATIVE</p><p>ifun: 间接函数。支持对一个函数创建多个实现，通过自己编写的resolver在运行时选择实现</p><p><a class="link"   href="http://sourceware.org/glibc/wiki/GNU_IFUNC" >http://sourceware.org/glibc/wiki/GNU_IFUNC<i class="fas fa-external-link-alt"></i></a></p></li><li><p>pic且relative的情况，需要rel_type为R_IRELATIVE，否则不需要rel_type</p></li></ol><p>针对ordinary symbols获取地址时都是NO_PLT的，因为都是已知实现和地址，不需要动态链接。</p></li><li><p>TLVs</p><p>TLV: thread local variarble</p><p>根据是否为static的情况做不同的处理，是否为static由这两个编译选项所控制</p><blockquote><p>–Bdynamic, –dy Link against shared libraries (default)<br>–Bstatic, –dn, –static Do not link against shared libraries</p></blockquote></li><li><p>tls</p><ol><li>针对符号是否为_TLS_MODULE_BASE_进行处理，唯一的区别是是否将符号关联进去，但是两者都需要设置rel_type为TLS_DESC</li></ol></li><li><p>gottp_syms</p><p>tp: thread pointer</p><ol><li>imported，这种符号所有信息未知，需要dynamic linker填充got entry，rel_type为R_TPOFF</li><li>shared，知道offset，需要dynamic linker调整，rel_type为R_TPOFF</li><li>other，链接时知道相对于tp的offset，所以能直接填写got entry</li></ol></li><li><p>tlsld_idx</p><ol><li>是否为static。static的情况下不需要rel，同时设置地址为1（表示main executable)否则需要设置rel为R_DTPMOD</li></ol></li></ol><p>总结一下</p><p>不需要设置rel_type的情况如下</p><ol><li>ordinary symbol，pic且非relative符号的情况下，也就是说非pic或者pic但是没有relative符号（即不需要重定位）的情况下），不需要设置rel_type</li><li>TLVS为static的情况下不需要设置rel_type</li><li>非shared以及imported的gottp symbol</li><li>tlsld_idx不为1且是static的情况</li></ol><p>不过这里我有一个不明白的地方，为什么不需要rel_type的符号会在got中。查到的答案是</p><ol><li>作为函数的间接跳转入口:<br>所有函数,包括不需要重定位的函数,在第一次调用时都需要通过.got表来间接跳转。即使函数在链接时就已经获得了绝对地址,但仍需要通过.got表调用。</li><li>访问全局变量:<br>程序中所有全局变量,包括不需要重定位的变量,都需要通过基址寄存器加上.got中的偏移量来访问。<br>即使变量的值在链接时就已经确定,但程序仍需要通过.got表访问。</li><li>作为函数指针:<br>函数的地址可以被用作函数指针。而所有的函数指针,包括指向不需要重定位的函数的函数指针,都需要通过.got表来存取。</li><li>链接器的要求:<br>链接器要求所有函数和变量,无论是否需要重定位,都需要一个.got表项。这样它才能在程序加载时准确构建.got表。</li><li>兼容性考虑:<br>加入所有符号大大提高程序的兼容性。如果后续添加了需要重定位的符号,程序无需任何改动。<br>所以,总之,.got表中的所有符号都是程序加载时解析的。<br>即使符号不需要重定位,但仍需要通过.got表间接存取。主要是作为函数入口和变量、函数指针的访问入口。<br>另外链接器及兼容性的要求也促使符号加入.got表。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get .got and .rel.dyn contents.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// .got is a linker-synthesized constant pool whose entry is of pointer</span></span><br><span class="line"><span class="comment">// size. If we know a correct value for an entry, we&#x27;ll just set that value</span></span><br><span class="line"><span class="comment">// to the entry. Otherwise, we&#x27;ll create a dynamic relocation and let the</span></span><br><span class="line"><span class="comment">// dynamic linker to fill the entry at load-time.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Most GOT entries contain addresses of global variable. If a global</span></span><br><span class="line"><span class="comment">// variable is an imported symbol, we don&#x27;t know its address until runtime.</span></span><br><span class="line"><span class="comment">// GOT contains the addresses of such variables at runtime so that we can</span></span><br><span class="line"><span class="comment">// access imported global variables via GOT.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Thread-local variables (TLVs) also use GOT entries. We need them because</span></span><br><span class="line"><span class="comment">// TLVs are accessed in a different way than the ordinary global variables.</span></span><br><span class="line"><span class="comment">// Their addresses are not unique; each thread has its own copy of TLVs.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::vector&lt;GotEntry&lt;E&gt;&gt; <span class="built_in">get_got_entries</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  std::vector&lt;GotEntry&lt;E&gt;&gt; entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create GOT entries for ordinary symbols</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;got_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_got_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a symbol is imported, let the dynamic linker to resolve it.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_GLOB_DAT, sym&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IFUNC always needs to be fixed up by the dynamic linker.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;<span class="built_in">is_ifunc</span>()) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT), E::R_IRELATIVE&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know an address at link-time, fill that GOT entry now.</span></span><br><span class="line">    <span class="comment">// It may need a base relocation, though.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.pic &amp;&amp; sym-&gt;<span class="built_in">is_relative</span>())</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT), E::R_RELATIVE&#125;);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx, NO_PLT)&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create GOT entries for TLVs.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;tlsgd_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_tlsgd_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.is_static) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">1</span>&#125;); <span class="comment">// One indicates the main executable file</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx + <span class="number">1</span>, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.dtp_addr&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_DTPMOD, sym&#125;);</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx + <span class="number">1</span>, <span class="number">0</span>, E::R_DTPOFF, sym&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(supports_tlsdesc&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;tlsdesc_syms) &#123;</span><br><span class="line">      <span class="comment">// _TLS_MODULE_BASE_ is a linker-synthesized virtual symbol that</span></span><br><span class="line">      <span class="comment">// refers the begining of the TLS block.</span></span><br><span class="line">      <span class="keyword">if</span> (sym == ctx._TLS_MODULE_BASE_)</span><br><span class="line">        entries.<span class="built_in">push_back</span>(&#123;sym-&gt;<span class="built_in">get_tlsdesc_idx</span>(ctx), <span class="number">0</span>, E::R_TLSDESC&#125;);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        entries.<span class="built_in">push_back</span>(&#123;sym-&gt;<span class="built_in">get_tlsdesc_idx</span>(ctx), <span class="number">0</span>, E::R_TLSDESC, sym&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : ctx.got-&gt;gottp_syms) &#123;</span><br><span class="line">    i64 idx = sym-&gt;<span class="built_in">get_gottp_idx</span>(ctx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know nothing about the symbol, let the dynamic linker</span></span><br><span class="line">    <span class="comment">// to fill the GOT entry.</span></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, <span class="number">0</span>, E::R_TPOFF, sym&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we know the offset within the current thread vector,</span></span><br><span class="line">    <span class="comment">// let the dynamic linker to adjust it.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared) &#123;</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.tls_begin, E::R_TPOFF&#125;);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, we know the offset from the thread pointer (TP) at</span></span><br><span class="line">    <span class="comment">// link-time, so we can fill the GOT entry directly.</span></span><br><span class="line">    entries.<span class="built_in">push_back</span>(&#123;idx, sym-&gt;<span class="built_in">get_addr</span>(ctx) - ctx.tp_addr&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.got-&gt;tlsld_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.is_static)</span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;ctx.got-&gt;tlsld_idx, <span class="number">1</span>&#125;); <span class="comment">// 1 means the main executable</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      entries.<span class="built_in">push_back</span>(&#123;ctx.got-&gt;tlsld_idx, <span class="number">0</span>, E::R_DTPMOD&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-addr"><a href="#get-addr" class="headerlink" title="get_addr"></a>get_addr</h2><p>这个函数是确定地址的过程。</p><p>首先说明PLT（Procedure Linkage Table），用于存放函数调用的跳转指令。主要用于提供函数入口点，实现间接调用。第一次调用对应函数时plt段被链接器处理，链接到函数的真实地址，也就是GOT中存放的具体值。</p><p>比如说某些符号在链接的时候是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call fun@PLT</span><br></pre></td></tr></table></figure><p>当调用fun后，这里的代码就会变成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call *foo@GOT</span><br></pre></td></tr></table></figure><p>另外是absolute符号，简单来说就是有一个固定的绝对地址的符号，因此可以直接获得其地址</p><p><a class="link"   href="https://stackoverflow.com/questions/33324076/what-is-absolute-symbol-and-how-to-define-it-in-c" >https://stackoverflow.com/questions/33324076/what-is-absolute-symbol-and-how-to-define-it-in-c<i class="fas fa-external-link-alt"></i></a></p><ol><li>针对frag，非alive则是0，否则从frag中获取地址，</li><li>has copy rel，去从ctx中的copy_rel获取基地址</li><li>PPC64</li><li>plt，直接get_plt_addr</li><li>input section为空，absolute符号直接返回value的地址</li><li>input section非alive的情况<ol><li>killed by icf，从leader中获取地址</li><li>eh_frame，根据符号名获取eh_frame中对应位置的地址</li><li>否则返回0</li></ol></li><li>普通的input section，直接isec→get_addr + value</li></ol><p>下面代码中出现的value的含义如下，属于Symbol的成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `value` contains symbol value. If it&#x27;s an absolute symbol, it is</span></span><br><span class="line"><span class="comment">// equivalent to its address. If it belongs to an input section or a</span></span><br><span class="line"><span class="comment">// section fragment, value is added to the base of the input section</span></span><br><span class="line"><span class="comment">// to yield an address.</span></span><br><span class="line"><span class="comment">// u64 value = 0;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 SectionFragment&lt;E&gt;::<span class="built_in">get_addr</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> output_section.shdr.sh_addr + offset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `value` contains symbol value. If it&#x27;s an absolute symbol, it is</span></span><br><span class="line"><span class="comment">// equivalent to its address. If it belongs to an input section or a</span></span><br><span class="line"><span class="comment">// section fragment, value is added to the base of the input section</span></span><br><span class="line"><span class="comment">// to yield an address.</span></span><br><span class="line"><span class="comment">// u64 value = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 Symbol&lt;E&gt;::<span class="built_in">get_plt_addr</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (i32 idx = <span class="built_in">get_plt_idx</span>(ctx); idx != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> ctx.plt-&gt;shdr.sh_addr + E::plt_hdr_size + idx * E::plt_size;</span><br><span class="line">  <span class="keyword">return</span> ctx.pltgot-&gt;shdr.sh_addr + <span class="built_in">get_pltgot_idx</span>(ctx) * E::pltgot_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> i32 Symbol&lt;E&gt;::<span class="built_in">get_pltgot_idx</span>(Context&lt;E&gt; &amp;ctx) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (aux_idx == <span class="number">-1</span>) ? <span class="number">-1</span> : ctx.symbol_aux[aux_idx].pltgot_idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> InputSection&lt;E&gt;::<span class="built_in">is_killed_by_icf</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;leader &amp;&amp; <span class="keyword">this</span>-&gt;leader != <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> u64 Symbol&lt;E&gt;::<span class="built_in">get_addr</span>(Context&lt;E&gt; &amp;ctx, i64 flags) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = <span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!frag-&gt;is_alive) &#123;</span><br><span class="line">      <span class="comment">// This condition is met if a non-alloc section refers an</span></span><br><span class="line">      <span class="comment">// alloc section and if the referenced piece of data is</span></span><br><span class="line">      <span class="comment">// garbage-collected. Typically, this condition occurs if a</span></span><br><span class="line">      <span class="comment">// debug info section refers a string constant in .rodata.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frag-&gt;<span class="built_in">get_addr</span>(ctx) + value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has_copyrel) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyrel_readonly</span><br><span class="line">      ? ctx.copyrel_relro-&gt;shdr.sh_addr + value</span><br><span class="line">      : ctx.copyrel-&gt;shdr.sh_addr + value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(!(flags &amp; NO_OPD) &amp;&amp; has_opd(ctx))</span></span></span><br><span class="line"><span class="function">      <span class="keyword">return</span> <span class="title">get_opd_addr</span><span class="params">(ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; NO_PLT) &amp;&amp; <span class="built_in">has_plt</span>(ctx)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(is_imported || <span class="built_in">is_ifunc</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_plt_addr</span>(ctx);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  InputSection&lt;E&gt; *isec = <span class="built_in">get_input_section</span>();</span><br><span class="line">  <span class="keyword">if</span> (!isec)</span><br><span class="line">    <span class="keyword">return</span> value; <span class="comment">// absolute symbol</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isec-&gt;is_alive) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isec-&gt;<span class="built_in">is_killed_by_icf</span>())</span><br><span class="line">      <span class="keyword">return</span> isec-&gt;leader-&gt;<span class="built_in">get_addr</span>() + value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isec-&gt;<span class="built_in">name</span>() == <span class="string">&quot;.eh_frame&quot;</span>) &#123;</span><br><span class="line">      <span class="comment">// .eh_frame contents are parsed and reconstructed by the linker,</span></span><br><span class="line">      <span class="comment">// so pointing to a specific location in a source .eh_frame</span></span><br><span class="line">      <span class="comment">// section doesn&#x27;t make much sense. However, CRT files contain</span></span><br><span class="line">      <span class="comment">// symbols pointing to the very beginning and ending of the section.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_BEGIN__&quot;</span> || <span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_LIST__&quot;</span> ||</span><br><span class="line">          <span class="built_in">name</span>() == <span class="string">&quot;.eh_frame_seg&quot;</span> || <span class="built_in">esym</span>().st_type == STT_SECTION)</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;__FRAME_END__&quot;</span> || <span class="built_in">name</span>() == <span class="string">&quot;__EH_FRAME_LIST_END__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr + ctx.eh_frame-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// ARM object files contain &quot;$d&quot; local symbol at the beginning</span></span><br><span class="line">      <span class="comment">// of data sections. Their values are not significant for .eh_frame,</span></span><br><span class="line">      <span class="comment">// so we just treat them as offset 0.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">name</span>() == <span class="string">&quot;$d&quot;</span> || <span class="built_in">name</span>().<span class="built_in">starts_with</span>(<span class="string">&quot;$d.&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> ctx.eh_frame-&gt;shdr.sh_addr;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;symbol referring .eh_frame is not supported: &quot;</span></span><br><span class="line">                 &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The control can reach here if there&#x27;s a relocation that refers</span></span><br><span class="line">    <span class="comment">// a local symbol belonging to a comdat group section. This is a</span></span><br><span class="line">    <span class="comment">// violation of the spec, as all relocations should use only global</span></span><br><span class="line">    <span class="comment">// symbols of comdat members. However, .eh_frame tends to have such</span></span><br><span class="line">    <span class="comment">// relocations.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> isec-&gt;<span class="built_in">get_addr</span>() + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="dynsym-finalize"><a href="#dynsym-finalize" class="headerlink" title="dynsym finalize"></a>dynsym finalize</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reserve a space for dynamic symbol strings in .dynstr and sort</span></span><br><span class="line"><span class="comment">// .dynsym contents if necessary. Beyond this point, no symbol will</span></span><br><span class="line"><span class="comment">// be added to .dynsym.</span></span><br><span class="line">ctx.dynsym-&gt;<span class="built_in">finalize</span>(ctx);</span><br></pre></td></tr></table></figure><p>为dynamic symbol的字符串在dynstr中留出空间，并且排序dynsym的内容。在这之后不会有符号被加入到dynsym，因此这里dynstr section的大小以及排布确定下来了。</p><p>具体的处理过程如下</p><ol><li>symbols排序，local在前global在后，和elf中的格式一样。</li><li>处理gnu_hash的情况</li><li>设置dynsym_offset后计算dynstr的size</li><li>更新DynsymSection的shdr的信息</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> DynsymSection&lt;E&gt;::<span class="built_in">finalize</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;DynsymSection::finalize&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (symbols.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort symbols. In any symtab, local symbols must precede global symbols.</span></span><br><span class="line">  <span class="keyword">auto</span> first_global = std::<span class="built_in">stable_partition</span>(symbols.<span class="built_in">begin</span>() + <span class="number">1</span>, symbols.<span class="built_in">end</span>(),</span><br><span class="line">                                            [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">return</span> sym-&gt;<span class="built_in">is_local</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We also place undefined symbols before defined symbols for .gnu.hash.</span></span><br><span class="line">  <span class="comment">// Defined symbols are sorted by their hashes for .gnu.hash.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.gnu_hash) &#123;</span><br><span class="line">    <span class="comment">// Count the number of exported symbols to compute the size of .gnu.hash.</span></span><br><span class="line">    i64 num_exported = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; symbols.<span class="built_in">size</span>(); i++)</span><br><span class="line">      <span class="keyword">if</span> (symbols[i]-&gt;is_exported)</span><br><span class="line">        num_exported++;</span><br><span class="line"></span><br><span class="line">    u32 num_buckets = num_exported / ctx.gnu_hash-&gt;LOAD_FACTOR + <span class="number">1</span>;</span><br><span class="line">    ctx.gnu_hash-&gt;num_buckets = num_buckets;</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for</span>((i64)(first_global - symbols.<span class="built_in">begin</span>()), (i64)symbols.<span class="built_in">size</span>(),</span><br><span class="line">                      [&amp;](i64 i) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *symbols[i];</span><br><span class="line">      sym.<span class="built_in">set_dynsym_idx</span>(ctx, i);</span><br><span class="line">      sym.<span class="built_in">set_djb_hash</span>(ctx, <span class="built_in">djb_hash</span>(sym.<span class="built_in">name</span>()));</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_sort</span>(first_global, symbols.<span class="built_in">end</span>(),</span><br><span class="line">                       [&amp;](Symbol&lt;E&gt; *a, Symbol&lt;E&gt; *b) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a-&gt;is_exported != b-&gt;is_exported)</span><br><span class="line">        <span class="keyword">return</span> b-&gt;is_exported;</span><br><span class="line"></span><br><span class="line">      u32 h1 = a-&gt;<span class="built_in">get_djb_hash</span>(ctx) % num_buckets;</span><br><span class="line">      u32 h2 = b-&gt;<span class="built_in">get_djb_hash</span>(ctx) % num_buckets;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">tuple</span>(h1, a-&gt;<span class="built_in">get_dynsym_idx</span>(ctx)) &lt;</span><br><span class="line">             std::<span class="built_in">tuple</span>(h2, b-&gt;<span class="built_in">get_dynsym_idx</span>(ctx));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compute .dynstr size</span></span><br><span class="line">  ctx.dynstr-&gt;dynsym_offset = ctx.dynstr-&gt;shdr.sh_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    symbols[i]-&gt;<span class="built_in">set_dynsym_idx</span>(ctx, i);</span><br><span class="line">    ctx.dynstr-&gt;shdr.sh_size += symbols[i]-&gt;<span class="built_in">name</span>().<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ELF&#x27;s symbol table sh_info holds the offset of the first global symbol.</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_info = first_global - symbols.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Symbol&lt;E&gt;::<span class="built_in">set_dynsym_idx</span>(Context&lt;E&gt; &amp;ctx, i32 idx) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(aux_idx != <span class="number">-1</span>);</span><br><span class="line">  ctx.symbol_aux[aux_idx].dynsym_idx = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的ctx.symbol_aux[aux_idx].dynsym_idx是在之前的scan_relocations的过程中设置的，对应的dynsym_idx默认为-1</p><h1 id="report-undef-error"><a href="#report-undef-error" class="headerlink" title="report_undef_error"></a>report_undef_error</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Print reports about undefined symbols, if needed.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_ERROR)</span><br><span class="line">  <span class="built_in">report_undef_errors</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Report all undefined symbols, grouped by symbol.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">report_undef_errors</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> i64 max_errors = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pair : ctx.undef_errors) &#123;</span><br><span class="line">    std::string_view sym_name = pair.first;</span><br><span class="line">    std::span&lt;std::string&gt; errors = pair.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.demangle)</span><br><span class="line">      sym_name = <span class="built_in">demangle</span>(sym_name);</span><br><span class="line"></span><br><span class="line">    std::stringstream ss;</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;undefined symbol: &quot;</span> &lt;&lt; sym_name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; errors.<span class="built_in">size</span>() &amp;&amp; i &lt; max_errors; i++)</span><br><span class="line">      ss &lt;&lt; errors[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (errors.<span class="built_in">size</span>() &gt; max_errors)</span><br><span class="line">      ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced &quot;</span> &lt;&lt; (errors.<span class="built_in">size</span>() - max_errors) &lt;&lt; <span class="string">&quot; more times\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_ERROR)</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_WARN)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; ss.<span class="built_in">str</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报告之前在claim_unresolved_symbols中收集的undef的错误信息</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-11-rel-an</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
    <category term="got" scheme="https://fusionbolt.github.io/tags/got/"/>
    
    <category term="rel" scheme="https://fusionbolt.github.io/tags/rel/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读十 段排序</title>
    <link href="https://fusionbolt.github.io/2023/06/24/mold/mold-10-sort-section/"/>
    <id>https://fusionbolt.github.io/2023/06/24/mold/mold-10-sort-section/</id>
    <published>2023-06-24T12:39:10.000Z</published>
    <updated>2023-06-24T13:29:25.093Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:76218989</center> <h1 id="段排序"><a href="#段排序" class="headerlink" title="段排序"></a>段排序</h1><p>本篇文章提到的mold中出现的段排序，包含了一个chunk内的段与段的排序，还包含了chunk与chunk之间的排序。或者也可以说是对于输入角度来看待的排序，以及从输出角度看待的段进行排序。对于输入来讲，段的基本单位是InputSection，比如说一个输入文件中的一个text段，而对于输出来讲，也就是目标文件来讲，段的基本单位是一个chunk，而一个chunk是由多个输入的段组成的，比如说大的text段是由所有的输入文件中的text段组合而成。</p><p>首先要说明为什么需要进行排序</p><p>sort_init_fini，sort_ctor_dtor以及shuffle_sections属于chunk内的段与段之间的排序，在这里来说是为了满足mold的特殊需求。不过完全随机以及reverse的shuffle我还是不明白为什么需要这样来做。对于init这样的段来说，链接器需要将所有输入文件的同名段合并到同一个输出段中，因此必须要在chunk内的段与段之间的排序。</p><p>sort_output_sections属于chunk与chunk之间的排序，这里排序的目的很大一部分是为了满足特定规则的需要，不论是regular顺序的还是指定的顺序都会使得ehdr/phdr在最前，而shdr在最后。</p><p>对于中间灵活可变的部分，和对齐以及跳转指令都有关系。跳转指令这个问题我在实际遇到过，JAL指令的立即数字段的长度是固定的，而所要跳转的地址超出了JAL这个字段所能代表的长度，最后通过修改链接脚本中相关段的顺序使得地址控制在了立即数的范围之内。</p><h1 id="sort-init-fini"><a href="#sort-init-fini" class="headerlink" title="sort_init_fini"></a>sort_init_fini</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_init_fini</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_init_fini&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_priority = [](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::regex <span class="built_in">re</span>(<span class="string">R&quot;(\.(\d+)$)&quot;</span>, std::regex_constants::optimize);</span><br><span class="line">    std::string_view name = isec-&gt;<span class="built_in">name</span>();</span><br><span class="line">    std::cmatch m;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(name.<span class="built_in">data</span>(), name.<span class="built_in">data</span>() + name.<span class="built_in">size</span>(), m, re))</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">stoi</span>(m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (osec-&gt;name == <span class="string">&quot;.init_array&quot;</span> || osec-&gt;name == <span class="string">&quot;.preinit_array&quot;</span> ||</span><br><span class="line">          osec-&gt;name == <span class="string">&quot;.fini_array&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.shuffle_sections == SHUFFLE_SECTIONS_REVERSE)</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(osec-&gt;members, [&amp;](InputSection&lt;E&gt; *a, InputSection&lt;E&gt; *b) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get_priority</span>(a) &lt; <span class="built_in">get_priority</span>(b);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有的chunk转换为OutputSection，其中对init_array，preinit_array，fini_array段的所有成员按照priority进行排序。</p><blockquote><p>–shuffle-sections[=SEED]   Randomize the output by shuffling input sections</p></blockquote><p>关于init以及后面ctor相关的段，参考maskray聚聚的博客</p><p><a class="link"   href="https://maskray.me/blog/2021-11-07-init-ctors-init-array" >.init, .ctors, and .init_array<i class="fas fa-external-link-alt"></i></a></p><p>其中有这样一段示例汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.section.text.startup,&quot;ax&quot;,@progbits</span><br><span class="line">_GLOBAL__sub_I_a.cc:</span><br><span class="line">  callq_Znwm</span><br><span class="line">  callq_ZN1SC1Ev</span><br><span class="line">  callqgetpid</span><br><span class="line"></span><br><span class="line">.section.init_array.101,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors.65434,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z7init101v</span><br><span class="line"></span><br><span class="line">.section.init_array.102,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors.65433,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z7init102v</span><br><span class="line"></span><br><span class="line">.section.init_array,&quot;aw&quot;,@init_array</span><br><span class="line">## legacy: .section .ctors,&quot;aw&quot;,@progbits</span><br><span class="line">.p2align3</span><br><span class="line">.quad_Z4initv</span><br><span class="line">.quad_GLOBAL__sub_I_a.cc</span><br></pre></td></tr></table></figure><p>这里面的init_array根据不同的priority增加不同的后缀数字，而这里的排序正是针对这些</p><h1 id="sort-ctor-dtor"><a href="#sort-ctor-dtor" class="headerlink" title="sort_ctor_dtor"></a>sort_ctor_dtor</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_ctor_dtor</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sort_ctor_dtor&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_priority = [](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">auto</span> opts = std::regex_constants::optimize | std::regex_constants::ECMAScript;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re1</span><span class="params">(<span class="string">R&quot;((?:clang_rt\.)?crtbegin)&quot;</span>, opts)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re2</span><span class="params">(<span class="string">R&quot;((?:clang_rt\.)?crtend)&quot;</span>, opts)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> std::regex <span class="title">re3</span><span class="params">(<span class="string">R&quot;(\.(\d+)$)&quot;</span>, opts)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// crtbegin.o and crtend.o contain marker symbols such as</span></span><br><span class="line">    <span class="comment">// __CTOR_LIST__ or __DTOR_LIST__. So they have to be at the</span></span><br><span class="line">    <span class="comment">// beginning or end of the section.</span></span><br><span class="line">    std::smatch m;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(isec-&gt;file.filename, m, re1))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(isec-&gt;file.filename, m, re2))</span><br><span class="line">      <span class="keyword">return</span> <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">(isec-&gt;name())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (std::<span class="built_in">regex_search</span>(name, m, re3))</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">stoi</span>(m[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (osec-&gt;name == <span class="string">&quot;.ctors&quot;</span> || osec-&gt;name == <span class="string">&quot;.dtors&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.shuffle_sections != SHUFFLE_SECTIONS_REVERSE)</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(osec-&gt;members, [&amp;](InputSection&lt;E&gt; *a, InputSection&lt;E&gt; *b) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">get_priority</span>(a) &lt; <span class="built_in">get_priority</span>(b);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和sort init类似的逻辑，除了priority的计算方式不同。这里针对了clang_rt的crtbegin和crtend做了特殊的处理，最后再对其余的按照编号进行排序。</p><h1 id="shuffle-sections"><a href="#shuffle-sections" class="headerlink" title="shuffle_sections"></a>shuffle_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --shuffle-sections</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.shuffle_sections != SHUFFLE_SECTIONS_NONE)</span><br><span class="line">  <span class="built_in">shuffle_sections</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>-shuffle-sections[=SEED] Randomize the output by shuffling input sections</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;shuffle_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> is_eligible = [](OutputSection&lt;E&gt; &amp;osec) &#123;</span><br><span class="line">    <span class="keyword">return</span> osec.name != <span class="string">&quot;.init&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.fini&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.ctors&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.dtors&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.init_array&quot;</span> &amp;&amp; osec.name != <span class="string">&quot;.preinit_array&quot;</span> &amp;&amp;</span><br><span class="line">           osec.name != <span class="string">&quot;.fini_array&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (ctx.arg.shuffle_sections) &#123;</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_NONE:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_SHUFFLE: &#123;</span><br><span class="line">    u64 seed;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shuffle_sections_seed)</span><br><span class="line">      seed = *ctx.arg.shuffle_sections_seed;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      seed = ((u64)std::<span class="built_in">random_device</span>()() &lt;&lt; <span class="number">32</span>) | std::<span class="built_in">random_device</span>()();</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_eligible</span>(*osec))</span><br><span class="line">          <span class="built_in">shuffle</span>(osec-&gt;members, seed + <span class="built_in">hash_string</span>(osec-&gt;name));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> SHUFFLE_SECTIONS_REVERSE:</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">is_eligible</span>(*osec))</span><br><span class="line">          std::<span class="built_in">reverse</span>(osec-&gt;members.<span class="built_in">begin</span>(), osec-&gt;members.<span class="built_in">end</span>());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里跳过了上面sort_init_fini以及sort_ctor_dtor的特殊段，对剩下段的members根据shuffle_sections选项进行shuffle或者reverse</p><h1 id="copy-str"><a href="#copy-str" class="headerlink" title="copy str"></a>copy str</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy string referred by .dynamic to .dynstr.</span></span><br><span class="line"><span class="keyword">for</span> (SharedFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(file-&gt;soname);</span><br><span class="line"><span class="keyword">for</span> (std::string_view str : ctx.arg.auxiliary)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(str);</span><br><span class="line"><span class="keyword">for</span> (std::string_view str : ctx.arg.filter)</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(str);</span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.rpaths.<span class="built_in">empty</span>())</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(ctx.arg.rpaths);</span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.soname.<span class="built_in">empty</span>())</span><br><span class="line">  ctx.dynstr-&gt;<span class="built_in">add_string</span>(ctx.arg.soname);</span><br></pre></td></tr></table></figure><p>拷贝所有动态库所需要用的字符串到dynstr中，主要是soname和一些路径之类的信息，而这些信息只是通过段合并是无法添加到dynstr中的，因为这些属于链接时的信息，无法通过链接输入的编译产物获取。</p><p>关于这几个链接选项的介绍</p><blockquote><p>-f SHLIB, –auxiliary SHLIB Set DT_AUXILIARY to the specified value</p></blockquote><blockquote><p>-F LIBNAME, –filter LIBNAME<br>Set DT_FILTER to the specified value</p></blockquote><blockquote><p>–rpath DIR                 Add DIR to runtime search path</p></blockquote><blockquote><p>h LIBNAME, –soname LIBNAME Set shared library name</p></blockquote><h1 id="scan-relocations"><a href="#scan-relocations" class="headerlink" title="scan_relocations"></a>scan_relocations</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Scan relocations to find symbols that need entries in .got, .plt,</span></span><br><span class="line"><span class="comment">// .got.plt, .dynsym, .dynstr, etc.</span></span><br><span class="line"><span class="built_in">scan_relocations</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;scan_relocations&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations to find dynamic symbols.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证输出文件中的got和plt等section包含对应rel的信息，递归所有所有的rel找到在got和plt中需要的符号，并且添加到got/plt中。而got和plt本身就是synthetic的段，无法从编译产物中获取，只能在链接的时候产生，为了确保rel段符号的正确查找，一定需要这一步骤。</p><p>这里主要做了三部分</p><ol><li>扫描每个obj里所有段中的符号，另外标记rel段中要处理的符合条件的符号为NEEDS_PLT</li><li>将flag不为空，或者是imported/exported的符号保留，过滤掉其他符号</li><li>对过滤后的符号，根据其flga添加到对应的chunk中，比如说got或者plt等，最后再清空其flag</li></ol><h2 id="rel-scan"><a href="#rel-scan" class="headerlink" title="rel scan"></a>rel scan</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;scan_relocations&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations to find dynamic symbols.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Exit if there was a relocation that refers an undefined symbol.</span></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每个obj进行scan_relocations</p><h3 id="object-file"><a href="#object-file" class="headerlink" title="object file"></a>object file</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">scan_relocations</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Scan relocations against seciton contents</span></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : sections)</span><br><span class="line">    <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; (isec-&gt;<span class="built_in">shdr</span>().sh_flags &amp; SHF_ALLOC))</span><br><span class="line">      isec-&gt;<span class="built_in">scan_relocations</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Scan relocations against exception frames</span></span><br><span class="line">  <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : cies) &#123;</span><br><span class="line">    <span class="keyword">for</span> (ElfRel&lt;E&gt; &amp;rel : cie.<span class="built_in">get_rels</span>()) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym.is_imported) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() != STT_FUNC)</span><br><span class="line">          <span class="built_in">Fatal</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sym</span><br><span class="line">                     &lt;&lt; <span class="string">&quot;: .eh_frame CIE record with an external data reference&quot;</span></span><br><span class="line">                     &lt;&lt; <span class="string">&quot; is not supported&quot;</span>;</span><br><span class="line">        sym.flags |= NEEDS_PLT;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲InputSection之前先看一下CIE的部分。CIE的代码中也会包含rel的部分。</p><h3 id="InputSection"><a href="#InputSection" class="headerlink" title="InputSection"></a>InputSection</h3><p>isec-&gt;scan_relocations(ctx);</p><p>这里针对不同的arch有着不同的特化实现</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled%201.png"                      alt="Untitled"                ></p><p>这里我们拿i386和riscv的实现做对比看一下差异</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-10-sort-section/Untitled%202.png"                      alt="Untitled"                ></p><p>可以看到前面的内容几乎一致，获取rels之后遍历，针对不同的rel type做出不同的处理</p><p>关于riscv的rel type，可以参考这两个链接</p><p><a class="link"   href="https://github.com/riscv-non-isa/riscv-elf-psabi-doc" >https://github.com/riscv-non-isa/riscv-elf-psabi-doc<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://www.risc-v1.com/thread-906-1-1.html" >RISC-V ELF规范和函数调用规范 - 国内芯片技术交流 - RISC-V单片机中文网——全球首家只专注于RISC-V单片机行业应用的中文网站<i class="fas fa-external-link-alt"></i></a></p><p>然后我们看针对不同rel type处理的部分</p><p>本质都是调用了InputSection的一些辅助函数，挑几个看一下。在此之前先补充两个缩写的全拼</p><p>absrel: absolute relocations</p><p>pcrel: PC-relative relocations</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (rel.r_type) &#123;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_32:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(E::is_64)</span></span></span><br><span class="line"><span class="function">      <span class="title">scan_absrel</span><span class="params">(ctx, sym, rel)</span></span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">scan_dyn_absrel</span>(ctx, sym, rel);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_HI20:</span><br><span class="line">    <span class="built_in">scan_absrel</span>(ctx, sym, rel);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> R_RISCV_64:</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!E::is_64)</span></span></span><br><span class="line"><span class="function">      <span class="title">Fatal</span><span class="params">(ctx)</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; &quot;: R_RISCV_64 cannot be used on RV32<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="function">    scan_dyn_absrel(ctx, sym, rel);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_CALL:</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_CALL_PLT:</span></span></span><br><span class="line"><span class="string"><span class="function">    if (sym.is_imported)</span></span></span><br><span class="line"><span class="string"><span class="function">      sym.flags.fetch_or(NEEDS_PLT, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_GOT_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_GOT, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_TLS_GOT_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    ctx.has_gottp_rel.store(true, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_GOTTP, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_TLS_GD_HI20:</span></span></span><br><span class="line"><span class="string"><span class="function">    sym.flags.fetch_or(NEEDS_TLSGD, std::memory_order_relaxed);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br><span class="line"><span class="string"><span class="function">  case R_RISCV_32_PCREL:</span></span></span><br><span class="line"><span class="string"><span class="function">    scan_pcrel(ctx, sym, rel);</span></span></span><br><span class="line"><span class="string"><span class="function">    break;</span></span></span><br></pre></td></tr></table></figure><p>fetch_or是执行按位or运算，可以简单视为 flags |= NEEDS_XXX，相当于更新了flag，前面也说过在这个scan的过程本质就是要更新其flag</p><p>这里主要的内容就是scan_xxx，而这些scan的实现都是调用的scan_rel，区别是传入了不同的action</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_pcrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                 <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_pcrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_absrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                  <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_absrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_dyn_absrel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                      <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_dyn_absrel_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">scan_toc_rel</span>(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span><br><span class="line">                                   <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel) &#123;</span><br><span class="line">  <span class="built_in">scan_rel</span>(ctx, *<span class="keyword">this</span>, sym, rel, <span class="built_in">get_ppc64_toc_action</span>(ctx, sym));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而不同的action则是通过查表的方式来获取。每个不同的类别有着自己的表，将这个表传递给get_rel_action后进行获取。在get_rel_action中则是通过output type和sym type进行查表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_pcrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is for PC-relative relocations (e.g. R_X86_64_PC32).</span></span><br><span class="line">  <span class="comment">// We cannot promote them to dynamic relocations because the dynamic</span></span><br><span class="line">  <span class="comment">// linker generally does not support PC-relative relocations.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  ERROR,    NONE,    ERROR,         PLT    &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  ERROR,    NONE,    COPYREL,       PLT    &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    COPYREL,       CPLT   &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_absrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This is a decision table for absolute relocations that is smaller</span></span><br><span class="line">  <span class="comment">// than the word size (e.g. R_X86_64_32). Since the dynamic linker</span></span><br><span class="line">  <span class="comment">// generally does not support dynamic relocations smaller than the</span></span><br><span class="line">  <span class="comment">// word size, we need to report an error if a relocation cannot be</span></span><br><span class="line">  <span class="comment">// resolved at link-time.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     ERROR,   ERROR,         ERROR &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     ERROR,   ERROR,         ERROR &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    COPYREL,       CPLT  &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_dyn_absrel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">is_ifunc</span>())</span><br><span class="line">    <span class="keyword">return</span> IFUNC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a decision table for absolute relocations for the word</span></span><br><span class="line">  <span class="comment">// size data (e.g. R_X86_64_64). Unlike the absrel_table, we can emit</span></span><br><span class="line">  <span class="comment">// a dynamic relocation if we cannot resolve an address at link-time.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL   &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL   &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    DYN_COPYREL,   DYN_CPLT &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_ppc64_toc_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.<span class="built_in">is_ifunc</span>())</span><br><span class="line">    <span class="keyword">return</span> IFUNC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// As a special case, we do not create copy relocations nor canonical</span></span><br><span class="line">  <span class="comment">// PLTs for .toc sections. PPC64&#x27;s .toc is a compiler-generated</span></span><br><span class="line">  <span class="comment">// GOT-like section, and no user-generated code directly uses values</span></span><br><span class="line">  <span class="comment">// in it.</span></span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">static</span> Action table[<span class="number">3</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="comment">// Absolute  Local    Imported data  Imported code</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL &#125;,  <span class="comment">// Shared object</span></span><br><span class="line">    &#123;  NONE,     BASEREL, DYNREL,        DYNREL &#125;,  <span class="comment">// Position-independent exec</span></span><br><span class="line">    &#123;  NONE,     NONE,    DYNREL,        DYNREL &#125;,  <span class="comment">// Position-dependent exec</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_rel_action</span>(ctx, sym, table);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Action <span class="title">get_rel_action</span><span class="params">(Context&lt;E&gt; &amp;ctx, Symbol&lt;E&gt; &amp;sym,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> Action table[<span class="number">3</span>][<span class="number">4</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> get_output_type = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.pie)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> get_sym_type = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">is_absolute</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!sym.is_imported)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">get_type</span>() != STT_FUNC)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> table[<span class="built_in">get_output_type</span>()][<span class="built_in">get_sym_type</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scan-rel"><a href="#scan-rel" class="headerlink" title="scan_rel"></a>scan_rel</h3><p>这里是对符号进行标记的地方，根据传入的不同action使用不同处理以及标记方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scan_rel</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec, Symbol&lt;E&gt; &amp;sym,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel, Action action)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> writable = (isec.<span class="built_in">shdr</span>().sh_flags &amp; SHF_WRITE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> error = [&amp;] &#123;</span><br><span class="line">    std::string msg = sym.<span class="built_in">is_absolute</span>() ? <span class="string">&quot;-fno-PIC&quot;</span> : <span class="string">&quot;-fPIC&quot;</span>;</span><br><span class="line">    <span class="built_in">Error</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; rel &lt;&lt; <span class="string">&quot; relocation at offset 0x&quot;</span></span><br><span class="line">               &lt;&lt; std::hex &lt;&lt; rel.r_offset &lt;&lt; <span class="string">&quot; against symbol `&quot;</span></span><br><span class="line">               &lt;&lt; sym &lt;&lt; <span class="string">&quot;&#x27; can not be used; recompile with &quot;</span> &lt;&lt; msg;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check_textrel = [&amp;] &#123;</span><br><span class="line">    <span class="keyword">if</span> (!writable) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.z_text) &#123;</span><br><span class="line">        <span class="built_in">error</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.warn_textrel) &#123;</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; isec &lt;&lt; <span class="string">&quot;: relocation against symbol `&quot;</span> &lt;&lt; sym</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&#x27; in read-only section&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ctx.has_textrel = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> copyrel = [&amp;] &#123;</span><br><span class="line">    <span class="built_in">assert</span>(sym.is_imported);</span><br><span class="line">    <span class="keyword">if</span> (sym.<span class="built_in">esym</span>().st_visibility == STV_PROTECTED) &#123;</span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; isec</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;: cannot make copy relocation for protected symbol &#x27;&quot;</span> &lt;&lt; sym</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;&#x27;, defined in &quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot;; recompile with -fPIC&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sym.flags |= NEEDS_COPYREL;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> dynrel = [&amp;] &#123;</span><br><span class="line">    <span class="built_in">check_textrel</span>();</span><br><span class="line">    isec.file.num_dynrel++;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in"><span class="keyword">switch</span></span> (action) &#123;</span><br><span class="line">  <span class="keyword">case</span> NONE:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> ERROR:</span><br><span class="line">    <span class="built_in">error</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COPYREL:</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.z_copyreloc)</span><br><span class="line">      <span class="built_in">error</span>();</span><br><span class="line">    <span class="built_in">copyrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYN_COPYREL:</span><br><span class="line">    <span class="keyword">if</span> (writable || !ctx.arg.z_copyreloc)</span><br><span class="line">      <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copyrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> PLT:</span><br><span class="line">    sym.flags |= NEEDS_PLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CPLT:</span><br><span class="line">    sym.flags |= NEEDS_CPLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYN_CPLT:</span><br><span class="line">    <span class="keyword">if</span> (writable)</span><br><span class="line">      <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      sym.flags |= NEEDS_CPLT;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DYNREL:</span><br><span class="line">  <span class="keyword">case</span> IFUNC:</span><br><span class="line">    <span class="built_in">dynrel</span>();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> BASEREL:</span><br><span class="line">    <span class="built_in">check_textrel</span>();</span><br><span class="line">    <span class="keyword">if</span> (!isec.<span class="built_in">is_relr_reloc</span>(ctx, rel))</span><br><span class="line">      isec.file.num_dynrel++;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">unreachable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="symbols-to-a-vec"><a href="#symbols-to-a-vec" class="headerlink" title="symbols to a vec"></a>symbols to a vec</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Aggregate dynamic symbols to a single vector.</span></span><br><span class="line">std::vector&lt;InputFile&lt;E&gt; *&gt; files;</span><br><span class="line"><span class="built_in">append</span>(files, ctx.objs);</span><br><span class="line"><span class="built_in">append</span>(files, ctx.dsos);</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::vector&lt;Symbol&lt;E&gt; *&gt;&gt; <span class="built_in">vec</span>(files.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)files.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : files[i]-&gt;symbols)</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == files[i])</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;flags || sym-&gt;is_imported || sym-&gt;is_exported)</span><br><span class="line">        vec[i].<span class="built_in">push_back</span>(sym);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">std::vector&lt;Symbol&lt;E&gt; *&gt; syms = <span class="built_in">flatten</span>(vec);</span><br><span class="line">ctx.symbol_aux.<span class="built_in">reserve</span>(syms.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将所有的文件中所有符合条件的symbol收集起来，其中flag则是在前面的阶段进行标记的</p><p>关于这里的symbol_aux</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Symbol auxiliary data</span></span><br><span class="line">std::vector&lt;SymbolAux&gt; symbol_aux;</span><br></pre></td></tr></table></figure><p>SymbolAux</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Additional class members for dynamic symbols. Because most symbols</span></span><br><span class="line"><span class="comment">// don&#x27;t need them and we allocate tens of millions of symbol objects</span></span><br><span class="line"><span class="comment">// for large programs, we separate them from `Symbol` class to save</span></span><br><span class="line"><span class="comment">// memory.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SymbolAux</span> &#123;</span></span><br><span class="line">  i32 got_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 gottp_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 tlsgd_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 tlsdesc_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 plt_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 pltgot_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 opd_idx = <span class="number">-1</span>;</span><br><span class="line">  i32 dynsym_idx = <span class="number">-1</span>;</span><br><span class="line">  u32 djb_hash = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="add-to-table"><a href="#add-to-table" class="headerlink" title="add to table"></a>add to table</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_relocations</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// Assign offsets in additional tables for each dynamic symbol.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : syms) &#123;</span><br><span class="line">    <span class="built_in">add_aux</span>(sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;is_imported || sym-&gt;is_exported)</span><br><span class="line">      ctx.dynsym-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOT)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_got_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_CPLT) &#123;</span><br><span class="line">      sym-&gt;is_canonical = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// A canonical PLT needs to be visible from DSOs.</span></span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// We can&#x27;t use .plt.got for a canonical PLT because otherwise</span></span><br><span class="line">      <span class="comment">// .plt.got and .got would refer each other, resulting in an</span></span><br><span class="line">      <span class="comment">// infinite loop at runtime.</span></span><br><span class="line">      ctx.plt-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_PLT) &#123;</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOT)</span><br><span class="line">        ctx.pltgot-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.plt-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_GOTTP)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_gottp_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_TLSGD)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_tlsgd_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_TLSDESC)</span><br><span class="line">      ctx.got-&gt;<span class="built_in">add_tlsdesc_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;flags &amp; NEEDS_COPYREL) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(sym-&gt;file-&gt;is_dso);</span><br><span class="line">      SharedFile&lt;E&gt; *file = (SharedFile&lt;E&gt; *)sym-&gt;file;</span><br><span class="line">      sym-&gt;copyrel_readonly = file-&gt;<span class="built_in">is_readonly</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;copyrel_readonly)</span><br><span class="line">        ctx.copyrel_relro-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        ctx.copyrel-&gt;<span class="built_in">add_symbol</span>(ctx, sym);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If a symbol needs copyrel, it is considered both imported</span></span><br><span class="line">      <span class="comment">// and exported.</span></span><br><span class="line">      <span class="built_in">assert</span>(sym-&gt;is_imported);</span><br><span class="line">      sym-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Aliases of this symbol are also copied so that they will be</span></span><br><span class="line">      <span class="comment">// resolved to the same address at runtime.</span></span><br><span class="line">      <span class="keyword">for</span> (Symbol&lt;E&gt; *alias : file-&gt;<span class="built_in">find_aliases</span>(sym)) &#123;</span><br><span class="line">        <span class="built_in">add_aux</span>(alias);</span><br><span class="line">        alias-&gt;is_imported = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;is_exported = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;has_copyrel = <span class="literal">true</span>;</span><br><span class="line">        alias-&gt;value = sym-&gt;value;</span><br><span class="line">        alias-&gt;copyrel_readonly = sym-&gt;copyrel_readonly;</span><br><span class="line">        ctx.dynsym-&gt;<span class="built_in">add_symbol</span>(ctx, alias);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">      <span class="title">if</span> <span class="params">(sym-&gt;flags &amp; NEEDS_OPD)</span></span></span><br><span class="line"><span class="function">        ctx.ppc64_opd-&gt;<span class="title">add_symbol</span><span class="params">(ctx, sym)</span></span>;</span><br><span class="line"></span><br><span class="line">    sym-&gt;flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.needs_tlsld)</span><br><span class="line">    ctx.got-&gt;<span class="built_in">add_tlsld</span>(ctx);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.has_textrel &amp;&amp; ctx.arg.warn_textrel)</span><br><span class="line">    <span class="built_in">Warn</span>(ctx) &lt;&lt; <span class="string">&quot;creating a DT_TEXTREL in an output file&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有符合条件的符号添加到ctx.symbol_aux中，之后加入到对应的表中</p><h1 id="compute-section-sizes"><a href="#compute-section-sizes" class="headerlink" title="compute_section_sizes"></a>compute_section_sizes</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute sizes of output sections while assigning offsets</span></span><br><span class="line"><span class="comment">// within an output section to input sections.</span></span><br><span class="line"><span class="built_in">compute_section_sizes</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里做了如下几件事情</p><ol><li>chunks里面找到所有符合条件的osec进行处理<ol><li>划分group并且处理每个group的size和p2align</li><li>计算与设置group的offset以及p2align</li></ol></li><li>处理ARM的特殊情况</li><li>根据arg的section_align设定特定osec的sh_addralign</li></ol><h2 id="chunks的处理"><a href="#chunks的处理" class="headerlink" title="chunks的处理"></a>chunks的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_section_sizes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Group</span> &#123;</span></span><br><span class="line">    i64 size = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    std::span&lt;InputSection&lt;E&gt; *&gt; members;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">    OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>();</span><br><span class="line">    <span class="keyword">if</span> (!osec)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This pattern will be processed in the next loop.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in"><span class="keyword">constexpr</span></span> (needs_thunk&lt;E&gt;)</span><br><span class="line">      <span class="keyword">if</span> ((osec-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &amp;&amp; !ctx.arg.relocatable)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since one output section may contain millions of input sections,</span></span><br><span class="line">    <span class="comment">// we first split input sections into groups and assign offsets to</span></span><br><span class="line">    <span class="comment">// groups.</span></span><br><span class="line">    std::vector&lt;Group&gt; groups;</span><br><span class="line">    <span class="keyword">constexpr</span> i64 group_size = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::span&lt;InputSection&lt;E&gt; *&gt; span : <span class="built_in">split</span>(osec-&gt;members, group_size))</span><br><span class="line">      groups.<span class="built_in">push_back</span>(Group&#123;.members = span&#125;);</span><br><span class="line"></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(groups, [](Group &amp;group) &#123;</span><br><span class="line">      <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : group.members) &#123;</span><br><span class="line">        group.size = <span class="built_in">align_to</span>(group.size, <span class="number">1</span> &lt;&lt; isec-&gt;p2align) + isec-&gt;sh_size;</span><br><span class="line">        group.p2align = std::max&lt;i64&gt;(group.p2align, isec-&gt;p2align);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; groups.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; groups[i].p2align);</span><br><span class="line">      groups[i].offset = offset;</span><br><span class="line">      offset += groups[i].size;</span><br><span class="line">      p2align = std::<span class="built_in">max</span>(p2align, groups[i].p2align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    osec-&gt;shdr.sh_size = offset;</span><br><span class="line">    osec-&gt;shdr.sh_addralign = <span class="number">1</span> &lt;&lt; p2align;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign offsets to input sections.</span></span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(groups, [](Group &amp;group) &#123;</span><br><span class="line">      i64 offset = group.offset;</span><br><span class="line">      <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : group.members) &#123;</span><br><span class="line">        offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; isec-&gt;p2align);</span><br><span class="line">        isec-&gt;offset = offset;</span><br><span class="line">        offset += isec-&gt;sh_size;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><ol><li>找到chunks中的osec</li><li>将osec中的InputSections拆分为几个group并行计算</li><li>针对每个group的每个InputSection<ol><li>将group size根据isec的p2align计算出一个对齐的size，之后加上当前isec的size</li><li>p2align更新为最大值</li></ol></li><li>更新所有group的offset以及p2align</li><li>更新osec的size和addralign</li><li>对所有group中的input section设置offset</li></ol><h2 id="ARM的处理"><a href="#ARM的处理" class="headerlink" title="ARM的处理"></a>ARM的处理</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// On ARM32 or ARM64, we may need to create so-called &quot;range extension</span></span><br><span class="line">  <span class="comment">// thunks&quot; to extend branch instructions reach, as they can jump only</span></span><br><span class="line">  <span class="comment">// to ±16 MiB or ±128 MiB, respecitvely.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// In the following loop, We compute the sizes of sections while</span></span><br><span class="line">  <span class="comment">// inserting thunks. This pass cannot be parallelized. That is,</span></span><br><span class="line">  <span class="comment">// create_range_extension_thunks is parallelized internally, but the</span></span><br><span class="line">  <span class="comment">// function itself is not thread-safe.</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(needs_thunk&lt;E&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">      OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>();</span><br><span class="line">      <span class="keyword">if</span> (osec &amp;&amp; (osec-&gt;shdr.sh_flags &amp; SHF_EXECINSTR) &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">        <span class="built_in">create_range_extension_thunks</span>(ctx, *osec);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InputSection&lt;E&gt; *isec : osec-&gt;members)</span><br><span class="line">          osec-&gt;shdr.sh_addralign =</span><br><span class="line">            std::max&lt;u32&gt;(osec-&gt;shdr.sh_addralign, <span class="number">1</span> &lt;&lt; isec-&gt;p2align);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设定osec的sh-addralign"><a href="#设定osec的sh-addralign" class="headerlink" title="设定osec的sh_addralign"></a>设定osec的sh_addralign</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">    <span class="keyword">if</span> (OutputSection&lt;E&gt; *osec = chunk-&gt;<span class="built_in">to_osec</span>())</span><br><span class="line">      <span class="keyword">if</span> (u32 align = ctx.arg.section_align[osec-&gt;name])</span><br><span class="line">        osec-&gt;shdr.sh_addralign = std::max&lt;u32&gt;(osec-&gt;shdr.sh_addralign, align);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="sort-output-sections"><a href="#sort-output-sections" class="headerlink" title="sort_output_sections"></a>sort_output_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort sections by section attributes so that we&#x27;ll have to</span></span><br><span class="line"><span class="comment">// create as few segments as possible.</span></span><br><span class="line"><span class="built_in">sort_output_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="built_in">sort_output_sections_regular</span>(ctx);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">sort_output_sections_by_order</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里对所有chunk进行了排序。</p><p>其中顺序为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ELF Header</span><br><span class="line">program header</span><br><span class="line">normal memory allocated sections</span><br><span class="line">non-memory-allocated sections</span><br><span class="line">section header</span><br></pre></td></tr></table></figure><p>normal memory allocated sections的顺序会根据用户指定的顺序，或者使用一套regular的规则</p><h2 id="regular"><a href="#regular" class="headerlink" title="regular"></a>regular</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections_regular</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">sort</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *a, Chunk&lt;E&gt; *b) &#123;</span><br><span class="line">    <span class="comment">// Sort sections by segments</span></span><br><span class="line">    i64 x = <span class="built_in">get_rank1</span>(a);</span><br><span class="line">    i64 y = <span class="built_in">get_rank1</span>(b);</span><br><span class="line">    <span class="keyword">if</span> (x != y)</span><br><span class="line">      <span class="keyword">return</span> x &lt; y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ties are broken by additional rules</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get_rank2</span>(a) &lt; <span class="built_in">get_rank2</span>(b);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释中对排序的规则进行了说明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We want to sort output chunks in the following order.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &lt;ELF header&gt;</span></span><br><span class="line"><span class="comment">//   &lt;program header&gt;</span></span><br><span class="line"><span class="comment">//   .interp</span></span><br><span class="line"><span class="comment">//   .note</span></span><br><span class="line"><span class="comment">//   .hash</span></span><br><span class="line"><span class="comment">//   .gnu.hash</span></span><br><span class="line"><span class="comment">//   .dynsym</span></span><br><span class="line"><span class="comment">//   .dynstr</span></span><br><span class="line"><span class="comment">//   .gnu.version</span></span><br><span class="line"><span class="comment">//   .gnu.version_r</span></span><br><span class="line"><span class="comment">//   .rela.dyn</span></span><br><span class="line"><span class="comment">//   .rela.plt</span></span><br><span class="line"><span class="comment">//   &lt;readonly data&gt;</span></span><br><span class="line"><span class="comment">//   &lt;readonly code&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable tdata&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable tbss&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable RELRO data&gt;</span></span><br><span class="line"><span class="comment">//   .got</span></span><br><span class="line"><span class="comment">//   .toc</span></span><br><span class="line"><span class="comment">//   &lt;writable RELRO bss&gt;</span></span><br><span class="line"><span class="comment">//   .relro_padding</span></span><br><span class="line"><span class="comment">//   &lt;writable non-RELRO data&gt;</span></span><br><span class="line"><span class="comment">//   &lt;writable non-RELRO bss&gt;</span></span><br><span class="line"><span class="comment">//   &lt;non-memory-allocated sections&gt;</span></span><br><span class="line"><span class="comment">//   &lt;section header&gt;</span></span><br></pre></td></tr></table></figure><p>代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_rank1 = [&amp;](Chunk&lt;E&gt; *chunk) &#123;</span><br><span class="line">  u64 type = chunk-&gt;shdr.sh_type;</span><br><span class="line">  u64 flags = chunk-&gt;shdr.sh_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.ehdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.phdr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.interp)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (type == SHT_NOTE &amp;&amp; (flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.gnu_hash)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.dynsym)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.dynstr)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.versym)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.verneed)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.reldyn)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.relplt)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.shdr)</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> alloc = (flags &amp; SHF_ALLOC);</span><br><span class="line">  <span class="keyword">bool</span> writable = (flags &amp; SHF_WRITE);</span><br><span class="line">  <span class="keyword">bool</span> exec = (flags &amp; SHF_EXECINSTR);</span><br><span class="line">  <span class="keyword">bool</span> tls = (flags &amp; SHF_TLS);</span><br><span class="line">  <span class="keyword">bool</span> relro = <span class="built_in">is_relro</span>(ctx, chunk);</span><br><span class="line">  <span class="keyword">bool</span> is_bss = (type == SHT_NOBITS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) | (!alloc &lt;&lt; <span class="number">9</span>) | (writable &lt;&lt; <span class="number">8</span>) | (exec &lt;&lt; <span class="number">7</span>) |</span><br><span class="line">         (!tls &lt;&lt; <span class="number">6</span>) | (!relro &lt;&lt; <span class="number">5</span>) | (is_bss &lt;&lt; <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> get_rank2 = [&amp;](Chunk&lt;E&gt; *chunk) -&gt; i64 &#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk-&gt;shdr.sh_type == SHT_NOTE)</span><br><span class="line">    <span class="keyword">return</span> -chunk-&gt;shdr.sh_addralign;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.relro_padding)</span><br><span class="line">    <span class="keyword">return</span> INT_MAX;</span><br><span class="line">  <span class="keyword">if</span> (chunk-&gt;name == <span class="string">&quot;.toc&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.got)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>tls: This section holds Thread-Local Storage, meaning that each separate execution flow has its own distinct instance of this data.</p></blockquote><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sort sections according to a --section-order argument.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_output_sections_by_order</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// It is an error if a section order cannot be determined by a given</span></span><br><span class="line"><span class="comment">// section order list.</span></span><br><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks)</span><br><span class="line">  chunk-&gt;sect_order = <span class="built_in">get_rank</span>(chunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort output sections by --section-order</span></span><br><span class="line"><span class="built_in">sort</span>(ctx.chunks, [&amp;](Chunk&lt;E&gt; *a, Chunk&lt;E&gt; *b) &#123;</span><br><span class="line">  <span class="keyword">return</span> a-&gt;sect_order &lt; b-&gt;sect_order;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的chunk设置sect_order，之后根据这个排序。这个功能我觉得就是类似于在链接脚本中按顺序写下段的名字然后按照脚本的顺序来排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> get_rank = [&amp;](Chunk&lt;E&gt; *chunk) -&gt; i64 &#123;</span><br><span class="line">  u64 flags = chunk-&gt;shdr.sh_flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.ehdr &amp;&amp; !(chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.phdr &amp;&amp; !(chunk-&gt;shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk == ctx.shdr)</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX;</span><br><span class="line">  <span class="keyword">if</span> (!(flags &amp; SHF_ALLOC))</span><br><span class="line">    <span class="keyword">return</span> INT32_MAX - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; <span class="keyword">const</span> SectionOrder &amp;arg : ctx.arg.section_order) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arg.type == SectionOrder::SECTION &amp;&amp; arg.name == chunk-&gt;name)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::string_view group = <span class="built_in">get_section_order_group</span>(*chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.section_order.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    SectionOrder arg = ctx.arg.section_order[i];</span><br><span class="line">    <span class="keyword">if</span> (arg.type == SectionOrder::GROUP &amp;&amp; arg.name == group)</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--section-order: missing section specification for &quot;</span></span><br><span class="line">             &lt;&lt; chunk-&gt;name;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对ehdr，phdr，以及shdr强制指定一个rank</p><p>之后根据arg的order查找优先级。如果没指定，则根据section_order_group再查优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> std::string_view <span class="title">get_section_order_group</span><span class="params">(Chunk&lt;E&gt; &amp;chunk)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_type == SHT_NOBITS)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;BSS&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_flags &amp; SHF_EXECINSTR)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;TEXT&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (chunk.shdr.sh_flags &amp; SHF_WRITE)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;DATA&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;RODATA&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-10-sort-s</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读九 未解析符号的处理</title>
    <link href="https://fusionbolt.github.io/2023/06/19/mold/mold-9-unresolve-symbol/"/>
    <id>https://fusionbolt.github.io/2023/06/19/mold/mold-9-unresolve-symbol/</id>
    <published>2023-06-19T13:54:17.000Z</published>
    <updated>2023-06-19T13:55:07.319Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-9-unresolve-symbol/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341_p16</center> <p>本期内容主要是claim_unresolved_symbols的部分，其次是其他一些简单的处理</p><h1 id="claim-unresolved-symbols"><a href="#claim-unresolved-symbols" class="headerlink" title="claim_unresolved_symbols"></a>claim_unresolved_symbols</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If we are linking a .so file, remaining undefined symbols does</span></span><br><span class="line"><span class="comment">// not cause a linker error. Instead, they are treated as if they</span></span><br><span class="line"><span class="comment">// were imported symbols.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If we are linking an executable, weak undefs are converted to</span></span><br><span class="line"><span class="comment">// weakly imported symbols so that they&#x27;ll have another chance to be</span></span><br><span class="line"><span class="comment">// resolved.</span></span><br><span class="line"><span class="built_in">claim_unresolved_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">claim_unresolved_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;claim_unresolved_symbols&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">claim_unresolved_symbols</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数主要还是针对需要在链接期就确定定义的符号进行检查，针对部分符号产生一些修改，在这个过程之后，不会再有符号发生新的变动了</p><p>对so来说undef是可以存在的，因此将避免报错，将undef的符号转换为imported，并且修改相关信息。</p><p>但是如果是protected或者hidden的符号即便链接了运行时也无法访问到，此时即便是undef也无法再在运行时找到定义，因此需要在链接时确定定义。也正因为这些条件，这里只需要对global符号做检查即可。</p><p>以下是具体处理过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">claim_unresolved_symbols</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>-&gt;is_alive)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="keyword">this</span>-&gt;first_global; i &lt; <span class="keyword">this</span>-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = <span class="keyword">this</span>-&gt;elf_syms[i];</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[i];</span><br><span class="line">    <span class="keyword">if</span> (!esym.<span class="built_in">is_undef</span>())</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(sym.mu)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a protected/hidden undefined symbol is resolved to an</span></span><br><span class="line">    <span class="comment">// imported symbol, it&#x27;s handled as if no symbols were found.</span></span><br><span class="line">    <span class="keyword">if</span> (sym.file &amp;&amp; sym.file-&gt;is_dso &amp;&amp;</span><br><span class="line">        (sym.visibility == STV_PROTECTED || sym.visibility == STV_HIDDEN)) &#123;</span><br><span class="line">      <span class="built_in">report_undef</span>(sym);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sym.file &amp;&amp;</span><br><span class="line">        (!sym.<span class="built_in">esym</span>().<span class="built_in">is_undef</span>() || sym.file-&gt;priority &lt;= <span class="keyword">this</span>-&gt;priority))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a symbol name is in the form of &quot;foo@version&quot;, search for</span></span><br><span class="line">    <span class="comment">// symbol &quot;foo&quot; and check if the symbol has version &quot;version&quot;.</span></span><br><span class="line">    std::string_view key = <span class="keyword">this</span>-&gt;symbol_strtab.<span class="built_in">data</span>() + esym.st_name;</span><br><span class="line">    <span class="keyword">if</span> (i64 pos = key.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>); pos != key.npos) &#123;</span><br><span class="line">      Symbol&lt;E&gt; *sym2 = <span class="built_in">get_symbol</span>(ctx, key.<span class="built_in">substr</span>(<span class="number">0</span>, pos));</span><br><span class="line">      <span class="keyword">if</span> (sym2-&gt;file &amp;&amp; sym2-&gt;file-&gt;is_dso &amp;&amp;</span><br><span class="line">          sym2-&gt;<span class="built_in">get_version</span>() == key.<span class="built_in">substr</span>(pos + <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;symbols[i] = sym2;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (esym.<span class="built_in">is_undef_weak</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym.visibility != STV_HIDDEN &amp;&amp;</span><br><span class="line">          ctx.arg.z_dynamic_undefined_weak) &#123;</span><br><span class="line">        <span class="comment">// Global weak undefined symbols are promoted to dynamic symbols</span></span><br><span class="line">        <span class="comment">// when when linking a DSO, unless `-z nodynamic_undefined_weak`</span></span><br><span class="line">        <span class="comment">// was given.</span></span><br><span class="line">        <span class="built_in">claim</span>(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise, weak undefs are converted to absolute symbols with value 0.</span></span><br><span class="line">        <span class="built_in">claim</span>(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols == UNRESOLVED_WARN)</span><br><span class="line">      <span class="built_in">report_undef</span>(sym);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traditionally, remaining undefined symbols cause a link failure</span></span><br><span class="line">    <span class="comment">// only when we are creating an executable. Undefined symbols in</span></span><br><span class="line">    <span class="comment">// shared objects are promoted to dynamic symbols, so that they&#x27;ll</span></span><br><span class="line">    <span class="comment">// get another chance to be resolved at run-time. You can change the</span></span><br><span class="line">    <span class="comment">// behavior by passing `-z defs` to the linker.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Even if `-z defs` is given, weak undefined symbols are still</span></span><br><span class="line">    <span class="comment">// promoted to dynamic symbols for compatibility with other linkers.</span></span><br><span class="line">    <span class="comment">// Some major programs, notably Firefox, depend on the behavior</span></span><br><span class="line">    <span class="comment">// (they use this loophole to export symbols from libxul.so).</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.shared &amp;&amp; sym.visibility != STV_HIDDEN &amp;&amp;</span><br><span class="line">        (!ctx.arg.z_defs || ctx.arg.unresolved_symbols != UNRESOLVED_ERROR)) &#123;</span><br><span class="line">      <span class="built_in">claim</span>(<span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert remaining undefined symbols to absolute symbols with value 0.</span></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.unresolved_symbols != UNRESOLVED_ERROR || ctx.arg.noinhibit_exec)</span><br><span class="line">      <span class="built_in">claim</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面所说，整个过程描述如下</p><ol><li><p>从全局符号开始，先跳过了已经有定义的esym</p></li><li><p>将protected和hidden的符号进行报错</p></li><li><p>对esym对应位置的sym进行判断，如果sym所对应的esym是有定义的也跳过。</p><p>这种情况是esym实际的定义在其他位置，sym是esym resolve的结果</p></li><li><p>解析符号名，如果带有版本信息则再次尝试进行重新将esym和sym进行关联。这个关联体现在esym对应index的symbols重新设置值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sym2-&gt;file &amp;&amp; sym2-&gt;file-&gt;is_dso &amp;&amp;</span><br><span class="line">    sym2-&gt;<span class="built_in">get_version</span>() == key.<span class="built_in">substr</span>(pos + <span class="number">1</span>)) &#123;</span><br><span class="line">  <span class="keyword">this</span>-&gt;symbols[i] = sym2;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>针对undef_weak进行claim</p></li><li><p>剩下的undef的符号在创建executable的时候导致链接失败，但在dso中会被提升为dynamic symbols</p></li></ol><p>claim和report_undef的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> report_undef = [&amp;](Symbol&lt;E&gt; &amp;sym) &#123;</span><br><span class="line">  std::stringstream ss;</span><br><span class="line">  <span class="keyword">if</span> (std::string_view source = <span class="keyword">this</span>-&gt;<span class="built_in">get_source_name</span>(); !source.<span class="built_in">empty</span>())</span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced by &quot;</span> &lt;&lt; source &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ss &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; referenced by &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">typename</span> <span class="title">decltype</span><span class="params">(ctx.undef_errors)</span>::accessor acc</span>;</span><br><span class="line">  ctx.undef_errors.<span class="built_in">insert</span>(acc, &#123;sym.<span class="built_in">name</span>(), &#123;&#125;&#125;);</span><br><span class="line">  acc-&gt;second.<span class="built_in">push_back</span>(ss.<span class="built_in">str</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tbb::concurrent_hash_map&lt;std::string_view, std::vector&lt;std::string&gt;&gt; undef_errors;</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> claim = [&amp;](<span class="keyword">bool</span> is_imported) &#123;</span><br><span class="line">  <span class="keyword">if</span> (sym.traced)</span><br><span class="line">    <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;trace-symbol: &quot;</span> &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: unresolved&quot;</span></span><br><span class="line">                 &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&quot; weak&quot;</span> : <span class="string">&quot;&quot;</span>)</span><br><span class="line">                 &lt;&lt; <span class="string">&quot; symbol &quot;</span> &lt;&lt; sym;</span><br><span class="line"></span><br><span class="line">  sym.file = <span class="keyword">this</span>;</span><br><span class="line">  sym.origin = <span class="number">0</span>;</span><br><span class="line">  sym.value = <span class="number">0</span>;</span><br><span class="line">  sym.sym_idx = i;</span><br><span class="line">  sym.is_weak = <span class="literal">false</span>;</span><br><span class="line">  sym.is_imported = is_imported;</span><br><span class="line">  sym.is_exported = <span class="literal">false</span>;</span><br><span class="line">  sym.ver_idx = is_imported ? <span class="number">0</span> : ctx.default_version;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="print-dependencies"><a href="#print-dependencies" class="headerlink" title="print dependencies"></a>print dependencies</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --print-dependencies</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.print_dependencies == <span class="number">1</span>)</span><br><span class="line">  <span class="built_in">print_dependencies</span>(ctx);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ctx.arg.print_dependencies == <span class="number">2</span>)</span><br><span class="line">  <span class="built_in">print_dependencies_full</span>(ctx);</span><br></pre></td></tr></table></figure><p>针对所有的obj和dso打印其依赖，那么具体怎么样才算依赖呢？在一个obj a里面，有一个未定义的符号，链接的时候另一个obj b包含了这个符号的定义，那么这就算是a依赖b。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dependencies</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt;</span><br><span class="line"><span class="string">R&quot;(# This is an output of the mold linker&#x27;s --print-dependencies option.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Each line consists of three fields, &lt;file1&gt;, &lt;file2&gt; and &lt;symbol&gt;</span></span><br><span class="line"><span class="string"># separated by tab characters. It indicates that &lt;file1&gt; depends on</span></span><br><span class="line"><span class="string"># &lt;file2&gt; to use &lt;symbol&gt;.)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> print = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line">      <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file)</span><br><span class="line">        <span class="built_in">SyncOut</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="built_in">print</span>(file);</span><br><span class="line">  <span class="keyword">for</span> (InputFile&lt;E&gt; *file : ctx.dsos)</span><br><span class="line">    <span class="built_in">print</span>(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种是最简单的遍历所有文件打印其依赖，包含了obj a，obj b以及对应符号的名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_dependencies_full</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SyncOut</span>(ctx) &lt;&lt;</span><br><span class="line"><span class="string">R&quot;(# This is an output of the mold linker&#x27;s --print-dependencies=full option.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># Each line consists of 4 fields, &lt;section1&gt;, &lt;section2&gt;, &lt;symbol-type&gt; and</span></span><br><span class="line"><span class="string"># &lt;symbol&gt;, separated by tab characters. It indicates that &lt;section1&gt; depends</span></span><br><span class="line"><span class="string"># on &lt;section2&gt; to use &lt;symbol&gt;. &lt;symbol-type&gt; is either &quot;u&quot; or &quot;w&quot; for</span></span><br><span class="line"><span class="string"># regular undefined or weak undefined, respectively.</span></span><br><span class="line"><span class="string">#</span></span><br><span class="line"><span class="string"># If you want to obtain dependency information per function granularity,</span></span><br><span class="line"><span class="string"># compile source files with the -ffunction-sections compiler flag.)&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> println = [&amp;](<span class="keyword">auto</span> &amp;src, Symbol&lt;E&gt; &amp;sym, ElfSym&lt;E&gt; &amp;esym) &#123;</span><br><span class="line">    <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">      <span class="built_in">SyncOut</span>(ctx) &lt;&lt; src &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *isec</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">SyncOut</span>(ctx) &lt;&lt; src &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; (esym.<span class="built_in">is_weak</span>() ? <span class="string">&#x27;w&#x27;</span> : <span class="string">&#x27;u&#x27;</span>)</span><br><span class="line">                   &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; sym;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      std::unordered_set&lt;<span class="keyword">void</span> *&gt; visited;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;r : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.r_type == R_NONE)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[r.r_sym];</span><br><span class="line">        Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[r.r_sym];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file &amp;&amp;</span><br><span class="line">            visited.<span class="built_in">insert</span>((<span class="keyword">void</span> *)&amp;sym).second)</span><br><span class="line">          <span class="built_in">println</span>(*isec, sym, esym);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (SharedFile&lt;E&gt; *file : ctx.dsos) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;symbols.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line">      <span class="keyword">if</span> (esym.<span class="built_in">is_undef</span>() &amp;&amp; sym.file &amp;&amp; sym.file != file)</span><br><span class="line">        <span class="built_in">println</span>(*file, sym, esym);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种更复杂一些，不仅打印依赖，还包含了符号到底是undefined还是weak这一信息。</p><p>另外遍历objs的时候还针对每个obj遍历InputSection及其包含的rel，根据这些信息来进行打印。</p><p>遍历dsos的判断条件则是和上面最简单的打印是相同的。</p><h1 id="write-repro-file"><a href="#write-repro-file" class="headerlink" title="write_repro_file"></a>write_repro_file</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle -repro</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.repro)</span><br><span class="line">  <span class="built_in">write_repro_file</span>(ctx);</span><br></pre></td></tr></table></figure><blockquote><p>–repro                     Embed input files to .repro section</p></blockquote><p>repro file是Reproducible Example Routine file的简称，包含最小可复现用例，用于调试。具体写的过程并非这里关注的重点，有兴趣可以自行查看更多细节，这里只简单看一下由哪些部分组成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_repro_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::string path = ctx.arg.output + <span class="string">&quot;.repro.tar&quot;</span>;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;TarWriter&gt; tar =</span><br><span class="line">    TarWriter::<span class="built_in">open</span>(path, <span class="built_in">filepath</span>(ctx.arg.output).<span class="built_in">filename</span>().<span class="built_in">string</span>() + <span class="string">&quot;.repro&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (!tar)</span><br><span class="line">    <span class="built_in">Fatal</span>(ctx) &lt;&lt; <span class="string">&quot;cannot open &quot;</span> &lt;&lt; path &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">errno_string</span>();</span><br><span class="line"></span><br><span class="line">  tar-&gt;<span class="built_in">append</span>(<span class="string">&quot;response.txt&quot;</span>, <span class="built_in">save_string</span>(ctx, <span class="built_in">create_response_file</span>(ctx)));</span><br><span class="line">  tar-&gt;<span class="built_in">append</span>(<span class="string">&quot;version.txt&quot;</span>, <span class="built_in">save_string</span>(ctx, mold_version + <span class="string">&quot;\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  std::unordered_set&lt;std::string&gt; seen;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MappedFile&lt;Context&lt;E&gt;&gt;&gt; &amp;mf : ctx.mf_pool) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mf-&gt;parent) &#123;</span><br><span class="line">      std::string path = <span class="built_in">to_abs_path</span>(mf-&gt;name).<span class="built_in">string</span>();</span><br><span class="line">      <span class="keyword">if</span> (seen.<span class="built_in">insert</span>(path).second) &#123;</span><br><span class="line">        <span class="comment">// We reopen a file because we may have modified the contents of mf</span></span><br><span class="line">        <span class="comment">// in memory, which is mapped with PROT_WRITE and MAP_PRIVATE.</span></span><br><span class="line">        MappedFile&lt;Context&lt;E&gt;&gt; *mf2 = MappedFile&lt;Context&lt;E&gt;&gt;::<span class="built_in">must_open</span>(ctx, path);</span><br><span class="line">        tar-&gt;<span class="built_in">append</span>(path, mf2-&gt;<span class="built_in">get_contents</span>());</span><br><span class="line">        mf2-&gt;<span class="built_in">unmap</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> std::string <span class="title">create_response_file</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  std::string buf;</span><br><span class="line">  std::stringstream out;</span><br><span class="line"></span><br><span class="line">  std::string cwd = std::filesystem::<span class="built_in">current_path</span>().<span class="built_in">string</span>();</span><br><span class="line">  out &lt;&lt; <span class="string">&quot;-C &quot;</span> &lt;&lt; cwd.<span class="built_in">substr</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cwd != <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;--chroot ..&quot;</span>;</span><br><span class="line">    i64 depth = std::<span class="built_in">count</span>(cwd.<span class="built_in">begin</span>(), cwd.<span class="built_in">end</span>(), <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; depth; i++)</span><br><span class="line">      out &lt;&lt; <span class="string">&quot;/..&quot;</span>;</span><br><span class="line">    out &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; ctx.cmdline_args.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    std::string_view arg = ctx.cmdline_args[i];</span><br><span class="line">    <span class="keyword">if</span> (arg != <span class="string">&quot;-repro&quot;</span> &amp;&amp; arg != <span class="string">&quot;--repro&quot;</span>)</span><br><span class="line">      out &lt;&lt; arg &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out.<span class="built_in">str</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码我们得知，主要分为三部分</p><ol><li>response_file，本质上是编译命令以及参数</li><li>mold的version info</li><li>所有的输入文件</li></ol><p>也就表示这三者就是确定问题的必要条件，另外还可以认为执行到这里之后符号不会再发生什么改动，也不会产生新的用户引发的问题（比如说少链接文件，或者什么参数错了导致符号决议出问题等）</p><h1 id="required-defined"><a href="#required-defined" class="headerlink" title="required-defined"></a>required-defined</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --require-defined</span></span><br><span class="line"><span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, name)-&gt;file)</span><br><span class="line">    <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;--require-defined: undefined symbol: &quot;</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure><p>强制要求某些符号是必须在链接时就包含定义的，对这些符号进行检查并且进行报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-9-unresol</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读八 创建输出段</title>
    <link href="https://fusionbolt.github.io/2023/06/10/mold/mold-8-create-output-section/"/>
    <id>https://fusionbolt.github.io/2023/06/10/mold/mold-8-create-output-section/</id>
    <published>2023-06-10T08:24:45.000Z</published>
    <updated>2023-06-10T08:26:12.044Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-8-create-output-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341_p18</center> <p>上一期介绍了一些创建输出段之前的工作，本期主要是把创建输出相关的最后一些前置准备讲解完成。根据代码中的注释，add_synthetic_symbols以后，不会再有任何新的文件添加到ctx.objs和ctx.dsos中了。之后会再讲解简单的命令行参数处理，下一期再讲对于输出chunk中的一些处理</p><h1 id="create-output-sections"><a href="#create-output-sections" class="headerlink" title="create output sections"></a>create output sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create output sections for input sections.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_output_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;create_output_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> OutputSectionKey &amp;k)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      u64 h = <span class="built_in">hash_string</span>(k.name);</span><br><span class="line">      h = <span class="built_in">combine_hash</span>(h, std::hash&lt;u64&gt;&#123;&#125;(k.type));</span><br><span class="line">      h = <span class="built_in">combine_hash</span>(h, std::hash&lt;u64&gt;&#123;&#125;(k.flags));</span><br><span class="line">      <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::unordered_map&lt;OutputSectionKey, OutputSection&lt;E&gt; *, Cmp&gt; map;</span><br><span class="line">  std::shared_mutex mu;</span><br></pre></td></tr></table></figure><ol><li>首先针对所有的InputSection生成一个key，并且根据key创建所有的OutputSection</li><li>将所有obj中的InputSection加入到对应OutputSection的members中</li><li>对所有的output section和mergeable section加入到chunks</li><li>将所有的chunk进行排序</li><li>所有的chunk加入到ctx.chunks中（在加入之前chunks中有一些synthetic的chunk，在上一期中有提及）</li></ol><p>以下是这五个过程的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Instantiate output sections</span></span><br><span class="line">tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    OutputSectionKey key = <span class="built_in">get_output_section_key</span>(ctx, *isec);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      std::shared_lock <span class="built_in">lock</span>(mu);</span><br><span class="line">      <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (it != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        isec-&gt;output_section = it-&gt;second;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;OutputSection&lt;E&gt;&gt; osec =</span><br><span class="line">      std::make_unique&lt;OutputSection&lt;E&gt;&gt;(key.name, key.type, key.flags);</span><br><span class="line">    std::unique_lock <span class="built_in">lock</span>(mu);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = map.<span class="built_in">insert</span>(&#123;key, osec.<span class="built_in">get</span>()&#125;);</span><br><span class="line">    isec-&gt;output_section = it-&gt;second;</span><br><span class="line">    <span class="keyword">if</span> (inserted)</span><br><span class="line">      ctx.osec_pool.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(osec));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add input sections to output sections</span></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive)</span><br><span class="line">        isec-&gt;output_section-&gt;members.<span class="built_in">push_back</span>(isec.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add output sections and mergeable sections to ctx.chunks</span></span><br><span class="line">  std::vector&lt;Chunk&lt;E&gt; *&gt; vec;</span><br><span class="line">  <span class="keyword">for</span> (std::pair&lt;<span class="keyword">const</span> OutputSectionKey, OutputSection&lt;E&gt; *&gt; &amp;kv : map)</span><br><span class="line">    vec.<span class="built_in">push_back</span>(kv.second);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;osec : ctx.merged_sections)</span><br><span class="line">    <span class="keyword">if</span> (osec-&gt;shdr.sh_size)</span><br><span class="line">      vec.<span class="built_in">push_back</span>(osec.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sections are added to the section lists in an arbitrary order</span></span><br><span class="line">  <span class="comment">// because they are created in parallel. Sort them to to make the</span></span><br><span class="line">  <span class="comment">// output deterministic.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](Chunk&lt;E&gt; *x, Chunk&lt;E&gt; *y) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">tuple</span>(x-&gt;name, x-&gt;shdr.sh_type, x-&gt;shdr.sh_flags) &lt;</span><br><span class="line">           std::<span class="built_in">tuple</span>(y-&gt;name, y-&gt;shdr.sh_type, y-&gt;shdr.sh_flags);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">append</span>(ctx.chunks, vec);</span><br></pre></td></tr></table></figure><h2 id="get-output-section-key"><a href="#get-output-section-key" class="headerlink" title="get_output_section_key"></a>get_output_section_key</h2><p>这个函数的作用是从一个InputSection构造一个OutputSectionKey</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> OutputSectionKey</span></span><br><span class="line"><span class="function"><span class="title">get_output_section_key</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = isec.<span class="built_in">shdr</span>();</span><br><span class="line">  std::string_view name = <span class="built_in">get_output_name</span>(ctx, isec.<span class="built_in">name</span>(), shdr.sh_flags);</span><br><span class="line">  u64 type = canonicalize_type&lt;E&gt;(name, shdr.sh_type);</span><br><span class="line">  u64 flags = shdr.sh_flags &amp; ~(u64)SHF_COMPRESSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.relocatable)</span><br><span class="line">    flags &amp;= ~(u64)SHF_GROUP &amp; ~(u64)SHF_GNU_RETAIN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .init_array is usually writable. We don&#x27;t want to create multiple</span></span><br><span class="line">  <span class="comment">// .init_array output sections, so make it always writable.</span></span><br><span class="line">  <span class="comment">// So is .fini_array.</span></span><br><span class="line">  <span class="keyword">if</span> (type == SHT_INIT_ARRAY || type == SHT_FINI_ARRAY)</span><br><span class="line">    flags |= SHF_WRITE;</span><br><span class="line">  <span class="keyword">return</span> &#123;name, type, flags&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputSectionKey</span> &#123;</span></span><br><span class="line">  std::string_view name;</span><br><span class="line">  u64 type;</span><br><span class="line">  u64 flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> OutputSectionKey &amp;other) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name == other.name &amp;&amp; type == other.type &amp;&amp; flags == other.flags;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从InputSection获取的output name。这里有以下几种情况</p><ol><li><p>返回原始名字</p></li><li><p>忽略段名字的后缀</p><p>不知道这里应该用什么术语，还是举个例子，比如说里面的.ARM.exidx，如果有.ARM.exidx.f1以及.ARM.exidx.f2，那么这两个的名字都会归为.ARM.exidx</p></li><li><p>将一些特殊的text段单独分开，而不是合并为一个text。这里涉及到了一个z_keep_text_section_prefix的编译选项，命令行的介绍是</p><blockquote><p>z keep-text-section-prefix Keep .text.{hot,unknown,unlikely,startup,exit} as separate sections in the final binary</p></blockquote></li><li><p>对于text等特定段则是只保留原始前缀，比如说所有的.text.xxx最后都会合并到一个.text段。这个对于函数定义非常常见，查看编译产物的时候，经常会看到一些.text.function_name，最后都会合并为一个.text，这种合并其实就是这里实现的。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function">std::string_view</span></span><br><span class="line"><span class="function"><span class="title">get_output_name</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string_view name, u64 flags)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.relocatable &amp;&amp; !ctx.arg.relocatable_merge_sections)</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.unique &amp;&amp; ctx.arg.unique-&gt;<span class="built_in">match</span>(name))</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; SHF_MERGE)</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ARM.exidx&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.ARM.exidx&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ARM.extab&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.ARM.extab&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_keep_text_section_prefix) &#123;</span><br><span class="line">    <span class="keyword">static</span> std::string_view prefixes[] = &#123;</span><br><span class="line">      <span class="string">&quot;.text.hot.&quot;</span>, <span class="string">&quot;.text.unknown.&quot;</span>, <span class="string">&quot;.text.unlikely.&quot;</span>, <span class="string">&quot;.text.startup.&quot;</span>,</span><br><span class="line">      <span class="string">&quot;.text.exit.&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (std::string_view prefix : prefixes) &#123;</span><br><span class="line">      std::string_view stem = prefix.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (name == stem || name.<span class="built_in">starts_with</span>(prefix))</span><br><span class="line">        <span class="keyword">return</span> stem;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> std::string_view prefixes[] = &#123;</span><br><span class="line">    <span class="string">&quot;.text.&quot;</span>, <span class="string">&quot;.data.rel.ro.&quot;</span>, <span class="string">&quot;.data.&quot;</span>, <span class="string">&quot;.rodata.&quot;</span>, <span class="string">&quot;.bss.rel.ro.&quot;</span>, <span class="string">&quot;.bss.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.init_array.&quot;</span>, <span class="string">&quot;.fini_array.&quot;</span>, <span class="string">&quot;.tbss.&quot;</span>, <span class="string">&quot;.tdata.&quot;</span>, <span class="string">&quot;.gcc_except_table.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;.ctors.&quot;</span>, <span class="string">&quot;.dtors.&quot;</span>, <span class="string">&quot;.gnu.warning.&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view prefix : prefixes) &#123;</span><br><span class="line">    std::string_view stem = prefix.<span class="built_in">substr</span>(<span class="number">0</span>, prefix.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (name == stem || name.<span class="built_in">starts_with</span>(prefix))</span><br><span class="line">      <span class="keyword">return</span> stem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="add-synthetic-symbols"><a href="#add-synthetic-symbols" class="headerlink" title="add synthetic symbols"></a>add synthetic symbols</h1><p>这里的功能如名字一样，就是添加一些synthetic的符号，添加后将这些符号关联到ctx.symtab中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_synthetic_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  ObjectFile&lt;E&gt; &amp;obj = *ctx.internal_obj;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> add = [&amp;](std::string_view name) &#123;</span><br><span class="line">    ElfSym&lt;E&gt; esym;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;esym, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(esym));</span><br><span class="line">    esym.st_type = STT_NOTYPE;</span><br><span class="line">    esym.st_shndx = SHN_ABS;</span><br><span class="line">    esym.st_bind = STB_GLOBAL;</span><br><span class="line">    esym.st_visibility = STV_HIDDEN;</span><br><span class="line">    ctx.internal_esyms.<span class="built_in">push_back</span>(esym);</span><br><span class="line"></span><br><span class="line">    Symbol&lt;E&gt; *sym = <span class="built_in">get_symbol</span>(ctx, name);</span><br><span class="line">    sym-&gt;value = <span class="number">0xdeadbeef</span>; <span class="comment">// unique dummy value</span></span><br><span class="line">    obj.symbols.<span class="built_in">push_back</span>(sym);</span><br><span class="line">    <span class="keyword">return</span> sym;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ctx.__ehdr_start = <span class="built_in">add</span>(<span class="string">&quot;__ehdr_start&quot;</span>);</span><br><span class="line">ctx.__init_array_start = <span class="built_in">add</span>(<span class="string">&quot;__init_array_start&quot;</span>);</span><br><span class="line">ctx.__init_array_end = <span class="built_in">add</span>(<span class="string">&quot;__init_array_end&quot;</span>);</span><br><span class="line">ctx.__fini_array_start = <span class="built_in">add</span>(<span class="string">&quot;__fini_array_start&quot;</span>);</span><br><span class="line">ctx.__fini_array_end = <span class="built_in">add</span>(<span class="string">&quot;__fini_array_end&quot;</span>);</span><br><span class="line">ctx.__preinit_array_start = <span class="built_in">add</span>(<span class="string">&quot;__preinit_array_start&quot;</span>);</span><br><span class="line">ctx.__preinit_array_end = <span class="built_in">add</span>(<span class="string">&quot;__preinit_array_end&quot;</span>);</span><br><span class="line">ctx._DYNAMIC = <span class="built_in">add</span>(<span class="string">&quot;_DYNAMIC&quot;</span>);</span><br><span class="line">ctx._GLOBAL_OFFSET_TABLE_ = <span class="built_in">add</span>(<span class="string">&quot;_GLOBAL_OFFSET_TABLE_&quot;</span>);</span><br><span class="line">ctx._PROCEDURE_LINKAGE_TABLE_ = <span class="built_in">add</span>(<span class="string">&quot;_PROCEDURE_LINKAGE_TABLE_&quot;</span>);</span><br><span class="line">ctx.__bss_start = <span class="built_in">add</span>(<span class="string">&quot;__bss_start&quot;</span>);</span><br><span class="line">ctx._end = <span class="built_in">add</span>(<span class="string">&quot;_end&quot;</span>);</span><br><span class="line">ctx._etext = <span class="built_in">add</span>(<span class="string">&quot;_etext&quot;</span>);</span><br><span class="line">ctx._edata = <span class="built_in">add</span>(<span class="string">&quot;_edata&quot;</span>);</span><br><span class="line">ctx.__executable_start = <span class="built_in">add</span>(<span class="string">&quot;__executable_start&quot;</span>);</span><br><span class="line"></span><br><span class="line">ctx.__rel_iplt_start =</span><br><span class="line">  <span class="built_in">add</span>(is_rela&lt;E&gt; ? <span class="string">&quot;__rela_iplt_start&quot;</span> : <span class="string">&quot;__rel_iplt_start&quot;</span>);</span><br><span class="line">ctx.__rel_iplt_end =</span><br><span class="line">  <span class="built_in">add</span>(is_rela&lt;E&gt; ? <span class="string">&quot;__rela_iplt_end&quot;</span> : <span class="string">&quot;__rel_iplt_end&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.eh_frame_hdr)</span><br><span class="line">  ctx.__GNU_EH_FRAME_HDR = <span class="built_in">add</span>(<span class="string">&quot;__GNU_EH_FRAME_HDR&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;end&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.end = <span class="built_in">add</span>(<span class="string">&quot;end&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;etext&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.etext = <span class="built_in">add</span>(<span class="string">&quot;etext&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;edata&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.edata = <span class="built_in">add</span>(<span class="string">&quot;edata&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__dso_handle&quot;</span>)-&gt;file)</span><br><span class="line">  ctx.__dso_handle = <span class="built_in">add</span>(<span class="string">&quot;__dso_handle&quot;</span>);</span><br></pre></td></tr></table></figure><p>添加通用的特殊符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(supports_tlsdesc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  ctx._TLS_MODULE_BASE_ </span>= <span class="built_in">add</span>(<span class="string">&quot;_TLS_MODULE_BASE_&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_riscv&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(!ctx.arg.shared)</span></span></span><br><span class="line"><span class="function">    ctx.__global_pointer </span>= <span class="built_in">add</span>(<span class="string">&quot;__global_pointer$&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, ARM32&gt;)</span> </span>&#123;</span><br><span class="line">  ctx.__exidx_start = <span class="built_in">add</span>(<span class="string">&quot;__exidx_start&quot;</span>);</span><br><span class="line">  ctx.__exidx_end = <span class="built_in">add</span>(<span class="string">&quot;__exidx_end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_ppc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">  ctx.TOC </span>= <span class="built_in">add</span>(<span class="string">&quot;.TOC.&quot;</span>);</span><br></pre></td></tr></table></figure><p>针对特殊平台添加特定的符号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Chunk&lt;E&gt; *chunk : ctx.chunks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (std::optional&lt;std::string&gt; name = <span class="built_in">get_start_stop_name</span>(ctx, *chunk)) &#123;</span><br><span class="line">      <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__start_&quot;</span> + *name));</span><br><span class="line">      <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__stop_&quot;</span> + *name));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ctx.arg.physical_image_base) &#123;</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_start_&quot;</span> + *name));</span><br><span class="line">        <span class="built_in">add</span>(<span class="built_in">save_string</span>(ctx, <span class="string">&quot;__phys_stop_&quot;</span> + *name));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>针对特殊名字的trunk的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">obj.elf_syms = ctx.internal_esyms;</span><br><span class="line">obj.symvers.<span class="built_in">resize</span>(ctx.internal_esyms.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">obj.<span class="built_in">resolve_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><p>对internal_obj进行symbol resolve</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make all synthetic symbols relative ones by associating them to</span></span><br><span class="line"><span class="comment">// a dummy output section.</span></span><br><span class="line"><span class="keyword">for</span> (Symbol&lt;E&gt; *sym : obj.symbols)</span><br><span class="line">  <span class="keyword">if</span> (sym-&gt;file == &amp;obj)</span><br><span class="line">    sym-&gt;<span class="built_in">set_output_section</span>(ctx.symtab);</span><br></pre></td></tr></table></figure><p>符号关联到symtab这个output section里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle --defsym symbols.</span></span><br><span class="line"><span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.arg.defsyms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">  Symbol&lt;E&gt; *sym = ctx.arg.defsyms[i].first;</span><br><span class="line">  std::variant&lt;Symbol&lt;E&gt; *, u64&gt; val = ctx.arg.defsyms[i].second;</span><br><span class="line"></span><br><span class="line">  Symbol&lt;E&gt; *target = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (Symbol&lt;E&gt; **ref = std::get_if&lt;Symbol&lt;E&gt; *&gt;(&amp;val))</span><br><span class="line">    target = *ref;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the alias refers another symobl, copy ELF symbol attributes.</span></span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    ElfSym&lt;E&gt; &amp;esym = obj.elf_syms[i + <span class="number">1</span>];</span><br><span class="line">    esym.st_type = target-&gt;<span class="built_in">esym</span>().st_type;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">requires</span> &#123; esym.ppc_local_entry; &#125;)</span></span></span><br><span class="line"><span class="function">      esym.ppc_local_entry </span>= target-&gt;<span class="built_in">esym</span>().ppc_local_entry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make the target absolute if necessary.</span></span><br><span class="line">  <span class="keyword">if</span> (!target || target-&gt;<span class="built_in">is_absolute</span>())</span><br><span class="line">    sym-&gt;origin = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于—defsym指定的符号进行处理</p><h1 id="check-cet-errors"><a href="#check-cet-errors" class="headerlink" title="check_cet_errors"></a>check_cet_errors</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle `-z cet-report`.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_cet_report != CET_REPORT_NONE)</span><br><span class="line">    <span class="built_in">check_cet_errors</span>(ctx);</span><br></pre></td></tr></table></figure><p>首先，cet是Control Flow Enforcement Technology的缩写。简单来说就是预防控制流攻击的一种技术</p><blockquote><p>Control-flow Enforcement Technology (CET) covers several related x86 processor features that provide protection against control flow hijacking attacks. CET can protect both applications and the kernel.</p><p>CET introduces shadow stack and indirect branch tracking (IBT). A shadow stack is a secondary stack allocated from memory which cannot be directly modified by applications. When executing a CALL instruction, the processor pushes the return address to both the normal stack and the shadow stack. Upon function return, the processor pops the shadow stack copy and compares it to the normal stack copy. If the two differ, the processor raises a control-protection fault. IBT verifies indirect CALL/JMP targets are intended as marked by the compiler with ‘ENDBR’ opcodes. Not all CPU’s have both Shadow Stack and Indirect Branch Tracking. Today in the 64-bit kernel, only userspace shadow stack and kernel IBT are supported.</p></blockquote><p><a class="link"   href="https://www.kernel.org/doc/html/next/x86/shstk.html" >Control-flow Enforcement Technology (CET) Shadow Stack — The Linux Kernel  documentation<i class="fas fa-external-link-alt"></i></a></p><p>cet_report有三类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  CET_REPORT_NONE,</span><br><span class="line">  CET_REPORT_WARNING,</span><br><span class="line">  CET_REPORT_ERROR,</span><br><span class="line">&#125; CetReportKind;</span><br></pre></td></tr></table></figure><p>这个函数是用于进行针对每个file检查对应的gnu_properties，如果没有满足特定feature的话抛出warning或者error。</p><p>ELF中必须包含GNU_PROPERTY_X86_FEATURE_1_IBT和GNU_PROPERTY_X86_FEATURE_1_SHSTK属性才能支持cet。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_cet_errors</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> warning = (ctx.arg.z_cet_report == CET_REPORT_WARNING);</span><br><span class="line">  <span class="built_in">assert</span>(warning || (ctx.arg.z_cet_report == CET_REPORT_ERROR));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> has_feature = [](ObjectFile&lt;E&gt; *file, u32 feature) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">any_of</span>(file-&gt;gnu_properties.<span class="built_in">begin</span>(), file-&gt;gnu_properties.<span class="built_in">end</span>(),</span><br><span class="line">                       [&amp;](<span class="keyword">auto</span> kv) &#123;</span><br><span class="line">                         <span class="keyword">return</span> kv.first == GNU_PROPERTY_X86_FEATURE_1_AND</span><br><span class="line">                             &amp;&amp; (kv.second &amp; feature);</span><br><span class="line">                       &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (file == ctx.internal_obj)</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has_feature</span>(file, GNU_PROPERTY_X86_FEATURE_1_IBT)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (warning)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=warning: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_IBT&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=error: &quot;</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_IBT&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">has_feature</span>(file, GNU_PROPERTY_X86_FEATURE_1_SHSTK)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (warning)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=warning: &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_SHSTK&quot;</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">Error</span>(ctx) &lt;&lt; *file &lt;&lt; <span class="string">&quot;: -cet-report=error: &quot;</span></span><br><span class="line">                   &lt;&lt; <span class="string">&quot;missing GNU_PROPERTY_X86_FEATURE_1_SHSTK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="execstack-if-needed"><a href="#execstack-if-needed" class="headerlink" title="execstack-if-needed"></a>execstack-if-needed</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle `-z execstack-if-needed`.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.z_execstack_if_needed)</span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs)</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;needs_executable_stack)</span><br><span class="line">      ctx.arg.z_execstack = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>所有的obj中，如果有needs_executable_stack为true的情况，那么设置ctx中的arg。obj中的这个属性是在ObjectFile::initialize_sections中设置的。而全局的z_execstack会在后面被用到，此时先不过多提及。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .note.GNU-stack section controls executable-ness of the stack</span></span><br><span class="line"><span class="comment">// area in GNU linkers. We ignore that section because silently</span></span><br><span class="line"><span class="comment">// making the stack area executable is too dangerous. Tell our</span></span><br><span class="line"><span class="comment">// users about the difference if that matters.</span></span><br><span class="line"><span class="keyword">if</span> (name == <span class="string">&quot;.note.GNU-stack&quot;</span> &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (shdr.sh_flags &amp; SHF_EXECINSTR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ctx.arg.z_execstack &amp;&amp; !ctx.arg.z_execstack_if_needed)</span><br><span class="line">      <span class="built_in">Warn</span>(ctx) &lt;&lt; *<span class="keyword">this</span> &lt;&lt; <span class="string">&quot;: this file may cause a segmentation&quot;</span></span><br><span class="line">        <span class="string">&quot; fault because it requires an executable stack. See&quot;</span></span><br><span class="line">        <span class="string">&quot; https://github.com/rui314/mold/tree/main/docs/execstack.md&quot;</span></span><br><span class="line">        <span class="string">&quot; for more info.&quot;</span>;</span><br><span class="line">    needs_executable_stack = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-8-create-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读七 创建输出段之前</title>
    <link href="https://fusionbolt.github.io/2023/05/20/mold/mold-7-before-create-output-section/"/>
    <id>https://fusionbolt.github.io/2023/05/20/mold/mold-7-before-create-output-section/</id>
    <published>2023-05-20T08:06:32.000Z</published>
    <updated>2023-05-20T08:07:46.442Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-7-before-create-output-section/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341 p7</center> <p>上期的内容主要是section size相关的优化，这期内容是创建输出段前的最后一些处理</p><h1 id="Compute-Merged-Section-Size"><a href="#Compute-Merged-Section-Size" class="headerlink" title="Compute Merged Section Size"></a>Compute Merged Section Size</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute sizes of sections containing mergeable strings.</span></span><br><span class="line"><span class="built_in">compute_merged_section_sizes</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute_merged_section_sizes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;compute_merged_section_sizes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mark section fragments referenced by live objects.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.gc_sections) &#123;</span><br><span class="line">    tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">      <span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : file-&gt;mergeable_sections)</span><br><span class="line">        <span class="keyword">if</span> (m)</span><br><span class="line">          <span class="keyword">for</span> (SectionFragment&lt;E&gt; *frag : m-&gt;fragments)</span><br><span class="line">            frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add an identification string to .comment.</span></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary)</span><br><span class="line">    <span class="built_in">add_comment_string</span>(ctx, mold_version);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Embed command line arguments for debugging.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">char</span> *env = <span class="built_in">getenv</span>(<span class="string">&quot;MOLD_DEBUG&quot;</span>); env &amp;&amp; env[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">add_comment_string</span>(ctx, <span class="string">&quot;mold command line: &quot;</span> + <span class="built_in">get_cmdline_args</span>(ctx));</span><br><span class="line"></span><br><span class="line">  <span class="function">Timer <span class="title">t2</span><span class="params">(ctx, <span class="string">&quot;MergedSection assign_offsets&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.merged_sections,</span><br><span class="line">                         [&amp;](std::unique_ptr&lt;MergedSection&lt;E&gt;&gt; &amp;sec) &#123;</span><br><span class="line">    sec-&gt;<span class="built_in">assign_offsets</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程做了三件事情</p><ol><li>对非gc_sections的情况下标记fragment，在开启这个选项时会在之前的过程标记过</li><li>之后是添加comment string。</li><li>最后是针对每一个merged_section调用assign_offsets</li></ol><p>关于上面的oformat，其命令行的描述如下</p><blockquote><p>-oformat=binary Omit ELF, section and program headers</p></blockquote><p>add_comment_string的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_comment_string</span><span class="params">(Context&lt;E&gt; &amp;ctx, std::string str)</span> </span>&#123;</span><br><span class="line">  MergedSection&lt;E&gt; *sec =</span><br><span class="line">    MergedSection&lt;E&gt;::<span class="built_in">get_instance</span>(ctx, <span class="string">&quot;.comment&quot;</span>, SHT_PROGBITS,</span><br><span class="line">                                   SHF_MERGE | SHF_STRINGS);</span><br><span class="line"></span><br><span class="line">  std::string_view buf = <span class="built_in">save_string</span>(ctx, str);</span><br><span class="line">  <span class="function">std::string_view <span class="title">data</span><span class="params">(buf.data(), buf.size() + <span class="number">1</span>)</span></span>;</span><br><span class="line">  SectionFragment&lt;E&gt; *frag = sec-&gt;<span class="built_in">insert</span>(data, <span class="built_in">hash_string</span>(data), <span class="number">0</span>);</span><br><span class="line">  frag-&gt;is_alive = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程获取对应的MergeSecgtion的instance，之后插入comment str中一个新的fragment。</p><p>接下来看一下assign_offsets的实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> MergedSection&lt;E&gt;::<span class="built_in">assign_offsets</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">sizes</span><span class="params">(map.NUM_SHARDS)</span></span>;</span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">max_p2aligns</span><span class="params">(map.NUM_SHARDS)</span></span>;</span><br><span class="line">  shard_offsets.<span class="built_in">resize</span>(map.NUM_SHARDS + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  i64 shard_size = map.nbuckets / map.NUM_SHARDS;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, map.NUM_SHARDS, [&amp;](i64 i) &#123;</span><br><span class="line">    struct KeyVal &#123;</span><br><span class="line">      std::string_view key;</span><br><span class="line">      SectionFragment&lt;E&gt; *val;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;KeyVal&gt; fragments;</span><br><span class="line">    fragments.<span class="built_in">reserve</span>(shard_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i64 j = shard_size * i; j &lt; shard_size * (i + <span class="number">1</span>); j++)</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; &amp;frag = map.values[j]; frag.is_alive)</span><br><span class="line">        fragments.<span class="built_in">push_back</span>(&#123;&#123;map.keys[j], map.key_sizes[j]&#125;, &amp;frag&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort fragments to make output deterministic.</span></span><br><span class="line">    tbb::<span class="built_in">parallel_sort</span>(fragments.<span class="built_in">begin</span>(), fragments.<span class="built_in">end</span>(),</span><br><span class="line">                       [](<span class="keyword">const</span> KeyVal &amp;a, <span class="keyword">const</span> KeyVal &amp;b) &#123;</span><br><span class="line">      <span class="keyword">return</span> std::tuple&#123;(u32)a.val-&gt;p2align, a.key.<span class="built_in">size</span>(), a.key&#125; &lt;</span><br><span class="line">             std::tuple&#123;(u32)b.val-&gt;p2align, b.key.<span class="built_in">size</span>(), b.key&#125;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign offsets.</span></span><br><span class="line">    i64 offset = <span class="number">0</span>;</span><br><span class="line">    i64 p2align = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (KeyVal &amp;kv : fragments) &#123;</span><br><span class="line">      SectionFragment&lt;E&gt; &amp;frag = *kv.val;</span><br><span class="line">      offset = <span class="built_in">align_to</span>(offset, <span class="number">1</span> &lt;&lt; frag.p2align);</span><br><span class="line">      frag.offset = offset;</span><br><span class="line">      offset += kv.key.<span class="built_in">size</span>();</span><br><span class="line">      p2align = std::max&lt;i64&gt;(p2align, frag.p2align);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sizes[i] = offset;</span><br><span class="line">    max_p2aligns[i] = p2align;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Counter <span class="built_in">merged_strings</span>(<span class="string">&quot;merged_strings&quot;</span>);</span><br><span class="line">    merged_strings += fragments.<span class="built_in">size</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  i64 p2align = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 x : max_p2aligns)</span><br><span class="line">    p2align = std::<span class="built_in">max</span>(p2align, x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">1</span>; i &lt; map.NUM_SHARDS + <span class="number">1</span>; i++)</span><br><span class="line">    shard_offsets[i] =</span><br><span class="line">      <span class="built_in">align_to</span>(shard_offsets[i - <span class="number">1</span>] + sizes[i - <span class="number">1</span>], <span class="number">1</span> &lt;&lt; p2align);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">1</span>, map.NUM_SHARDS, [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 j = shard_size * i; j &lt; shard_size * (i + <span class="number">1</span>); j++)</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; &amp;frag = map.values[j]; frag.is_alive)</span><br><span class="line">        frag.offset += shard_offsets[i];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_size = shard_offsets[map.NUM_SHARDS];</span><br><span class="line">  <span class="keyword">this</span>-&gt;shdr.sh_addralign = <span class="number">1</span> &lt;&lt; p2align;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assign_offsets主要目的是设置对应MergedSection的section header中的sh_size和sh_addralign</p><p>这里的实现首先为了并行计算，将数据划分为了map.NUM_SHARDS个shard块。在每个并行的body中，先构建了对应的KeyVal，之后为了输出的确定性进行排序，最后计算其section fragment的p2aligns，以及将其长度设置为offset的初始值</p><p>在这之后算出一个最大的p2align用于设置MergedSection的section header的sh_addralign，以及计算出每一个shard块中fragment的shared_offset，最后将最后一个shard的offset(下标为n的元素，类似于vector的end的位置）作为整个MergedSection的size</p><h1 id="Create-Synthetic-Sections"><a href="#Create-Synthetic-Sections" class="headerlink" title="Create Synthetic Sections"></a>Create Synthetic Sections</h1><p>这里主要创建一些特殊的段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create linker-synthesized sections such as .got or .plt.</span></span><br><span class="line">  <span class="built_in">create_synthetic_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_synthetic_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> push = [&amp;]&lt;<span class="keyword">typename</span> T&gt;(T *x) &#123;</span><br><span class="line">    ctx.chunks.<span class="built_in">push_back</span>(x);</span><br><span class="line">    ctx.chunk_pool.<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary) &#123;</span><br><span class="line">    <span class="keyword">auto</span> find = [&amp;](std::string_view name) &#123;</span><br><span class="line">      <span class="keyword">for</span> (SectionOrder &amp;ord : ctx.arg.section_order)</span><br><span class="line">        <span class="keyword">if</span> (ord.type == SectionOrder::SECTION &amp;&amp; ord.name == name)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>() || <span class="built_in">find</span>(<span class="string">&quot;EHDR&quot;</span>))</span><br><span class="line">      ctx.ehdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputEhdr&lt;E&gt;(SHF_ALLOC));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ctx.ehdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputEhdr&lt;E&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ctx.arg.section_order.<span class="built_in">empty</span>() || <span class="built_in">find</span>(<span class="string">&quot;PHDR&quot;</span>))</span><br><span class="line">      ctx.phdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputPhdr&lt;E&gt;(SHF_ALLOC));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ctx.phdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputPhdr&lt;E&gt;(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    ctx.shdr = <span class="built_in">push</span>(<span class="keyword">new</span> OutputShdr&lt;E&gt;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.got = <span class="built_in">push</span>(<span class="keyword">new</span> GotSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!is_sparc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">    ctx.gotplt </span>= <span class="built_in">push</span>(<span class="keyword">new</span> GotPltSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.reldyn = <span class="built_in">push</span>(<span class="keyword">new</span> RelDynSection&lt;E&gt;);</span><br><span class="line">  ctx.relplt = <span class="built_in">push</span>(<span class="keyword">new</span> RelPltSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.pack_dyn_relocs_relr)</span><br><span class="line">    ctx.relrdyn = <span class="built_in">push</span>(<span class="keyword">new</span> RelrDynSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.strtab = <span class="built_in">push</span>(<span class="keyword">new</span> StrtabSection&lt;E&gt;);</span><br><span class="line">  ctx.plt = <span class="built_in">push</span>(<span class="keyword">new</span> PltSection&lt;E&gt;);</span><br><span class="line">  ctx.pltgot = <span class="built_in">push</span>(<span class="keyword">new</span> PltGotSection&lt;E&gt;);</span><br><span class="line">  ctx.symtab = <span class="built_in">push</span>(<span class="keyword">new</span> SymtabSection&lt;E&gt;);</span><br><span class="line">  ctx.dynsym = <span class="built_in">push</span>(<span class="keyword">new</span> DynsymSection&lt;E&gt;);</span><br><span class="line">  ctx.dynstr = <span class="built_in">push</span>(<span class="keyword">new</span> DynstrSection&lt;E&gt;);</span><br><span class="line">  ctx.eh_frame = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameSection&lt;E&gt;);</span><br><span class="line">  ctx.copyrel = <span class="built_in">push</span>(<span class="keyword">new</span> CopyrelSection&lt;E&gt;(<span class="literal">false</span>));</span><br><span class="line">  ctx.copyrel_relro = <span class="built_in">push</span>(<span class="keyword">new</span> CopyrelSection&lt;E&gt;(<span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.oformat_binary)</span><br><span class="line">    ctx.shstrtab = <span class="built_in">push</span>(<span class="keyword">new</span> ShstrtabSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.dynamic_linker.<span class="built_in">empty</span>())</span><br><span class="line">    ctx.interp = <span class="built_in">push</span>(<span class="keyword">new</span> InterpSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.build_id.kind != BuildId::NONE)</span><br><span class="line">    ctx.buildid = <span class="built_in">push</span>(<span class="keyword">new</span> BuildIdSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.eh_frame_hdr)</span><br><span class="line">    ctx.eh_frame_hdr = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameHdrSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.gdb_index)</span><br><span class="line">    ctx.gdb_index = <span class="built_in">push</span>(<span class="keyword">new</span> GdbIndexSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.z_relro &amp;&amp; ctx.arg.section_order.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">      ctx.arg.z_separate_code != SEPARATE_LOADABLE_SEGMENTS)</span><br><span class="line">    ctx.relro_padding = <span class="built_in">push</span>(<span class="keyword">new</span> RelroPaddingSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.hash_style_sysv)</span><br><span class="line">    ctx.hash = <span class="built_in">push</span>(<span class="keyword">new</span> HashSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.hash_style_gnu)</span><br><span class="line">    ctx.gnu_hash = <span class="built_in">push</span>(<span class="keyword">new</span> GnuHashSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (!ctx.arg.version_definitions.<span class="built_in">empty</span>())</span><br><span class="line">    ctx.verdef = <span class="built_in">push</span>(<span class="keyword">new</span> VerdefSection&lt;E&gt;);</span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.emit_relocs)</span><br><span class="line">    ctx.eh_frame_reloc = <span class="built_in">push</span>(<span class="keyword">new</span> EhFrameRelocSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.shared || !ctx.dsos.<span class="built_in">empty</span>() || ctx.arg.pie)</span><br><span class="line">    ctx.dynamic = <span class="built_in">push</span>(<span class="keyword">new</span> DynamicSection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  ctx.versym = <span class="built_in">push</span>(<span class="keyword">new</span> VersymSection&lt;E&gt;);</span><br><span class="line">  ctx.verneed = <span class="built_in">push</span>(<span class="keyword">new</span> VerneedSection&lt;E&gt;);</span><br><span class="line">  ctx.note_package = <span class="built_in">push</span>(<span class="keyword">new</span> NotePackageSection&lt;E&gt;);</span><br><span class="line">  ctx.note_property = <span class="built_in">push</span>(<span class="keyword">new</span> NotePropertySection&lt;E&gt;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ctx.arg.is_static) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_s390x&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">      ctx.s390x_tls_get_offset </span>= <span class="built_in">push</span>(<span class="keyword">new</span> S390XTlsGetOffsetSection);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_sparc&lt;E&gt;)</span></span></span><br><span class="line"><span class="function">      ctx.sparc_tls_get_addr </span>= <span class="built_in">push</span>(<span class="keyword">new</span> SparcTlsGetAddrSection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_same_v&lt;E, PPC64V1&gt;)</span></span></span><br><span class="line"><span class="function">    ctx.ppc64_opd </span>= <span class="built_in">push</span>(<span class="keyword">new</span> PPC64OpdSection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If .dynamic exists, .dynsym and .dynstr must exist as well</span></span><br><span class="line">  <span class="comment">// since .dynamic refers them.</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.dynamic) &#123;</span><br><span class="line">    ctx.dynstr-&gt;<span class="built_in">keep</span>();</span><br><span class="line">    ctx.dynsym-&gt;<span class="built_in">keep</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ctx.tls_get_addr = <span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__tls_get_addr&quot;</span>);</span><br><span class="line">  ctx.tls_get_offset = <span class="built_in">get_symbol</span>(ctx, <span class="string">&quot;__tls_get_offset&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里其实已经开始创建输出的内容了，因为是直接push到chunk中。在mold中chunk则是表示用于输出的一片区域，关于Chunk类源码中有这样的注释</p><blockquote><p>Chunk represents a contiguous region in an output file.</p></blockquote><p>首先是oformat_binary选项控制的EHDR和PHDR。</p><p>EHDR和PHDR分别是ELF Header和Program Header</p><p>EHDR和PHDR在不指定section_order或者指定的情况下存在对应的section则作为一个ALLOC的chunk加入到chunks中。</p><p>之后是添加了一些常见的段，以及各种参数控制的段，不再一一赘述。</p><p>最后提一下如果dynamic section存在的话，那么保留dynstr和dynsym段，也就是设置其size为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keep</span><span class="params">()</span> </span>&#123; <span class="keyword">this</span>-&gt;shdr.sh_size = <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure><h1 id="Check-Duplicate-Symbol"><a href="#Check-Duplicate-Symbol" class="headerlink" title="Check Duplicate Symbol"></a>Check Duplicate Symbol</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make sure that there&#x27;s no duplicate symbol</span></span><br><span class="line"><span class="keyword">if</span> (!ctx.arg.allow_multiple_definition)</span><br><span class="line">  <span class="built_in">check_duplicate_symbols</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_duplicate_symbols</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;check_duplicate_symbols&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip if our symbol is undef or weak</span></span><br><span class="line">      <span class="keyword">if</span> (sym.file == file || sym.file == ctx.internal_obj ||</span><br><span class="line">          esym.<span class="built_in">is_undef</span>() || esym.<span class="built_in">is_common</span>() || (esym.st_bind == STB_WEAK))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Skip if our symbol is in a dead section. In most cases, the</span></span><br><span class="line">      <span class="comment">// section has been eliminated due to comdat deduplication.</span></span><br><span class="line">      <span class="keyword">if</span> (!esym.<span class="built_in">is_abs</span>()) &#123;</span><br><span class="line">        InputSection&lt;E&gt; *isec = file-&gt;<span class="built_in">get_section</span>(esym);</span><br><span class="line">        <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">Error</span>(ctx) &lt;&lt; <span class="string">&quot;duplicate symbol: &quot;</span> &lt;&lt; *file &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; *sym.file</span><br><span class="line">                 &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; sym;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ctx.<span class="built_in">checkpoint</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有的obj进行检查，遍历所有的global symbol。</p><p>首先通过sym.file ==file 检查符号owner是否为当前文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A symbol is owned by a file. If two or more files define the</span></span><br><span class="line"><span class="comment">// same symbol, the one with the strongest definition owns the symbol.</span></span><br><span class="line"><span class="comment">// If `file` is null, the symbol is equivalent to nonexistent.</span></span><br><span class="line">InputFile&lt;E&gt; *file = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>以及如果是internal_obj中的符号，也进行跳过。剩下的就是可能有冲突的情况，但undef、weak、common的符号冲突不会造成影响，只有重复定义会导致冲突，因此这些情况也进行跳过。</p><p>最后跳过在dead section的符号，未满足前面条件的符号则是重复符号</p><h1 id="Check-Symbol-Types"><a href="#Check-Symbol-Types" class="headerlink" title="Check Symbol Types"></a>Check Symbol Types</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Warn if symbols with different types are defined under the same name.</span></span><br><span class="line">  <span class="built_in">check_symbol_types</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check_symbol_types</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;check_symbol_types&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> normalize_type = [](u32 type) &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == STT_GNU_IFUNC)</span><br><span class="line">      <span class="keyword">return</span> STT_FUNC;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> check = [&amp;](InputFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i64 i = file-&gt;first_global; i &lt; file-&gt;elf_syms.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> ElfSym&lt;E&gt; &amp;esym = file-&gt;elf_syms[i];</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *file-&gt;symbols[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!sym.file)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      u32 their_type = <span class="built_in">normalize_type</span>(sym.<span class="built_in">esym</span>().st_type);</span><br><span class="line">      u32 our_type = <span class="built_in">normalize_type</span>(esym.st_type);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (their_type != STT_NOTYPE &amp;&amp; our_type != STT_NOTYPE &amp;&amp;</span><br><span class="line">          their_type != our_type)</span><br><span class="line">        <span class="built_in">Warn</span>(ctx) &lt;&lt; <span class="string">&quot;symbol type mismatch: &quot;</span> &lt;&lt; sym &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; defined in &quot;</span> &lt;&lt; *sym.file &lt;&lt; <span class="string">&quot; as &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">stt_to_string</span>(sym.<span class="built_in">esym</span>().st_type) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; defined in &quot;</span> &lt;&lt; *file &lt;&lt; <span class="string">&quot; as &quot;</span></span><br><span class="line">                  &lt;&lt; <span class="built_in">stt_to_string</span>(esym.st_type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, check);</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.dsos, check);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里针对的是所有的obj和dso里的所有global_symbol进行检查。检查实际的Symbol和ElfSym中的type是否一致，但这里只是warning，而不像之前重复符号的检查一样直接报错。检查的方式是首先对两者的type进行normalize的操作，之后进行比较，都不为空NOTYPE的情况下判断相等性。我觉得这里更像是一种针对resolve的结果检查，因为一个esym是不会被修改的，只有Symbol引用的esym对象会发生改变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-7-before-</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>mold源码阅读六 section size优化</title>
    <link href="https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/"/>
    <id>https://fusionbolt.github.io/2023/05/07/mold/mold-6-section-size-reduce/</id>
    <published>2023-05-07T15:59:24.000Z</published>
    <updated>2023-05-07T16:16:54.092Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/mold-6-section-size-reduce/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:101015341 p2</center> <p>上一期我们讲解了一些符号相关的处理，这一期我们来讲一些对于section size的优化处理。</p><h1 id="mark-addrsig"><a href="#mark-addrsig" class="headerlink" title="mark_addrsig"></a>mark_addrsig</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read address-significant section information.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf &amp;&amp; !ctx.arg.icf_all)</span><br><span class="line">  <span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mark_addrsig</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_addrsig&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    file-&gt;<span class="built_in">mark_addrsig</span>(ctx);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相关的命令行参数</p><blockquote><p>-icf=[all,safe,none] Fold identical code<br>–no-icf</p></blockquote><p>针对所有的obj处理，因为dso的地址相关信息是在运行时加载进行处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">void</span> ObjectFile&lt;E&gt;::<span class="built_in">mark_addrsig</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="comment">// Parse a .llvm_addrsig section.</span></span><br><span class="line">  <span class="keyword">if</span> (llvm_addrsig) &#123;</span><br><span class="line">    u8 *cur = (u8 *)llvm_addrsig-&gt;contents.<span class="built_in">data</span>();</span><br><span class="line">    u8 *end = cur + llvm_addrsig-&gt;contents.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != end) &#123;</span><br><span class="line">      Symbol&lt;E&gt; &amp;sym = *<span class="keyword">this</span>-&gt;symbols[<span class="built_in">read_uleb</span>(cur)];</span><br><span class="line">      <span class="keyword">if</span> (sym.file == <span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym.<span class="built_in">get_input_section</span>())</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We treat a symbol&#x27;s address as significant if</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 1. we have no address significance information for the symbol, or</span></span><br><span class="line">  <span class="comment">// 2. the symbol can be referenced from the outside in an address-</span></span><br><span class="line">  <span class="comment">//    significant manner.</span></span><br><span class="line">  <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : <span class="keyword">this</span>-&gt;symbols)</span><br><span class="line">    <span class="keyword">if</span> (sym-&gt;file == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (InputSection&lt;E&gt; *isec = sym-&gt;<span class="built_in">get_input_section</span>())</span><br><span class="line">        <span class="keyword">if</span> (!llvm_addrsig || sym-&gt;is_exported)</span><br><span class="line">          isec-&gt;address_significant = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于llvm_addrsig，处理的是一个范围的Symbol，将这个范围的Symbol的address_significant设置为True</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ObjectFile&lt;E&gt;::initialize_sections</span></span><br><span class="line">std::unique_ptr&lt;InputSection&lt;E&gt;&gt; llvm_addrsig;</span><br><span class="line"><span class="comment">// Save .llvm_addrsig for --icf=safe.</span></span><br><span class="line"><span class="keyword">if</span> (shdr.sh_type == SHT_LLVM_ADDRSIG &amp;&amp; !ctx.arg.relocatable) &#123;</span><br><span class="line">  llvm_addrsig = std::make_unique&lt;InputSection&lt;E&gt;&gt;(ctx, *<span class="keyword">this</span>, name, i);</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通的symbol address，针对非llvm_addrsig或者exported的symbol将address_significant为True</p><p>那么address_significant是什么呢</p><p><a class="link"   href="https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table" >https://llvm.org/docs/Extensions.html#sht-llvm-addrsig-section-address-significance-table<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>the address of the symbol is used in a comparison or leaks outside the translation unit</p></blockquote><p>简单来说就是这个地址会被用于比较或者用于翻译单元之外，这个变量的具体含义到后面使用的时候会结合场景进一步讲述。</p><h1 id="gc-sections"><a href="#gc-sections" class="headerlink" title="gc_sections"></a>gc_sections</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Garbage-collect unreachable sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.gc_sections)</span><br><span class="line">  <span class="built_in">gc_sections</span>(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gc_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gc&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mark_nonalloc_fragments</span>(ctx);</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; rootset;</span><br><span class="line">  <span class="built_in">collect_root_set</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">mark</span>(ctx, rootset);</span><br><span class="line">  <span class="built_in">sweep</span>(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gc_sections主要是对section像GC一样进行mark and sweep，清理掉未被使用的段，关于gc_sections的选项</p><blockquote><p>–gc-sections               Remove unreferenced sections</p></blockquote><h2 id="mark-nonalloc-fragments"><a href="#mark-nonalloc-fragments" class="headerlink" title="mark_nonalloc_fragments"></a>mark_nonalloc_fragments</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Non-alloc section fragments are not subject of garbage collection.</span></span><br><span class="line"><span class="comment">// This function marks such fragments.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark_nonalloc_fragments</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark_nonalloc_fragments&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;MergeableSection&lt;E&gt;&gt; &amp;m : file-&gt;mergeable_sections)</span><br><span class="line">      <span class="keyword">if</span> (m)</span><br><span class="line">        <span class="keyword">for</span> (SectionFragment&lt;E&gt; *frag : m-&gt;fragments)</span><br><span class="line">          <span class="keyword">if</span> (!(frag-&gt;output_section.shdr.sh_flags &amp; SHF_ALLOC))</span><br><span class="line">            frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Non-alloc的fragment不是垃圾回收的对象，因此这里只是标记，避免后续被sweep</p><h2 id="collect-root-set"><a href="#collect-root-set" class="headerlink" title="collect_root_set"></a>collect_root_set</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collect_root_set</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                             tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;collect_root_set&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_section = [&amp;](InputSection&lt;E&gt; *isec) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mark_section</span>(isec))</span><br><span class="line">      rootset.<span class="built_in">push_back</span>(isec);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> enqueue_symbol = [&amp;](Symbol&lt;E&gt; *sym) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sym) &#123;</span><br><span class="line">      <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym-&gt;<span class="built_in">get_frag</span>())</span><br><span class="line">        frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">enqueue_section</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections that are not subject to garbage collection.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// -gc-sections discards only SHF_ALLOC sections. If you want to</span></span><br><span class="line">      <span class="comment">// reduce the amount of non-memory-mapped segments, you should</span></span><br><span class="line">      <span class="comment">// use `strip` command, compile without debug info or use</span></span><br><span class="line">      <span class="comment">// -strip-all linker option.</span></span><br><span class="line">      u32 flags = isec-&gt;<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">      <span class="keyword">if</span> (!(flags &amp; SHF_ALLOC))</span><br><span class="line">        isec-&gt;is_visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">should_keep</span>(*isec))</span><br><span class="line">        <span class="built_in">enqueue_section</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections containing exported symbols</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Symbol&lt;E&gt; *sym : file-&gt;symbols)</span><br><span class="line">      <span class="keyword">if</span> (sym-&gt;file == file &amp;&amp; sym-&gt;is_exported)</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(sym);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add sections referenced by root symbols.</span></span><br><span class="line">  <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, ctx.arg.entry));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.undefined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (std::string_view name : ctx.arg.require_defined)</span><br><span class="line">    <span class="built_in">enqueue_symbol</span>(<span class="built_in">get_symbol</span>(ctx, name));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// .eh_frame consists of variable-length records called CIE and FDE</span></span><br><span class="line">  <span class="comment">// records, and they are a unit of inclusion or exclusion.</span></span><br><span class="line">  <span class="comment">// We just keep all CIEs and everything that are referenced by them.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : cie.<span class="built_in">get_rels</span>())</span><br><span class="line">        <span class="built_in">enqueue_symbol</span>(file-&gt;symbols[rel.r_sym]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是进行收集root，以便之后进行mark and sweep。</p><p>主要收集的方向有两个</p><ol><li><p>对section直接添加，这里主要是针对一些不受垃圾回收影响的段。具体条件参考should_keep的实现。</p></li><li><p>针对符号进行处理，如果是在fragment中则会设置其为alive，因为fragment并非扫描的root。如果是在普通的段中则将符号引用的section添加到root中。</p><p>而符号的来源分为这么几种</p><ol><li>is_exported</li><li>undefined</li><li>require_defined</li><li>cie中的rel符号</li></ol></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">should_keep</span><span class="params">(<span class="keyword">const</span> InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  u32 type = isec.<span class="built_in">shdr</span>().sh_type;</span><br><span class="line">  u32 flags = isec.<span class="built_in">shdr</span>().sh_flags;</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (flags &amp; SHF_GNU_RETAIN) ||</span><br><span class="line">         type == SHT_NOTE ||</span><br><span class="line">         type == SHT_INIT_ARRAY ||</span><br><span class="line">         type == SHT_FINI_ARRAY ||</span><br><span class="line">         type == SHT_PREINIT_ARRAY ||</span><br><span class="line">         (std::is_same_v&lt;E, ARM32&gt; &amp;&amp; type == SHT_ARM_EXIDX) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.ctors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.dtors&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.init&quot;</span>) ||</span><br><span class="line">         name.<span class="built_in">starts_with</span>(<span class="string">&quot;.fini&quot;</span>) ||</span><br><span class="line">         <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mark all reachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(Context&lt;E&gt; &amp;ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                 tbb::concurrent_vector&lt;InputSection&lt;E&gt; *&gt; &amp;rootset)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;mark&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(rootset, [&amp;](InputSection&lt;E&gt; *isec,</span><br><span class="line">                                    tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder) &#123;</span><br><span class="line">    <span class="built_in">visit</span>(ctx, isec, feeder, <span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; *isec,</span></span></span><br><span class="line"><span class="params"><span class="function">                  tbb::feeder&lt;InputSection&lt;E&gt; *&gt; &amp;feeder, i64 depth)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(isec-&gt;is_visited);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this is a text section, .eh_frame may contain records</span></span><br><span class="line">  <span class="comment">// describing how to handle exceptions for that function.</span></span><br><span class="line">  <span class="comment">// We want to keep associated .eh_frame records.</span></span><br><span class="line">  <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : isec-&gt;<span class="built_in">get_fdes</span>())</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : fde.<span class="built_in">get_rels</span>(isec-&gt;file).<span class="built_in">subspan</span>(<span class="number">1</span>))</span><br><span class="line">      <span class="keyword">if</span> (Symbol&lt;E&gt; *sym = isec-&gt;file.symbols[rel.r_sym])</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mark_section</span>(sym-&gt;<span class="built_in">get_input_section</span>()))</span><br><span class="line">          feeder.<span class="built_in">add</span>(sym-&gt;<span class="built_in">get_input_section</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> ElfRel&lt;E&gt; &amp;rel : isec-&gt;<span class="built_in">get_rels</span>(ctx)) &#123;</span><br><span class="line">    Symbol&lt;E&gt; &amp;sym = *isec-&gt;file.symbols[rel.r_sym];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Symbol can refer either a section fragment or an input section.</span></span><br><span class="line">    <span class="comment">// Mark a fragment as alive.</span></span><br><span class="line">    <span class="keyword">if</span> (SectionFragment&lt;E&gt; *frag = sym.<span class="built_in">get_frag</span>()) &#123;</span><br><span class="line">      frag-&gt;is_alive.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">mark_section</span>(sym.<span class="built_in">get_input_section</span>()))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark a section alive. For better performacne, we don&#x27;t call</span></span><br><span class="line">    <span class="comment">// `feeder.add` too often.</span></span><br><span class="line">    <span class="keyword">if</span> (depth &lt; <span class="number">3</span>)</span><br><span class="line">      <span class="built_in">visit</span>(ctx, sym.<span class="built_in">get_input_section</span>(), feeder, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      feeder.<span class="built_in">add</span>(sym.<span class="built_in">get_input_section</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从rootset出发</p><ol><li>针对fde record中的rel符号所在的section进行标记，并且添加到feeder中（本质是加到了rootset中，后续会继续从这些节点开始遍历）</li><li>针对rel段中的符号进行遍历，如果是fragment则设置其alive，之后对sym的input section进行标记，标记成功的话则继续递归执行。</li></ol><h2 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remove unreachable sections</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sweep</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">counter</span><span class="params">(<span class="string">&quot;garbage_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [&amp;](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; !isec-&gt;is_visited) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.arg.print_gc_sections)</span><br><span class="line">          <span class="built_in">SyncOut</span>(ctx) &lt;&lt; <span class="string">&quot;removing unused section &quot;</span> &lt;&lt; *isec;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        counter++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> InputSection&lt;E&gt;::<span class="built_in">kill</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_alive.<span class="built_in">exchange</span>(<span class="literal">false</span>))</span><br><span class="line">    <span class="keyword">for</span> (FdeRecord&lt;E&gt; &amp;fde : <span class="built_in">get_fdes</span>())</span><br><span class="line">      fde.is_alive = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ehframe那一期提到会清理未用到的record，而在这里实际执行了fde的清理工作。</p><h1 id="icf-sections"><a href="#icf-sections" class="headerlink" title="icf_sections"></a>icf_sections</h1><p>这段内容比较长，建议单独查看源码对应位置进行对照，相关实现在elf/icf.cc中</p><p>icf的全拼推测是identical code folding</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Merge identical read-only sections.</span></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.icf)</span><br><span class="line"><span class="built_in">icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icf_sections</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;icf&quot;</span>)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (ctx.objs.<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">uniquify_cies</span>(ctx);</span><br><span class="line">  <span class="built_in">merge_leaf_nodes</span>(ctx);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="uniquify-cies"><a href="#uniquify-cies" class="headerlink" title="uniquify_cies"></a>uniquify_cies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uniquify_cies</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;uniquify_cies&quot;</span>)</span></span>;</span><br><span class="line">  std::vector&lt;CieRecord&lt;E&gt; *&gt; cies;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ObjectFile&lt;E&gt; *file : ctx.objs) &#123;</span><br><span class="line">    <span class="keyword">for</span> (CieRecord&lt;E&gt; &amp;cie : file-&gt;cies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; cies.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cie.<span class="built_in">equals</span>(*cies[i])) &#123;</span><br><span class="line">          cie.icf_idx = i;</span><br><span class="line">          <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cie.icf_idx = cies.<span class="built_in">size</span>();</span><br><span class="line">      cies.<span class="built_in">push_back</span>(&amp;cie);</span><br><span class="line">    found:;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中的所有cie，如果cie和cies中的任何一个相同，也就是出现了重复，则继续查看下一个cie是否重复，没有重复则将cie加进去。</p><p>这里我不太明白，为什么不保存一个CieRecord的Set，避免了再写一个循环的麻烦？如果有读者能解答我的疑惑欢迎邮件联系我。</p><h2 id="merge-leaf-nodes"><a href="#merge-leaf-nodes" class="headerlink" title="merge_leaf_nodes"></a>merge_leaf_nodes</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Early merge of leaf nodes, which can be processed without constructing the</span></span><br><span class="line"><span class="comment">// entire graph. This reduces the vertex count and improves memory efficiency.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge_leaf_nodes</span><span class="params">(Context&lt;E&gt; &amp;ctx)</span> </span>&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;merge_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eligible</span><span class="params">(<span class="string">&quot;icf_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">non_eligible</span><span class="params">(<span class="string">&quot;icf_non_eligibles&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">leaf</span><span class="params">(<span class="string">&quot;icf_leaf_nodes&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::concurrent_unordered_map&lt;InputSection&lt;E&gt; *, InputSection&lt;E&gt; *,</span><br><span class="line">                                LeafHasher&lt;E&gt;, LeafEq&lt;E&gt;&gt; map;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isec || !isec-&gt;is_alive)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">is_eligible</span>(ctx, *isec)) &#123;</span><br><span class="line">        non_eligible++;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">is_leaf</span>(ctx, *isec)) &#123;</span><br><span class="line">        leaf++;</span><br><span class="line">        isec-&gt;icf_leaf = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">auto</span> [it, inserted] = map.<span class="built_in">insert</span>(&#123;isec.<span class="built_in">get</span>(), isec.<span class="built_in">get</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">          it-&gt;second = isec.<span class="built_in">get</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        eligible++;</span><br><span class="line">        isec-&gt;icf_eligible = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_leaf) &#123;</span><br><span class="line">        <span class="keyword">auto</span> it = map.<span class="built_in">find</span>(isec.<span class="built_in">get</span>());</span><br><span class="line">        <span class="built_in">assert</span>(it != map.<span class="built_in">end</span>());</span><br><span class="line">        isec-&gt;leader = it-&gt;second;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对所有obj中eligible的sections来处理。</p><p>是leaf则设置leaf并且插入到map中，但是如果insert失败，且priority更高，那么就更新对应的section</p><p>非leaf的情况下只设置eligible，留到后面进行处理。</p><p>之后针对所有obj的sections，如果是icf_leaf，那么更新其leader为map中对应的值</p><h3 id="关于其中出现的InputSection的字段"><a href="#关于其中出现的InputSection的字段" class="headerlink" title="关于其中出现的InputSection的字段"></a>关于其中出现的InputSection的字段</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in InputSection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For ICF</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// `leader` is the section that this section has been merged with.</span></span><br><span class="line"><span class="comment">// Three kind of values are possible:</span></span><br><span class="line"><span class="comment">// - `leader == nullptr`: This section was not eligible for ICF.</span></span><br><span class="line"><span class="comment">// - `leader == this`: This section was retained.</span></span><br><span class="line"><span class="comment">// - `leader != this`: This section was merged with another identical section.</span></span><br><span class="line">InputSection&lt;E&gt; *leader = <span class="literal">nullptr</span>;</span><br><span class="line">u32 icf_idx = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_eligible = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> icf_leaf = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>简单来说这个leader实际上是用于指向当前section的一个唯一实现。</p><p>如果leader存在且为自己，那么对应内容的段只访问过一次，如果不为自己的话，那么代表这不是第一次访问对应内容的段了。</p><p>用实际实现结合注释来说明leader这个字段。</p><ol><li>==nullptr：这种情况表明这个section是not eligible的，也就是说会在上面的循环被忽略掉</li><li>==this：这种情况表明这个section是对应内容的段第一次出现，在后面更新leader的过程中是找到的section和自身相同。</li><li>≠this：这种情况表明后面更新leader的查找过程中，找到的section其实是其对应内容在前面第一次出现的段，也就是指向了对应的leader</li></ol><p>举个例子，假设有s1, s2, s3三个section，s1是not eligible的，s2和s3是相同的，按照s1-s3的顺序进行扫描</p><p>s1 = nullptr</p><p>s2 = s2 # leader</p><p>s3 = s2</p><h3 id="is-eligible"><a href="#is-eligible" class="headerlink" title="is_eligible"></a>is_eligible</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_eligible</span><span class="params">(Context&lt;E&gt; &amp;ctx, InputSection&lt;E&gt; &amp;isec)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ElfShdr&lt;E&gt; &amp;shdr = isec.<span class="built_in">shdr</span>();</span><br><span class="line">  std::string_view name = isec.<span class="built_in">name</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_alloc = (shdr.sh_flags &amp; SHF_ALLOC);</span><br><span class="line">  <span class="keyword">bool</span> is_exec = (shdr.sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">                 ctx.arg.ignore_data_address_equality;</span><br><span class="line">  <span class="keyword">bool</span> is_relro = (name == <span class="string">&quot;.data.rel.ro&quot;</span> ||</span><br><span class="line">                   name.<span class="built_in">starts_with</span>(<span class="string">&quot;.data.rel.ro.&quot;</span>));</span><br><span class="line">  <span class="keyword">bool</span> is_readonly = !(shdr.sh_flags &amp; SHF_WRITE) || is_relro;</span><br><span class="line">  <span class="keyword">bool</span> is_bss = (shdr.sh_type == SHT_NOBITS);</span><br><span class="line">  <span class="keyword">bool</span> is_empty = (shdr.sh_size == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_init = (shdr.sh_type == SHT_INIT_ARRAY || name == <span class="string">&quot;.init&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_fini = (shdr.sh_type == SHT_FINI_ARRAY || name == <span class="string">&quot;.fini&quot;</span>);</span><br><span class="line">  <span class="keyword">bool</span> is_enumerable = <span class="built_in">is_c_identifier</span>(name);</span><br><span class="line">  <span class="keyword">bool</span> is_addr_taken = !ctx.arg.icf_all &amp;&amp; isec.address_significant;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> is_alloc &amp;&amp; is_exec &amp;&amp; is_readonly &amp;&amp; !is_bss &amp;&amp; !is_empty &amp;&amp;</span><br><span class="line">         !is_init &amp;&amp; !is_fini &amp;&amp; !is_enumerable &amp;&amp; !is_addr_taken;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不满足这些情况的话无法被fold，具体条件以及判断方式无需再多讲解，纯粹是对应的规则。</p><p>注意这里出现了上面说的address_significant，需要为false才能满足，也就是说需要用地址比较的情况是无法被fold的。</p><h2 id="gather-sections"><a href="#gather-sections" class="headerlink" title="gather_sections"></a>gather_sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare for the propagation rounds.</span></span><br><span class="line">std::vector&lt;InputSection&lt;E&gt; *&gt; sections = <span class="built_in">gather_sections</span>(ctx);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">static</span> std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">gather_sections</span>(Context&lt;E&gt; &amp;ctx) &#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;gather_sections&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Count the number of input sections for each input file.</span></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">num_sections</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        num_sections[i]++;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;i64&gt; <span class="title">section_indices</span><span class="params">(ctx.objs.size())</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; ctx.objs.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    section_indices[i + <span class="number">1</span>] = section_indices[i] + num_sections[i];</span><br><span class="line"></span><br><span class="line">  std::vector&lt;InputSection&lt;E&gt; *&gt; <span class="built_in">sections</span>(</span><br><span class="line">    section_indices.<span class="built_in">back</span>() + num_sections.<span class="built_in">back</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Fill `sections` contents.</span></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)ctx.objs.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    i64 idx = section_indices[i];</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : ctx.objs[i]-&gt;sections)</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;icf_eligible)</span><br><span class="line">        sections[idx++] = isec.<span class="built_in">get</span>();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    sections[i]-&gt;icf_idx = i;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sections;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里出现了三个vector，先来理清对应的作用</p><ol><li>num_sections：每个obj中icf_eligible的input sections数量</li><li>section_indices：由前一个section_indices和num_sections的值决定，其实是用于标记每个位置的objs的input section的起始在最终的sections中的坐标</li><li>sections：初始化的容量是其实是section_indices[ctx.objs.size()]的值</li></ol><p>这样说可能比较抽象，举个例子</p><p>num_sections: 2, 3, 4, 5</p><p>section_indices: 0, 2+0, 3+2+0, 4+3+2+0</p><p>5+4+3+2+0</p><p>算出来的其实是所有obj中icf_eligible的input sections的数量</p><p>之后是fill content的部分，并行的获取每个obj中的所有icf_eligible的input section的指针</p><h2 id="Digest"><a href="#Digest" class="headerlink" title="Digest"></a>Digest</h2><p>接下来的部分都是在计算digest，具体算法有兴趣的可以去实现中自行查看细节。</p><p>什么是digest，这个链接中的一个回答说的比较明白了，我选取了关键内容放出来</p><p><a class="link"   href="https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function" >https://crypto.stackexchange.com/questions/51243/what-is-the-difference-between-a-digest-and-a-hash-function<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>The digest is the output of the hash function.<br>For example, sha256 has a digest of 256 bits, i.e. its digest has a length of 32 bytes.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::array&lt;<span class="keyword">uint8_t</span>, HASH_SIZE&gt; Digest;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// We allocate 3 arrays to store hashes for each vertex.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 0 and 1 are used for tree hashes from the previous</span></span><br><span class="line"><span class="comment">// iteration and the current iteration. They switch roles every</span></span><br><span class="line"><span class="comment">// iteration. See `slot` below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Index 2 stores the initial, single-vertex hash. This is combined</span></span><br><span class="line"><span class="comment">// with hashes from the connected vertices to form the tree hash</span></span><br><span class="line"><span class="comment">// described above.</span></span><br><span class="line">std::vector&lt;std::vector&lt;Digest&gt;&gt; <span class="built_in">digests</span>(<span class="number">3</span>);</span><br><span class="line">digests[<span class="number">0</span>] = compute_digests&lt;E&gt;(ctx, sections);</span><br><span class="line">digests[<span class="number">1</span>].<span class="built_in">resize</span>(digests[<span class="number">0</span>].<span class="built_in">size</span>());</span><br><span class="line">digests[<span class="number">2</span>] = digests[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">std::vector&lt;u32&gt; edges;</span><br><span class="line">std::vector&lt;u32&gt; edge_indices;</span><br><span class="line">gather_edges&lt;E&gt;(ctx, sections, edges, edge_indices);</span><br><span class="line"></span><br><span class="line"><span class="function">BitVector <span class="title">converged</span><span class="params">(digests[<span class="number">0</span>].size())</span></span>;</span><br><span class="line"><span class="keyword">bool</span> slot = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Execute the propagation rounds until convergence is obtained.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;propagate&quot;</span>)</span></span>;</span><br><span class="line">  tbb::affinity_partitioner ap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A cheap test that the graph hasn&#x27;t converged yet.</span></span><br><span class="line">  <span class="comment">// The loop after this one uses a strict condition, but it&#x27;s expensive</span></span><br><span class="line">  <span class="comment">// as it requires sorting the entire hash collection.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// For nodes that have a cycle in downstream (i.e. recursive</span></span><br><span class="line">  <span class="comment">// functions and functions that calls recursive functions) will always</span></span><br><span class="line">  <span class="comment">// change with the iterations. Nodes that doesn&#x27;t (i.e. non-recursive</span></span><br><span class="line">  <span class="comment">// functions) will stop changing as soon as the propagation depth reaches</span></span><br><span class="line">  <span class="comment">// the call tree depth.</span></span><br><span class="line">  <span class="comment">// Here, we test whether we have reached sufficient depth for the latter,</span></span><br><span class="line">  <span class="comment">// which is a necessary (but not sufficient) condition for convergence.</span></span><br><span class="line">  i64 num_changed = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    i64 n = propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_changed)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_changed = n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Run the pass until the unique number of hashes stop increasing, at which</span></span><br><span class="line">  <span class="comment">// point we have achieved convergence (proof omitted for brevity).</span></span><br><span class="line">  i64 num_classes = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// count_num_classes requires sorting which is O(n log n), so do a little</span></span><br><span class="line">    <span class="comment">// more work beforehand to amortize that log factor.</span></span><br><span class="line">    <span class="keyword">for</span> (i64 i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">      propagate&lt;E&gt;(digests, edges, edge_indices, slot, converged, ap);</span><br><span class="line"></span><br><span class="line">    i64 n = count_num_classes&lt;E&gt;(digests[slot], ap);</span><br><span class="line">    <span class="keyword">if</span> (n == num_classes)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    num_classes = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="group-sections"><a href="#group-sections" class="headerlink" title="group sections"></a>group sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Group sections by SHA digest.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;group&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> *map = <span class="keyword">new</span> tbb::concurrent_unordered_map&lt;Digest, InputSection&lt;E&gt; *&gt;;</span><br><span class="line">  std::span&lt;Digest&gt; digest = digests[slot];</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    InputSection&lt;E&gt; *isec = sections[i];</span><br><span class="line">    <span class="keyword">auto</span> [it, inserted] = map-&gt;<span class="built_in">insert</span>(&#123;digest[i], isec&#125;);</span><br><span class="line">    <span class="keyword">if</span> (!inserted &amp;&amp; isec-&gt;<span class="built_in">get_priority</span>() &lt; it-&gt;second-&gt;<span class="built_in">get_priority</span>())</span><br><span class="line">      it-&gt;second = isec;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  tbb::<span class="built_in">parallel_for</span>((i64)<span class="number">0</span>, (i64)sections.<span class="built_in">size</span>(), [&amp;](i64 i) &#123;</span><br><span class="line">    <span class="keyword">auto</span> it = map-&gt;<span class="built_in">find</span>(digest[i]);</span><br><span class="line">    <span class="built_in">assert</span>(it != map-&gt;<span class="built_in">end</span>());</span><br><span class="line">    sections[i]-&gt;leader = it-&gt;second;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Since free&#x27;ing the map is slow, postpone it.</span></span><br><span class="line">  ctx.on_exit.<span class="built_in">push_back</span>([=] &#123; <span class="keyword">delete</span> map; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx.arg.print_icf_sections)</span><br><span class="line">  <span class="built_in">print_icf_sections</span>(ctx);</span><br></pre></td></tr></table></figure><p>这里我们暂时忽略digest是怎么来的细节，直接看这里使用的过程。将digest关联一个input section，这里的逻辑很像merge_leaf_nodes，只是key换成了Digest，本质更换了一种hash方式，另外不再是只针对leaf的了</p><h2 id="sweep-sections"><a href="#sweep-sections" class="headerlink" title="sweep sections"></a>sweep sections</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Eliminate duplicate sections.</span></span><br><span class="line"><span class="comment">// Symbols pointing to eliminated sections will be redirected on the fly when</span></span><br><span class="line"><span class="comment">// exporting to the symtab.</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function">Timer <span class="title">t</span><span class="params">(ctx, <span class="string">&quot;sweep&quot;</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Counter <span class="title">eliminated</span><span class="params">(<span class="string">&quot;icf_eliminated&quot;</span>)</span></span>;</span><br><span class="line">  tbb::<span class="built_in">parallel_for_each</span>(ctx.objs, [](ObjectFile&lt;E&gt; *file) &#123;</span><br><span class="line">    <span class="keyword">for</span> (std::unique_ptr&lt;InputSection&lt;E&gt;&gt; &amp;isec : file-&gt;sections) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isec &amp;&amp; isec-&gt;is_alive &amp;&amp; isec-&gt;<span class="built_in">is_killed_by_icf</span>()) &#123;</span><br><span class="line">        isec-&gt;<span class="built_in">kill</span>();</span><br><span class="line">        eliminated++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> InputSection&lt;E&gt;::<span class="built_in">is_killed_by_icf</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>-&gt;leader &amp;&amp; <span class="keyword">this</span>-&gt;leader != <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后消除掉重复的section。判断重复的依据是leader不等于自身。</p><h2 id="icf-sections-总结"><a href="#icf-sections-总结" class="headerlink" title="icf_sections 总结"></a>icf_sections 总结</h2><ol><li>CieRecord去重</li><li>merge leaf node</li><li>取出所有需要处理的section</li><li>计算digest</li><li>根据digest处理所有需要处理的section</li><li>消除重复的section</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/mold-6-section</summary>
      
    
    
    
    <category term="Linker" scheme="https://fusionbolt.github.io/categories/Linker/"/>
    
    
    <category term="mold" scheme="https://fusionbolt.github.io/tags/mold/"/>
    
  </entry>
  
  <entry>
    <title>”荒原狼训练者的奇迹“</title>
    <link href="https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/"/>
    <id>https://fusionbolt.github.io/2023/05/04/Reading/def-steppenwolr/</id>
    <published>2023-05-04T09:27:54.000Z</published>
    <updated>2023-05-04T09:42:17.441Z</updated>
    
    <content type="html"><![CDATA[<p>当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒原狼双重人格的痛苦，而这一切碎片，又唤醒了我疯狂的那一面。</p><p>哈里的个性使得他成为了一个非市民般的存在，但为了生存，依然住在市民所在的城市，银行里有着一定的财产，这些都约束住了他。而在市民之中，他那强烈的个性使得他与这个社会格格不入，无法被理解，亦无法被接受。</p><p>他既超脱于人，却又受限于人，对于他来说内心中人和狼的关系似乎也是如此矛盾，与他的身份不同，人和狼必须要有一方战胜另一方并且存在，为此他的内心中几乎每天都在上演一场人狼大战。但这场战争不可能有他想要的结果，除非他选择自我了断，使得这场战争成立的条件本身不复存在。</p><p>但他过去却一直未能注意到，即便不这样做，这场战争仍可以不复存在，而且本身其实是无意义的。因为人和狼的战争并非是为了争夺什么领土，它们本来是在这里和平相处，但受到了作为主观意识的哈里影响，所以他们认为必须要战胜对方，统一这个世界。除此之外哈里还未注意到的一个真相是这里除了人和狼之外，这里还有非常多种类的存在。</p><p>直到另一个“自己”，赫尔米娜的出现，这一切才开始发生改变。身为另一个哈里，她十分理解哈里所想，同时哈里带入崭新的世界，将他所忽视的、遗漏的东西再度展现在他的面前，哈里也因此开始看到自己内心中更多的角色。</p><p>这一切最终都在魔剧院中由哈里亲眼见证。当哈里暂时杀死了荒原狼的存在，哈里内心中的其他存在不再受到其抑制，因此它们全部从镜子中跳了出来，而哈里跟着内心中的无数个“我“前往了它们各自所在的区域，看到这些被遗忘、忽略了的自己。直到最后，哈里如另一个“自己”所想，亲手处决了另一个“自己”，并且迎来了自我的绞刑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当我开始阅读这本书，不出意外被哈里，被荒原狼，被这本书，被作者扼住了灵魂。作者与译者的描写，作者对哈里·荒原狼的刻画，哈里对那无聊人生的态度，我喜欢这种夹杂着内心深处嘶吼的疯狂。正文的副标题为：专为狂人而作，而书中所刻画出来的一切都被狂人的人格碎片所填满，哈里的自我压抑，荒</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="黑塞" scheme="https://fusionbolt.github.io/tags/%E9%BB%91%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>局外人</title>
    <link href="https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/"/>
    <id>https://fusionbolt.github.io/2023/05/03/Reading/thr-outsider-by-albert-camus/</id>
    <published>2023-05-03T09:03:59.000Z</published>
    <updated>2023-05-03T09:09:16.591Z</updated>
    
    <content type="html"><![CDATA[<p>对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种态度来传达给我们什么呢？是想表达出他所认为的人生无意义吗？</p><p>在序言中讲到局外人的直接含义是默尔索在审判过程被隔离在外，整个审判过程自己参与了但是又没有参与。想到了故事中律师说到了这样一句话：“这就是这场审讯的形象，所有一切都是真的，但又没有任何东西是真的！”网上一个评价的重点则是提到是因为对母亲的死无动于衷被判了死刑，这点过于荒谬。</p><p>在第一部分中出现了许多的角色，都有一些非常看似矛盾的行为：沙拉玛诺老头每天都在骂狗，但实际丢了又是那么牵挂。雷蒙虽然说这跟人打架自己没去惹对方，是对方来冒犯自己，但他却供养着对方的老婆，作者这里还添加了一句“我没有答言。”</p><blockquote><p>他对我说，他一直供养着这个女人。我没有答言。接着他又说，他知道附近一带关于他的流言飞语，但他问心无愧，他确实是一个仓库保管员。</p></blockquote><p>这个样子甚至还能问心无愧，我觉得实属荒谬。还有第二部中最后出现的神父，他不顾主角的心情和想法，只是想要将自己的想法强加，这可以说是他自大，但是最让人感到惊讶与荒谬的是他居然也是囚犯，身为神父还做出犯罪之举。</p><p>我感觉到默尔索与现实世界的分离，联想到文章后面的内容并且结合加缪的思想来看，也许是因为他觉得现实世界是无理的且不可掌控的。</p><blockquote><p>他的神气不是那么确信有把握吗？但他的确信不值女人的一根头发，他甚至连自己是否活着都没有把握，因为他干脆就像行尸走肉。而我，我好像是两手空空，一无所有，但我对自己很有把握，对我所有的一切都有把握，比他有把握得多，对我的生命，对我即将来到的死亡，都有把握。是的，我只有这份把握，但至少我掌握了这个真理，正如这个真理抓住了我一样。我以前有理，现在有理，将来永远有理。</p></blockquote><p>后面他对即将到来的死亡是有把握的，这种分离在后面也有谈及</p><blockquote><p>正当我的律师在继续发言时，一个卖冰的小贩吹响了喇叭，声音从街上穿过一个个大厅与法庭，传到了我耳边，对过去生活的种种回忆突然涌入我的脑海，那生活已经不属于我了。</p></blockquote><p>回到书名与故事中。局外人这个名字所象征的事情，在故事中的主角身上充分表现了出来。主角在许多发生的事情上像局外人一样存在，而他在这个世界像一个局外人一样存在。两章的内容中，第一章中默尔索那漠不关心的态度，像是在说默尔索自己主动选择作为一切的局外人，而第二章中则是处于审判中，虽然参与其中，但是整个过程并没有任何说话与行动的权利。</p><blockquote><p>我呢，我认为这仍然是把我这个人排斥出审判过程，把我化成一个零，又以某种方式，由他取代了我。</p></blockquote><p>我想加缪正是想要通过这样一则有些不讲理的故事来表达出他对这个世界的看法，他所认为的荒谬，在序言中译者也提到了</p><blockquote><p>人类对理性、和谐、永恒的渴求与向往和自然社会生存有限性之间的“断裂”，人类的奋斗作为与徒劳无功这一后果之间的断裂。</p></blockquote><p>这样一则不讲理的故事，正是这种看法的体现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对我来说读了这本书后最先能感受到的是默尔索的那种觉得许多事情都无所谓的心态，仿佛发生一切事情都与自己无关，对于母亲的去世没有什么特别的感受，第二天也该做什么做什么。我对于许多大多数人所认为很有必要的事情，或者大多数的日常都是抱有同样的态度，所以有些感同身受。加缪想要通过这种</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="加缪" scheme="https://fusionbolt.github.io/tags/%E5%8A%A0%E7%BC%AA/"/>
    
  </entry>
  
  <entry>
    <title>艾尔登法环</title>
    <link href="https://fusionbolt.github.io/2023/05/03/elden-ring/"/>
    <id>https://fusionbolt.github.io/2023/05/03/elden-ring/</id>
    <published>2023-05-03T09:01:53.000Z</published>
    <updated>2023-05-03T09:02:43.804Z</updated>
    
    <content type="html"><![CDATA[<p>二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。</p><p>首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能找到一个传送点，再加上玛丽卡楔石的帮助，几乎不需要花费太多的时间在打boss的路上。</p><p>招魂机制可以通过骨灰召唤角色出来吸引仇恨，你可以安心输出，当然魂系列其他作品也是有召唤npc的机制存在，但是都远不如这作骨灰的强大，后期召唤大哥甚至可以单挑许多boss，玩家被称为摇铃仆人。其次由于开放世界的设计，你可以绕过绝大多数boss，同时可以提前跑到中后期的地区捡垃圾，把自己的装备和等级提升一下再回来砍boss。</p><p>不过说到这里就要提到宫崎英高的恶意了，开局的大树守卫估计是很多人的阴影，可能很多人也没想到可以直接绕过，不过我想这里的设计是为了让玩家理解后面遇到的许多boss是可以直接跑的。另外有的玩家会选择直接到史东威尔去打恶兆，恶兆对于低级入门玩家还是不太友好，我觉得这里也有让你再去其他区域多探索的一个想法，只是这些设计都比较隐晦。</p><p>不熟悉的玩家个人开荒还是有些费劲的，我一开始也吃了很多瘪，后来“学习”了一下装备选择以及跑路捡强化石，以及去龙墓升级，也慢慢开始舒服多了。从数值方面降低了受苦的要素，之后作为一个探索类游戏真的非常棒，地图是真的大，而且景色非常棒。尤其是当你一开始走出了漆黑的新手洞窟后，当你通过升降梯到达了王城后，看到的那美丽的景色。</p><p>整体来说还是有许多有特色的boss。恶兆王给我的印象是比较深刻的，除了早期受苦的原因，另外独特的配音，在整个故事中其所在的位置，整个角色的塑造，以及经典的怒斥众臣等让这个角色深深的引入了我的脑海。</p><p>除了boss，许多精英怪也让大家印象深刻，比如说虾薪王，熊薪王，王室幽魂等，虽然受苦，但是也给网上的视频创作添加了许多素材，通过这种方式也给玩家们带来了很多欢乐，虽然这点或许并不在设计的初衷内。</p><p>这一作内容非常多，最首先感受到这一点的地方是地图。当我第一次打开地图，心想地图就这吗？但是随着后来我收集了一块又一块的地图碎片，整个地图也逐渐显现出了它原本的样子，这个过程中逐渐意识到原来一开始所能看到的部分只是整个交界地的冰山一角。</p><p>这一作的细节也非常非常多，游戏内容远超以往的魂系列，我一周目认真收集花了一百个小时才结束，但依然漏了许多东西。尽管不可避免的有一些偏向重复的要素，或者有一些玩家觉得很应付的要素，比如说一个后期的精英怪作为前中期区域的一些小boss，但是瑕不掩瑜。</p><p>泥头车的设计者你这样搞晚上睡得着觉吗？！</p><p>同时法环继承了魂系列一如既往的叙事，尽管拥有非常庞大的故事背景，但将故事隐藏在各种支线，以及各种道具的说明之中，给足了玩家们发掘、思考和想象的空间。</p><p>总体来说《艾尔登法环》是当之无愧的2022年度最佳游戏。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;二月底前入手了PS5以及艾尔登法环，打了一个月总算白金了，现在随便讲讲自己的感受。以下内容基本上避免了剧透，可安心食用。&lt;/p&gt;
&lt;p&gt;首先作为宫崎英高老贼的作品，受苦是大家最深刻的印象，不过这作在难度上确实降低了不少。首先是遍地都是的传送点，不再像魂系列一样跑路跑半天才能</summary>
      
    
    
    
    <category term="Game" scheme="https://fusionbolt.github.io/categories/Game/"/>
    
    
    <category term="魂系列" scheme="https://fusionbolt.github.io/tags/%E9%AD%82%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
</feed>
