<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Homura&#39;s Blog</title>
  
  
  <link href="https://fusionbolt.github.io/atom.xml" rel="self"/>
  
  <link href="https://fusionbolt.github.io/"/>
  <updated>2022-10-02T09:27:44.010Z</updated>
  <id>https://fusionbolt.github.io/</id>
  
  <author>
    <name>Homura</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工作踩坑小结</title>
    <link href="https://fusionbolt.github.io/2022/10/02/some-work-problem/"/>
    <id>https://fusionbolt.github.io/2022/10/02/some-work-problem/</id>
    <published>2022-10-02T09:26:12.000Z</published>
    <updated>2022-10-02T09:27:44.010Z</updated>
    
    <content type="html"><![CDATA[<p>前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>一开始闹了一个小乌龙，工具链支持到c++17的标准，但是同事之前指定了14的标准，差点就要把filesystem相关的代码全改掉了。但是后来依然编译不过，在需要系统调用的标准库处报了错误，这才想到裸机并没有这种东西，最后还是加条件判断宏全部处理掉了…</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><h2 id="修复问题"><a href="#修复问题" class="headerlink" title="修复问题"></a>修复问题</h2><p>裸机的启动代码中有一些汇编，其中JAL跳转指令在链接的时候报了错</p><p>startup.S:120:(.text+0xbe): relocation truncated to fit: R_RISCV_JAL against symbol `SystemInit’ defined in .text.SystemInit section in</p><p><a class="link"   href="https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean" >https://stackoverflow.com/questions/10486116/what-does-this-gcc-error-relocation-truncated-to-fit-mean<i class="fas fa-external-link-alt"></i></a></p><p>先说结论，JAL指令的立即数字段的长度是固定的，而所要跳转的地址超出了JAL这个字段所能代表的长度。</p><p>最初猜想是否和我的lib大小有关系，尝试删掉了部分代码缩小了接近一半的体积后果然可行。但是依靠这种方法解决是不可行的，代码体积无法再简化了，而且以后lib体积只会增大。参考链接中设置mcmodel，然而依然报错。</p><p>接着尝试修改链接顺序，因为符号的顺序是和链接的顺序相关的，想要将对应的符号放到链接的最前面，但是需要跳转到我的lib中的符号，又不方便再去调整lib中的顺序。</p><p>最后在同事的提醒下修改了链接脚本，将这些报错的text section放到了最前面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text : &#123;</span><br><span class="line">  . = ALIGN(0x8) ;</span><br><span class="line">  __stext = . ;</span><br><span class="line">  KEEP(*startup.o(*.text*))</span><br><span class="line">  KEEP(*startup.o(*.vectors*))</span><br><span class="line">  /* avoid link failed when lib too large */</span><br><span class="line">  *(.text.SystemInit)</span><br><span class="line">  *(.text.trap_c)</span><br><span class="line">  *(.text.vTaskSwitchContext)</span><br><span class="line">  *(.text.startup.main)</span><br><span class="line">*(.text)</span><br><span class="line">  *(.text*)</span><br><span class="line">  *(.text.*)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="conda的环境问题"><a href="#conda的环境问题" class="headerlink" title="conda的环境问题"></a>conda的环境问题</h1><p>在使用某个python库的时候提示了Could not find a suitable hostfxr library，一直以为hostfxr相关的库版本错了，直到我点进这个源码看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_hostfxr</span>(<span class="params">dotnet_root: <span class="built_in">str</span></span>):</span></span><br><span class="line">    hostfxr_name = _get_dll_name(<span class="string">&quot;hostfxr&quot;</span>)</span><br><span class="line">    hostfxr_path = os.path.join(dotnet_root, <span class="string">&quot;host&quot;</span>, <span class="string">&quot;fxr&quot;</span>, <span class="string">&quot;?.*&quot;</span>, hostfxr_name)</span><br><span class="line">    <span class="keyword">for</span> hostfxr_path <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">sorted</span>(glob.glob(hostfxr_path))):</span><br><span class="line">        <span class="built_in">print</span>(hostfxr_path)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> ffi.dlopen(hostfxr_path)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> error:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">raise</span> RuntimeError(<span class="string">f&quot;Could not find a suitable hostfxr library in <span class="subst">&#123;dotnet_root&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>一看血压直接拉满，抛了异常一律视为没找到。手动改成打印错误信息才发现是dlopen的时候所加载的glibcxx版本不对，由于是在conda环境下因此去修改conda的链接。不是第一次被conda坑了…</p><h1 id="优化与调试"><a href="#优化与调试" class="headerlink" title="优化与调试"></a>优化与调试</h1><p>这算是我第一次实际遇到因为优化产生的问题。由于最近在调试内存分配相关模块的问题，我想要手动malloc/new一块内存复现问题。此处为代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_malloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;na\n&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nb\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="keyword">int</span> *c = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nc\n&quot;</span>);</span><br><span class="line"><span class="built_in">free</span>(c);</span><br><span class="line"><span class="keyword">int</span> *d = <span class="built_in">malloc</span>(<span class="number">32</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;nd\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于用的是裸机专用的工具链，因此内存的分配和释放都会调用工具链中的代码，我在其中打了log，但是发现new的时候并没有打印log。</p><p>没有调试器，想了半天怎么也想不明白，最后查看反汇编发现画风是这样的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/some-work-problem/Untitled.png"                      alt="Untitled"                ></p><p>指定编译选项的部分都是其他同事编写的，我一开始也没往这里想。看了半天最后发现原来malloc被优化掉了。b和d很直接，是unused的代码，但是a和c都被free了却依然被优化掉。</p><p>关于这个问题好奇搜了一下，搜到这个回答</p><p><a class="link"   href="https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2" >https://stackoverflow.com/questions/17899497/malloc-and-gcc-optimization-2<i class="fas fa-external-link-alt"></i></a></p><p>the optimizer knows malloc and considers it is a function with no side-effects，多半是编译器内部针对特定符号编写的优化</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前些时间工作中踩到的坑做个简单小总结，第一次搞裸机与交叉编译，本次内容也以此为主。&lt;/p&gt;
&lt;h1 id=&quot;编译&quot;&gt;&lt;a href=&quot;#编译&quot; class=&quot;headerlink&quot; title=&quot;编译&quot;&gt;&lt;/a&gt;编译&lt;/h1&gt;&lt;p&gt;一开始闹了一个小乌龙，工具链支持到c++1</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CrossCompiling" scheme="https://fusionbolt.github.io/tags/CrossCompiling/"/>
    
    <category term="Conda" scheme="https://fusionbolt.github.io/tags/Conda/"/>
    
  </entry>
  
  <entry>
    <title>NuttX mm模块在64位环境下的问题</title>
    <link href="https://fusionbolt.github.io/2022/10/02/nuttx-mm-in-64/"/>
    <id>https://fusionbolt.github.io/2022/10/02/nuttx-mm-in-64/</id>
    <published>2022-10-02T08:03:03.000Z</published>
    <updated>2022-10-02T08:08:51.683Z</updated>
    
    <content type="html"><![CDATA[<p>随手记录一下最近折磨了我很久的一个问题。最近在基于某一套裸机工具链做交叉编译并且在某个模拟器上执行代码，模拟器上几乎没法断点，没法用调试器，只能手工加log的方式。加上打log本身非常拖累运行速度，几乎一秒一个字符，所以这个问题来来回回拖了好几天才解决。</p><p>提供的工具链中内存分配和释放相关的代码是基于开源的nuttx做了一点点修改，不涉及代码隐私问题，因此这里也会直接贴对应的代码。nuttx是为32位设计的系统，直接拿来64位的环境自然会有不少问题。</p><p>nuttx源码</p><p><a class="link"   href="https://github.com/projectara/nuttx/tree/master/nuttx/include/nuttx/mm" >https://github.com/projectara/nuttx/tree/master/nuttx/include/nuttx/mm<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://github.com/projectara/nuttx/tree/master/nuttx/mm/mm_heap" >https://github.com/projectara/nuttx/tree/master/nuttx/mm/mm_heap<i class="fas fa-external-link-alt"></i></a></p><h1 id="最小可复现代码与初定位"><a href="#最小可复现代码与初定位" class="headerlink" title="最小可复现代码与初定位"></a>最小可复现代码与初定位</h1><p>模拟器上执行代码的时候遇到vector的第三次push_back就会死循环在某个地方，写了一个vector push_back的用例来测试，依然会死循环卡住。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_vector_pushback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 1\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 2\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;p 3\n&quot;</span>);</span><br><span class="line">  v.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是最简单的用例，自然不可能是我代码写错了。后来想到模拟器或许能dump pc，拿到pc后再去反汇编代码中看（全部都是静态链接塞进去），发现在这里死循环了</p><p>mm_mallinfo.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (node = heap-&gt;mm_heapstart[region];</span><br><span class="line">           node &lt; heap-&gt;mm_heapend[region];</span><br><span class="line">     node = (struct mm_allocnode_s *)((<span class="keyword">char</span> *)node + node-&gt;size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//  printf(&quot;node=%p size=%d pre=%d (%c)\n&quot;, node,</span></span><br><span class="line"><span class="comment">//         node-&gt;size, (node-&gt;preceding &amp; ~MM_ALLOC_BIT),</span></span><br><span class="line"><span class="comment">//         (node-&gt;preceding &amp; MM_ALLOC_BIT) ? &#x27;A&#x27; : &#x27;F&#x27;);</span></span><br><span class="line">  <span class="keyword">if</span> ((node-&gt;preceding &amp; MM_ALLOC_BIT) != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    uordblks += node-&gt;size;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    ordblks++;</span><br><span class="line">    fordblks += node-&gt;size;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;size &gt; mxordblk)</span><br><span class="line">    &#123;</span><br><span class="line">      mxordblk = node-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看到这个for循环的更新和判断条件，第一反应想到的就是size在某个地方为0了，导致不断在原地打转，因此我打印了heap的start和end，以及开启了循环内的打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">heapstart:<span class="number">00000000001</span>C9B30</span><br><span class="line">heapend:<span class="number">000000001</span>EFFFFE8</span><br><span class="line">...</span><br><span class="line">node=<span class="number">00000000001</span>CAF08 size=<span class="number">0000000000000410</span> pre=<span class="number">00000000000011</span>D0 (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB318 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000410</span> (F)</span><br><span class="line">node=<span class="number">00000000001</span>CB328 size=<span class="number">00000000001</span>C75C8 pre=<span class="number">0000000000000000</span> (F)</span><br><span class="line">node=<span class="number">00000000003928F</span>0 size=<span class="number">0000000000000000</span> pre=<span class="number">0000000000000000</span> (F)</span><br></pre></td></tr></table></figure><p>可以看到遍历到某个node的时候size就变成了空。但我这个时候注意力全都放在了size为空这件事情上，因为这个工程同事之前接触到free出错的情况，就让同事来帮忙看，这才意识到原来0 size node之前的node的size和pre也都不对劲。</p><p>之后通过打各种log，将直接产生问题的地方定位到了free中，同时也就能在出错之前打印出原本正确的node信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node=<span class="number">00000000001</span>CAF08 size=<span class="number">0000000000000410</span> pre=<span class="number">00000000000011</span>D0 (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB318 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000410</span> (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB328 size=<span class="number">0000000000000010</span> pre=<span class="number">0000000000000010</span> (A)</span><br><span class="line">node=<span class="number">00000000001</span>CB338 size=<span class="number">000000001</span>EE34CB0 pre=<span class="number">0000000000000010</span> (F)</span><br></pre></td></tr></table></figure><p>注意这里坏掉的是1CB328，也就是倒数第二个结点</p><p>再看一下关于free的主要逻辑。源代码比较长，由于在这个例子中未进行merge，因此省略了对应的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_free</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *mem, <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>)caller;</span><br><span class="line">  <span class="comment">//mvdbg(&quot;Freeing %p\n&quot;, mem);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protect against attempts to free a NULL reference */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!mem)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Map the memory chunk into a free node */</span></span><br><span class="line"></span><br><span class="line">  node = (struct mm_freenode_s *)((<span class="keyword">uint64_t</span>)mem - SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  node-&gt;preceding &amp;= ~MM_ALLOC_BIT;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the merged node to the nodelist */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addfreechunk</span>(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里很明显关键在于mm_addfreechunk。但是在看这个函数之前，我们先看一下heap和各种node是怎样的。</p><h1 id="heap与node"><a href="#heap与node" class="headerlink" title="heap与node"></a>heap与node</h1><p>heap的成员很多，我们在这里只放出我们这里需要关注的几个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_heap_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span> *<span class="title">mm_heapstart</span>[<span class="title">CONFIG_MM_REGIONS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span> *<span class="title">mm_heapend</span>[<span class="title">CONFIG_MM_REGIONS</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> <span class="title">mm_nodelist</span>[<span class="title">MM_NNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后我们先来看一下初始化全局堆的地方</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_heap_initialize</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">mm_initialize</span>(&amp;g_mmheap, &amp;__heap_start, (<span class="keyword">uint64_t</span>)(&amp;__heap_end) - (<span class="keyword">uint64_t</span>)(&amp;__heap_start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_initialize</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *heapstart,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">size_t</span> heapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//mlldbg(&quot;Heap: start=%p size=%u\n&quot;, heapstart, heapsize);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following two lines have cause problems for some older ZiLog</span></span><br><span class="line"><span class="comment">   * compilers in the past (but not the more recent).  Life is easier if we</span></span><br><span class="line"><span class="comment">   * just the suppress them altogther for those tools.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ZILOG__</span></span><br><span class="line">  <span class="comment">//CHECK_ALLOCNODE_SIZE;</span></span><br><span class="line">  <span class="comment">//CHECK_FREENODE_SIZE;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up global variables */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  heap-&gt;mm_nregions = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the node array */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(heap-&gt;mm_nodelist, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(struct mm_freenode_s) * MM_NNODES);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MM_NNODES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">      heap-&gt;mm_nodelist[i<span class="number">-1</span>].flink = &amp;heap-&gt;mm_nodelist[i];</span><br><span class="line">      heap-&gt;mm_nodelist[i].blink   = &amp;heap-&gt;mm_nodelist[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize the malloc semaphore to one (to support one-at-</span></span><br><span class="line"><span class="comment">   * a-time access to private data sets).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_seminitialize</span>(heap);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the initial region of memory to the heap */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addregion</span>(heap, heapstart, heapsize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化nodelist，添加一个region。（目前的代码中只有一个region</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_addregion</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">void</span> *heapstart,</span></span></span><br><span class="line"><span class="params"><span class="function">                  <span class="keyword">size_t</span> heapsize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> heapbase;</span><br><span class="line">  <span class="keyword">uintptr_t</span> heapend;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  <span class="keyword">int</span> IDX = heap-&gt;mm_nregions;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> IDX 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If the MCU handles wide addresses but the memory manager is configured</span></span><br><span class="line"><span class="comment">   * for a small heap, then verify that the caller is  not doing something</span></span><br><span class="line"><span class="comment">   * crazy.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_SMALL) &amp;&amp; !defined(CONFIG_SMALL_MEMORY)</span></span><br><span class="line">  <span class="comment">//DEBUGASSERT(heapsize &lt;= MMSIZE_MAX+1);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust the provide heap start and size so that they are both aligned</span></span><br><span class="line"><span class="comment">   * with the MM_MIN_CHUNK size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  heapbase = <span class="built_in">MM_ALIGN_UP</span>((<span class="keyword">uintptr_t</span>)heapstart);</span><br><span class="line">  heapend  = <span class="built_in">MM_ALIGN_DOWN</span>((<span class="keyword">uintptr_t</span>)heapstart + (<span class="keyword">uintptr_t</span>)heapsize);</span><br><span class="line">  heapsize = heapend - heapbase;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//mlldbg(&quot;Region %d: base=%p size=%u\n&quot;, IDX+1, heapstart, heapsize);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the size of this region to the total size of the heap */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapsize += heapsize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Create two &quot;allocated&quot; guard nodes at the beginning and end of</span></span><br><span class="line"><span class="comment">   * the heap.  These only serve to keep us from allocating outside</span></span><br><span class="line"><span class="comment">   * of the heap.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * And create one free node between the guard nodes that contains</span></span><br><span class="line"><span class="comment">   * all available memory.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapstart[IDX]            = (struct mm_allocnode_s *)heapbase;</span><br><span class="line">  heap-&gt;mm_heapstart[IDX]-&gt;size      = SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  heap-&gt;mm_heapstart[IDX]-&gt;preceding = MM_ALLOC_BIT;</span><br><span class="line"></span><br><span class="line">  node                        = (struct mm_freenode_s *)(heapbase + SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  node-&gt;size                  = heapsize - <span class="number">2</span>*SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  node-&gt;preceding             = SIZEOF_MM_ALLOCNODE;</span><br><span class="line"></span><br><span class="line">  heap-&gt;mm_heapend[IDX]              = (struct mm_allocnode_s *)(heapend - SIZEOF_MM_ALLOCNODE);</span><br><span class="line">  heap-&gt;mm_heapend[IDX]-&gt;size        = SIZEOF_MM_ALLOCNODE;</span><br><span class="line">  heap-&gt;mm_heapend[IDX]-&gt;preceding   = node-&gt;size | MM_ALLOC_BIT;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> IDX</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> CONFIG_MM_REGIONS &gt; 1</span></span><br><span class="line">  heap-&gt;mm_nregions++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Add the single, large free node to the nodelist */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">mm_addfreechunk</span>(heap, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapstart和heapend分别保存了一个指向heap开始和结尾的allocnode的地址，初始化的时候中间有一个非常大的空闲的freenode，而随着之后内存的分配，中间会有越来越多的node。</p><p>注意allocnode和freenode的异同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_allocnode_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> size;           <span class="comment">/* Size of this chunk */</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> preceding;      <span class="comment">/* Size of the preceding chunk */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> size;                   <span class="comment">/* Size of this chunk */</span></span><br><span class="line">  <span class="keyword">mmsize_t</span> preceding;              <span class="comment">/* Size of the preceding chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">flink</span>;</span> <span class="comment">/* Supports a doubly linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">blink</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>显而易见，allocnode和freenode存储的时候都是以一个size和preceding开始，只是free的后面还会跟两个指针。</p><p>其中的preceding保存了前一个chunk的size，同时也标记了当前的块是被分配的状态还是被释放的状态，allocnode和freenode的处理方式都是不相同的。</p><p>我们再回到初始化的部分，可以看到start和end的size是SIZEOF_MM_ALLOCNODE，中间空闲的node size为heapsize - 2 * SIZEOF_MM_ALLOCNODE，也就是说<strong>这个size是算入了保存内存信息的空间</strong>。</p><h1 id="mm-addfreechunk"><a href="#mm-addfreechunk" class="headerlink" title="mm_addfreechunk"></a>mm_addfreechunk</h1><p>我们再回来看mm_addfreechunk。我在这个函的前后从heapstart开始出发采用size递增的方式遍历，经过addfreechunk之后就开始死循环了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mm_addfreechunk</span><span class="params">(struct mm_heap_s *heap, struct mm_freenode_s *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Convert the size to a nodelist index */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ndx = <span class="built_in">mm_size2ndx</span>(node-&gt;size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Now put the new node int the next */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (prev = &amp;heap-&gt;mm_nodelist[ndx], next = heap-&gt;mm_nodelist[ndx].flink;</span><br><span class="line">       next &amp;&amp; next-&gt;size &amp;&amp; next-&gt;size &lt; node-&gt;size;</span><br><span class="line">       prev = next, next = next-&gt;flink);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Does it go in mid next or at the end? */</span></span><br><span class="line"></span><br><span class="line">  prev-&gt;flink = node;</span><br><span class="line">  node-&gt;blink = prev;</span><br><span class="line">  node-&gt;flink = next;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (next)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* The new node goes between prev and next */</span></span><br><span class="line"></span><br><span class="line">      next-&gt;blink = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数逻辑也比较简单，找到对应的节点，修改flink和blink，只是看着这段逻辑很难想到为什么会引起那么奇怪的问题。</p><p>不过我一开始以错误的思路打下了一个log反而利于我想明白问题。最初理解node排布之后，我手动采用了node + size的方式访问到了这种方式访问到的最后一个node。我在mm_addfreechunk之前获取了最后一个node，并在前后打印该node的信息，发现并没有什么异常。后来晚上回家的路上突然意识到这样打印是有问题的，mm_addfreechunk会改变连接关系。但是这后来给了我一个提示，原来end node所在的地址没有被写掉。</p><h1 id="内存排布与解决方案"><a href="#内存排布与解决方案" class="headerlink" title="内存排布与解决方案"></a>内存排布与解决方案</h1><p>最后我开始画了内存图，想明白了原因。</p><p>回看最早出现死循环的地方，每次循环的递增是通过node = (struct mm_allocnode_s *)((char *)node + node-&gt;size))来做的，也就是说所有的node是排布在heapstart和heapend中间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start     <span class="number">328</span>            <span class="number">338</span>            free                 end</span><br><span class="line">|size|prec|size|prec|data|size|prec|data|size|prec|data      |size|prec|</span><br></pre></td></tr></table></figure><p>倒数第二个结点(338)坏掉，是因为倒数第三个结点(328)数据写越界了。这块空间被释放掉以后那么起始地址就会被视为一个freenode，在后面mm_addfreechunk修改对应的flink和blink的时候，由于除了size和preceding的数据大小小于了两个指针的大小，因此覆写了下一个内存块开头的部分。</p><p>那么我们实际上需要保证每次分配给数据的大小需要大于等于两个指针的大小。</p><p>mm_malloc.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">mm_malloc</span><span class="params">(struct mm_heap_s *heap, <span class="keyword">size_t</span> size, <span class="keyword">void</span> *caller)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mm_freenode_s</span> *<span class="title">node</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> ndx;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_DETECT_ERROR)</span></span><br><span class="line">  <span class="keyword">size_t</span> real_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Handle bad sizes */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (size &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_DETECT_ERROR)</span></span><br><span class="line">  size = (size + <span class="number">3</span>) &amp; ~<span class="number">3</span>;</span><br><span class="line">  real_size = size;</span><br><span class="line">  size += MDBG_SZ_HEAD + MDBG_SZ_TAIL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Adjust the size to account for (1) the size of the allocated node and</span></span><br><span class="line"><span class="comment">   * (2) to make sure that it is an even multiple of our granule size.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  size = <span class="built_in">MM_ALIGN_UP</span>(size + SIZEOF_MM_ALLOCNODE);</span><br></pre></td></tr></table></figure><p>这里最后实际alloc的size是MM_ALIGN_UP以后的大小</p><p>mm.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_MM_SMALL) &amp;&amp; UINTPTR_MAX &lt;= UINT32_MAX</span></span><br><span class="line"><span class="comment">/* Two byte offsets; Pointers may be 2 or 4 bytes;</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 8 or 12 bytes.</span></span><br><span class="line"><span class="comment"> * REVISIT: We could do better on machines with 16-bit addressing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MIN_SHIFT    4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   15  <span class="comment">/* 32 Kb */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(CONFIG_HAVE_LONG_LONG)</span></span><br><span class="line"><span class="comment">/* Four byte offsets; Pointers may be 4 or 8 bytes</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 16 or 24 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">if</span> UINTPTR_MAX &lt;= UINT32_MAX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> MM_MIN_SHIFT  4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">elif</span> UINTPTR_MAX &lt;= UINT64_MAX</span></span><br><span class="line"><span class="meta">#    <span class="meta-keyword">define</span> MM_MIN_SHIFT  5  <span class="comment">/* 32 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   22  <span class="comment">/*  4 Mb */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* Four byte offsets; Pointers must be 4 bytes.</span></span><br><span class="line"><span class="comment"> * sizeof(struct mm_freenode_s) is 16 bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MIN_SHIFT    4  <span class="comment">/* 16 bytes */</span></span></span><br><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> MM_MAX_SHIFT   22  <span class="comment">/*  4 Mb */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All other definitions derive from these two */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_MIN_CHUNK     (1 &lt;&lt; MM_MIN_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_MAX_CHUNK     (1 &lt;&lt; MM_MAX_SHIFT)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_NNODES        (MM_MAX_SHIFT - MM_MIN_SHIFT + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_GRAN_MASK     (MM_MIN_CHUNK-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_ALIGN_UP(a)   (((a) + MM_GRAN_MASK) &amp; ~MM_GRAN_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MM_ALIGN_DOWN(a) ((a) &amp; ~MM_GRAN_MASK)</span></span><br></pre></td></tr></table></figure><p>根据这里的代码可以得知我们只需要修改对应的MM_MIN_SHIFT即可解决问题</p><p>解决问题以后发现在这段代码的正上方也有相关的注释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Chunk Header Definitions *************************************************/</span></span><br><span class="line"><span class="comment">/* These definitions define the characteristics of allocator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MM_MIN_SHIFT is used to define MM_MIN_CHUNK.</span></span><br><span class="line"><span class="comment"> * MM_MIN_CHUNK - is the smallest physical chunk that can</span></span><br><span class="line"><span class="comment"> *   be allocated.  It must be at least a large as</span></span><br><span class="line"><span class="comment"> *   sizeof(struct mm_freenode_s).  Larger values may</span></span><br><span class="line"><span class="comment"> *   improve performance slightly, but will waste memory</span></span><br><span class="line"><span class="comment"> *   due to quantization losses.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MM_MAX_SHIFT is used to define MM_MAX_CHUNK</span></span><br><span class="line"><span class="comment"> * MM_MAX_CHUNK is the largest, contiguous chunk of memory</span></span><br><span class="line"><span class="comment"> *   that can be allocated.  It can range from 16-bytes to</span></span><br><span class="line"><span class="comment"> *   4Gb.  Larger values of MM_MAX_SHIFT can cause larger</span></span><br><span class="line"><span class="comment"> *   data structure sizes and, perhaps, minor performance</span></span><br><span class="line"><span class="comment"> *   losses.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>这个文件访问了很多次，但是每次都是为了访问特定的声明和定义，没有在意到其他地方的注释。不过自己潜入代码中去了解，自己去思考原因也算是一个增加经验的机会。就算提早看到了这个注释可能因为缺少很多信息也不会想到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;随手记录一下最近折磨了我很久的一个问题。最近在基于某一套裸机工具链做交叉编译并且在某个模拟器上执行代码，模拟器上几乎没法断点，没法用调试器，只能手工加log的方式。加上打log本身非常拖累运行速度，几乎一秒一个字符，所以这个问题来来回回拖了好几天才解决。&lt;/p&gt;
&lt;p&gt;提供</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Memory" scheme="https://fusionbolt.github.io/tags/Memory/"/>
    
    <category term="Baremetal" scheme="https://fusionbolt.github.io/tags/Baremetal/"/>
    
    <category term="NuttX" scheme="https://fusionbolt.github.io/tags/NuttX/"/>
    
  </entry>
  
  <entry>
    <title>游颐和园</title>
    <link href="https://fusionbolt.github.io/2022/09/17/TourTheSummerPalace/"/>
    <id>https://fusionbolt.github.io/2022/09/17/TourTheSummerPalace/</id>
    <published>2022-09-17T15:10:57.000Z</published>
    <updated>2022-09-17T15:15:10.499Z</updated>
    
    <content type="html"><![CDATA[<p>下午从新建宫门入了颐和园，上次来已经是去年冬天的事情了，与上次不同的是十七孔桥现在不再设置栏杆，遂带着好奇心走向桥的另一端。到了对面看也没看到什么特别的，也没什么好拍的。倒是看到了许多经典十七孔桥照片的视角，但非金光穿洞日这些地方不太值得拍。</p><p>走着走着开始感觉热了起来，身上出了很多汗，来的也不是个好时候，几乎可以说是一天中最热的时间段，北京这个日子甚至还能到30度。但之后走到了一处三面被树木环绕一面朝湖的阴凉地，此时微风携带着湖水的清凉吹过来，甚是舒服。也许是这阵清凉的感觉激起了我调动更多感官去感受周围一切的想法。我开始触摸岩石，建筑，体会它们的纹理与摸上去时手的触感。看起来尖锐的岩石摸上去并不扎手，大多锋利的边缘都已经被时间所打磨的光滑，像极了经历了几年工作后脱发的程序员群体们（bushi）。自己多久没有摸过这些东西了呢？每天的手接触的都是冷酷无情的机械设备，这样的我与自然完全断开了联系。</p><p>由于包比较重，体验了没多久便找了个地方坐下休息一会，由于没什么事情做就开始发呆。看着湖中一艘艘小船驶过，脑袋里的新想法似有似无，但脑袋里想的事情哪怕是自己也很捉摸不透，就放任它在混沌中产生新的混沌吧。</p><p>没多久又决定走回了起始点，向着北边的东门走去。路上回想着去年冬天拍的视角都是怎样的，想要拍一组对比的照片，之前拍的照片没有发过，而群晖的quickconnect太慢加上没有折腾内网穿透也就无法访问家里的照片查看，最后只有凭借着记忆多拍了几张。回来发现好多之前觉得不好看都删掉了，就剩下这组对比，视角差的还挺大，不过意思传达到了，有机会再补吧（下次一定！）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5702.jpg"                      alt="DSCF5702.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF0406.jpg"                      alt="DSCF0406.jpg"                ></p><p>拍的过程中刚才调动感官的想法再次冒了出来，开始像个新生儿一样带着好奇心触摸各种事物。树干带给我的印象是粗糙且潮湿，后者大概是因为在湖边吧；而树叶带给我的感觉是柔软但边缘有些不平整的毛刺，不同种类的树叶摸起来的感觉自然也不同，但没有太多的印象了。接着是感受着太阳烘烤下岩石的温暖，以及各种地面与建筑表面。看到了小时候经常看到的一种墙面，多久没有这样仔细触摸过这样的石墙了呢，不过这倒也不是什么问题。还仔细觉察脚踩到地面的感觉，鹅卵石地面与普通的水泥地有着各自独特的感觉，由于隔着鞋子需要更加注意才能体会到，不过最关键的还是去觉察那个部位的感觉，如果没有觉察那么习惯了以后很容易就会忽略掉这些感受。</p><p>回到走向东门这个话题，本来此行就是为了桂花来的。中秋前两天忙着各种地方拍月亮，第三天累的只想休息，也就没来看桂花，明年可能会来吧。这里我所看到的有金桂和银桂两种，银桂只有一个小花苞，大概花期还要点时间，遗憾的是金桂大都凋谢的差不多了，万幸的是气味多少还残留一点。本着来都来了的优良传统，我想再好好找找再走，果不其然最后找到了一株还有一些花朵残留的金桂，兴奋的我赶紧放下背包赶紧收拾东西准备开拍。要去拍的时候发现有几个大爷大妈们拿着手机在拍，拍遮挡视线倒是也没啥问题，等一会有位置再拍就好，只是都把手机怼到了树枝里面，树枝的强烈颤动导致许多花都掉了下来。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5714.jpg"                      alt="DSCF5714.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5722.jpg"                      alt="DSCF5722.jpg"                ></p><p>还拍到了一只小蜜蜂！</p><p>拍完桂花则是向着东北角出发，尽管来过两三次但一直没有走过那边的路线。在看路线施工告示的时候一个老奶奶和阿姨跟我讲这里的路现在是怎么回事，后面跟着老奶奶和阿姨进了谐趣园，听了很多有意思的故事，比如说谐趣园里面有一个特别大的柳树，曾经有一只白鹭每天来水池里捕食鱼类，有一位拍到下落、下水捕捞、飞走的照片，之后第二天开园的时候就来了得有两百多的人把谐趣园水池旁边的路围绕的水泄不通，一个个都架好了长枪短炮。白鹭也确实来了，但是看到人这么多也就一直在柳树上没再下过水，老奶奶等到了中午十一点多没来也就走了（前一天是这个时间拍到的）。在北京的人应该能想象，无论你去什么有名景点总有一些老大爷全副武装在拍些什么。</p><p>之后听老奶奶讲了很多关于谐趣园里的事情，这里建筑的风格、合适的拍照点、以及一些历史背景之类的。在园内几乎转了一圈，最后坐在了园内的走廊讲起了各种各样的事情。“什么也不做坐在这里喝杯茶、看看景、聊聊天就挺好的，按照我们老年人的想法是这样的”，对此我深表认同。这种宁静也未必一定要老年人才应该去享受，每日都市的喧嚣又快节奏的生活偶尔也需要这样安静的坐下来，不急于做些什么，只是看着周围漂亮的风景，和旁边的人聊聊天，大概此时周围的环境会像海绵一样吸收掉压力、焦虑与烦呐吧。谐趣园里面很多地方设计的也确实非常巧妙，景色也很不错，看到有人坐在走廊里读书。我想夏季的雨天在这里漫步一定非常惬意吧，听着雨击打池塘与地面的声音，看着满池子绽放的荷花与游动的鱼群，和旁边的人聊聊天或者看看书，这该是多么美妙的景象，明年如果还记得这件事情我一定要来体会一次。不过赶上休息日合适的时间下雨也确实是一件难事。</p><p>我的照片难以显现出这里的一些设计之巧妙，还是需要亲自体会才行</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5744.jpg"                      alt="DSCF5744.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5755.jpg"                      alt="DSCF5755.jpg"                ></p><p>老奶奶还讲了很多关于圆明园的故事，说道圆明园今天有爱国教育活动免费，虽然早就得知了这件事但我想要避开人流，因此今天也就来了颐和园。即便圆明园很大，很多地方人多的话很多地方依然显得空，但是我更想要安静的地方。人也不需要那么多，有认识的人就够了。大概坐了半个多小时，老奶奶和阿姨与我告别了。我在园内又转了好久，拍了一些照片。幸运的是今天又拍到了停留在花朵上的蝴蝶，上一次拍到还是之前去玉渊潭的时候拍到的蝴蝶落在樱花上。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5740.jpg"                      alt="DSCF5740.jpg"                ></p><p>拍了几张后出了谐趣园右转，发现这里有许多猫。每天云吸猫的我当然不肯放过这样的好机会，于是准备装备开拍。但这个时候我有些冲动，看到一个小孩子要拿一根草去动猫我竟然动手制止了，我并没有用什么力气，也没想吓到他，但是也算是碰到他了，还说出了不要动猫这样的话，随后他的家长说道他也没有要去动猫，我也不该动手。此时的我算是十分的羞愧，不是他是否真的要去动猫，而是我居然动手了，只能连忙道歉，他们走后我内心还是一阵不安，为了刚才做的错事感到一阵情绪存在。也许是赎罪性质，我只是挂着相机，但是迟迟没有去拍。我蹲在猫猫面前，一直学着招财猫的手势向猫猫摆手了半天，当然不仅是这个时候，之后我拍猫的时候一直都在这样摆手，不知为什么总想要做出这样的行为。随后我觉得不应该为了这些事情烦恼，拍猫要紧，连忙拍起了猫猫。这只猫一开始我以为它不开心，但是最后发现大概是困了，做什么动作，哪怕是接近它都毫无反应，最后它就在那边睡了过去，我也只好不再打扰。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5772.jpg"                      alt="DSCF5772.jpg"                ></p><p>睡得可真香啊，在做什么样的梦呢</p><p>随后周围拍其他猫的时候发现有一个铁栅栏后面有更多的猫，并且对面是可抵达的，遂即决定赶过去拍猫。赶向铁栅栏后的路上，开始感觉到疲惫逐渐侵蚀我的身心。开始有点无力，有一点点晕，还毫无理由的产生了一些负面的想法。虽然没走多少步，但架不住包和里面的东西实在太重，上午去上钢琴课还背了一大堆课本，同时手里还在举着相机四处拍照。但我不想就这么离开，找了个地方坐下尝试恢复一波能量后就继续出发。</p><p>到了猫猫的聚集地，呆了半个多小时，拍了几张照片。拍照倒是没什么，有意思的是和猫猫的互动。和一只猫对视，我往后退一步，它就往前走一步。这个很难以照片的形式体现了</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5804.jpg"                      alt="DSCF5804.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5835.jpg"                      alt="DSCF5835.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5843.jpg"                      alt="DSCF5843.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5844.jpg"                      alt="DSCF5844.jpg"                ></p><p>猫猫也拍完了，我走向出口的路上坐在了一个延伸出的木台阶上，看着眼前翠绿的世界，就这么静静的坐着，除了偶尔听一下歌词的内容之外什么也不去想，什么也不去做。我很喜欢这里，宁静，有树有湖，让人感到安心，如果小雨天在这里散步该有多棒</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5789.jpg"                      alt="DSCF5789.jpg"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/TourTheSummerPalace/DSCF5846.jpg"                      alt="DSCF5846.jpg"                ></p><p>随后边走边随便拍几张，最后终于出了北门。饿的不行，便直冲离这最近的一家速食店，此时不得不说KFC虽然其他方面不行，但是店是真的多，这周围甚至都没看到其他能吃饭的店铺。KFC旁边的自动售货机买了一瓶脉动，象征性补充一下流失的其他物质，身体缺水的情况还是不太想直接去喝可乐，之后在KFC随便吃了点就坐上了回家的地铁。坐地铁的过程中倒是没什么好说的，离这也不远，大概五六站的路程，只是上车的时候正赶上日落的时间，出地铁时周围已是一片漆黑，不由得让人想要感叹时间流逝之快。</p><p>今天比预想的逛的要久，非常累，明天大概会去圆明园吧，并且会更累。主要是听说那边现在有花海，我还没有亲身经历过什么花海，之前去过北京植物园但是并没有见到数量多到花海程度的花，毕竟植物园更关键的是多样性。</p><p>以下是宝可梦爱好者的专享内容。</p><p>虽然前面说道想要体会各种感官，但今天一下午都没有摘下耳机。下午基本上就是宝可梦dp相关的几首音乐反复听，原本是想找最终对战白菜姐的bgm，但是偶然搜到了动画的op，倒是也很好听就一起加入了清单。对战白菜姐的bgm就没什么可讲的了，讲讲op的部分吧。</p><p>dp的动画主题曲给我印象最深刻的是这么两个地方：一个是跨越天冠山，另一个是超越时间与空间。</p><p>高いテンガン山　越えていこう</p><p>天冠山对于这作游戏来说是十分重要的，全部的游戏主线剧情，甚至整个地图我都觉得是围绕着天冠山设计的。而天冠山内部的剧情又相对比较难打，跨越这座山给我的感觉不仅是单独的征服一座山，而是克服诸多困难。尽管登山本身是如此，但是只是说跨越山对于我一个不爬山的人来说真的没有什么感觉。</p><p>時空を超えて 僕らは会える、まぶしいみんなの顔</p><p>本身dp的两个封面神就是代表时间与空间，而超越时空的相会又是十分珍贵的。后面还有きらめく瞳　ダイヤかパール这样的歌词，很容易就会联想到“友情是珍珠，回忆是钻石”这句话。不得不说dp不仅是神兽设定B格很高，而且动画本身的立意也很深刻。</p><p>一直在听的除了上面提到的两首还有对战赤日的bgm，这首bgm给了我许多不一样的感觉，略低沉的开头让我联想到了对战之前黑暗的世界，想到了对战时黑暗的背景，同时联想到了赤日的角色性格。</p><p>这几首都非常好听，况且这一作的宝可梦对我来说也是最喜欢的。</p><p>对战dp神以及三蘑菇的bgm其实也很棒，但今天下午并没有反复听。听这一下午搞得我很想收藏ost</p><p>最后放一下三首歌的Spotify的链接吧，其他的bgm都可以在专辑中找到</p><p>op：together</p><p><a class="link"   href="https://open.spotify.com/track/5eO5Bnv3wLgW9qawRpYfFR?si=421e89091bcb494a" >https://open.spotify.com/track/5eO5Bnv3wLgW9qawRpYfFR?si=421e89091bcb494a<i class="fas fa-external-link-alt"></i></a></p><p>白菜姐对战时的bgm</p><p><a class="link"   href="https://open.spotify.com/track/0u18DUjJSoq9gDQhxJBgxD?si=d257af05927d4c9d" >https://open.spotify.com/track/0u18DUjJSoq9gDQhxJBgxD?si=d257af05927d4c9d<i class="fas fa-external-link-alt"></i></a></p><p>对战赤日的bgm</p><p>[<a class="link"   href="https://open.spotify.com/track/25ns1GhXoBMo7XFfFtcJbU?si=a949e8cbdac54081%5D" >https://open.spotify.com/track/25ns1GhXoBMo7XFfFtcJbU?si=a949e8cbdac54081]<i class="fas fa-external-link-alt"></i></a>(</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;下午从新建宫门入了颐和园，上次来已经是去年冬天的事情了，与上次不同的是十七孔桥现在不再设置栏杆，遂带着好奇心走向桥的另一端。到了对面看也没看到什么特别的，也没什么好拍的。倒是看到了许多经典十七孔桥照片的视角，但非金光穿洞日这些地方不太值得拍。&lt;/p&gt;
&lt;p&gt;走着走着开始感觉</summary>
      
    
    
    
    <category term="Life" scheme="https://fusionbolt.github.io/categories/Life/"/>
    
    
    <category term="颐和园" scheme="https://fusionbolt.github.io/tags/%E9%A2%90%E5%92%8C%E5%9B%AD/"/>
    
  </entry>
  
  <entry>
    <title>吹响吧！上低音号</title>
    <link href="https://fusionbolt.github.io/2022/08/24/Sound-Enphonium/"/>
    <id>https://fusionbolt.github.io/2022/08/24/Sound-Enphonium/</id>
    <published>2022-08-24T05:35:08.000Z</published>
    <updated>2022-08-28T05:36:39.357Z</updated>
    
    <content type="html"><![CDATA[<p>整部番一切都距离我的现实过于遥远，无法引起什么共鸣，但是依然能够感受到各个剧情所表达出的情感：努力过后取得成果的兴奋，失败的遗憾与不甘心等等，仿佛自己也是其中的一员一样。日常生活中点点细节的衬托，人物的台词和表情，无一例外都在推动着情感的变化，有的是直白的，有的是非常隐晦的。同时两季+剧场版充足的分量讲述了十分多的故事，包含了高中生活中的方方面面，或许对于各种各样的观众都会多少找到一些自身的影子，不论是兴趣爱好与升学的矛盾、角色的成长、角色的不甘心还是努力的成功与失败等等，包含了太多太多真实的人生，这也让整个故事更加让人感同身受。</p><p>这部动画个人最喜欢的地方当然还是久美子和丽奈的互动。印象最深刻的是选拔的时候，久美子认为丽奈和别人不同，丽奈不能淹没在人群中，这部分的喊声将情绪全部带动起来。即便丽奈赢了要成为坏人久美子也会陪她一起，那句“我背叛你你可以杀了我”以及后面的台词简直是神来之笔，将两个之间的感情全部展现的淋漓尽致。</p><p>随着各种故事的开展，每个角色都在不断成长，久美子的性格成长是最显著的，最开始被丽奈说“久美子性格真是差劲呢”，后面经历了各种各样的事情以后逐渐变的成熟，这种方面也是有些让人羡慕。同时各个角色的形象也逐渐变的饱满，最初看起来非常高冷的丽奈，但是在剧情的发展过程中不断展现出各种各样的性格，对久美子”爱的告白“，选拔的剧情，后面为了和老师说话早去练习（还被久美子说”丽奈的这一点真是可爱“），以及后面的大胆表白，都是我印象比较深刻的地方。</p><p>有的作品天马行空，完全脱离现实，满足了人们的幻想；有的作品完全是贴近现实，引发情感冲动。京吹自然是后者，这两种不能说绝对的谁好谁坏，只是不同方面罢了。看京吹的时候注意力很难不放在可爱的角色上，看到可爱的角色们互动自然也会很开心，看同样为百合动画的Lycoris是这样的。但对于京吹来说，即便观众的注意力会被角色的可爱所吸引，但是接近现实的剧情更容易触动观众的内心，观众更会不自觉的把自己代入到其中的角色中，感受角色的想法，过于现实反而让人有感触，不像一些过于虚构的动画一样。不过最后总会从动画的幻想回到现实，这个时候会对自己所欠缺的开始感到羡慕、难过、渴求，或者说开始感受到更强烈的感受。而观众所感受到的这种强烈的感觉，我觉得也是京吹这部动画的魅力之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;整部番一切都距离我的现实过于遥远，无法引起什么共鸣，但是依然能够感受到各个剧情所表达出的情感：努力过后取得成果的兴奋，失败的遗憾与不甘心等等，仿佛自己也是其中的一员一样。日常生活中点点细节的衬托，人物的台词和表情，无一例外都在推动着情感的变化，有的是直白的，有的是非常隐晦的</summary>
      
    
    
    
    <category term="Animate" scheme="https://fusionbolt.github.io/categories/Animate/"/>
    
    
    <category term="京阿尼" scheme="https://fusionbolt.github.io/tags/%E4%BA%AC%E9%98%BF%E5%B0%BC/"/>
    
  </entry>
  
  <entry>
    <title>世界尽头与冷酷仙境</title>
    <link href="https://fusionbolt.github.io/2022/08/21/Hard-Boiled-Wonderland/"/>
    <id>https://fusionbolt.github.io/2022/08/21/Hard-Boiled-Wonderland/</id>
    <published>2022-08-21T05:30:13.000Z</published>
    <updated>2022-08-28T05:34:12.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冷酷仙境"><a href="#冷酷仙境" class="headerlink" title="冷酷仙境"></a>冷酷仙境</h1><p>冷酷仙境的人们有心却又无法交心，心仿佛摆设一样。名为冷酷仙境，我不是很能明白名字的用意，也许是有了心因此相比于世界尽头算是仙境，但是人们之间无法交心因此是冷酷的。</p><p>其中情感外壳非常坚固的主人公的这段想法让我印象十分深刻</p><blockquote><p>也许，我想。任何人都不会紧紧搂抱我，我也不会紧紧搂抱别人。我就这样一年老似一年，像贴在海底岩石的海参一样孤单单地一年年衰老下去。</p></blockquote><p>紧紧搂抱是多么温暖的一件事情，但是却寻求不到。不会有人来抱着自己，自己也不会去抱别人。海底是那么的黑暗，陪伴自己的却只有冰冷的岩石，独自贴在上面又是多么的孤单的一件事情。即便是在海洋这种充满了生物的环境，在这么隐蔽的地方就不会被看到，也不会有人愿意来这里看，最终只会只身孤单下去，直到死去。即便有人会来到这里，自己却习惯了贴在岩石之上，因为长时间在这样的环境之中内心已经开始形成了一层层的外壳来保护自己，因此不愿去和他人接触，不愿去拥抱他人。</p><p>同时前后文中女郎的回应同样让我印象深刻</p><blockquote><p>在又黑暗又孤寂难过渴望别人拥抱的时候周围却没有人拥抱自己</p></blockquote><blockquote><p>即使花钱买很多很多女郎同床，即使同很多很多萍水相逢的女孩睡觉，也都不是实实在在的，谁都不会紧紧搂抱你的身体</p></blockquote><p>冷酷仙境的世界即便大家都有心，都能够正常生活，却无法找到和自己紧紧搂抱的人。人虽然正常的生存在这里，能够与他人产生交集，却无法与他人产生些什么深入的联系，无法产生爱意，即便身处人流之中却依然感到十分孤单，因为没有建立起密切联系的人。</p><p>冷酷仙境就是这样孤单的世界。</p><h1 id="世界尽头"><a href="#世界尽头" class="headerlink" title="世界尽头"></a>世界尽头</h1><p>世界尽头的人们进入了小镇后心会逐渐消失。名为世界尽头的深意，除了故事中提到的人进来了就要失去影子并且无法再出去之外，我觉得如果人没有了心那么也就到了其世界的尽头了。</p><p>这个世界这样能够运行很奇怪吧，本应当和人一体的影子逐渐和人分离，后面就会渐渐变得虚弱，最终死去，此时人也就彻底失去了心。人们即便没有心却依然这样生存着，每个人做事情也没有什么原因，没有什么自己的想法，只是因为要做这件事情。</p><p>心没了，情感自然也就没了所在之处。而这样的人并非不会产生情感而是都被独角兽吸去了。独角兽们带着情感逝去，被看门人斩下带有情感的头骨，再转生，像情感本身一样不断的诞生与消亡。</p><p>从记忆中就没有心的图书管理员不会对现状感到任何异样与奇怪，未曾感受过温暖也不知温暖为何物。而没有心的她也无法对主人公的想法产生任何回应，就像大校所说的：即便能和她在一起，能同她睡，但她没有心依然无法回应你。人的心意无法传达到，无法感受到她人的心意都是非常悲伤的事情。</p><p>世界尽头就是这样的“墓穴”。</p><h1 id="世界尽头与冷酷仙境"><a href="#世界尽头与冷酷仙境" class="headerlink" title="世界尽头与冷酷仙境"></a>世界尽头与冷酷仙境</h1><p>不论是冷酷仙境中的主角和女郎，还是世界尽头的人们，大家都以各自的形式缺少爱与温暖，但是对他们来说这个样子都是可以生存的。是可以生存，但是仅仅如此罢了。这样的世界该是多么孤独与悲伤啊。明知是这样孤独与悲伤的故事，却又无法从心底唤起什么情感，可能我像图书管理员一样早已没了影子，又或许我已经不知什么时候成为了世界尽头的居民吧，回过神的时候自己的影子就已经不知何时被看门人分离了，而它现在也只能虚弱的躺在床上。</p><p>不论是心还是情感对于人都是非常重要的。冷酷仙境中的人们有心但未能对他人真正产生情感，而世界尽头的人们更是直接失去了心。不论是哪一方，在旁观者的角度来看都是那么的孤单和悲伤。</p><p>最后两个世界交汇的方式着实有点意外，也许这个结局是在暗示一直将自己包裹在坚固外壳中的孤独者的最终归宿就是在世界尽头中与自己的影子分离，最终彻底失去自己的心。写到这里多少有些感伤了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冷酷仙境&quot;&gt;&lt;a href=&quot;#冷酷仙境&quot; class=&quot;headerlink&quot; title=&quot;冷酷仙境&quot;&gt;&lt;/a&gt;冷酷仙境&lt;/h1&gt;&lt;p&gt;冷酷仙境的人们有心却又无法交心，心仿佛摆设一样。名为冷酷仙境，我不是很能明白名字的用意，也许是有了心因此相比于世界尽头算是仙</summary>
      
    
    
    
    <category term="Reading" scheme="https://fusionbolt.github.io/categories/Reading/"/>
    
    
    <category term="村上春树" scheme="https://fusionbolt.github.io/tags/%E6%9D%91%E4%B8%8A%E6%98%A5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其四：PassManager的改进与迁移现状</title>
    <link href="https://fusionbolt.github.io/2022/07/17/llvm-pass-4/"/>
    <id>https://fusionbolt.github.io/2022/07/17/llvm-pass-4/</id>
    <published>2022-07-17T08:54:17.000Z</published>
    <updated>2022-07-17T08:55:26.664Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-4/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">仪式召唤！降临吧，青眼混沌极龙！这样闹剧也就结束了，混沌的极限爆裂！</center> <p>这一期我们来做一下之前遗漏的AM和PM的对比分析、新的PM机制相比legacy PM做了哪些改进以及LLVM中PM的现状</p><h1 id="PassManager和AnalysisManager"><a href="#PassManager和AnalysisManager" class="headerlink" title="PassManager和AnalysisManager"></a>PassManager和AnalysisManager</h1><p>之前虽然单独讲过PassManager（简称PM）以及AnalysisManager（简称AM），但是没有将这两者放到一起对比，在这里我们简单对比一下PM、AM以及对应的Pass，通过对比我们能够更深入的理解普通Pass和Analysis的异同。这里算是一个回顾也就不再贴代码了，如果忘记了可以参考前面几篇，其中都包含了详细的代码</p><h2 id="显然的相同点"><a href="#显然的相同点" class="headerlink" title="显然的相同点"></a>显然的相同点</h2><p>这里的相同点更多的是代码实现方式上，而不是Pass（这段统称Analysis和Pass为Pass）自身性质之间的差异</p><p>Pass自身都采取了ConceptBase的实现方式，PM添加一个Pass的时候通过将这个Pass保存到一个相应的Model中，之后通过Model来执行Pass</p><h2 id="addPass"><a href="#addPass" class="headerlink" title="addPass"></a>addPass</h2><p>Manager的使用首先从添加Pass开始，对于两者来说都是保存了一个XXXModel在Manager中，但是对于普通Pass来说传入的参数是一个Pass的实例，而一个Analysis传入的是一个AnalysisBuilder，也就说Analysis的构建实际上是通过这个builder延迟执行的，如果这个Analysis存在的话则不会再重复构造</p><p>这样的差异是由于对于一个Analysis来说只需要存有一个实例即可，每次做分析都会找到这个analysis进行分析，同时analysis不需要考虑顺序的问题，在普通Pass需要的时候进来找到对应Pass跑就可以了。对于普通Pass则会添加多个实例到整个流程中，普通Pass的执行顺序是依靠于添加的Pass实例的顺序</p><p>还有一个差异是PM允许添加一个作为Pass的PM（换个说法PM也是一个符合条件的Pass），实际的行为则是将另一个PM的所有pass添加进来，这和上面提到的传参方式的差异本质是相同的</p><h2 id="执行Pass"><a href="#执行Pass" class="headerlink" title="执行Pass"></a>执行Pass</h2><p>PM执行的入口是run，这里没什么特别的，只要不是被指定skip的pass都会执行（执行Pass之前会有callback进行判断）</p><p>AM执行的入口是getResult，由于AM不仅需要保存实例还需要缓存之前分析的结果，因此每次getResult都需要分析是否存在缓存再决定是否执行Analysis，也就是说并非一定会执行。</p><h1 id="新PM改进了什么"><a href="#新PM改进了什么" class="headerlink" title="新PM改进了什么"></a>新PM改进了什么</h1><p>接下来的内容以这个链接内容的解读为主，许多地方会讲的比较粗略，不明白的请优先参考原文</p><p><a class="link"   href="https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/" >https://blog.llvm.org/posts/2021-03-26-the-new-pass-manager/<i class="fas fa-external-link-alt"></i></a></p><p>这个链接中主要提到了这么几个问题</p><h2 id="Pass和Analysis分离"><a href="#Pass和Analysis分离" class="headerlink" title="Pass和Analysis分离"></a>Pass和Analysis分离</h2><p>在legacy Pass架构中普通Pass和Analysis都是相同的Pass，而在新架构中从类型以及实际执行上区分开了两者</p><blockquote><p>With the legacy PM, each pass declares which analyses it requires and preserves, and the pass manager schedules those analyses as passes to be run if they aren’t currently cached or have been invalidated. Declaring ahead of time which analyses a pass may need is unnecessary boilerplate, and a pass might not end up using all analyses in all cases.</p></blockquote><p>legacy Pass主要有以下这么两类问题</p><ol><li><p>执行不必要的分析</p><p>执行Pass的时候可能还没到需要信息的地方就提前停下了，也就是说这些Analysis并没有被用上，又或者说根据分支结构有些修改没有执行（即不会影响某些分析结果），会导致实际没有修改的部分的分析又重新跑了一遍</p></li><li><p>Pass编写上十分麻烦</p><ol><li>手动指定依赖的analysis又蠢又麻烦</li><li>还要写各种构造函数初始化</li></ol></li></ol><p>除了作者提到的这些之外，我觉得还有两个重要的点</p><ol><li><p>Pass的顺序</p><p>这里的顺序主要还是指的普通Pass和Analysis之间。在legacy PM中主要是通过每次addPass的时候进行一次schedule来解决普通Pass依赖analysis的情况，而在新Pass中则是需要的时候再根据是否有缓存再实际跑分析，不需要考虑analysis应该什么时候执行的问题</p></li><li><p>新的Pass很大程度的简化了各个和Pass相关部分的实现。不需要再手动指定是否为Analysis或者CFGPass了，直接通过类型来做区分而不是记录在PassInfo中，Pass自身的元信息记录内容以及记录方式都简化了许多，而用到这些信息的代码也会精简很多</p></li></ol><h2 id="获取Analysis信息"><a href="#获取Analysis信息" class="headerlink" title="获取Analysis信息"></a>获取Analysis信息</h2><blockquote><p>Since the legacy PM modelled analyses as passes to be scheduled and run, we can’t efficiently access analyses to arbitrary functions.For a function analysis, the corresponding analysis pass will only contain the info for the current function, which is created during the latest run of the analysis pass. We can manually create analyses for other functions, but they won’t be cached anywhere</p></blockquote><p>这里主要还是说legacy PM中analysis视为一个普通pass的话无法缓存结果。这些都是通过AM管理analysis以及缓存结果来实现的。AM最重要的意义我认为一个是不需要再通过各种schedule的方式来管理执行analysis的时间，另一个则是缓存机制来减少不必要的分析</p><h2 id="CGSCC-Pass"><a href="#CGSCC-Pass" class="headerlink" title="CGSCC Pass"></a>CGSCC Pass</h2><p>这部分我不太了解，目前还没有了解过CGSCC相关的代码，直接看一下原文吧</p><blockquote><p>However, the legacy CGSCC pass manager only stored the functions in the current SCC in memory and did not have a persistent call graph data structure to use as keys to cache analyses. So we need to keep the whole graph in memory to have something to use as a key. And if we have a persistent call graph, we need to make sure it is up to date if passes change its structure.</p></blockquote><h2 id="Pass结构关系"><a href="#Pass结构关系" class="headerlink" title="Pass结构关系"></a>Pass结构关系</h2><blockquote><p>When adding passes to the legacy pass manager, the nesting of different pass types is implicit.For example, adding function passes after a module pass implicitly creates a function pass manager over a contiguous list of function passes.</p></blockquote><p>对于legacy PM来说每次添加的Pass都是一个Pass基类，看不到任何类型之间的关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassManager::add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">  PM-&gt;<span class="built_in">add</span>(P);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PM-&gt;add</span></span><br><span class="line"><span class="comment">/// \copydoc PassManager::add()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">schedulePass</span>(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在新pm中normal pass都是有着严格的类型限制，PM和Pass级别不同的时候使用各种adaptor显式转换的，而analysis则是通过各种proxy来处理</p><p>这是上期里我们看过的图，这就是整个PM中保存的Pass结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    R(ModulePassManager)</span><br><span class="line">    R--&gt;MP(ModulePass)</span><br><span class="line">    R--&gt;FP(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FP--&gt;FPS(FunctionPass)</span><br><span class="line">    R--&gt;FPTemp(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FPTemp--&gt;LPP(FunctionToLoopPassAdator)</span><br><span class="line">    LPP--&gt;LPPS(LoopPass)</span><br></pre></td></tr></table></figure><h2 id="避免过多的全局变量"><a href="#避免过多的全局变量" class="headerlink" title="避免过多的全局变量"></a>避免过多的全局变量</h2><blockquote><p>The legacy pass manager relies on many global flags and registries. This is supported by macros generating functions and variables to initialize passes, and any users of the legacy pass manager must make sure to call a function to initialize these passes. But we need some way for a pass manager builder to be aware of all passes for testing purposes.</p></blockquote><p>在旧的Pass架构中存在过多的全局变量与registries，每个Pass都需要通过宏来注册，进而产生全局变量以及initialize函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">initializeFlattenCFGLegacyPassPassOnce</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">initializeAAResultsWrapperPassPass</span>(Registry);</span><br><span class="line">  PassInfo *PI =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassInfo</span>(<span class="string">&quot;Flatten the CFG&quot;</span>, <span class="string">&quot;flattencfg&quot;</span>, &amp;FlattenCFGLegacyPass::ID,</span><br><span class="line">                   PassInfo::<span class="built_in">NormalCtor_t</span>(callDefaultCtor&lt;FlattenCFGLegacyPass&gt;),</span><br><span class="line">                   <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  Registry.<span class="built_in">registerPass</span>(*PI, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> llvm::once_flag InitializeFlattenCFGLegacyPassPassFlag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llvm::initializeFlattenCFGLegacyPassPass</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  llvm::<span class="built_in">call_once</span>(InitializeFlattenCFGLegacyPassPassFlag,</span><br><span class="line">                  initializeFlattenCFGLegacyPassPassOnce, std::<span class="built_in">ref</span>(Registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的架构中通过传递PassManager以及使用PassBuilder统一来注册Pass到PM中来解决这个问题（实际LLVMRunPasses的情况）</p><h2 id="out-of-tree-passes"><a href="#out-of-tree-passes" class="headerlink" title="out of tree passes"></a>out of tree passes</h2><p>我对legacy的注册out of tree passes的情况不太了解，看官方的example中是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Legacy PM Registration */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">RegisterBye</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    llvm::PassManagerBuilder::EP_VectorizerStart,</span></span></span><br><span class="line"><span class="params"><span class="function">    [](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="params"><span class="function">       llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> LegacyBye()); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> llvm::RegisterStandardPasses <span class="title">RegisterByeLTO</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    llvm::PassManagerBuilder::EP_ModuleOptimizerEarly,</span></span></span><br><span class="line"><span class="params"><span class="function">    [](<span class="keyword">const</span> llvm::PassManagerBuilder &amp;Builder,</span></span></span><br><span class="line"><span class="params"><span class="function">       llvm::legacy::PassManagerBase &amp;PM) &#123; PM.add(<span class="keyword">new</span> LegacyBye()); &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>新 PM的注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* New PM Registration */</span></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getByePluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Bye&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerVectorizerStartEPCallback</span>(</span><br><span class="line">                [](llvm::FunctionPassManager &amp;PM, OptimizationLevel Level) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, llvm::FunctionPassManager &amp;PM,</span><br><span class="line">                   ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;goodbye&quot;</span>) &#123;</span><br><span class="line">                    PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_BYE_LINK_INTO_TOOLS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getByePluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这个简单的例子看起来写的更麻烦的了，复杂的情况使用callback的形式或许会更方便实现。比起写法上来说，更大的差异是不再需要一大堆global成员了，以及legacy中还要对LTO以及非LTO做处理，但是对于新PM来说LTO也是依靠的PassBuilder来注册Pass，也就是说不需要再对两处进行注册。</p><p>新PM的注册是通过在PassBuiler中注册callback形式实现的。在文章中提到了这样一句</p><blockquote><p>Although there is a global list of functions, there is no mutable global state since each pass manager builder can parse pass pipelines without going through a global registry.</p></blockquote><h2 id="parallelize"><a href="#parallelize" class="headerlink" title="parallelize"></a>parallelize</h2><p>这篇文章的后面提到了并行相关的问题。对于SCC的Pass来说是比较容易并行的，但是对于其他的就不一样了。比如说这里</p><blockquote><p>Some passes only use analyses if they are cached, so parallelization can <strong>cause non-determinism since a module analysis may or may not exist based on other parallel pipelines</strong>.The new PM <strong>only allows function passes to access cached module analyses and does not allow running them</strong>. This has the downside of needing to make sure that certain higher-level analyses are present before running a lower-level pipeline, e.g. making sure GlobalsAA has been computed before running a function pipeline.</p></blockquote><p>一个Module的analysis可能基于其他并行的pipeline，所以会导致不确定性。因此新的PM只允许获取cached的module analyses。比如说上期提到的ModuleAnalysisManagerFunctionProxy并非直接getResult获取结果，而是直接getCachedResult。我觉得这里说的可能更类似于多线程读一个只读变量的情况，但是我不知道自己的理解是否存在问题，如有不对还请指正</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getModuleAAResultImpl</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AAResults &amp;AAResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;MAMProxy = AM.getResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *R =</span><br><span class="line">          MAMProxy.<span class="keyword">template</span> getCachedResult&lt;AnalysisT&gt;(*F.<span class="built_in">getParent</span>())) &#123;</span><br><span class="line">    AAResults.<span class="built_in">addAAResult</span>(*R);</span><br><span class="line">    MAMProxy</span><br><span class="line">        .<span class="keyword">template</span> registerOuterAnalysisInvalidation&lt;AnalysisT, AAManager&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h1><p>注：以下内容的实效性不强</p><h2 id="部分迁移"><a href="#部分迁移" class="headerlink" title="部分迁移"></a>部分迁移</h2><blockquote><p>Currently the new PM applies only to the middle-end optimization pipeline working with LLVM IR. The backend codegen pipeline still works only with the legacy PM, mostly because most codegen passes don’t work on LLVM IR, but rather machine IR (MIR), and nobody has yet put in the time to create the new PM infrastructure for MIR passes and to migrate all of the backends to use the new PM. Migrating to the new PM for the codegen pipeline likely won’t unlock performance gains since there are almost no interprocedural codegen passes. However, it would clean up a lot of technical debt.</p></blockquote><p>根据这段所讲，目前codegen的部分还没有完成迁移，只做了少部分的处理。但是许多Pass依然是旧的形式，现在的代码中也能看到许多为了兼容legacy Pass的形式</p><p>在旧的架构中codegen是通过加到legacy PM中的</p><p>以下代码来自llvm的教程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">legacy::PassManager pass;</span><br><span class="line"><span class="keyword">auto</span> FileType = CGFT_ObjectFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (TheTargetMachine-&gt;<span class="built_in">addPassesToEmitFile</span>(pass, dest, <span class="literal">nullptr</span>, FileType)) &#123;</span><br><span class="line">  <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;TheTargetMachine can&#x27;t emit a file of this type&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pass.<span class="built_in">run</span>(*TheModule);</span><br></pre></td></tr></table></figure><p>LLVM目前的CodeGen这里的PassBuilder基本成形（新架构注册Pass相关的转换为了PassBuilder的形式）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line">Error CodeGenPassBuilder&lt;Derived&gt;::<span class="built_in">buildPipeline</span>(</span><br><span class="line">    ModulePassManager &amp;MPM, MachineFunctionPassManager &amp;MFPM,</span><br><span class="line">    raw_pwrite_stream &amp;Out, raw_pwrite_stream *DwoOut,</span><br><span class="line">    CodeGenFileType FileType) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="function">AddIRPass <span class="title">addIRPass</span><span class="params">(MPM, Opt.DebugPM)</span></span>;</span><br><span class="line">  <span class="built_in">addISelPasses</span>(addIRPass);</span><br><span class="line"></span><br><span class="line">  <span class="function">AddMachinePass <span class="title">addPass</span><span class="params">(MFPM)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">addCoreISelPasses</span>(addPass))</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">derived</span>().<span class="built_in">addMachinePasses</span>(addPass))</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(Err);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addAsmPrinter</span>(</span><br><span class="line">      addPass, [<span class="keyword">this</span>, &amp;Out, DwoOut, FileType](MCContext &amp;Ctx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;TM.<span class="built_in">createMCStreamer</span>(Out, DwoOut, FileType, Ctx);</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addPass</span>(<span class="built_in">FreeMachineFunctionPass</span>());</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这些addPass的变量我觉得是一种为了兼容临时过渡的形式，在使用的时候是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;</span><br><span class="line"><span class="keyword">void</span> CodeGenPassBuilder&lt;Derived&gt;::<span class="built_in">addISelPasses</span>(AddIRPass &amp;addPass) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (TM.<span class="built_in">useEmulatedTLS</span>())</span><br><span class="line">    <span class="built_in">addPass</span>(<span class="built_in">LowerEmuTLSPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">addPass</span>(<span class="built_in">PreISelIntrinsicLoweringPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addIRPasses</span>(addPass);</span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addCodeGenPrepare</span>(addPass);</span><br><span class="line">  <span class="built_in">addPassesToHandleExceptions</span>(addPass);</span><br><span class="line">  <span class="built_in">derived</span>().<span class="built_in">addISelPrepare</span>(addPass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deprecated"><a href="#deprecated" class="headerlink" title="deprecated"></a>deprecated</h2><p>在LLVM14的Release Notes中看到</p><blockquote><p>Using the legacy pass manager for the optimization pipeline is deprecated and will be removed after LLVM 14. In the meantime, only minimal effort will be made to maintain the legacy pass manager for the optimization pipeline.</p></blockquote><p>看起来的意思是LLVM15都要移植完并且删除，LLVM15的文档还在施工初期，其中也并没有什么有价值的信息，codegen这部分不知道会不会也要全部移植完</p><h2 id="test"><a href="#test" class="headerlink" title="test"></a>test</h2><p>除了核心功能之外，还有一些Test目前依然是使用Legacy PM的形式</p><p>比如说TimePassesTest中这段测试的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clear and generate report again.</span></span><br><span class="line">TimePassesStr.<span class="built_in">clear</span>();</span><br><span class="line"><span class="built_in">reportAndResetTimings</span>(&amp;ReportStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since we did not run any passes since last print, report should be empty.</span></span><br><span class="line"><span class="built_in">EXPECT_TRUE</span>(TimePassesStr.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now run just a single pass to populate timers again.</span></span><br><span class="line">legacy::PassManager PM2;</span><br><span class="line">PM2.<span class="built_in">add</span>(<span class="keyword">new</span> llvm::<span class="built_in">Pass2</span>());</span><br><span class="line">PM2.<span class="built_in">run</span>(M);</span><br></pre></td></tr></table></figure><h1 id="本系列结束"><a href="#本系列结束" class="headerlink" title="本系列结束"></a>本系列结束</h1><p>正如本文开始的召唤台词“这样闹剧也就结束了”所说，这个系列到此也就结束了，在这里扯点感想啥的吧。结束的比预想的要早，一开始列出的大纲有一些不是很大的组件都被合并进了各期中。一共五期，也就意味着过去了28天，真的是不知不觉就过去了…</p><p>内容上我不可能讲的面面俱到，但是我想如果你读完了这个系列的话会对整个新PM的结构，各个组件之间的关系有了一个了解。如果你还存有什么疑惑或者想法欢迎和我进行交流。</p><p>后续一定会开新的系列，欢迎持续关注我的博客/推特。之后的方向不出意外应该就是Pass里的具体实现，可能会从某一个DefaultPipeline为线索开始。更新频率不敢保证，就我这段时间学习的过程来说，Pass内部实现的代码非常长，加上相关联的知识点也非常多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-4/Un</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其三：PassBuilder</title>
    <link href="https://fusionbolt.github.io/2022/07/10/llvm-pass-3/"/>
    <id>https://fusionbolt.github.io/2022/07/10/llvm-pass-3/</id>
    <published>2022-07-10T11:45:23.000Z</published>
    <updated>2022-07-10T13:09:56.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LLVM-Pass-其三：PassBuilder"><a href="#LLVM-Pass-其三：PassBuilder" class="headerlink" title="LLVM Pass 其三：PassBuilder"></a>LLVM Pass 其三：PassBuilder</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">出来吧，罪青眼白龙！（为什么这张卡台词这么简单</center> <p>在前面几期中我们讲了新Pass，PassManager，Analysis是怎么样的，这期我们来讲一下PassBuilder以及实际许多Pass是如何组织起来的。</p><p>PassBuilder相关的源文件有这几个</p><p>include/llvm/Passes/PassBuilder.h</p><p>lib/Passes/PassBuilder.cpp</p><p>lib/Passes/PassBuilderPipelines.cpp</p><h1 id="PassBuilder结构"><a href="#PassBuilder结构" class="headerlink" title="PassBuilder结构"></a>PassBuilder结构</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This class provides access to building LLVM&#x27;s passes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Its members provide the baseline state available to passes during their</span></span><br><span class="line"><span class="comment">/// construction. The \c PassRegistry.def file specifies how to construct all</span></span><br><span class="line"><span class="comment">/// of the built-in passes, and those may reference these members during</span></span><br><span class="line"><span class="comment">/// construction.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassBuilder</span> &#123;</span></span><br><span class="line">  TargetMachine *TM;</span><br><span class="line">  PipelineTuningOptions PTO;</span><br><span class="line">  Optional&lt;PGOOptions&gt; PGOOpt;</span><br><span class="line">  PassInstrumentationCallbacks *PIC;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里有一个TargetMachine</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%201.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%202.png"                      alt="Untitled"                ></p><p>可以看到由这么几类成员构成</p><ol><li>存放基本信息的成员，包括TargetMachine以及各种保存的callback等</li><li>registerXXXAnalysis / registerXXXCallback</li><li>buildXXXpipeline</li><li>parseXXXPass / parseXXXPasePipeline</li></ol><h1 id="PassBuilder的使用"><a href="#PassBuilder的使用" class="headerlink" title="PassBuilder的使用"></a>PassBuilder的使用</h1><p>我们从PassBuilder的使用开始理顺里面的流程。PassBuilder有两处主要的使用位置，一处是在lto中调用，另一处是这次主要讲解的LLVMRunPasses</p><p>这个函数对应的头文件是include/llvm-c/Transforms/PassBuilder.h</p><p>而LLVMRunPasses的实现在lib/Passes/PassBuilderBindings.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LLVMErrorRef <span class="title">LLVMRunPasses</span><span class="params">(LLVMModuleRef M, <span class="keyword">const</span> <span class="keyword">char</span> *Passes,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMTargetMachineRef TM,</span></span></span><br><span class="line"><span class="params"><span class="function">                           LLVMPassBuilderOptionsRef Options)</span> </span>&#123;</span><br><span class="line">  TargetMachine *Machine = <span class="built_in">unwrap</span>(TM);</span><br><span class="line">  LLVMPassBuilderOptions *PassOpts = <span class="built_in">unwrap</span>(Options);</span><br><span class="line">  <span class="keyword">bool</span> Debug = PassOpts-&gt;DebugLogging;</span><br><span class="line">  <span class="keyword">bool</span> VerifyEach = PassOpts-&gt;VerifyEach;</span><br><span class="line"></span><br><span class="line">  Module *Mod = <span class="built_in">unwrap</span>(M);</span><br><span class="line">  PassInstrumentationCallbacks PIC;</span><br><span class="line">  <span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line">  LoopAnalysisManager LAM;</span><br><span class="line">  FunctionAnalysisManager FAM;</span><br><span class="line">  CGSCCAnalysisManager CGAM;</span><br><span class="line">  ModuleAnalysisManager MAM;</span><br><span class="line">  PB.<span class="built_in">registerLoopAnalyses</span>(LAM);</span><br><span class="line">  PB.<span class="built_in">registerFunctionAnalyses</span>(FAM);</span><br><span class="line">  PB.<span class="built_in">registerCGSCCAnalyses</span>(CGAM);</span><br><span class="line">  PB.<span class="built_in">registerModuleAnalyses</span>(MAM);</span><br><span class="line">  PB.<span class="built_in">crossRegisterProxies</span>(LAM, FAM, CGAM, MAM);</span><br><span class="line"></span><br><span class="line">  <span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">  SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach) &#123;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">VerifierPass</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">run</span>(*Mod, MAM);</span><br><span class="line">  <span class="keyword">return</span> LLVMErrorSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑非常清晰</p><ol><li>先对每一种Analysis注册，之后注册Proxies</li><li>注册callback</li><li>parsePassPieline开始添加Pass到MPM中</li></ol><p>接下来我们对这三部分操作逐一讲解</p><h1 id="注册Analyses"><a href="#注册Analyses" class="headerlink" title="注册Analyses"></a>注册Analyses</h1><p>首先我们回顾一下之前讲过的Pass注册方式。LLVM内部的Pass注册需要在PassRegistry.def中以宏的方式写下，之后在include这个文件的前面定义这些宏，之后再include这个文件完成整个流程</p><h2 id="registerXXXAnalyses"><a href="#registerXXXAnalyses" class="headerlink" title="registerXXXAnalyses"></a>registerXXXAnalyses</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::registerModuleAnalyses</span><span class="params">(ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  MAM.registerPass([&amp;] &#123; return CREATE_PASS; &#125;);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModuleAnalysisRegistrationCallbacks)</span><br><span class="line">    <span class="built_in">C</span>(MAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单的注册一遍Analysis之后执行一下ModuleAnalysisRegistrationCallbacks</p><p>除了Module，Function，Loop之类的实现基本上一致，这里不再重复贴代码了</p><h2 id="crossRegisterProxies"><a href="#crossRegisterProxies" class="headerlink" title="crossRegisterProxies"></a>crossRegisterProxies</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::crossRegisterProxies</span><span class="params">(LoopAnalysisManager &amp;LAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       FunctionAnalysisManager &amp;FAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       CGSCCAnalysisManager &amp;CGAM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       ModuleAnalysisManager &amp;MAM)</span> </span>&#123;</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerModuleProxy</span>(FAM); &#125;);</span><br><span class="line">  MAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerModuleProxy</span>(CGAM); &#125;);</span><br><span class="line">  CGAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerCGSCCProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">CGSCCAnalysisManagerFunctionProxy</span>(CGAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">ModuleAnalysisManagerFunctionProxy</span>(MAM); &#125;);</span><br><span class="line">  FAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">LoopAnalysisManagerFunctionProxy</span>(LAM); &#125;);</span><br><span class="line">  LAM.<span class="built_in">registerPass</span>([&amp;] &#123; <span class="keyword">return</span> <span class="built_in">FunctionAnalysisManagerLoopProxy</span>(FAM); &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是给各种的AnalysisManager注册了一个XXXXAnalysisManagerXXXProxy，而这些类型本质上是一个给proxy指定了部分模板参数的别名。比如说FunctionAnalysisManagerModuleProxy这个类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> FunctionAnalysisManagerModuleProxy =</span><br><span class="line">    InnerAnalysisManagerProxy&lt;FunctionAnalysisManager, Module&gt;;</span><br></pre></td></tr></table></figure><p>和普通Pass使用adaptor不同的是一个Function的Manager注册了到Module的Proxy，而Module也注册了一个到Function的Proxy。注意这里的是Outer，而不再是Inner了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure><h2 id="InnerAnalysisManagerProxy"><a href="#InnerAnalysisManagerProxy" class="headerlink" title="InnerAnalysisManagerProxy"></a>InnerAnalysisManagerProxy</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%203.png"                      alt="Untitled"                ></p><p>对于Proxy来说功能也是类似于adaptor，用于在不同范围的IRUnit之间转换处理。Inner和adaptor一样，将一个小范围的pass的应用在大的范围上（Function的analysis应用到整个Module上）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerAnalysisManagerProxy</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;</span><br><span class="line">          InnerAnalysisManagerProxy&lt;AnalysisManagerT, IRUnitT&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面addPass的行为以及类型声明可以看到Proxy也是一个Analysis，对于一个Analysis最主要的就是run以及Result里的行为了。</p><p>这里run的逻辑就是将InnerAM塞到InnerAnalysisManagerProxy::Result中返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">           ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Result</span>(*InnerAM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(AnalysisManagerT &amp;InnerAM)</span> : InnerAM(&amp;InnerAM) &#123;</span>&#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="function">AnalysisManagerT &amp;<span class="title">getManager</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *InnerAM; &#125;</span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AnalysisManagerT *InnerAM;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的Result并不是一个具体的什么值，而是一个AnalysisManagerT的包装，这样做避免了每个AnalysisManager中塞入不必要的invalidate。</p><p>在实际使用的时候都是要先获取proxy的result再从中getManager，最后从AnalysisManager中获取某个具体的Analysis</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LazyCallGraph <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">    FunctionAnalysisManager &amp;FAM =</span><br><span class="line">        AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">    <span class="keyword">auto</span> GetTLI = [&amp;FAM](Function &amp;F) -&gt; TargetLibraryInfo &amp; &#123;</span><br><span class="line">      <span class="keyword">return</span> FAM.getResult&lt;TargetLibraryAnalysis&gt;(F);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LazyCallGraph</span>(M, GetTLI);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h3><p>对于一个Result来说invalidate的行为是最关键的。Result类内部本身并没有定义invalidate的行为，但是通过各种偏特化的形式定义不同IRUnit类型对应的invalidate方式</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%204.png"                      alt="Untitled"                ></p><p>复杂的invalidate逻辑（已删去所有注释），这不是本期重点因此不赘述，整体逻辑应当和上一期的invalidate一致，如果要理顺这些可以看上一期作为参考</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">bool</span> FunctionAnalysisManagerModuleProxy::Result::<span class="built_in">invalidate</span>(</span><br><span class="line">    Module &amp;M, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span><br><span class="line">    ModuleAnalysisManager::Invalidator &amp;Inv) &#123;</span><br><span class="line">  <span class="keyword">if</span> (PA.<span class="built_in">areAllPreserved</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// This is still a valid proxy.</span></span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.getChecker&lt;FunctionAnalysisManagerModuleProxy&gt;();</span><br><span class="line">  <span class="keyword">if</span> (!PAC.<span class="built_in">preserved</span>() &amp;&amp; !PAC.preservedSet&lt;AllAnalysesOn&lt;Module&gt;&gt;()) &#123;</span><br><span class="line">    InnerAM-&gt;<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> AreFunctionAnalysesPreserved =</span><br><span class="line">      PA.allAnalysesInSetPreserved&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    Optional&lt;PreservedAnalyses&gt; FunctionPA;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *OuterProxy =</span><br><span class="line">            InnerAM-&gt;getCachedResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F))</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;OuterInvalidationPair :</span><br><span class="line">           OuterProxy-&gt;<span class="built_in">getOuterInvalidations</span>()) &#123;</span><br><span class="line">        AnalysisKey *OuterAnalysisID = OuterInvalidationPair.first;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> &amp;InnerAnalysisIDs = OuterInvalidationPair.second;</span><br><span class="line">        <span class="keyword">if</span> (Inv.<span class="built_in">invalidate</span>(OuterAnalysisID, M, PA)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!FunctionPA)</span><br><span class="line">            FunctionPA = PA;</span><br><span class="line">          <span class="keyword">for</span> (AnalysisKey *InnerAnalysisID : InnerAnalysisIDs)</span><br><span class="line">            FunctionPA-&gt;<span class="built_in">abandon</span>(InnerAnalysisID);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (FunctionPA) &#123;</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, *FunctionPA);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!AreFunctionAnalysesPreserved)</span><br><span class="line">      InnerAM-&gt;<span class="built_in">invalidate</span>(F, PA);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OuterAnalysisManagerProxy"><a href="#OuterAnalysisManagerProxy" class="headerlink" title="OuterAnalysisManagerProxy"></a>OuterAnalysisManagerProxy</h2><p>这个与上面提到的InnerAnalysisManagerProxy相反。将一个大范围的Analysis应用到一个小范围的IRUnit上。比如说这个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModuleAnalysisManagerFunctionProxy =</span><br><span class="line">    OuterAnalysisManagerProxy&lt;ModuleAnalysisManager, Function&gt;;</span><br></pre></td></tr></table></figure><p>除了Result之外的逻辑和InnerAnalysisManagerProxy基本上一致，但是Proxy保存的则是一个const AnalysisManagerT<em>，也就是说是一个只读的包装。Inner的Result是用来存放一个AnalysisManager，而Outer的Result则和外层的Manager一样保存的是一个const AnalysisManagerT</em>，也就是说是一个只读的包装。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Result</span><span class="params">(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span> : OuterAM(&amp;OuterAM) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Get a cached analysis. If the analysis can be invalidated, this will</span></span><br><span class="line">    <span class="comment">/// assert.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> PassT::Result *<span class="title">getCachedResult</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">if</span> (Res)</span><br><span class="line">        OuterAM-&gt;<span class="keyword">template</span> verifyNotInvalidated&lt;PassT&gt;(IR, Res);</span><br><span class="line">      <span class="keyword">return</span> Res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Method provided for unit testing, not intended for general use.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT, <span class="keyword">typename</span> IRUnitTParam&gt;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cachedResultExists</span><span class="params">(IRUnitTParam &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">      <span class="keyword">typename</span> PassT::Result *Res =</span><br><span class="line">          OuterAM-&gt;<span class="keyword">template</span> getCachedResult&lt;PassT&gt;(IR);</span><br><span class="line">      <span class="keyword">return</span> Res != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// When invalidation occurs, remove any registered invalidation events.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IRUnitT &amp;IRUnit, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::Invalidator &amp;Inv)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Loop over the set of registered outer invalidation mappings and if any</span></span><br><span class="line">      <span class="comment">// of them map to an analysis that is now invalid, clear it out.</span></span><br><span class="line">      SmallVector&lt;AnalysisKey *, <span class="number">4</span>&gt; DeadKeys;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;KeyValuePair : OuterAnalysisInvalidationMap) &#123;</span><br><span class="line">        AnalysisKey *OuterID = KeyValuePair.first;</span><br><span class="line">        <span class="keyword">auto</span> &amp;InnerIDs = KeyValuePair.second;</span><br><span class="line">        llvm::<span class="built_in">erase_if</span>(InnerIDs, [&amp;](AnalysisKey *InnerID) &#123;</span><br><span class="line">          <span class="keyword">return</span> Inv.<span class="built_in">invalidate</span>(InnerID, IRUnit, PA);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (InnerIDs.<span class="built_in">empty</span>())</span><br><span class="line">          DeadKeys.<span class="built_in">push_back</span>(OuterID);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> OuterID : DeadKeys)</span><br><span class="line">        OuterAnalysisInvalidationMap.<span class="built_in">erase</span>(OuterID);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The proxy itself remains valid regardless of anything else.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Register a deferred invalidation event for when the outer analysis</span></span><br><span class="line">    <span class="comment">/// manager processes its invalidations.</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> OuterAnalysisT, <span class="keyword">typename</span> InvalidatedAnalysisT&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerOuterAnalysisInvalidation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      AnalysisKey *OuterID = OuterAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line">      AnalysisKey *InvalidatedID = InvalidatedAnalysisT::<span class="built_in">ID</span>();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">auto</span> &amp;InvalidatedIDList = OuterAnalysisInvalidationMap[OuterID];</span><br><span class="line">      <span class="comment">// Note, this is a linear scan. If we end up with large numbers of</span></span><br><span class="line">      <span class="comment">// analyses that all trigger invalidation on the same outer analysis,</span></span><br><span class="line">      <span class="comment">// this entire system should be changed to some other deterministic</span></span><br><span class="line">      <span class="comment">// data structure such as a `SetVector` of a pair of pointers.</span></span><br><span class="line">      <span class="keyword">if</span> (!llvm::<span class="built_in">is_contained</span>(InvalidatedIDList, InvalidatedID))</span><br><span class="line">        InvalidatedIDList.<span class="built_in">push_back</span>(InvalidatedID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Access the map from outer analyses to deferred invalidation requiring</span></span><br><span class="line">    <span class="comment">/// analyses.</span></span><br><span class="line">    <span class="keyword">const</span> SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt; &amp;</span><br><span class="line">    <span class="built_in">getOuterInvalidations</span>() <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> OuterAnalysisInvalidationMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> AnalysisManagerT *OuterAM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A map from an outer analysis ID to the set of this IR-unit&#x27;s analyses</span></span><br><span class="line">    <span class="comment">/// which need to be invalidated.</span></span><br><span class="line">    SmallDenseMap&lt;AnalysisKey *, TinyPtrVector&lt;AnalysisKey *&gt;, <span class="number">2</span>&gt;</span><br><span class="line">        OuterAnalysisInvalidationMap;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">OuterAnalysisManagerProxy</span>(<span class="keyword">const</span> AnalysisManagerT &amp;OuterAM)</span><br><span class="line">      : <span class="built_in">OuterAM</span>(&amp;OuterAM) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Run the analysis pass and create our proxy result object.</span></span><br><span class="line">  <span class="comment">/// Nothing to see here, it just forwards the \c OuterAM reference into the</span></span><br><span class="line">  <span class="comment">/// result.</span></span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;,</span></span></span><br><span class="line"><span class="params"><span class="function">             ExtraArgTs...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Result</span>(*OuterAM);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要注意这里的设计是不能修改OuterAM的因此只能获取cached的result，并且有一套自己的analysis Invalidation机制，这里就不展开讲解了。</p><p>我们来实际看一下使用的场合。目前实际有效的getResult的场合只搜到了这一处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getModuleAAResultImpl</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  AAResults &amp;AAResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;MAMProxy = AM.getResult&lt;ModuleAnalysisManagerFunctionProxy&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> *R =</span><br><span class="line">          MAMProxy.<span class="keyword">template</span> getCachedResult&lt;AnalysisT&gt;(*F.<span class="built_in">getParent</span>())) &#123;</span><br><span class="line">    AAResults.<span class="built_in">addAAResult</span>(*R);</span><br><span class="line">    MAMProxy</span><br><span class="line">        .<span class="keyword">template</span> registerOuterAnalysisInvalidation&lt;AnalysisT, AAManager&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我觉得是分析需要在Function内部做，但是全局变量的存在使得Function仍然需要一个全局范围内的别名分析</p><h2 id="AnalysisManager结构"><a href="#AnalysisManager结构" class="headerlink" title="AnalysisManager结构"></a>AnalysisManager结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">FAM(FunctionAnalysisManager)</span><br><span class="line">LAM(LoopAnalysisManager)</span><br><span class="line">CGAM(CGSCCAnalysisManager)</span><br><span class="line">MAM(ModuleAnalysisManager)</span><br><span class="line">FAMP(FunctionAnalysisManagerModuleProxy)</span><br><span class="line">    CGAMP(CGSCCAnalysisManagerModuleProxy)</span><br><span class="line">    CGAFP(CGSCCAnalysisManagerFunctionProxy)</span><br><span class="line">    MCGAP(ModuleAnalysisManagerCGSCCProxy)</span><br><span class="line">MAFP(ModuleAnalysisManagerFunctionProxy)</span><br><span class="line">LAFP(LoopAnalysisManagerFunctionProxy)</span><br><span class="line">FLAP(FunctionAnalysisManagerLoopProxy)</span><br><span class="line">    MAM --&gt;  FAMP --&gt; FAM</span><br><span class="line">MAM --&gt; CGAMP --&gt; CGAM</span><br><span class="line">    CGAM --&gt; MCGAP --&gt; MAM</span><br><span class="line">FAM --&gt; CGAFP --&gt; CGAM</span><br><span class="line">FAM --&gt; MAFP --&gt; MAM</span><br><span class="line">FAM --&gt; LAFP --&gt; LAM</span><br><span class="line">LAM --&gt; FLAP --&gt; FAM</span><br></pre></td></tr></table></figure><p>感觉画出来的图非常奇怪…</p><p>至此Analysis的部分就已经处理结束了</p><h1 id="Callbacks-and-Instrumentation"><a href="#Callbacks-and-Instrumentation" class="headerlink" title="Callbacks and Instrumentation"></a>Callbacks and Instrumentation</h1><p>Analysis之后则是添加各种callback。而这里则是通过StandardInstrumentations来注册callback到PIC（PassInstrumentCallbacks）中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PassInstrumentationCallbacks PIC;</span><br><span class="line"><span class="function">PassBuilder <span class="title">PB</span><span class="params">(Machine, PassOpts-&gt;PTO, None, &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">StandardInstrumentations <span class="title">SI</span><span class="params">(Debug, VerifyEach)</span></span>;</span><br><span class="line">SI.<span class="built_in">registerCallbacks</span>(PIC, &amp;FAM);</span><br></pre></td></tr></table></figure><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>include/llvm/IR/PassInstrumentation.h</p><p>先不说StandardInstrumentations，和PassInstrument相关的有这么两个类</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%205.png"                      alt="Untitled"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-3/Untitled%206.png"                      alt="Untitled"                ></p><p>两个类的关系也非常简单，PassInstrumentation中保存了一个实际持有各种callback的PassInstrumentationCallbacks对象。里面保存的各种callbacks的作用从成员名就能看出，这里不再赘述细节</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>而获取PassInstrumentation则是通过PassInstrumentationAnalysis这个analysis获取的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassInstrumentationAnalysis</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;PassInstrumentationAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"></span><br><span class="line">  PassInstrumentationCallbacks *Callbacks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// PassInstrumentationCallbacks object is shared, owned by something else,</span></span><br><span class="line">  <span class="comment">/// not this analysis.</span></span><br><span class="line">  <span class="built_in">PassInstrumentationAnalysis</span>(PassInstrumentationCallbacks *Callbacks = <span class="literal">nullptr</span>)</span><br><span class="line">      : <span class="built_in">Callbacks</span>(Callbacks) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> Result = PassInstrumentation;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line">  <span class="function">Result <span class="title">run</span><span class="params">(IRUnitT &amp;, AnalysisManagerT &amp;, ExtraArgTs &amp;&amp;...)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PassInstrumentation</span>(Callbacks);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如说我们之前讲过的PassManager中的代码（删掉了许多无关的代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                        ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">    PassInstrumentation PI =</span><br><span class="line">        detail::getAnalysisResult&lt;PassInstrumentationAnalysis&gt;(</span><br><span class="line">            AM, IR, std::tuple&lt;ExtraArgTs...&gt;(ExtraArgs...));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!PI.runBeforePass&lt;IRUnitT&gt;(*P, IR))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">      PreservedAnalyses PassPA;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(P-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">        PassPA = P-&gt;<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Call onto PassInstrumentation&#x27;s AfterPass callbacks immediately after</span></span><br><span class="line">      <span class="comment">// running the pass.</span></span><br><span class="line">      PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="StandardInstrumentations"><a href="#StandardInstrumentations" class="headerlink" title="StandardInstrumentations"></a>StandardInstrumentations</h2><p>StandardInstrumentations里面提供了注册standard pass instrumentations的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardInstrumentations</span> &#123;</span></span><br><span class="line">  PrintIRInstrumentation PrintIR;</span><br><span class="line">  PrintPassInstrumentation PrintPass;</span><br><span class="line">  TimePassesHandler TimePasses;</span><br><span class="line">  OptNoneInstrumentation OptNone;</span><br><span class="line">  OptBisectInstrumentation OptBisect;</span><br><span class="line">  PreservedCFGCheckerInstrumentation PreservedCFGChecker;</span><br><span class="line">  IRChangedPrinter PrintChangedIR;</span><br><span class="line">  PseudoProbeVerifier PseudoProbeVerification;</span><br><span class="line">  InLineChangePrinter PrintChangedDiff;</span><br><span class="line">  DotCfgChangeReporter WebsiteChangeReporter;</span><br><span class="line">  VerifyInstrumentation Verify;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> VerifyEach;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">StandardInstrumentations</span>(<span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach = <span class="literal">false</span>,</span><br><span class="line">                           PrintPassOptions PrintPassOpts = <span class="built_in">PrintPassOptions</span>());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register all the standard instrumentation callbacks. If \p FAM is nullptr</span></span><br><span class="line">  <span class="comment">// then PreservedCFGChecker is not enabled.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC,</span></span></span><br><span class="line"><span class="params"><span class="function">                         FunctionAnalysisManager *FAM = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">TimePassesHandler &amp;<span class="title">getTimePasses</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> TimePasses; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>提供了一些基本的Instrumentation，通过StandardInstrumentations::registerCallbacks来将这些callback注册到PIC中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">StandardInstrumentations::<span class="built_in">StandardInstrumentations</span>(</span><br><span class="line">    <span class="keyword">bool</span> DebugLogging, <span class="keyword">bool</span> VerifyEach, PrintPassOptions PrintPassOpts)</span><br><span class="line">    : <span class="built_in">PrintPass</span>(DebugLogging, PrintPassOpts), <span class="built_in">OptNone</span>(DebugLogging),</span><br><span class="line">      <span class="built_in">PrintChangedIR</span>(PrintChanged == ChangePrinter::PrintChangedVerbose),</span><br><span class="line">      <span class="built_in">PrintChangedDiff</span>(</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose,</span><br><span class="line">          PrintChanged == ChangePrinter::PrintChangedColourDiffVerbose ||</span><br><span class="line">              PrintChanged == ChangePrinter::PrintChangedColourDiffQuiet),</span><br><span class="line">      <span class="built_in">WebsiteChangeReporter</span>(PrintChanged ==</span><br><span class="line">                            ChangePrinter::PrintChangedDotCfgVerbose),</span><br><span class="line">      <span class="built_in">Verify</span>(DebugLogging), <span class="built_in">VerifyEach</span>(VerifyEach) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StandardInstrumentations::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC, FunctionAnalysisManager *FAM)</span> </span>&#123;</span><br><span class="line">  PrintIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintPass.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  TimePasses.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptNone.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  OptBisect.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (FAM)</span><br><span class="line">    PreservedCFGChecker.<span class="built_in">registerCallbacks</span>(PIC, *FAM);</span><br><span class="line">  PrintChangedIR.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PseudoProbeVerification.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  <span class="keyword">if</span> (VerifyEach)</span><br><span class="line">    Verify.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  PrintChangedDiff.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">  WebsiteChangeReporter.<span class="built_in">registerCallbacks</span>(PIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看其中一个的实现（比较长，故省略了一部分，基本上都是在register各种callback</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Debug logging for transformation and analysis passes.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintPassInstrumentation</span> &#123;</span></span><br><span class="line">  <span class="function">raw_ostream &amp;<span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">PrintPassInstrumentation</span>(<span class="keyword">bool</span> Enabled, PrintPassOptions Opts)</span><br><span class="line">      : <span class="built_in">Enabled</span>(Enabled), <span class="built_in">Opts</span>(Opts) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerCallbacks</span><span class="params">(PassInstrumentationCallbacks &amp;PIC)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">bool</span> Enabled;</span><br><span class="line">  PrintPassOptions Opts;</span><br><span class="line">  <span class="keyword">int</span> Indent = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">raw_ostream &amp;<span class="title">PrintPassInstrumentation::print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Opts.Indent) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(Indent &gt;= <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dbgs</span>().<span class="built_in">indent</span>(Indent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">dbgs</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintPassInstrumentation::registerCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    PassInstrumentationCallbacks &amp;PIC)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Enabled)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  std::vector&lt;StringRef&gt; SpecialPasses;</span><br><span class="line">  <span class="keyword">if</span> (!Opts.Verbose) &#123;</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassManager&quot;</span>);</span><br><span class="line">    SpecialPasses.<span class="built_in">emplace_back</span>(<span class="string">&quot;PassAdaptor&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ...</span><br><span class="line">  <span class="keyword">if</span> (!Opts.SkipAnalyses) &#123;</span><br><span class="line">    PIC.<span class="built_in">registerAnalysisInvalidatedCallback</span>([<span class="keyword">this</span>](StringRef PassID, Any IR) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Invalidating analysis: &quot;</span> &lt;&lt; PassID &lt;&lt; <span class="string">&quot; on &quot;</span> &lt;&lt; <span class="built_in">getIRName</span>(IR)</span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    PIC.<span class="built_in">registerAnalysesClearedCallback</span>([<span class="keyword">this</span>](StringRef IRName) &#123;</span><br><span class="line">      <span class="built_in">print</span>() &lt;&lt; <span class="string">&quot;Clearing all analysis results for: &quot;</span> &lt;&lt; IRName &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的注册了各个阶段的callback</p><h1 id="ParsePipeline"><a href="#ParsePipeline" class="headerlink" title="ParsePipeline"></a>ParsePipeline</h1><p>在Analysis和callbacks都处理好以后开始执行parsePassPipeline。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> Err = PB.<span class="built_in">parsePassPipeline</span>(MPM, Passes)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">wrap</span>(std::<span class="built_in">move</span>(Err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parsePassPipeline"><a href="#parsePassPipeline" class="headerlink" title="parsePassPipeline"></a>parsePassPipeline</h2><p>PassBuilder的成员函数和ParsePipeline相关的有两类，一个是ParseXXXPassPipeline，另一个是ParseXXXPass</p><p>这里我们就先不关心pipeline里面是怎样的形式以及parser的过程了，重点在于通过看这个pipeline了解整个PassManager的构建过程。从parsePassPipeline开始</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parsePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     StringRef PipelineText)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> Pipeline = <span class="built_in">parsePipelineText</span>(PipelineText);</span><br><span class="line">  <span class="keyword">if</span> (!Pipeline || Pipeline-&gt;<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid pipeline &#x27;&#123;0&#125;&#x27;&quot;</span>, PipelineText).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(MPM, *Pipeline))</span><br><span class="line">    <span class="keyword">return</span> Err;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="parseModulePassPipeline"><a href="#parseModulePassPipeline" class="headerlink" title="parseModulePassPipeline"></a>parseModulePassPipeline</h2><p>关于parseModulePassPipeline</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePassPipeline</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           ArrayRef&lt;PipelineElement&gt; Pipeline)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;Element : Pipeline) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePass</span>(MPM, Element))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseModulePass</span><span class="params">(ModulePassManager &amp;MPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="keyword">const</span> PipelineElement &amp;E)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;Name = E.Name;</span><br><span class="line">  <span class="keyword">auto</span> &amp;InnerPipeline = E.InnerPipeline;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// First handle complex passes like the pass managers which carry pipelines.</span></span><br><span class="line">  <span class="keyword">if</span> (!InnerPipeline.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">      ModulePassManager NestedMPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">      FunctionPassManager FPM;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Err;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                    Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">        <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normal passes can&#x27;t have pipelines.</span></span><br><span class="line">    <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">        formatv(<span class="string">&quot;invalid use of &#x27;&#123;0&#125;&#x27; pass as module pipeline&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">        <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">    ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Manually handle aliases for pre-configured pipeline fragments.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">startsWithDefaultPipelineAliasPrefix</span>(Name)) &#123;</span><br><span class="line">    SmallVector&lt;StringRef, <span class="number">3</span>&gt; Matches;</span><br><span class="line">    <span class="keyword">if</span> (!DefaultAliasRegex.<span class="built_in">match</span>(Name, &amp;Matches))</span><br><span class="line">      <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">          formatv(<span class="string">&quot;unknown default pipeline alias &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">          <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(Matches.<span class="built_in">size</span>() == <span class="number">3</span> &amp;&amp; <span class="string">&quot;Must capture two matched strings!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    OptimizationLevel L = StringSwitch&lt;OptimizationLevel&gt;(Matches[<span class="number">2</span>])</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O0&quot;</span>, OptimizationLevel::O0)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O1&quot;</span>, OptimizationLevel::O1)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O2&quot;</span>, OptimizationLevel::O2)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;O3&quot;</span>, OptimizationLevel::O3)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Os&quot;</span>, OptimizationLevel::Os)</span><br><span class="line">                              .<span class="built_in">Case</span>(<span class="string">&quot;Oz&quot;</span>, OptimizationLevel::Oz);</span><br><span class="line">    <span class="keyword">if</span> (L == OptimizationLevel::O0 &amp;&amp; Matches[<span class="number">1</span>] != <span class="string">&quot;thinlto&quot;</span> &amp;&amp;</span><br><span class="line">        Matches[<span class="number">1</span>] != <span class="string">&quot;lto&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildO0DefaultPipeline</span>(L, Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span> ||</span><br><span class="line">                                                Matches[<span class="number">1</span>] == <span class="string">&quot;lto-pre-link&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is consistent with old pass manager invoked via opt, but</span></span><br><span class="line">    <span class="comment">// inconsistent with clang. Clang doesn&#x27;t enable loop vectorization</span></span><br><span class="line">    <span class="comment">// but does enable slp vectorization at Oz.</span></span><br><span class="line">    PTO.LoopVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line">    PTO.SLPVectorization =</span><br><span class="line">        L.<span class="built_in">getSpeedupLevel</span>() &gt; <span class="number">1</span> &amp;&amp; L != OptimizationLevel::Oz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;default&quot;</span>) &#123;</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">buildPerModuleDefaultPipeline</span>(L));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Matches[<span class="number">1</span>] == <span class="string">&quot;thinlto-pre-link&quot;</span>) &#123;</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally expand the basic registered passes from the .inc file.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">...                                 </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : ModulePipelineParsingCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">C</span>(Name, MPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  <span class="keyword">return</span> make_error&lt;StringError&gt;(</span><br><span class="line">      formatv(<span class="string">&quot;unknown module pass &#x27;&#123;0&#125;&#x27;&quot;</span>, Name).<span class="built_in">str</span>(),</span><br><span class="line">      <span class="built_in">inconvertibleErrorCode</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数实在太长了，省略掉了大部分。</p><ol><li>pipeline非空的情况下继续parseXXXPipeline。通过parseModulePipeline调用parseModulePass我们可以猜到每个parseXXPipeline都会调用对应的parseXXParse</li><li>根据优化等级以及一些lto选项添加一些buildXXXDefaultPipeline‘</li><li>展开PassRegistry中的定义</li></ol><p>在详细展开这些之前我们先来讲解一下上面出现的各种createXXAdaptor</p><h2 id="Adaptor"><a href="#Adaptor" class="headerlink" title="Adaptor"></a>Adaptor</h2><p>各种adaptor被用于将IRUnit范围更小的Pass应用到更大的IRUnit上，比如说这里的Function的范围比一个Module要小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionPassT&gt;</span><br><span class="line"><span class="function">ModuleToFunctionPassAdaptor</span></span><br><span class="line"><span class="function"><span class="title">createModuleToFunctionPassAdaptor</span><span class="params">(FunctionPassT &amp;&amp;Pass,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="keyword">bool</span> EagerlyInvalidate = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::PassModel&lt;Function, FunctionPassT, PreservedAnalyses,</span><br><span class="line">                        FunctionAnalysisManager&gt;;</span><br><span class="line">  <span class="comment">// Do not use make_unique, it causes too many template instantiations,</span></span><br><span class="line">  <span class="comment">// causing terrible compile times.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ModuleToFunctionPassAdaptor</span>(</span><br><span class="line">      std::unique_ptr&lt;ModuleToFunctionPassAdaptor::PassConceptT&gt;(</span><br><span class="line">          <span class="keyword">new</span> <span class="built_in">PassModelT</span>(std::forward&lt;FunctionPassT&gt;(Pass))),</span><br><span class="line">      EagerlyInvalidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModuleToFunctionPassAdaptor</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> PassInfoMixin&lt;ModuleToFunctionPassAdaptor&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Module &amp;M, ModuleAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;PassConceptT&gt; Pass;</span><br><span class="line">  <span class="keyword">bool</span> EagerlyInvalidate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里和一个常规Pass都差不多，主要是run有比较大的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">ModuleToFunctionPassAdaptor::run</span><span class="params">(Module &amp;M,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                   ModuleAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  FunctionAnalysisManager &amp;FAM =</span><br><span class="line">      AM.getResult&lt;FunctionAnalysisManagerModuleProxy&gt;(M).<span class="built_in">getManager</span>();</span><br><span class="line">  PassInstrumentation PI = AM.getResult&lt;PassInstrumentationAnalysis&gt;(M);</span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">  <span class="keyword">for</span> (Function &amp;F : M) &#123;</span><br><span class="line">    <span class="keyword">if</span> (F.<span class="built_in">isDeclaration</span>())</span><br><span class="line">      <span class="keyword">continue</span>; <span class="function">execution completely <span class="keyword">if</span> asked <span class="title">to</span> <span class="params">(callback returns</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// false).</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (!PI.runBeforePass&lt;Function&gt;(*Pass, F))</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="keyword">continue</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    PreservedAnalyses PassPA;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">      TimeTraceScope TimeScope(Pass-&gt;name(), F.getName());</span></span></span><br><span class="line"><span class="params"><span class="function">      PassPA = Pass-&gt;run(F, FAM);</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    PI.runAfterPass(*Pass, F, PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    FAM.invalidate(F, EagerlyInvalidate ? PreservedAnalyses::none() : PassPA);</span></span></span><br><span class="line"><span class="params"><span class="function">    PA.intersect(std::move(PassPA));</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserveSet&lt;AllAnalysesOn&lt;Function&gt;&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  PA.preserve&lt;FunctionAnalysisManagerModuleProxy&gt;();</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">return</span> PA;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><p>首先是获取AnalysisManager（AM）这里的AM也是通过上面所讲过的Proxy获取的。由于是Function范围的Pass应用到Module的范围上，很自然要遍历大的IR中的所有Function。大体逻辑有点类似于一个PassManager。</p><h2 id="parseModulePass与更小范围的IR的parseXXPassPipeline"><a href="#parseModulePass与更小范围的IR的parseXXPassPipeline" class="headerlink" title="parseModulePass与更小范围的IR的parseXXPassPipeline"></a>parseModulePass与更小范围的IR的parseXXPassPipeline</h2><p>根据上面的内容所说，parsePassPipeline会进入到parseModulePipeline中。而在parseModulePass中有这样的处理代码，也就是说可能会嵌套Module，也可能去处理IRUnit范围更小的相关Pass，并通过adaptor来加入到ModulePassManager中。其他的parseXXXPass也是有类似的处理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Name == <span class="string">&quot;module&quot;</span>) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(std::<span class="built_in">move</span>(NestedMPM));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;cgscc&quot;</span>) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseCGSCCPassPipeline</span>(CGPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;function&quot;</span> || Name == <span class="string">&quot;function&lt;eager-inv&gt;&quot;</span>) &#123;</span><br><span class="line">    FunctionPassManager FPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseFunctionPassPipeline</span>(FPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(std::<span class="built_in">move</span>(FPM),</span><br><span class="line">                                                  Name != <span class="string">&quot;function&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">auto</span> Count = <span class="built_in">parseRepeatPassName</span>(Name)) &#123;</span><br><span class="line">    ModulePassManager NestedMPM;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">parseModulePassPipeline</span>(NestedMPM, InnerPipeline))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">createRepeatedPass</span>(*Count, std::<span class="built_in">move</span>(NestedMPM)));</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="BuildXXPipeline"><a href="#BuildXXPipeline" class="headerlink" title="BuildXXPipeline"></a>BuildXXPipeline</h2><p>相关的逻辑也很简单，就是在这个函数中按照顺序和各种选项添加Pass，返回了一个构建好的ModulePassManager。还记得吗，一个PassManager（PM）添加Pass时可以传另一个PM，此时的行为是直接将传入PM的Pass添加到被添加的PM的Pass列表中。</p><p>我们来看一下buildO0DefaultPipeline就好了，这里面不需要根据pipeline的text判断是否添加Pass，用一个非常不严谨的说法是这里面添加的逻辑和你是否指定了里面的Pass没有关系，不像之前的函数都是要先parse pipeline text之后根据parse得到的结果判断某个Pass是否要被添加</p><p>这部分的实现都在PassBuilderPipelines.cpp中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ModulePassManager <span class="title">PassBuilder::buildO0DefaultPipeline</span><span class="params">(OptimizationLevel Level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                      <span class="keyword">bool</span> LTOPreLink)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(Level == OptimizationLevel::O0 &amp;&amp;</span><br><span class="line">         <span class="string">&quot;buildO0DefaultPipeline should only be used with O0&quot;</span>);</span><br><span class="line"></span><br><span class="line">  ModulePassManager MPM;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Build a minimal pipeline based on the semantics required by LLVM,</span></span><br><span class="line">  <span class="comment">// which is just that always inlining occurs. Further, disable generating</span></span><br><span class="line">  <span class="comment">// lifetime intrinsics to avoid enabling further optimizations during</span></span><br><span class="line">  <span class="comment">// code generation.</span></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">AlwaysInlinerPass</span>(</span><br><span class="line">      <span class="comment">/*InsertLifetimeIntrinsics=*/</span><span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (PTO.MergeFunctions)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(<span class="built_in">MergeFunctionsPass</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (EnableMatrix)</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(</span><br><span class="line">        <span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">LowerMatrixIntrinsicsPass</span>(<span class="literal">true</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CGSCCOptimizerLateEPCallbacks.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    CGSCCPassManager CGPM;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : CGSCCOptimizerLateEPCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(CGPM, Level);</span><br><span class="line">    <span class="keyword">if</span> (!CGPM.<span class="built_in">isEmpty</span>())</span><br><span class="line">      MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToPostOrderCGSCCPassAdaptor</span>(std::<span class="built_in">move</span>(CGPM)));</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ModulePassManager CoroPM;</span><br><span class="line">  CoroPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">CoroEarlyPass</span>()));</span><br><span class="line">  CGSCCPassManager CGPM;</span><br><span class="line">  CGPM.<span class="built_in">addPass</span>(<span class="built_in">CoroSplitPass</span>());</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (LTOPreLink)</span><br><span class="line">    <span class="built_in">addRequiredLTOPreLinkPasses</span>(MPM);</span><br><span class="line"></span><br><span class="line">  MPM.<span class="built_in">addPass</span>(<span class="built_in">createModuleToFunctionPassAdaptor</span>(<span class="built_in">AnnotationRemarksPass</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MPM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展开Registry"><a href="#展开Registry" class="headerlink" title="展开Registry"></a>展开Registry</h2><p>展开PassRegistry中的定义，有这么几类</p><h3 id="直接添加ModulePass"><a href="#直接添加ModulePass" class="headerlink" title="直接添加ModulePass"></a>直接添加ModulePass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS(NAME, CREATE_PASS)                                         \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><p>有的还需要传入参数构造Pass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_PASS_WITH_PARAMS(NAME, CLASS, CREATE_PASS, PARSER, PARAMS)      \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (checkParametrizedPassName(Name, NAME)) &#123;                                 \</span></span><br><span class="line"><span class="meta">    auto Params = parsePassParameters(PARSER, Name, NAME);                     \</span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">if</span> (!Params)                                                               \</span></span><br><span class="line"><span class="meta">      return Params.takeError();                                               \</span></span><br><span class="line"><span class="meta">    MPM.addPass(CREATE_PASS(Params.get()));                                    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="通过adaptor的形式传入PassManager"><a href="#通过adaptor的形式传入PassManager" class="headerlink" title="通过adaptor的形式传入PassManager"></a>通过adaptor的形式传入PassManager</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS)                                       \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(CREATE_PASS));               \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><p>不仅是一层，甚至会有多层Adaptor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOOP_PASS(NAME, CREATE_PASS)                                           \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    MPM.addPass(createModuleToFunctionPassAdaptor(                             \</span></span><br><span class="line"><span class="meta">        createFunctionToLoopPassAdaptor(CREATE_PASS, false, false)));          \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br></pre></td></tr></table></figure><h3 id="AnalysisPass"><a href="#AnalysisPass" class="headerlink" title="AnalysisPass"></a>AnalysisPass</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_ANALYSIS(NAME, CREATE_PASS)                                     \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == <span class="meta-string">&quot;require&lt;&quot;</span> NAME <span class="meta-string">&quot;&gt;&quot;</span>) &#123;                                           \</span></span><br><span class="line"><span class="meta">    MPM.addPass(                                                               \</span></span><br><span class="line"><span class="meta">        RequireAnalysisPass&lt;                                                   \</span></span><br><span class="line"><span class="meta">            std::remove_reference<span class="meta-string">&lt;decltype(CREATE_PASS)&gt;</span>::type, Module&gt;());    \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;                                  </span></span><br><span class="line">                                          \</span><br><span class="line">  <span class="keyword">if</span> (Name == <span class="string">&quot;invalidate&lt;&quot;</span> NAME <span class="string">&quot;&gt;&quot;</span>) &#123;                                        \</span><br><span class="line">    MPM.<span class="built_in">addPass</span>(InvalidateAnalysisPass&lt;                                        \</span><br><span class="line">                std::remove_reference&lt;<span class="keyword">decltype</span>(CREATE_PASS)&gt;::type&gt;());        \</span><br><span class="line">    <span class="keyword">return</span> Error::<span class="built_in">success</span>();                                                   \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="PassManager中Pass的结构"><a href="#PassManager中Pass的结构" class="headerlink" title="PassManager中Pass的结构"></a>PassManager中Pass的结构</h2><p>实际还有CGSCC以及Loop之类的Pass，这里就挑出三个有代表性的结构展示关系了</p><p>一个是顶级的ModulePass，一个是一层adaptor，另一个是多层adaptor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">    R(ModulePassManager)</span><br><span class="line">    R--&gt;MP(ModulePass)</span><br><span class="line">    R--&gt;FP(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FP--&gt;FPS(FunctionPass)</span><br><span class="line">    R--&gt;FPTemp(ModuleToFunctionPassAdaptor)</span><br><span class="line">    FPTemp--&gt;LPP(FunctionToLoopPassAdator)</span><br><span class="line">    LPP--&gt;LPPS(LoopPass)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="用户自定义添加Pass的方式"><a href="#用户自定义添加Pass的方式" class="headerlink" title="用户自定义添加Pass的方式"></a>用户自定义添加Pass的方式</h1><p>最后介绍一下讲解一下如何添加自己的Pass到LLVM中。在llvm官方的仓库里example目录中有这么一段代码</p><p>examples/Bye/Bye.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* New PM Registration */</span></span><br><span class="line"><span class="function">llvm::PassPluginLibraryInfo <span class="title">getByePluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;LLVM_PLUGIN_API_VERSION, <span class="string">&quot;Bye&quot;</span>, LLVM_VERSION_STRING,</span><br><span class="line">          [](PassBuilder &amp;PB) &#123;</span><br><span class="line">            PB.<span class="built_in">registerVectorizerStartEPCallback</span>(</span><br><span class="line">                [](llvm::FunctionPassManager &amp;PM, OptimizationLevel Level) &#123;</span><br><span class="line">                  PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                &#125;);</span><br><span class="line">            PB.<span class="built_in">registerPipelineParsingCallback</span>(</span><br><span class="line">                [](StringRef Name, llvm::FunctionPassManager &amp;PM,</span><br><span class="line">                   ArrayRef&lt;llvm::PassBuilder::PipelineElement&gt;) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (Name == <span class="string">&quot;goodbye&quot;</span>) &#123;</span><br><span class="line">                    PM.<span class="built_in">addPass</span>(<span class="built_in">Bye</span>());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;);</span><br><span class="line">          &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LLVM_BYE_LINK_INTO_TOOLS</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> LLVM_ATTRIBUTE_WEAK ::<span class="function">llvm::PassPluginLibraryInfo</span></span><br><span class="line"><span class="function"><span class="title">llvmGetPassPluginInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">getByePluginInfo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassPluginLibraryInfo</span> &#123;</span></span><br><span class="line">  <span class="comment">/// The API version understood by this plugin, usually \c</span></span><br><span class="line">  <span class="comment">/// LLVM_PLUGIN_API_VERSION</span></span><br><span class="line">  <span class="keyword">uint32_t</span> APIVersion;</span><br><span class="line">  <span class="comment">/// A meaningful name of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginName;</span><br><span class="line">  <span class="comment">/// The version of the plugin.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *PluginVersion;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The callback for registering plugin passes with a \c PassBuilder</span></span><br><span class="line">  <span class="comment">/// instance</span></span><br><span class="line">  <span class="built_in"><span class="keyword">void</span></span> (*RegisterPassBuilderCallbacks)(PassBuilder &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里我们先不考虑PassPlugin相关的具体细节。通过这种插件的方式可以给LLVM添加一些自己实现的Pass，可以看到有一个传入PassBuilder的lambda，之后通过注册各种callback来实现。LLVM也一定有某种机制找到对应的Plugin之后调用其callback</p><p>除此之外上面提及过的PassBuilder的构造函数有这么一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PassBuilder::<span class="built_in">PassBuilder</span>(TargetMachine *TM, PipelineTuningOptions PTO,</span><br><span class="line">                         Optional&lt;PGOOptions&gt; PGOOpt,</span><br><span class="line">                         PassInstrumentationCallbacks *PIC)</span><br><span class="line">    : <span class="built_in">TM</span>(TM), <span class="built_in">PTO</span>(PTO), <span class="built_in">PGOOpt</span>(PGOOpt), <span class="built_in">PIC</span>(PIC) &#123;</span><br><span class="line">  <span class="keyword">if</span> (TM)</span><br><span class="line">    TM-&gt;<span class="built_in">registerPassBuilderCallbacks</span>(*<span class="keyword">this</span>);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说如果你是调用LLVM进行生成代码而不是给llvm添加一个自己的Pass的话应该在自己继承的TargetMachine中实现registerPassBuilderCallbacks方法，而在这个方法中也应当是通过传入的PassBuilder添加各种callback的形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LLVM-Pass-其三：PassBuilder&quot;&gt;&lt;a href=&quot;#LLVM-Pass-其三：PassBuilder&quot; class=&quot;headerlink&quot; title=&quot;LLVM Pass 其三：PassBuilder&quot;&gt;&lt;/a&gt;LLVM Pass 其三：P</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
    <category term="PassBuilder" scheme="https://fusionbolt.github.io/tags/PassBuilder/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其二：Analysis与AnalysisManager</title>
    <link href="https://fusionbolt.github.io/2022/07/03/llvm-pass-2/"/>
    <id>https://fusionbolt.github.io/2022/07/03/llvm-pass-2/</id>
    <published>2022-07-03T10:31:37.000Z</published>
    <updated>2022-07-03T10:34:22.586Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-2/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">来自究极怪兽之上的召唤，将一切全部抹消的光之龙！现身吧！青眼光龙！</center> <p>在第一期的时候我们就提到过，新的Pass与LegacyPass的其中一个不同在于将Analysis单独分离了出来，那么本期我们从一个Analysis的写法开始写起。</p><h1 id="实现一个Analysis"><a href="#实现一个Analysis" class="headerlink" title="实现一个Analysis"></a>实现一个Analysis</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Analysis pass which computes a \c DominatorTree.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DominatorTreeAnalysis</span> :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;DominatorTreeAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;DominatorTreeAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Provide the result typedef for this analysis pass.</span></span><br><span class="line">  <span class="keyword">using</span> Result = DominatorTree;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Run the analysis pass over a function and produce a dominator tree.</span></span><br><span class="line">  <span class="function">DominatorTree <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和Pass相比有这么几处不同</p><ol><li>直接继承的是AnalysisInfoMixin而不是PassInfoMixin</li><li>run返回的不是一个Preserved Analyses而是一个对应的Result类型</li><li>声明了一个static的AnalysisKey</li></ol><p>读完后面的内容或许就能理解为什么会有这样的不同了</p><h1 id="Analysis本身相关的类型"><a href="#Analysis本身相关的类型" class="headerlink" title="Analysis本身相关的类型"></a>Analysis本身相关的类型</h1><p>先来回顾一下前面两期在讲普通Pass相关的时候我们提到了这么几样东西</p><ol><li>PassInfoMixin</li><li>PassConcept</li><li>PassModel</li></ol><p>这些东西和Pass本身的关联如下</p><ol><li>Pass类自身继承自PassInfoMixin（PassInfoMixin保存了一些获取信息的接口）</li><li>PassConcept定义了Pass类应有的行为</li><li>PassManager实际直接保存与执行的是PassConcept</li><li>PassModel是满足了PassConcept的一个类型</li><li>在PassManager中实际添加Pass的时候使用Pass类创建一个保存了这个Pass类的PassModel</li></ol><p>而在Analysis中这些东西也都是相同的，因此代码只会展示关键部分。Analysis相关的类有这么几个部分</p><ol><li>AnalysisInfoMixin</li><li>AnalysisPass[Concept | Model]</li><li>AnalysisResult[Concept | Model]</li></ol><h2 id="AnalysisInfoMixin"><a href="#AnalysisInfoMixin" class="headerlink" title="AnalysisInfoMixin"></a>AnalysisInfoMixin</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalysisInfoMixin</span> :</span> PassInfoMixin&lt;DerivedT&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AnalysisKey *<span class="title">ID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_base_of&lt;AnalysisInfoMixin, DerivedT&gt;::value,</span><br><span class="line">                  <span class="string">&quot;Must pass the derived type as the template argument!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> &amp;DerivedT::Key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然AnalysisInfoMixin继承自PassInfoMixin，但是实际上一个Analysis并没有实现PassConcept中的接口，而每个AnalysisPass中也没有实现PassConcept中的接口，因此Analysis并不是一个可以被PassManager执行的Pass（但是有自己的AnalysisManager）</p><p>Analysis增加了一个获取ID的功能，内部的实现是获取子类的key，也就是上面Analysis实现的时候声明的。后面再对这个Key进行展开讲解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AnalysisKey Key;</span><br></pre></td></tr></table></figure><h2 id="AnalysisPass"><a href="#AnalysisPass" class="headerlink" title="AnalysisPass"></a>AnalysisPass</h2><h3 id="AnalysisPassConcept"><a href="#AnalysisPassConcept" class="headerlink" title="AnalysisPassConcept"></a>AnalysisPassConcept</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PreservedAnalysesT, <span class="keyword">typename</span> InvalidatorT,</span><br><span class="line">          <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalysisPassConcept</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">AnalysisPassConcept</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> std::unique_ptr&lt;</span><br><span class="line">      AnalysisResultConcept&lt;IRUnitT, PreservedAnalysesT, InvalidatorT&gt;&gt;</span><br><span class="line">  <span class="built_in">run</span>(IRUnitT &amp;IR, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;AM,</span><br><span class="line">      ExtraArgTs... ExtraArgs) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> StringRef <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>run的时候返回的是一个AnalysisResultConcept</p><p>Analysis的模板参数出现一个InvalidatorT</p><h3 id="AnalysisPassModel"><a href="#AnalysisPassModel" class="headerlink" title="AnalysisPassModel"></a>AnalysisPassModel</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT, <span class="keyword">typename</span> PreservedAnalysesT,</span><br><span class="line">          <span class="keyword">typename</span> InvalidatorT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalysisPassModel</span> :</span> AnalysisPassConcept&lt;IRUnitT, PreservedAnalysesT,</span><br><span class="line">                                               InvalidatorT, ExtraArgTs...&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">using</span> ResultModelT =</span><br><span class="line">      AnalysisResultModel&lt;IRUnitT, PassT, <span class="keyword">typename</span> PassT::Result,</span><br><span class="line">                          PreservedAnalysesT, InvalidatorT&gt;;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;</span><br><span class="line">      AnalysisResultConcept&lt;IRUnitT, PreservedAnalysesT, InvalidatorT&gt;&gt;</span><br><span class="line">  <span class="built_in">run</span>(IRUnitT &amp;IR, AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt; &amp;AM,</span><br><span class="line">      ExtraArgTs... ExtraArgs) <span class="keyword">override</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> std::make_unique&lt;ResultModelT&gt;(</span><br><span class="line">        Pass.<span class="built_in">run</span>(IR, AM, std::forward&lt;ExtraArgTs&gt;(ExtraArgs)...));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>没什么可讲的，简单调用一下保存的Analysis</p><h2 id="AnalysisResult"><a href="#AnalysisResult" class="headerlink" title="AnalysisResult"></a>AnalysisResult</h2><h3 id="AnalysisResultConcept"><a href="#AnalysisResultConcept" class="headerlink" title="AnalysisResultConcept"></a>AnalysisResultConcept</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PreservedAnalysesT, <span class="keyword">typename</span> InvalidatorT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalysisResultConcept</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">AnalysisResultConcept</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Method to try and mark a result as invalid.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// When the outer analysis manager detects a change in some underlying</span></span><br><span class="line">  <span class="comment">/// unit of the IR, it will call this method on all of the results cached.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \p PA is a set of preserved analyses which can be used to avoid</span></span><br><span class="line">  <span class="comment">/// invalidation because the pass which changed the underlying IR took care</span></span><br><span class="line">  <span class="comment">/// to update or preserve the analysis result in some way.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \p Inv is typically a \c AnalysisManager::Invalidator object that can be</span></span><br><span class="line">  <span class="comment">/// used by a particular analysis result to discover if other analyses</span></span><br><span class="line">  <span class="comment">/// results are also invalidated in the event that this result depends on</span></span><br><span class="line">  <span class="comment">/// them. See the documentation in the \c AnalysisManager for more details.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// \returns true if the result is indeed invalid (the default).</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalysesT &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                          InvalidatorT &amp;Inv)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AnalysisResultModel"><a href="#AnalysisResultModel" class="headerlink" title="AnalysisResultModel"></a>AnalysisResultModel</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Wrapper to model the analysis result concept.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// By default, this will implement the invalidate method with a trivial</span></span><br><span class="line"><span class="comment">/// implementation so that the actual analysis result doesn&#x27;t need to provide</span></span><br><span class="line"><span class="comment">/// an invalidation handler. It is only selected when the invalidation handler</span></span><br><span class="line"><span class="comment">/// is not part of the ResultT&#x27;s interface.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT, <span class="keyword">typename</span> ResultT,</span><br><span class="line">          <span class="keyword">typename</span> PreservedAnalysesT, <span class="keyword">typename</span> InvalidatorT,</span><br><span class="line">          <span class="keyword">bool</span> HasInvalidateHandler =</span><br><span class="line">              ResultHasInvalidateMethod&lt;IRUnitT, ResultT&gt;::Value&gt;</span><br><span class="line">struct AnalysisResultModel;</span><br></pre></td></tr></table></figure><p>这里实际会根据是否存在invalidator而产生不同的特化，我们在后面讲到invalidate的时候再细说</p><h1 id="AnalysisManager"><a href="#AnalysisManager" class="headerlink" title="AnalysisManager"></a>AnalysisManager</h1><p>先来看一下声明和成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A container for analyses that lazily runs them and caches their</span></span><br><span class="line"><span class="comment">/// results.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This class can manage analyses for any IR unit where the address of the IR</span></span><br><span class="line"><span class="comment">/// unit sufficies as its identity.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt; <span class="class"><span class="keyword">class</span> <span class="title">AnalysisManager</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意看声明中的类型，这里和PassManager不同的是没有继承PassInfoMixin，因此AnalysisManager并不是一个Pass</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-2/Untitled%201.png"                      alt="Untitled"                ></p><h2 id="添加Analysis"><a href="#添加Analysis" class="headerlink" title="添加Analysis"></a>添加Analysis</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassBuilderT&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">registerPass</span><span class="params">(PassBuilderT &amp;&amp;PassBuilder)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> PassT = <span class="keyword">decltype</span>(<span class="built_in">PassBuilder</span>());</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::AnalysisPassModel&lt;IRUnitT, PassT, PreservedAnalyses,</span><br><span class="line">                                Invalidator, ExtraArgTs...&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> &amp;PassPtr = AnalysisPasses[PassT::<span class="built_in">ID</span>()];</span><br><span class="line">  <span class="keyword">if</span> (PassPtr)</span><br><span class="line">    <span class="comment">// Already registered this pass type!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Construct a new model around the instance returned by the builder.</span></span><br><span class="line">  PassPtr.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">PassModelT</span>(<span class="built_in">PassBuilder</span>()));</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和普通Pass不同之处有两点</p><ol><li>Analysis的Pass只允许存在一个。因为Analysis本身并不需要多次add进来，而是通过AnalysisManager统一管理多次调用的情况</li><li>Analysis在添加的时候是使用一个Builder来构建的。因为一个Analysis如果存在的话则不会再进行构建，这里我想也是为了性能考虑</li></ol><h2 id="外部从AnalysisManager获取信息"><a href="#外部从AnalysisManager获取信息" class="headerlink" title="外部从AnalysisManager获取信息"></a>外部从AnalysisManager获取信息</h2><p>至于如何从AnalysisManager获取信息，通过已有Pass的使用方式可以看到是通过getResult来获取结果的，比如说这里</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PreservedAnalyses <span class="title">PromotePass::run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;DT = AM.getResult&lt;DominatorTreeAnalysis&gt;(F);</span><br><span class="line">  <span class="keyword">auto</span> &amp;AC = AM.getResult&lt;AssumptionAnalysis&gt;(F);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">promoteMemoryToRegister</span>(F, DT, AC))</span><br><span class="line">    <span class="keyword">return</span> PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line"></span><br><span class="line">  PreservedAnalyses PA;</span><br><span class="line">  PA.preserveSet&lt;CFGAnalyses&gt;();</span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们从getResult作为起点来讲述AnalysisManager</p><h1 id="getResult"><a href="#getResult" class="headerlink" title="getResult"></a>getResult</h1><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><p>先放一下整个流程的代码，之后通过选择片段讲解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> PassT::Result &amp;<span class="title">getResult</span><span class="params">(IRUnitT &amp;IR, ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(AnalysisPasses.<span class="built_in">count</span>(PassT::<span class="built_in">ID</span>()) &amp;&amp;</span><br><span class="line">         <span class="string">&quot;This analysis pass was not registered prior to being queried&quot;</span>);</span><br><span class="line">  ResultConceptT &amp;ResultConcept =</span><br><span class="line">      <span class="built_in">getResultImpl</span>(PassT::<span class="built_in">ID</span>(), IR, ExtraArgs...);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ResultModelT =</span><br><span class="line">      detail::AnalysisResultModel&lt;IRUnitT, PassT, <span class="keyword">typename</span> PassT::Result,</span><br><span class="line">                                  PreservedAnalyses, Invalidator&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ResultModelT &amp;&gt;(ResultConcept).Result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::ResultConceptT &amp;</span><br><span class="line">AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::<span class="built_in">getResultImpl</span>(</span><br><span class="line">    AnalysisKey *ID, IRUnitT &amp;IR, ExtraArgTs... ExtraArgs) &#123;</span><br><span class="line">  <span class="keyword">typename</span> AnalysisResultMapT::iterator RI;</span><br><span class="line">  <span class="keyword">bool</span> Inserted;</span><br><span class="line">  std::<span class="built_in">tie</span>(RI, Inserted) = AnalysisResults.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(</span><br><span class="line">      std::<span class="built_in">make_pair</span>(ID, &amp;IR), <span class="keyword">typename</span> AnalysisResultListT::<span class="built_in">iterator</span>()));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we don&#x27;t have a cached result for this function, look up the pass and</span></span><br><span class="line">  <span class="comment">// run it to produce a result, which we then add to the cache.</span></span><br><span class="line">  <span class="keyword">if</span> (Inserted) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;P = <span class="keyword">this</span>-&gt;<span class="built_in">lookUpPass</span>(ID);</span><br><span class="line"></span><br><span class="line">    PassInstrumentation PI;</span><br><span class="line">    <span class="keyword">if</span> (ID != PassInstrumentationAnalysis::<span class="built_in">ID</span>()) &#123;</span><br><span class="line">      PI = getResult&lt;PassInstrumentationAnalysis&gt;(IR, ExtraArgs...);</span><br><span class="line">      PI.<span class="built_in">runBeforeAnalysis</span>(P, IR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AnalysisResultListT &amp;ResultList = AnalysisResultLists[&amp;IR];</span><br><span class="line">    ResultList.<span class="built_in">emplace_back</span>(ID, P.<span class="built_in">run</span>(IR, *<span class="keyword">this</span>, ExtraArgs...));</span><br><span class="line"></span><br><span class="line">    PI.<span class="built_in">runAfterAnalysis</span>(P, IR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// P.run may have inserted elements into AnalysisResults and invalidated</span></span><br><span class="line">    <span class="comment">// RI.</span></span><br><span class="line">    RI = AnalysisResults.<span class="built_in">find</span>(&#123;ID, &amp;IR&#125;);</span><br><span class="line">    <span class="built_in">assert</span>(RI != AnalysisResults.<span class="built_in">end</span>() &amp;&amp; <span class="string">&quot;we just inserted it!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    RI-&gt;second = std::<span class="built_in">prev</span>(ResultList.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *RI-&gt;second-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getResult-1"><a href="#getResult-1" class="headerlink" title="getResult"></a>getResult</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> PassT::Result &amp;<span class="title">getResult</span><span class="params">(IRUnitT &amp;IR, ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(AnalysisPasses.<span class="built_in">count</span>(PassT::<span class="built_in">ID</span>()) &amp;&amp;</span><br><span class="line">         <span class="string">&quot;This analysis pass was not registered prior to being queried&quot;</span>);</span><br><span class="line">  ResultConceptT &amp;ResultConcept =</span><br><span class="line">      <span class="built_in">getResultImpl</span>(PassT::<span class="built_in">ID</span>(), IR, ExtraArgs...);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> ResultModelT =</span><br><span class="line">      detail::AnalysisResultModel&lt;IRUnitT, PassT, <span class="keyword">typename</span> PassT::Result,</span><br><span class="line">                                  PreservedAnalyses, Invalidator&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;ResultModelT &amp;&gt;(ResultConcept).Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过PassT::Result的方式来获取到在Analysis中声明的Result的别名</p><p>之后就是通过getResultImpl中取出一个ResultConcept再转成ResultModel取出具体的Result</p><h2 id="getResultImpl"><a href="#getResultImpl" class="headerlink" title="getResultImpl"></a>getResultImpl</h2><p>impl逻辑首先尝试将这个IR insert到ResultMap中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> AnalysisResultMapT::iterator RI;</span><br><span class="line"><span class="keyword">bool</span> Inserted;</span><br><span class="line">std::<span class="built_in">tie</span>(RI, Inserted) = AnalysisResults.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(</span><br><span class="line">    std::<span class="built_in">make_pair</span>(ID, &amp;IR), <span class="keyword">typename</span> AnalysisResultListT::<span class="built_in">iterator</span>()));</span><br></pre></td></tr></table></figure><p>而这个AnalysisResultMapT是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Map type from a pair of analysis ID and IRUnitT pointer to an</span></span><br><span class="line"><span class="comment">/// iterator into a particular result list (which is where the actual analysis</span></span><br><span class="line"><span class="comment">/// result is stored).</span></span><br><span class="line"><span class="keyword">using</span> AnalysisResultMapT =</span><br><span class="line">    DenseMap&lt;std::pair&lt;AnalysisKey *, IRUnitT *&gt;,</span><br><span class="line">             <span class="keyword">typename</span> AnalysisResultListT::iterator&gt;;</span><br></pre></td></tr></table></figure><p>key → std::make_pair(ID, &amp;IR)</p><p>value → typename AnalysisResultListT::iterator()</p><p>也就是说通过一对(AnalysisKey *, IRUnitT *)来判断result是否存在</p><p>已经存在则直接返回值，不存在则表示没有cache，之后开始跑Pass。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PassInstrumentation PI;</span><br><span class="line"><span class="keyword">if</span> (ID != PassInstrumentationAnalysis::<span class="built_in">ID</span>()) &#123;</span><br><span class="line">  PI = getResult&lt;PassInstrumentationAnalysis&gt;(IR, ExtraArgs...);</span><br><span class="line">  PI.<span class="built_in">runBeforeAnalysis</span>(P, IR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AnalysisResultListT &amp;ResultList = AnalysisResultLists[&amp;IR];</span><br><span class="line">ResultList.<span class="built_in">emplace_back</span>(ID, P.<span class="built_in">run</span>(IR, *<span class="keyword">this</span>, ExtraArgs...));</span><br><span class="line"></span><br><span class="line">PI.<span class="built_in">runAfterAnalysis</span>(P, IR);</span><br></pre></td></tr></table></figure><p>这部分的代码可以看到实际跑pass的结果是存到了ResultList中，但是前面看到判断是否存在是依靠AnalysisResult实现的，那么我们要理一下将这两者关联起来的途径。</p><h3 id="AnalysisResultLists"><a href="#AnalysisResultLists" class="headerlink" title="AnalysisResultLists"></a>AnalysisResultLists</h3><p>对于一个AnalysisResultLists来说，通过一个IR来索引，找到这个IR所执行的所有PassID以及Pass对应的结果，也就是说通过一个IR关联到其所有跑的PassID，而每个PassID又和一个结果联系起来。</p><p>换个说法就是一个IRUnit和一个PassID实际上是唯一标识一组Result的。这里不标明pair的first、second以及end了，知道是pair就够了</p><p>（感谢rami3l推荐的mermaid，画图真方便）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">  AnalysisResultList -- key --&gt; IRUnit1 -- value --&gt; Pair11 --&gt; ID1 &amp; Result1</span><br><span class="line">  IRUnit1 --&gt; Pair12 --&gt; ID2 &amp; Result2</span><br><span class="line">  IRUnit1 --&gt; ....</span><br><span class="line">  AnalysisResultList --&gt; IRUnit2 --&gt; Pair21 --&gt; ID1 &amp; Result3</span><br><span class="line">  AnalysisResultList --&gt; ...</span><br><span class="line">  AnalysisResultList --&gt; IRUnitN --&gt; PairNM --&gt; IDN &amp; ResultX</span><br></pre></td></tr></table></figure><h3 id="AnalysisResult-1"><a href="#AnalysisResult-1" class="headerlink" title="AnalysisResult"></a>AnalysisResult</h3><p>上面也提到了AnalysisResultList中实际上是通过一个IRUnit和一个PassID来确定一个唯一的Result的。AnalysisResult在上面也看到了是一个IRUnit和PassID的pair作为key的Map，画成图是这样的。pair这里不知道怎么画了，姑且用这样的形式</p><p>而作为值的iter本质是指向了AnalysisResultList中结果所保存的PassID与Result的pair</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">AnalysisResult -- key --&gt; Pair1Start -- first --&gt; ID1 --&gt; Pair1End</span><br><span class="line">  Pair1Start -- second --&gt; ID1IRUnit1 --&gt; Pair1End </span><br><span class="line">Pair1End -- value --&gt; Iter1</span><br><span class="line">AnalysisResult -- key --&gt; Pair2Start -- first --&gt; ID2 --&gt; Pair2End</span><br><span class="line">  Pair2Start -- second --&gt; ID2IRUnit2 --&gt; Pair2End </span><br><span class="line">Pair2End -- value --&gt; Iter2</span><br><span class="line">AnalysisResult --&gt; ...</span><br><span class="line">AnalysisResult -- key --&gt; PairNStart -- first --&gt; IDN --&gt; PairNEnd</span><br><span class="line">  PairNStart -- second --&gt; IDNIRUnitN --&gt; PairNEnd </span><br><span class="line">PairNEnd -- value --&gt; IterN</span><br></pre></td></tr></table></figure><h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>那么我们把这两个部分串联起来看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">AnalysisResult -- key --&gt; Pair1Start -- first --&gt; ID1 --&gt; Pair1End</span><br><span class="line">  Pair1Start -- second --&gt; ID1IRUnit1 --&gt; Pair1End </span><br><span class="line">Pair1End -- value --&gt; Iter1</span><br><span class="line">  AnalysisResultList -- key --&gt; IRUnit1 -- value --&gt; Pair11 --&gt; ID1 &amp; Result1</span><br><span class="line">  IRUnit1 --&gt; Pair12 --&gt; ID2 &amp; Result2</span><br><span class="line">  </span><br><span class="line">  Iter1 --&gt; Result1</span><br></pre></td></tr></table></figure><h3 id="AnalysisKey"><a href="#AnalysisKey" class="headerlink" title="AnalysisKey"></a>AnalysisKey</h3><p>上面的查询过程中一直提到一个ID，而这个ID正是上面提及过的AnalysisInfoMixin所携带的ID函数所获取的。</p><p>类型定义是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">8</span>)</span> AnalysisKey </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>还记得每个Analysis中会声明一个静态的id变量么，C++中空对象依然需要保留1字节的空间来标识地址，因此使用了这种方式区分不同的Analysis</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个Analysis的结果是在Pass中通过AnalysisManager的getResult实例方法获取的</p><p>只有在实际进入这个函数的时候才会得到结果(lazily runs)，而每次进入到getResult的时候会根据一个Analysis ID以及一个IR来判断是否有结果的cache，没有cache这个时候才会进行分析得到结果(caches their results)</p><p>AnalysisResultList是IR为Key，Analysis的ID与结果为值的Map</p><p>AnalysisResults保存的则是一个IR + Analysis ID为key，结果为指向AnalysisResultList中某个结果的迭代器</p><h1 id="Analysis-Cache"><a href="#Analysis-Cache" class="headerlink" title="Analysis Cache"></a>Analysis Cache</h1><p>那么问题来了，既然是类似cache的机制，cache失效是怎么判断的呢？</p><p>我们回看一下PassManger中执行完Pass后的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">    ...</span><br><span class="line">    PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the analysis manager as each pass runs and potentially</span></span><br><span class="line">    <span class="comment">// invalidates analyses.</span></span><br><span class="line">    AM.<span class="built_in">invalidate</span>(IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, intersect the preserved analyses to compute the aggregate</span></span><br><span class="line">    <span class="comment">// preserved set for this pass manager.</span></span><br><span class="line">    PA.<span class="built_in">intersect</span>(std::<span class="built_in">move</span>(PassPA));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里提到了AM.invalidate，那么我们开始看一下invalidate的整个流程。不过在这之前我们先大概了解一下PreservedAnalyses</p><h1 id="PreservedAnalyses"><a href="#PreservedAnalyses" class="headerlink" title="PreservedAnalyses"></a>PreservedAnalyses</h1><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-2/Untitled%202.png"                      alt="Untitled"                ></p><p>大体看一下成员分为这么几类</p><ol><li>实际保存的preserve信息</li><li>基本的preserve相关的接口</li><li>abandon以及intersect</li><li>PreservedAnalysisChecker</li></ol><p>有这么三个成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalyses</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/// A special key used to indicate all analyses.</span></span><br><span class="line">  <span class="keyword">static</span> AnalysisSetKey AllAnalysesKey;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The IDs of analyses and analysis sets that are preserved.</span></span><br><span class="line">  SmallPtrSet&lt;<span class="keyword">void</span> *, <span class="number">2</span>&gt; PreservedIDs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// The IDs of explicitly not-preserved analyses.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// If an analysis in this set is covered by a set in `PreservedIDs`, we</span></span><br><span class="line">  <span class="comment">/// consider it not-preserved. That is, `NotPreservedAnalysisIDs` always</span></span><br><span class="line">  <span class="comment">/// &quot;wins&quot; over analysis sets in `PreservedIDs`.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// Also, a given ID should never occur both here and in `PreservedIDs`.</span></span><br><span class="line">  SmallPtrSet&lt;AnalysisKey *, <span class="number">2</span>&gt; NotPreservedAnalysisIDs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看名字就能理解其用途，一个Set保存了Preserved的ID，另一个Set保存NotPreserved的ID。要注意的是PreserveIDs里面的是void<em>而不是AnalysisKey</em>，因为被preserved的不仅可以是单个Analysis，还可以AnalysisSetKey。</p><h2 id="AnalysisSetKey"><a href="#AnalysisSetKey" class="headerlink" title="AnalysisSetKey"></a>AnalysisSetKey</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">8</span>)</span> AnalysisKey </span>&#123;&#125;;</span><br><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">8</span>)</span> AnalysisSetKey </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>AnalysisSetKey是一个代表一个IRUnit类型所有Analysis的。比如说IRUnit的类型是一个Function，那么就会有一个Function的AnalysisSetKey来表示preserve了所有Function相关的Pass，避免了对每个FunctionAnalysis进行比较判断</p><p>每个AnalysisSetKey也是像AnalysisKey有一个静态的实例。</p><p>首先是AllAnalysesOn这个类保存了Module和Function的AnalysisSetKey。AllAnalysesOn<IRUnitT>::ID就是获取表示对应IRUnit类型所有Analysis的AnalysisSetKey</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// This templated class represents &quot;all analyses that operate over \&lt;a</span></span><br><span class="line"><span class="comment">/// particular IR unit\&gt;&quot; (e.g. a Function or a Module) in instances of</span></span><br><span class="line"><span class="comment">/// PreservedAnalysis.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This lets a transformation say e.g. &quot;I preserved all function analyses&quot;.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Note that you must provide an explicit instantiation declaration and</span></span><br><span class="line"><span class="comment">/// definition for this template in order to get the correct behavior on</span></span><br><span class="line"><span class="comment">/// Windows. Otherwise, the address of SetKey will not be stable.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT&gt; <span class="class"><span class="keyword">class</span> <span class="title">AllAnalysesOn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AnalysisSetKey *<span class="title">ID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;SetKey; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> AnalysisSetKey SetKey;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT&gt; AnalysisSetKey AllAnalysesOn&lt;IRUnitT&gt;::SetKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">AllAnalysesOn</span>&lt;</span>Module&gt;;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">AllAnalysesOn</span>&lt;</span>Function&gt;;</span><br></pre></td></tr></table></figure><p>除此之外，在PreservedAnalyses中有一个表示保存了所有Analysis的key。注意这里的是private的，通过public的all来返回</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalyses</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"><span class="function"><span class="keyword">static</span> PreservedAnalyses <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PreservedAnalyses PA;</span><br><span class="line">    PA.PreservedIDs.<span class="built_in">insert</span>(&amp;AllAnalysesKey);</span><br><span class="line">    <span class="keyword">return</span> PA;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// A special key used to indicate all analyses.</span></span><br><span class="line">  <span class="keyword">static</span> AnalysisSetKey AllAnalysesKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CFGAnalyses还有自己的一个AnalysisSetKey</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CFGAnalyses</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> AnalysisSetKey *<span class="title">ID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;SetKey; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> AnalysisSetKey SetKey;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="preserve的相关接口"><a href="#preserve的相关接口" class="headerlink" title="preserve的相关接口"></a>preserve的相关接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalyses</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// Convenience factory function for the empty preserved set.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> PreservedAnalyses <span class="title">none</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">PreservedAnalyses</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Construct a special preserved set that preserves all passes.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> PreservedAnalyses <span class="title">all</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PreservedAnalyses PA;</span><br><span class="line">    PA.PreservedIDs.<span class="built_in">insert</span>(&amp;AllAnalysesKey);</span><br><span class="line">    <span class="keyword">return</span> PA;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/// Construct a preserved analyses object with a single preserved set.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisSetT&gt;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> PreservedAnalyses <span class="title">allInSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PreservedAnalyses PA;</span><br><span class="line">    PA.preserveSet&lt;AnalysisSetT&gt;();</span><br><span class="line">    <span class="keyword">return</span> PA;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Mark an analysis as preserved.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt; <span class="function"><span class="keyword">void</span> <span class="title">preserve</span><span class="params">()</span> </span>&#123; <span class="built_in">preserve</span>(AnalysisT::<span class="built_in">ID</span>()); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Given an analysis&#x27;s ID, mark the analysis as preserved, adding it</span></span><br><span class="line">  <span class="comment">/// to the set.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">preserve</span><span class="params">(AnalysisKey *ID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Clear this ID from the explicit not-preserved set if present.</span></span><br><span class="line">    NotPreservedAnalysisIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we&#x27;re not already preserving all analyses (other than those in</span></span><br><span class="line">    <span class="comment">// NotPreservedAnalysisIDs).</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">areAllPreserved</span>())</span><br><span class="line">      PreservedIDs.<span class="built_in">insert</span>(ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Mark an analysis set as preserved.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisSetT&gt; <span class="function"><span class="keyword">void</span> <span class="title">preserveSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">preserveSet</span>(AnalysisSetT::<span class="built_in">ID</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Mark an analysis set as preserved using its ID.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">preserveSet</span><span class="params">(AnalysisSetKey *ID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we&#x27;re not already in the saturated &#x27;all&#x27; state, add this set.</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">areAllPreserved</span>())</span><br><span class="line">      PreservedIDs.<span class="built_in">insert</span>(ID);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些比较基础的preserve接口，和Set相关的只需要操作PreservedIDs就可以，如果是非Set的Key则需要再操作NotPreservedAnalysisIDs</p><h2 id="abandon"><a href="#abandon" class="headerlink" title="abandon"></a>abandon</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Mark an analysis as abandoned.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An abandoned analysis is not preserved, even if it is nominally covered</span></span><br><span class="line"><span class="comment">/// by some other set or was previously explicitly marked as preserved.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Note that you can only abandon a specific analysis, not a *set* of</span></span><br><span class="line"><span class="comment">/// analyses.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt; <span class="function"><span class="keyword">void</span> <span class="title">abandon</span><span class="params">()</span> </span>&#123; <span class="built_in">abandon</span>(AnalysisT::<span class="built_in">ID</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Mark an analysis as abandoned using its ID.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// An abandoned analysis is not preserved, even if it is nominally covered</span></span><br><span class="line"><span class="comment">/// by some other set or was previously explicitly marked as preserved.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Note that you can only abandon a specific analysis, not a *set* of</span></span><br><span class="line"><span class="comment">/// analyses.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abandon</span><span class="params">(AnalysisKey *ID)</span> </span>&#123;</span><br><span class="line">  PreservedIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line">  NotPreservedAnalysisIDs.<span class="built_in">insert</span>(ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个就是简单的设置某个Analysis为NotPreserved</p><h2 id="intersect"><a href="#intersect" class="headerlink" title="intersect"></a>intersect</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Intersect this set with another in place.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This is a mutating operation on this preserved set, removing all</span></span><br><span class="line">  <span class="comment">/// preserved passes which are not also preserved in the argument.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">intersect</span><span class="params">(<span class="keyword">const</span> PreservedAnalyses &amp;Arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Arg.<span class="built_in">areAllPreserved</span>())</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">areAllPreserved</span>()) &#123;</span><br><span class="line">      *<span class="keyword">this</span> = Arg;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The intersection requires the *union* of the explicitly not-preserved</span></span><br><span class="line">    <span class="comment">// IDs and the *intersection* of the preserved IDs.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ID : Arg.NotPreservedAnalysisIDs) &#123;</span><br><span class="line">      PreservedIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line">      NotPreservedAnalysisIDs.<span class="built_in">insert</span>(ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ID : PreservedIDs)</span><br><span class="line">      <span class="keyword">if</span> (!Arg.PreservedIDs.<span class="built_in">count</span>(ID))</span><br><span class="line">        PreservedIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Intersect this set with a temporary other set in place.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// This is a mutating operation on this preserved set, removing all</span></span><br><span class="line">  <span class="comment">/// preserved passes which are not also preserved in the argument.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">intersect</span><span class="params">(PreservedAnalyses &amp;&amp;Arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Arg.<span class="built_in">areAllPreserved</span>())</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">areAllPreserved</span>()) &#123;</span><br><span class="line">      *<span class="keyword">this</span> = std::<span class="built_in">move</span>(Arg);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The intersection requires the *union* of the explicitly not-preserved</span></span><br><span class="line">    <span class="comment">// IDs and the *intersection* of the preserved IDs.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ID : Arg.NotPreservedAnalysisIDs) &#123;</span><br><span class="line">      PreservedIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line">      NotPreservedAnalysisIDs.<span class="built_in">insert</span>(ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ID : PreservedIDs)</span><br><span class="line">      <span class="keyword">if</span> (!Arg.PreservedIDs.<span class="built_in">count</span>(ID))</span><br><span class="line">        PreservedIDs.<span class="built_in">erase</span>(ID);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="invalidate"><a href="#invalidate" class="headerlink" title="invalidate"></a>invalidate</h1><p>声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Invalidate cached analyses for an IR unit.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Walk through all of the analyses pertaining to this unit of IR and</span></span><br><span class="line"><span class="comment">/// invalidate them, unless they are preserved by the PreservedAnalyses set.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalyses &amp;PA)</span></span>;</span><br></pre></td></tr></table></figure><p>实现的完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> AnalysisManager&lt;IRUnitT, ExtraArgTs...&gt;::<span class="built_in">invalidate</span>(</span><br><span class="line">    IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalyses &amp;PA) &#123;</span><br><span class="line">  <span class="comment">// We&#x27;re done if all analyses on this IR unit are preserved.</span></span><br><span class="line">  <span class="keyword">if</span> (PA.allAnalysesInSetPreserved&lt;AllAnalysesOn&lt;IRUnitT&gt;&gt;())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Track whether each analysis&#x27;s result is invalidated in</span></span><br><span class="line">  <span class="comment">// IsResultInvalidated.</span></span><br><span class="line">  SmallDenseMap&lt;AnalysisKey *, <span class="keyword">bool</span>, <span class="number">8</span>&gt; IsResultInvalidated;</span><br><span class="line">  <span class="function">Invalidator <span class="title">Inv</span><span class="params">(IsResultInvalidated, AnalysisResults)</span></span>;</span><br><span class="line">  AnalysisResultListT &amp;ResultsList = AnalysisResultLists[&amp;IR];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;AnalysisResultPair : ResultsList) &#123;</span><br><span class="line">    <span class="comment">// This is basically the same thing as Invalidator::invalidate, but we</span></span><br><span class="line">    <span class="comment">// can&#x27;t call it here because we&#x27;re operating on the type-erased result.</span></span><br><span class="line">    <span class="comment">// Moreover if we instead called invalidate() directly, it would do an</span></span><br><span class="line">    <span class="comment">// unnecessary look up in ResultsList.</span></span><br><span class="line">    AnalysisKey *ID = AnalysisResultPair.first;</span><br><span class="line">    <span class="keyword">auto</span> &amp;Result = *AnalysisResultPair.second;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> IMapI = IsResultInvalidated.<span class="built_in">find</span>(ID);</span><br><span class="line">    <span class="keyword">if</span> (IMapI != IsResultInvalidated.<span class="built_in">end</span>())</span><br><span class="line">      <span class="comment">// This result was already handled via the Invalidator.</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try to invalidate the result, giving it the Invalidator so it can</span></span><br><span class="line">    <span class="comment">// recursively query for any dependencies it has and record the result.</span></span><br><span class="line">    <span class="comment">// Note that we cannot reuse &#x27;IMapI&#x27; here or pre-insert the ID, as</span></span><br><span class="line">    <span class="comment">// Result.invalidate may insert things into the map, invalidating our</span></span><br><span class="line">    <span class="comment">// iterator.</span></span><br><span class="line">    <span class="keyword">bool</span> Inserted =</span><br><span class="line">        IsResultInvalidated.<span class="built_in">insert</span>(&#123;ID, Result.<span class="built_in">invalidate</span>(IR, PA, Inv)&#125;).second;</span><br><span class="line">    (<span class="keyword">void</span>)Inserted;</span><br><span class="line">    <span class="built_in">assert</span>(Inserted &amp;&amp; <span class="string">&quot;Should never have already inserted this ID, likely &quot;</span></span><br><span class="line">                       <span class="string">&quot;indicates a cycle!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now erase the results that were marked above as invalidated.</span></span><br><span class="line">  <span class="keyword">if</span> (!IsResultInvalidated.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> I = ResultsList.<span class="built_in">begin</span>(), E = ResultsList.<span class="built_in">end</span>(); I != E;) &#123;</span><br><span class="line">      AnalysisKey *ID = I-&gt;first;</span><br><span class="line">      <span class="keyword">if</span> (!IsResultInvalidated.<span class="built_in">lookup</span>(ID)) &#123;</span><br><span class="line">        ++I;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">auto</span> *PI = getCachedResult&lt;PassInstrumentationAnalysis&gt;(IR))</span><br><span class="line">        PI-&gt;<span class="built_in">runAnalysisInvalidated</span>(<span class="keyword">this</span>-&gt;<span class="built_in">lookUpPass</span>(ID), IR);</span><br><span class="line"></span><br><span class="line">      I = ResultsList.<span class="built_in">erase</span>(I);</span><br><span class="line">      AnalysisResults.<span class="built_in">erase</span>(&#123;ID, &amp;IR&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ResultsList.<span class="built_in">empty</span>())</span><br><span class="line">    AnalysisResultLists.<span class="built_in">erase</span>(&amp;IR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IsAllPreserved"><a href="#IsAllPreserved" class="headerlink" title="IsAllPreserved"></a>IsAllPreserved</h2><p>首先是判断是否这个set是被preserved的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We&#x27;re done if all analyses on this IR unit are preserved.</span></span><br><span class="line"><span class="keyword">if</span> (PA.allAnalysesInSetPreserved&lt;AllAnalysesOn&lt;IRUnitT&gt;&gt;())</span><br><span class="line">  <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>这里通过了一种AnalysisSetKey的方式来标识是否preserved了某个IRUnit的所有Analysis。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisSetT&gt; <span class="function"><span class="keyword">bool</span> <span class="title">allAnalysesInSetPreserved</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">allAnalysesInSetPreserved</span>(AnalysisSetT::<span class="built_in">ID</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Directly test whether a set of analyses is preserved.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This is only true when no analyses have been explicitly abandoned.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">allAnalysesInSetPreserved</span><span class="params">(AnalysisSetKey *SetID)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> NotPreservedAnalysisIDs.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">         (PreservedIDs.<span class="built_in">count</span>(&amp;AllAnalysesKey) || PreservedIDs.<span class="built_in">count</span>(SetID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里与其叫count不如叫find，查找是否存在对应的Key</p><h2 id="遍历所有Result执行invalidate"><a href="#遍历所有Result执行invalidate" class="headerlink" title="遍历所有Result执行invalidate"></a>遍历所有Result执行invalidate</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SmallDenseMap&lt;AnalysisKey *, <span class="keyword">bool</span>, <span class="number">8</span>&gt; IsResultInvalidated;</span><br><span class="line"><span class="function">Invalidator <span class="title">Inv</span><span class="params">(IsResultInvalidated, AnalysisResults)</span></span>;</span><br><span class="line">AnalysisResultListT &amp;ResultsList = AnalysisResultLists[&amp;IR];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;AnalysisResultPair : ResultsList) &#123;</span><br><span class="line">  AnalysisKey *ID = AnalysisResultPair.first;</span><br><span class="line">  <span class="keyword">auto</span> &amp;Result = *AnalysisResultPair.second;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> IMapI = IsResultInvalidated.<span class="built_in">find</span>(ID);</span><br><span class="line">  <span class="keyword">if</span> (IMapI != IsResultInvalidated.<span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> Inserted =</span><br><span class="line">      IsResultInvalidated.<span class="built_in">insert</span>(&#123;ID, Result.<span class="built_in">invalidate</span>(IR, PA, Inv)&#125;).second;</span><br><span class="line">  (<span class="keyword">void</span>)Inserted;</span><br><span class="line">  <span class="built_in">assert</span>(Inserted &amp;&amp; <span class="string">&quot;Should never have already inserted this ID, likely &quot;</span></span><br><span class="line">                     <span class="string">&quot;indicates a cycle!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想一下getResultImpl中将pass的结果存到了AnalysisResults中，前面的思路都捋清了这里也就很简单了</p><p>通过IsResultInvalidated记录处理过的Analysis</p><p>先找到所有这个IR关联的analysis以及result的组合，遍历每一个Result然后调用Result.invalidate，将验证结果塞入到IsResultInvalidated</p><h2 id="删除无效cache"><a href="#删除无效cache" class="headerlink" title="删除无效cache"></a>删除无效cache</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now erase the results that were marked above as invalidated.</span></span><br><span class="line"><span class="keyword">if</span> (!IsResultInvalidated.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> I = ResultsList.<span class="built_in">begin</span>(), E = ResultsList.<span class="built_in">end</span>(); I != E;) &#123;</span><br><span class="line">    AnalysisKey *ID = I-&gt;first;</span><br><span class="line">    <span class="keyword">if</span> (!IsResultInvalidated.<span class="built_in">lookup</span>(ID)) &#123;</span><br><span class="line">      ++I;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> *PI = getCachedResult&lt;PassInstrumentationAnalysis&gt;(IR))</span><br><span class="line">      PI-&gt;<span class="built_in">runAnalysisInvalidated</span>(<span class="keyword">this</span>-&gt;<span class="built_in">lookUpPass</span>(ID), IR);</span><br><span class="line"></span><br><span class="line">    I = ResultsList.<span class="built_in">erase</span>(I);</span><br><span class="line">    AnalysisResults.<span class="built_in">erase</span>(&#123;ID, &amp;IR&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ResultsList.<span class="built_in">empty</span>())</span><br><span class="line">  AnalysisResultLists.<span class="built_in">erase</span>(&amp;IR);</span><br></pre></td></tr></table></figure><p>最后则是简单的遍历所有的Result，根据IsResultInvalidated判断，如果是invalid则要从ResultList和AnalysisResults中删除</p><p>如果这个IR的所有Analysis结果都删掉了，那么就直接清除掉在ResultList中的这个IR相关的条目</p><p>这里的getCachedResult逻辑也很简单，就是取出保存的结果，这里不赘述了</p><h2 id="AnalysisResultModel-1"><a href="#AnalysisResultModel-1" class="headerlink" title="AnalysisResultModel"></a>AnalysisResultModel</h2><p>invalidate的过程中最关键的步骤在于Result.invalidate，而一个Result又是一个AnalysisResultModel</p><p>前面只看过了这个类的声明，我们在这里看一下HasInvalidateHandler为True和False的实现（省略了一些构造函数和相同的部分）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Specialization of \c AnalysisResultModel which delegates invalidate</span></span><br><span class="line"><span class="comment">/// handling to \c ResultT.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT, <span class="keyword">typename</span> ResultT,</span><br><span class="line">          <span class="keyword">typename</span> PreservedAnalysesT, <span class="keyword">typename</span> InvalidatorT&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnalysisResultModel</span>&lt;</span>IRUnitT, PassT, ResultT, PreservedAnalysesT,</span><br><span class="line">                           InvalidatorT, <span class="literal">true</span>&gt;</span><br><span class="line">    : AnalysisResultConcept&lt;IRUnitT, PreservedAnalysesT, InvalidatorT&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AnalysisResultModel</span><span class="params">(ResultT Result)</span> : Result(std::move(Result)) &#123;</span>&#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/// The model delegates to the \c ResultT method.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(IRUnitT &amp;IR, <span class="keyword">const</span> PreservedAnalysesT &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                  InvalidatorT &amp;Inv)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Result.<span class="built_in">invalidate</span>(IR, PA, Inv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ResultT Result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而为false的时候只有invalidate的内部实现是不同的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(IRUnitT &amp;, <span class="keyword">const</span> PreservedAnalysesT &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                InvalidatorT &amp;)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.<span class="keyword">template</span> getChecker&lt;PassT&gt;();</span><br><span class="line">  <span class="keyword">return</span> !PAC.<span class="built_in">preserved</span>() &amp;&amp;</span><br><span class="line">         !PAC.<span class="keyword">template</span> preservedSet&lt;AllAnalysesOn&lt;IRUnitT&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个参数有这样一段注释</p><blockquote><p>By default, this will implement the invalidate method with a trivial implementation so that the actual analysis result doesn’t need to provide an invalidation handler. It is only selected when the invalidation handler is not part of the ResultT’s interface.</p></blockquote><p>大意是LLVM中实现了一个默认的invalidate method，只有result不包含invalidate接口的时候才会被使用</p><p>那么我们先来从getChecker开始理解LLVM中默认的trivial invalidate过程</p><h3 id="getChecker"><a href="#getChecker" class="headerlink" title="getChecker"></a>getChecker</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalyses</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/// Build a checker for this `PreservedAnalyses` and the specified analysis</span></span><br><span class="line">  <span class="comment">/// type.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// You can use the returned object to query whether an analysis was</span></span><br><span class="line">  <span class="comment">/// preserved. See the example in the comment on `PreservedAnalysis`.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisT&gt; <span class="function">PreservedAnalysisChecker <span class="title">getChecker</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PreservedAnalysisChecker</span>(*<span class="keyword">this</span>, AnalysisT::<span class="built_in">ID</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Build a checker for this `PreservedAnalyses` and the specified analysis</span></span><br><span class="line">  <span class="comment">/// ID.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// You can use the returned object to query whether an analysis was</span></span><br><span class="line">  <span class="comment">/// preserved. See the example in the comment on `PreservedAnalysis`.</span></span><br><span class="line">  <span class="function">PreservedAnalysisChecker <span class="title">getChecker</span><span class="params">(AnalysisKey *ID)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PreservedAnalysisChecker</span>(*<span class="keyword">this</span>, ID);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PreservedAnalysisChecker"><a href="#PreservedAnalysisChecker" class="headerlink" title="PreservedAnalysisChecker"></a>PreservedAnalysisChecker</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalysisChecker</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PreservedAnalyses</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// A PreservedAnalysisChecker is tied to a particular Analysis because</span></span><br><span class="line">  <span class="comment">/// `preserved()` and `preservedSet()` both return false if the Analysis</span></span><br><span class="line">  <span class="comment">/// was abandoned.</span></span><br><span class="line">  <span class="built_in">PreservedAnalysisChecker</span>(<span class="keyword">const</span> PreservedAnalyses &amp;PA, AnalysisKey *ID)</span><br><span class="line">      : <span class="built_in">PA</span>(PA), <span class="built_in">ID</span>(ID), <span class="built_in">IsAbandoned</span>(PA.NotPreservedAnalysisIDs.<span class="built_in">count</span>(ID)) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns true if the checker&#x27;s analysis was not abandoned and either</span></span><br><span class="line">  <span class="comment">///  - the analysis is explicitly preserved or</span></span><br><span class="line">  <span class="comment">///  - all analyses are preserved.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">preserved</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !IsAbandoned &amp;&amp; (PA.PreservedIDs.<span class="built_in">count</span>(&amp;AllAnalysesKey) ||</span><br><span class="line">                            PA.PreservedIDs.<span class="built_in">count</span>(ID));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns true if the checker&#x27;s analysis was not abandoned and either</span></span><br><span class="line">  <span class="comment">///  - \p AnalysisSetT is explicitly preserved or</span></span><br><span class="line">  <span class="comment">///  - all analyses are preserved.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> AnalysisSetT&gt; <span class="function"><span class="keyword">bool</span> <span class="title">preservedSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnalysisSetKey *SetID = AnalysisSetT::<span class="built_in">ID</span>();</span><br><span class="line">    <span class="keyword">return</span> !IsAbandoned &amp;&amp; (PA.PreservedIDs.<span class="built_in">count</span>(&amp;AllAnalysesKey) ||</span><br><span class="line">                            PA.PreservedIDs.<span class="built_in">count</span>(SetID));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑也是比较简单。</p><h2 id="回顾invalidate流程"><a href="#回顾invalidate流程" class="headerlink" title="回顾invalidate流程"></a>回顾invalidate流程</h2><p>我们来回头捋一下invalidate的调用栈以及整个逻辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">  PassManager::run --&gt; AnalysisManager::invalidate</span><br><span class="line">AnalysisManager::invalidate --&gt; AnalysisResultModel::invalidate </span><br><span class="line">  AnalysisResultModel::invalidate --&gt; HasInvalidateHandlerFalse</span><br><span class="line">  HasInvalidateHandlerFalse --&gt; getChecker --&gt; PreservedAnalysisChecker</span><br><span class="line">PreservedAnalysisChecker --&gt; preserved</span><br><span class="line">PreservedAnalysisChecker --&gt; preservedSet</span><br></pre></td></tr></table></figure><p>一个Pass返回的PreservedAnalyses用于检查导致哪些Analysis失效了，而实际进行检查的则是对应的Result中的handler或者是LLVM默认的PreservedAnalysisChecker</p><h2 id="自定义的handler"><a href="#自定义的handler" class="headerlink" title="自定义的handler"></a>自定义的handler</h2><p>我们来看几个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Analysis pass which computes a \c DominatorTree.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DominatorTreeAnalysis</span> :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;DominatorTreeAnalysis&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/// Provide the result typedef for this analysis pass.</span></span><br><span class="line">  <span class="keyword">using</span> Result = DominatorTree;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DominatorTree</span> :</span> <span class="keyword">public</span> DominatorTreeBase&lt;BasicBlock, <span class="literal">false</span>&gt; &#123;</span><br><span class="line">  <span class="comment">/// Handle invalidation explicitly.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">invalidate</span><span class="params">(Function &amp;F, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                  FunctionAnalysisManager::Invalidator &amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DominatorTree::invalidate</span><span class="params">(Function &amp;F, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                               FunctionAnalysisManager::Invalidator &amp;)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check whether the analysis, all analyses on functions, or the function&#x27;s</span></span><br><span class="line">  <span class="comment">// CFG have been preserved.</span></span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.getChecker&lt;DominatorTreeAnalysis&gt;();</span><br><span class="line">  <span class="keyword">return</span> !(PAC.<span class="built_in">preserved</span>() || PAC.preservedSet&lt;AllAnalysesOn&lt;Function&gt;&gt;() ||</span><br><span class="line">           PAC.preservedSet&lt;CFGAnalyses&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallGraphAnalysis</span> :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;CallGraphAnalysis&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">using</span> Result = CallGraph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">CallGraph::invalidate</span><span class="params">(Module &amp;, <span class="keyword">const</span> PreservedAnalyses &amp;PA,</span></span></span><br><span class="line"><span class="params"><span class="function">                           ModuleAnalysisManager::Invalidator &amp;)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Check whether the analysis, all analyses on functions, or the function&#x27;s</span></span><br><span class="line">  <span class="comment">// CFG have been preserved.</span></span><br><span class="line">  <span class="keyword">auto</span> PAC = PA.getChecker&lt;CallGraphAnalysis&gt;();</span><br><span class="line">  <span class="keyword">return</span> !(PAC.<span class="built_in">preserved</span>() || PAC.preservedSet&lt;AllAnalysesOn&lt;Module&gt;&gt;() ||</span><br><span class="line">           PAC.preservedSet&lt;CFGAnalyses&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义invalidate的基本上都是利用了PreservedAnalysisChecker，加了一些特殊Set的检查，目前没看到有什么特别复杂的实现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-2/Un</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
    <category term="Analysis" scheme="https://fusionbolt.github.io/tags/Analysis/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其一：PassManager</title>
    <link href="https://fusionbolt.github.io/2022/06/26/llvm-pass-1/"/>
    <id>https://fusionbolt.github.io/2022/06/26/llvm-pass-1/</id>
    <published>2022-06-26T11:51:06.000Z</published>
    <updated>2022-06-26T12:45:11.813Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">现身吧，青眼亚白龙！ 把他给我烧的一干二净，毁灭的焦热疾风弹！</center> <p>上一期我们讲到了每个Pass基本的结构，这期我们从PassManager开始讲述Pass从创建到执行的整个流程，以及涉及到的种种问题</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT,</span><br><span class="line">          <span class="keyword">typename</span> AnalysisManagerT = AnalysisManager&lt;IRUnitT&gt;,</span><br><span class="line">          <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line">class PassManager : <span class="keyword">public</span> PassInfoMixin&lt;</span><br><span class="line">                        PassManager&lt;IRUnitT, AnalysisManagerT, ExtraArgTs...&gt;&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">std::vector&lt;std::unique_ptr&lt;PassConceptT&gt;&gt; Passes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于声明中要注意的有一点：上一期我们提到继承了PassInfoMixin的类我们就可以视为是一个Pass（从语法角度来说），也就是说PassManager本身也是一个Pass</p><p>接着来讲一下模板参数</p><h2 id="IRUnit"><a href="#IRUnit" class="headerlink" title="IRUnit"></a>IRUnit</h2><p>对于每个Pass有其作用的范围，有的是作用在函数上的，有的是作用到一个CFG中的</p><p>还记得上期里讲到新Pass是通过run传进去的参数来决定是作用到什么样的pass么</p><p>AnalysisManagerT</p><h1 id="添加一个Pass"><a href="#添加一个Pass" class="headerlink" title="添加一个Pass"></a>添加一个Pass</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!std::is_same&lt;PassT, PassManager&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> PassModelT =</span><br><span class="line">      detail::PassModel&lt;IRUnitT, PassT, PreservedAnalyses, AnalysisManagerT,</span><br><span class="line">                        ExtraArgTs...&gt;;</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  Passes.<span class="built_in">push_back</span>(std::unique_ptr&lt;PassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里先不管enable_if_t的部分，参数也没什么可讲的，我们来看函数体的部分</p><p>可以看到实际传给PassManager的其实是一个PassModelT的实例，而不是一个Pass</p><h2 id="PassModel"><a href="#PassModel" class="headerlink" title="PassModel"></a>PassModel</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%201.png"                      alt="Untitled"                ></p><p>include/llvm/IR/PassManagerInternal.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT, <span class="keyword">typename</span> PreservedAnalysesT,</span><br><span class="line">          <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassModel</span> :</span> PassConcept&lt;IRUnitT, AnalysisManagerT, ExtraArgTs...&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="function">PreservedAnalysesT <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                         ExtraArgTs... ExtraArgs)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pass.<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">  &#125;</span><br><span class="line">PassT Pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PassModel做的事情也很简单，最重要的就是运行保存的Pass实例。</p><p>上期提到了实现Pass时isRequired是可选的。对于非required的pass也不需要手动编写一个返回false的函数，而秘密就在于这个函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">has_required_t</span> = <span class="keyword">decltype</span>(std::declval&lt;T &amp;&gt;().<span class="built_in">isRequired</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_required_t</span>, T&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">passIsRequiredImpl</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> T::<span class="built_in">isRequired</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_required_t</span>, T&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">passIsRequiredImpl</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> passIsRequiredImpl&lt;PassT&gt;(); &#125;</span><br></pre></td></tr></table></figure><p>而这部分类似的代码还存在于PassInstrumentation的代码中。对于PassInstrumentation来说接收的就是一个PassT，并不一定就是PassModel 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">has_required_t</span> = <span class="keyword">decltype</span>(std::declval&lt;PassT &amp;&gt;().<span class="built_in">isRequired</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_required_t</span>, PassT&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">isRequired</span>(<span class="keyword">const</span> PassT &amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">return</span> Pass.<span class="built_in">isRequired</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="keyword">static</span> std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_required_t</span>, PassT&gt;::value, <span class="keyword">bool</span>&gt;</span><br><span class="line"><span class="built_in">isRequired</span>(<span class="keyword">const</span> PassT &amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加一个PassManager"><a href="#添加一个PassManager" class="headerlink" title="添加一个PassManager"></a>添加一个PassManager</h2><p>除了可以添加一个常规的Pass，还可以添加一个PassManager到一个PassManager中，听起来很奇怪，但是PassManager的行为也是一种Pass</p><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;std::is_same&lt;PassT, PassManager&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;P : Pass.Passes)</span><br><span class="line">    Passes.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(P));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过使用enable_if_t来判断这个PassT是否为PassManager。</p><p>关于为什么要这么做，目前的PassManager run的部分没有处理嵌套的情况，注释中提到了</p><blockquote><p>cases rely on executing nested pass managers. Doing this could reduce implementation complexity and avoid potential invalidation issues that may happen with nested pass managers of the same type.</p></blockquote><p>大意就是减少实现复杂度以及减少问题</p><h1 id="Run"><a href="#Run" class="headerlink" title="Run"></a>Run</h1><p>先来大概看一遍代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Run all of the passes in this manager over the given unit of IR.</span></span><br><span class="line"><span class="comment">/// ExtraArgs are passed to each pass.</span></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                      ExtraArgTs... ExtraArgs)</span> </span>&#123;</span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Request PassInstrumentation from analysis manager, will use it to run</span></span><br><span class="line">  <span class="comment">// instrumenting callbacks for the passes later.</span></span><br><span class="line">  <span class="comment">// Here we use std::tuple wrapper over getResult which helps to extract</span></span><br><span class="line">  <span class="comment">// AnalysisManager&#x27;s arguments out of the whole ExtraArgs set.</span></span><br><span class="line">  PassInstrumentation PI =</span><br><span class="line">      detail::getAnalysisResult&lt;PassInstrumentationAnalysis&gt;(</span><br><span class="line">          AM, IR, std::tuple&lt;ExtraArgTs...&gt;(ExtraArgs...));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> Idx = <span class="number">0</span>, Size = Passes.<span class="built_in">size</span>(); Idx != Size; ++Idx) &#123;</span><br><span class="line">    <span class="keyword">auto</span> *P = Passes[Idx].<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">    <span class="comment">// pass, skip its execution completely if asked to (callback returns</span></span><br><span class="line">    <span class="comment">// false).</span></span><br><span class="line">    <span class="keyword">if</span> (!PI.runBeforePass&lt;IRUnitT&gt;(*P, IR))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    PreservedAnalyses PassPA;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(P-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">      PassPA = P-&gt;<span class="built_in">run</span>(IR, AM, ExtraArgs...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call onto PassInstrumentation&#x27;s AfterPass callbacks immediately after</span></span><br><span class="line">    <span class="comment">// running the pass.</span></span><br><span class="line">    PI.runAfterPass&lt;IRUnitT&gt;(*P, IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the analysis manager as each pass runs and potentially</span></span><br><span class="line">    <span class="comment">// invalidates analyses.</span></span><br><span class="line">    AM.<span class="built_in">invalidate</span>(IR, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, intersect the preserved analyses to compute the aggregate</span></span><br><span class="line">    <span class="comment">// preserved set for this pass manager.</span></span><br><span class="line">    PA.<span class="built_in">intersect</span>(std::<span class="built_in">move</span>(PassPA));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation was handled after each pass in the above loop for the</span></span><br><span class="line">  <span class="comment">// current unit of IR. Therefore, the remaining analysis results in the</span></span><br><span class="line">  <span class="comment">// AnalysisManager are preserved. We mark this with a set so that we don&#x27;t</span></span><br><span class="line">  <span class="comment">// need to inspect each one individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;IRUnitT&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里从PassInstrumentationAnalysis获取了一个PassInstrumentation（简称PI），PI中存了各种各样的callback，在跑Pass的前后会执行对应的callback。</p><p>这边的逻辑也比较简单，关键点在于Analysis与Instrumentation的各种callback相关的</p><h2 id="对Analysis的影响"><a href="#对Analysis的影响" class="headerlink" title="对Analysis的影响"></a>对Analysis的影响</h2><p>我们之前已经讲过通过PreservedAnalyses来管理Pass会导致哪些Analysis的结果失效，在跑Pass后会将结果的PreservedAnalyses用于修正AnalysisManager里保存的分析结果，也就是在这里AnalysisManager（以下简称AM）会实际更新内部保存的信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AM.<span class="built_in">invalidate</span>(IR, PassPA);</span><br></pre></td></tr></table></figure><p>而在所有Pass跑完之后则preserve当前IRUnit类型的AnalysesSet，这里使用一个Set是为了避免和这个IRUnit类型的Analysis逐个比较。在最后preserve整个set的原因是在跑每个pass的时候都在不断的更新其中的AnalysisManager以及PreserveAnalyses信息，都跑完之后可以保证当前这个IRUnit类型的Analyses都确保是preserved的。</p><p>我一开始对这里的写法感到奇怪，为什么都跑完了、修改过了还是preserved的。我最初的想法是被保存的Analysis，理解上更偏向于是被缓存了的Pass，但是仔细一想我觉得换一种说法来描述PreserveAnalyses就好理解了：PreserveAnalyses中记录的是在这之后能够正确获取结果的Analyses。也就是说跑完PassManager这个“Pass”之后所有的Analysis依然是能够正确获取的</p><p>在编写自己Pass的时候要手动指定使得哪些Analysis失效，原因是因为你在这个Pass里面做过了修改并且没有更新AnalysisManager的信息，我觉得理论上来说如果每个人在Pass里面自己做了AM.invalidate的操作本质上是一样的，在这里只是PassManager帮你做了这个事情（这里不考虑这个做法是否有必要，只是讨论实现的本质）。那么如果要在Pass内部进行修改再做分析，也可以直接通过invalidate的操作更新AM之后再获取数据</p><p>关于Analysis更详细的部分会在下一期讲述</p><h2 id="runBeforePass"><a href="#runBeforePass" class="headerlink" title="runBeforePass"></a>runBeforePass</h2><p>include/llvm/IR/PassInstrumentation.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">runBeforePass</span><span class="params">(<span class="keyword">const</span> PassT &amp;Pass, <span class="keyword">const</span> IRUnitT &amp;IR)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!Callbacks)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> ShouldRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">isRequired</span>(Pass)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;ShouldRunOptionalPassCallbacks)</span><br><span class="line">      ShouldRun &amp;= <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ShouldRun) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;BeforeNonSkippedPassCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;C : Callbacks-&gt;BeforeSkippedPassCallbacks)</span><br><span class="line">      <span class="built_in">C</span>(Pass.<span class="built_in">name</span>(), llvm::<span class="built_in">Any</span>(&amp;IR));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ShouldRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runBeforePass除了执行一些常规callback之外，不同之处在于做了是否要执行当前pass的判断。如果并非required的pass则根据callback中的函数来确定是否运行当前pass</p><p>而runAfterPass就是简单的执行所有callback，这里就不再赘述</p><h1 id="更具体的PassManager"><a href="#更具体的PassManager" class="headerlink" title="更具体的PassManager"></a>更具体的PassManager</h1><p>讲完了基础的PassManager，我们再来看一下通过PassManager衍生出更加具体的PassManager都是怎样的。不过不管怎么衍生，关于执行的结果以及analysis处理以及callback这些的处理大致是一致的，只是加了一些对于某类IRUnit专用的处理操作</p><p>主要有以下这么几种方式</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>根据IRUnit的不同，有这么几类PassManager</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%202.png"                      alt="Untitled"                ></p><p>代码中是这样的</p><p>PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ModulePassManager = PassManager&lt;Module&gt;;</span><br><span class="line"><span class="keyword">using</span> FunctionPassManager = PassManager&lt;Function&gt;;</span><br></pre></td></tr></table></figure><p>这种没什么可讲的，就是简单的用了一个别名来标识</p><h2 id="针对Loop特化的PassManager"><a href="#针对Loop特化的PassManager" class="headerlink" title="针对Loop特化的PassManager"></a>针对Loop特化的PassManager</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%203.png"                      alt="Untitled"                ></p><p>include/llvm/Transforms/Scalar/LoopPassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Explicit specialization and instantiation declarations for the pass manager.</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManager</span>&lt;</span>Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                  LPMUpdater &amp;&gt;</span><br><span class="line">    : <span class="keyword">public</span> PassInfoMixin&lt;</span><br><span class="line">          PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                      LPMUpdater &amp;&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PassManager</span><span class="params">()</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过成员可以看到多了一些Loop相关的处理</p><h3 id="addPass"><a href="#addPass" class="headerlink" title="addPass"></a>addPass</h3><p>还是熟悉的enable_if，主要是根据参数是RepeatedPass还是普通Pass以及PassT是否满足HasRunOnLoopT产生了四种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> LoopPassModelT =</span><br><span class="line">      detail::PassModel&lt;Loop, PassT, PreservedAnalyses, LoopAnalysisManager,</span><br><span class="line">                        LoopStandardAnalysisResults &amp;, LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LoopPassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(PassT &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> LoopNestPassModelT =</span><br><span class="line">      detail::PassModel&lt;LoopNest, PassT, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopNestPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopNestPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">LoopNestPassModelT</span>(std::forward&lt;PassT&gt;(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Specializations of `addPass` for `RepeatedPass`. These are necessary since</span></span><br><span class="line"><span class="comment">// `RepeatedPass` has a templated `run` method that will result in incorrect</span></span><br><span class="line"><span class="comment">// detection of `HasRunOnLoopT`.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(RepeatedPass&lt;PassT&gt; &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> RepeatedLoopPassModelT =</span><br><span class="line">      detail::PassModel&lt;Loop, RepeatedPass&lt;PassT&gt;, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">RepeatedLoopPassModelT</span>(std::<span class="built_in">move</span>(Pass))));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">LLVM_ATTRIBUTE_MINSIZE</span><br><span class="line">    std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;HasRunOnLoopT, PassT&gt;::value&gt;</span><br><span class="line">    <span class="built_in">addPass</span>(RepeatedPass&lt;PassT&gt; &amp;&amp;Pass) &#123;</span><br><span class="line">  <span class="keyword">using</span> RepeatedLoopNestPassModelT =</span><br><span class="line">      detail::PassModel&lt;LoopNest, RepeatedPass&lt;PassT&gt;, PreservedAnalyses,</span><br><span class="line">                        LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                        LPMUpdater &amp;&gt;;</span><br><span class="line">  IsLoopNestPass.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Do not use make_unique or emplace_back, they cause too many template</span></span><br><span class="line">  <span class="comment">// instantiations, causing terrible compile times.</span></span><br><span class="line">  LoopNestPasses.<span class="built_in">push_back</span>(std::unique_ptr&lt;LoopNestPassConceptT&gt;(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">RepeatedLoopNestPassModelT</span>(std::<span class="built_in">move</span>(Pass))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Explicitly specialize the pass manager&#x27;s run method to handle loop nest</span></span><br><span class="line"><span class="comment">/// structure updates.</span></span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">            LPMUpdater &amp;&gt;::<span class="built_in">run</span>(Loop &amp;L, LoopAnalysisManager &amp;AM,</span><br><span class="line">                               LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U) &#123;</span><br><span class="line">  <span class="comment">// Runs loop-nest passes only when the current loop is a top-level one.</span></span><br><span class="line">  PreservedAnalyses PA = (L.<span class="built_in">isOutermost</span>() &amp;&amp; !LoopNestPasses.<span class="built_in">empty</span>())</span><br><span class="line">                             ? <span class="built_in">runWithLoopNestPasses</span>(L, AM, AR, U)</span><br><span class="line">                             : <span class="built_in">runWithoutLoopNestPasses</span>(L, AM, AR, U);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation for the current loop should be handled above, and other loop</span></span><br><span class="line">  <span class="comment">// analysis results shouldn&#x27;t be impacted by runs over this loop. Therefore,</span></span><br><span class="line">  <span class="comment">// the remaining analysis results in the AnalysisManager are preserved. We</span></span><br><span class="line">  <span class="comment">// mark this with a set so that we don&#x27;t need to inspect each one</span></span><br><span class="line">  <span class="comment">// individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;Loop&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Run either a loop pass or a loop-nest pass. Returns `None` if</span></span><br><span class="line"><span class="comment">/// PassInstrumentation&#x27;s BeforePass returns false. Otherwise, returns the</span></span><br><span class="line"><span class="comment">/// preserved analyses of the pass.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function">Optional&lt;PreservedAnalyses&gt;</span></span><br><span class="line"><span class="function"><span class="title">runSinglePass</span><span class="params">(IRUnitT &amp;IR, PassT &amp;Pass, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">              LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U,</span></span></span><br><span class="line"><span class="params"><span class="function">              PassInstrumentation &amp;PI)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">runWithLoopNestPasses</span><span class="params">(Loop &amp;L, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        LoopStandardAnalysisResults &amp;AR,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        LPMUpdater &amp;U)</span></span>;</span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">runWithoutLoopNestPasses</span><span class="params">(Loop &amp;L, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LoopStandardAnalysisResults &amp;AR,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           LPMUpdater &amp;U)</span></span>;</span><br></pre></td></tr></table></figure><p>runSinglePass</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> PassT&gt;</span><br><span class="line"><span class="function">Optional&lt;PreservedAnalyses&gt; <span class="title">LoopPassManager::runSinglePass</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IRUnitT &amp;IR, PassT &amp;Pass, LoopAnalysisManager &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">    LoopStandardAnalysisResults &amp;AR, LPMUpdater &amp;U, PassInstrumentation &amp;PI)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Get the loop in case of Loop pass and outermost loop in case of LoopNest</span></span><br><span class="line">  <span class="comment">// pass which is to be passed to BeforePass and AfterPass call backs.</span></span><br><span class="line">  <span class="keyword">const</span> Loop &amp;L = <span class="built_in">getLoopFromIR</span>(IR);</span><br><span class="line">  <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">  <span class="comment">// pass, skip its execution completely if asked to (callback returns false).</span></span><br><span class="line">  <span class="keyword">if</span> (!PI.runBeforePass&lt;Loop&gt;(*Pass, L))</span><br><span class="line">    <span class="keyword">return</span> None;</span><br><span class="line"></span><br><span class="line">  PreservedAnalyses PA;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(Pass-&gt;name(), IR.getName())</span></span>;</span><br><span class="line">    PA = Pass-&gt;<span class="built_in">run</span>(IR, AM, AR, U);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do not pass deleted Loop into the instrumentation</span></span><br><span class="line">  <span class="keyword">if</span> (U.<span class="built_in">skipCurrentLoop</span>())</span><br><span class="line">    PI.runAfterPassInvalidated&lt;IRUnitT&gt;(*Pass, PA);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    PI.runAfterPass&lt;Loop&gt;(*Pass, L, PA);</span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系大概是这个样子的，这里就不贴其他的具体实现了，里面关于Analysis以及各种处理本质上都是类似的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">  run --&gt; runWithLoopNestPasses --&gt; runSinglePass</span><br><span class="line">  run --&gt; runWithOutLoopNestPasses --&gt; runSinglePass</span><br></pre></td></tr></table></figure><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>最后也是使用了一个别名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> PassManager&lt;Loop, LoopAnalysisManager, LoopStandardAnalysisResults &amp;,</span><br><span class="line">                    LPMUpdater &amp;&gt;</span><br><span class="line">    LoopPassManager;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>include/llvm/CodeGen/MachinePassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// MachineFunctionPassManager adds/removes below features to/from the base</span></span><br><span class="line"><span class="comment">/// PassManager template instantiation.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Support passes that implement doInitialization/doFinalization. This is for</span></span><br><span class="line"><span class="comment">///   machine function passes to work on module level constructs. One such pass</span></span><br><span class="line"><span class="comment">///   is AsmPrinter.</span></span><br><span class="line"><span class="comment">/// ...</span></span><br><span class="line"><span class="comment">/// - The base class `run` method is replaced by an alternative `run` method.</span></span><br><span class="line"><span class="comment">///   See details below.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// - Support codegening in the SCC order. Users include interprocedural</span></span><br><span class="line"><span class="comment">///   register allocation (IPRA).</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MachineFunctionPassManager</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> PassManager&lt;MachineFunction, MachineFunctionAnalysisManager&gt; &#123;</span><br><span class="line">  <span class="keyword">using</span> Base = PassManager&lt;MachineFunction, MachineFunctionAnalysisManager&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MachineFunctionPassManager属于codegen的部分，而codegen的部分目前还未完全迁移到新的Pass架构中，因此为了兼容旧部分的内容做了一些特殊处理</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-1/Untitled%204.png"                      alt="Untitled"                ></p><h3 id="addPass-1"><a href="#addPass-1" class="headerlink" title="addPass"></a>addPass</h3><p>在旧的Pass中有doInitialization以及doFinalization的部分，因此在addPass的时候同时会将init和final的Pass注册进去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt; <span class="function"><span class="keyword">void</span> <span class="title">addPass</span><span class="params">(PassT &amp;&amp;Pass)</span> </span>&#123;</span><br><span class="line">  Base::<span class="built_in">addPass</span>(std::forward&lt;PassT&gt;(Pass));</span><br><span class="line">  PassConceptT *P = Passes.<span class="built_in">back</span>().<span class="built_in">get</span>();</span><br><span class="line">  addDoInitialization&lt;PassT&gt;(P);</span><br><span class="line">  addDoFinalization&lt;PassT&gt;(P);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add machine module pass.</span></span><br><span class="line">  addRunOnModule&lt;PassT&gt;(P);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于addDoInitialization的处理是这样的，addDoFinalization以及addRunOnModule的函数也是类似的做法，只是更换了detected的条件，不再过多赘述。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">  std::<span class="keyword">enable_if_t</span>&lt;!is_detected&lt;<span class="keyword">has_init_t</span>, PassT&gt;::value&gt;</span><br><span class="line">  <span class="built_in">addDoInitialization</span>(PassConceptT *Pass) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PassT&gt;</span><br><span class="line">  std::<span class="keyword">enable_if_t</span>&lt;is_detected&lt;<span class="keyword">has_init_t</span>, PassT&gt;::value&gt;</span><br><span class="line">  <span class="built_in">addDoInitialization</span>(PassConceptT *Pass) &#123;</span><br><span class="line">    <span class="keyword">using</span> PassModelT =</span><br><span class="line">        detail::PassModel&lt;MachineFunction, PassT, PreservedAnalyses,</span><br><span class="line">                          MachineFunctionAnalysisManager&gt;;</span><br><span class="line">    <span class="keyword">auto</span> *P = <span class="keyword">static_cast</span>&lt;PassModelT *&gt;(Pass);</span><br><span class="line">    InitializationFuncs.<span class="built_in">emplace_back</span>(</span><br><span class="line">        [=](Module &amp;M, MachineFunctionAnalysisManager &amp;MFAM) &#123;</span><br><span class="line">          <span class="keyword">return</span> P-&gt;Pass.<span class="built_in">doInitialization</span>(M, MFAM);</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="run-1"><a href="#run-1" class="headerlink" title="run"></a>run</h3><p>之后在run的前后执行（这里省略绝大部分的细节），addDoInitialization以及addDoFinalization的部分在新的Pass架构中我觉得应当是要转换为callback的形式，就像之前的runBeforePass一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">MachineFunctionPassManager::run</span><span class="params">(Module &amp;M,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      MachineFunctionAnalysisManager &amp;MFAM)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// Add a PIC to verify machine functions.</span></span><br><span class="line">  <span class="keyword">if</span> (VerifyMachineFunction) &#123;</span><br><span class="line">    PassInstrumentation PI = MFAM.getResult&lt;PassInstrumentationAnalysis&gt;(M);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No need to pop this callback later since MIR pipeline is flat which means</span></span><br><span class="line">    <span class="comment">// current pipeline is the top-level pipeline. Callbacks are not used after</span></span><br><span class="line">    <span class="comment">// current pipeline.</span></span><br><span class="line">    PI.<span class="built_in">pushBeforeNonSkippedPassCallback</span>([&amp;MFAM](StringRef PassID, Any IR) &#123;</span><br><span class="line">...</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : InitializationFuncs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">F</span>(M, MFAM))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// Run machine module passes</span></span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : FinalizationFuncs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> Err = <span class="built_in">F</span>(M, MFAM))</span><br><span class="line">      <span class="keyword">return</span> Err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Error::<span class="built_in">success</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="针对SCC特化了run的PassManager"><a href="#针对SCC特化了run的PassManager" class="headerlink" title="针对SCC特化了run的PassManager"></a>针对SCC特化了run的PassManager</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Explicit specialization and instantiation declarations for the pass manager.</span></span><br><span class="line"><span class="comment">// See the comments on the definition of the specialization for details on how</span></span><br><span class="line"><span class="comment">// it differs from the primary template.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">            CGSCCUpdateResult &amp;&gt;::<span class="built_in">run</span>(LazyCallGraph::SCC &amp;InitialC,</span><br><span class="line">                                      CGSCCAnalysisManager &amp;AM,</span><br><span class="line">                                      LazyCallGraph &amp;G, CGSCCUpdateResult &amp;UR);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">PassManager</span>&lt;</span>LazyCallGraph::SCC, CGSCCAnalysisManager,</span><br><span class="line">                                  LazyCallGraph &amp;, CGSCCUpdateResult &amp;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// The CGSCC pass manager.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// See the documentation for the PassManager template for details. It runs</span></span><br><span class="line"><span class="comment">/// a sequence of SCC passes over each SCC that the manager is run over. This</span></span><br><span class="line"><span class="comment">/// type serves as a convenient way to refer to this construct.</span></span><br><span class="line"><span class="keyword">using</span> CGSCCPassManager =</span><br><span class="line">    PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">                CGSCCUpdateResult &amp;&gt;;</span><br></pre></td></tr></table></figure><p>SCC的PassManager只是特化了run的部分。在原来PassManager的基础上加了一些SCC相关的处理，这里出现了proxy这个东西，先忽视它，我们之后再介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Explicitly specialize the pass manager run method to handle call graph</span></span><br><span class="line"><span class="comment">/// updates.</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">PreservedAnalyses</span><br><span class="line">PassManager&lt;LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;,</span><br><span class="line">            CGSCCUpdateResult &amp;&gt;::<span class="built_in">run</span>(LazyCallGraph::SCC &amp;InitialC,</span><br><span class="line">                                      CGSCCAnalysisManager &amp;AM,</span><br><span class="line">                                      LazyCallGraph &amp;G, CGSCCUpdateResult &amp;UR) &#123;</span><br><span class="line">  <span class="comment">// Request PassInstrumentation from analysis manager, will use it to run</span></span><br><span class="line">  <span class="comment">// instrumenting callbacks for the passes later.</span></span><br><span class="line">  PassInstrumentation PI =</span><br><span class="line">      AM.getResult&lt;PassInstrumentationAnalysis&gt;(InitialC, G);</span><br><span class="line"></span><br><span class="line">  PreservedAnalyses PA = PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The SCC may be refined while we are running passes over it, so set up</span></span><br><span class="line">  <span class="comment">// a pointer that we can update.</span></span><br><span class="line">  LazyCallGraph::SCC *C = &amp;InitialC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get Function analysis manager from its proxy.</span></span><br><span class="line">  FunctionAnalysisManager &amp;FAM =</span><br><span class="line">      AM.getCachedResult&lt;FunctionAnalysisManagerCGSCCProxy&gt;(*C)-&gt;<span class="built_in">getManager</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;Pass : Passes) &#123;</span><br><span class="line">    <span class="comment">// Check the PassInstrumentation&#x27;s BeforePass callbacks before running the</span></span><br><span class="line">    <span class="comment">// pass, skip its execution completely if asked to (callback returns false).</span></span><br><span class="line">    <span class="keyword">if</span> (!PI.<span class="built_in">runBeforePass</span>(*Pass, *C))</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    PreservedAnalyses PassPA;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">TimeTraceScope <span class="title">TimeScope</span><span class="params">(Pass-&gt;name())</span></span>;</span><br><span class="line">      PassPA = Pass-&gt;<span class="built_in">run</span>(*C, AM, G, UR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (UR.InvalidatedSCCs.<span class="built_in">count</span>(C))</span><br><span class="line">      PI.runAfterPassInvalidated&lt;LazyCallGraph::SCC&gt;(*Pass, PassPA);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      PI.runAfterPass&lt;LazyCallGraph::SCC&gt;(*Pass, *C, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the SCC if necessary.</span></span><br><span class="line">    C = UR.UpdatedC ? UR.UpdatedC : C;</span><br><span class="line">    <span class="keyword">if</span> (UR.UpdatedC) &#123;</span><br><span class="line">      <span class="comment">// If C is updated, also create a proxy and update FAM inside the result.</span></span><br><span class="line">      <span class="keyword">auto</span> *ResultFAMCP =</span><br><span class="line">          &amp;AM.getResult&lt;FunctionAnalysisManagerCGSCCProxy&gt;(*C, G);</span><br><span class="line">      ResultFAMCP-&gt;<span class="built_in">updateFAM</span>(FAM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the CGSCC pass wasn&#x27;t able to provide a valid updated SCC, the</span></span><br><span class="line">    <span class="comment">// current SCC may simply need to be skipped if invalid.</span></span><br><span class="line">    <span class="keyword">if</span> (UR.InvalidatedSCCs.<span class="built_in">count</span>(C)) &#123;</span><br><span class="line">      <span class="built_in">LLVM_DEBUG</span>(<span class="built_in">dbgs</span>() &lt;&lt; <span class="string">&quot;Skipping invalidated root or island SCC!\n&quot;</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check that we didn&#x27;t miss any update scenario.</span></span><br><span class="line">    <span class="built_in">assert</span>(C-&gt;<span class="built_in">begin</span>() != C-&gt;<span class="built_in">end</span>() &amp;&amp; <span class="string">&quot;Cannot have an empty SCC!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update the analysis manager as each pass runs and potentially</span></span><br><span class="line">    <span class="comment">// invalidates analyses.</span></span><br><span class="line">    AM.<span class="built_in">invalidate</span>(*C, PassPA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, we intersect the final preserved analyses to compute the</span></span><br><span class="line">    <span class="comment">// aggregate preserved set for this pass manager.</span></span><br><span class="line">    PA.<span class="built_in">intersect</span>(std::<span class="built_in">move</span>(PassPA));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Before we mark all of *this* SCC&#x27;s analyses as preserved below, intersect</span></span><br><span class="line">  <span class="comment">// this with the cross-SCC preserved analysis set. This is used to allow</span></span><br><span class="line">  <span class="comment">// CGSCC passes to mutate ancestor SCCs and still trigger proper invalidation</span></span><br><span class="line">  <span class="comment">// for them.</span></span><br><span class="line">  UR.CrossSCCPA.<span class="built_in">intersect</span>(PA);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Invalidation was handled after each pass in the above loop for the current</span></span><br><span class="line">  <span class="comment">// SCC. Therefore, the remaining analysis results in the AnalysisManager are</span></span><br><span class="line">  <span class="comment">// preserved. We mark this with a set so that we don&#x27;t need to inspect each</span></span><br><span class="line">  <span class="comment">// one individually.</span></span><br><span class="line">  PA.preserveSet&lt;AllAnalysesOn&lt;LazyCallGraph::SCC&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> PA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="旧的PassManager体系"><a href="#旧的PassManager体系" class="headerlink" title="旧的PassManager体系"></a>旧的PassManager体系</h1><p>最后再简单讲一下我了解的旧PassManager的一些做法，不会涉及太多细节</p><p>核心实现在PassManagerImpl中</p><p>lib/IR/LegacyPassManager.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// PassManagerImpl manages MPPassManagers</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassManagerImpl</span> :</span> <span class="keyword">public</span> Pass,</span><br><span class="line">                        <span class="keyword">public</span> PMDataManager,</span><br><span class="line">                        <span class="keyword">public</span> PMTopLevelManager &#123;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">anchor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PassManagerImpl</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : Pass(PT_PassManager, ID), PMTopLevelManager(new MPPassManager()) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// \copydoc PassManager::add()</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Pass *P)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">schedulePass</span>(P);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// createPrinterPass - Get a module printer pass.</span></span><br><span class="line">  <span class="function">Pass *<span class="title">createPrinterPass</span><span class="params">(raw_ostream &amp;O,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">const</span> std::string &amp;Banner)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">createPrintModulePass</span>(O, Banner);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// run - Execute all of the passes scheduled for execution.  Keep track of</span></span><br><span class="line">  <span class="comment">/// whether any of the passes modifies the module, and if so, return true.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">run</span><span class="params">(Module &amp;M)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> llvm::Pass::doInitialization;</span><br><span class="line">  <span class="keyword">using</span> llvm::Pass::doFinalization;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非常大的不同是LegacyPassManager（以下简称LegacyPM）每次添加Pass的时候需要进行一次schedule。LegacyPass中在Analysis内部保存Analysis的结果，而在schedule中管理Pass的顺序以及不再需要的Analysis的释放。</p><p>然后我们来看一下run</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// run - Execute all of the passes scheduled for execution.  Keep track of</span></span><br><span class="line"><span class="comment">/// whether any of the passes modifies the module, and if so, return true.</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PassManagerImpl::run</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dumpArguments</span>();</span><br><span class="line">  <span class="built_in">dumpPasses</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ImmutablePass *ImPass : <span class="built_in">getImmutablePasses</span>())</span><br><span class="line">    Changed |= ImPass-&gt;<span class="built_in">doInitialization</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">initializeAllAnalysisInfo</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index) &#123;</span><br><span class="line">    Changed |= <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">runOnModule</span>(M);</span><br><span class="line">    M.<span class="built_in">getContext</span>().<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ImmutablePass *ImPass : <span class="built_in">getImmutablePasses</span>())</span><br><span class="line">    Changed |= ImPass-&gt;<span class="built_in">doFinalization</span>(M);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run的前后会执行doInitialization和doFinalization，这两个函数名是不是很眼熟？就是我们上面提到MachinePassManager中提及的</p><p>除了针对Module的PassManager还有一个针对Function的FunctionPassManager。对于FunctionPassManager来说也是需要每次addPass的时候进行schedule</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FunctionPassManagerImpl::run</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line"><span class="keyword">bool</span> Changed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">initializeAllAnalysisInfo</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index) &#123;</span><br><span class="line">  Changed |= <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">runOnFunction</span>(F);</span><br><span class="line">  F.<span class="built_in">getContext</span>().<span class="built_in">yield</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> Index = <span class="number">0</span>; Index &lt; <span class="built_in">getNumContainedManagers</span>(); ++Index)</span><br><span class="line">  <span class="built_in">getContainedManager</span>(Index)-&gt;<span class="built_in">cleanup</span>();</span><br><span class="line"></span><br><span class="line">wasRun = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> Changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-1/Un</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>LLVM Pass 其零：新的Pass机制</title>
    <link href="https://fusionbolt.github.io/2022/06/19/llvm-pass-0/"/>
    <id>https://fusionbolt.github.io/2022/06/19/llvm-pass-0/</id>
    <published>2022-06-19T06:57:30.000Z</published>
    <updated>2022-06-19T07:17:20.871Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/2c8c0f197016eb2f404a18dc65212ff2ca62e772.jpg942w_1388h_progressive.jpg"                      alt="2c8c0f197016eb2f404a18dc65212ff2ca62e772.jpg@942w_1388h_progressive.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">以高攻击力著称的传说之龙。任何编程语言和目标平台都能被粉碎，其破坏力不可估量</center> <p>在目前的LLVM中存在两套Pass相关的机制，一套是基本上已经过时的被称为LegacyPass的机制（codegen的部分还没有迁移完毕），另一套则是现在主要使用的Pass机制</p><p>这个系列会讲解新Pass结构的各个方面（重点在于新的Pass结构），PassManager以及与Pass的联系、Pass相关基础设施，旧架构设计上的问题以及在新架构的解决方案等内容，而第一篇则是着重于Pass本身。这个系列有些一笔带过的内容通常都会在后续文章提及，后面不再赘述。</p><p>本文从以下几个点来对比分析这两类的不同并且着重看一下新的机制的实现</p><ol><li>Pass的类结构是怎样的</li><li>Pass的编写方式</li><li>Pass的注册方式（这里只提及LLVM本身的Pass）</li><li>Pass元信息的获取方式</li></ol><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><h2 id="类型关系链"><a href="#类型关系链" class="headerlink" title="类型关系链"></a>类型关系链</h2><p>在LegacyPass中通过类型严格区分了module pass，function pass等。通过这张图可以看到Pass的继承链。（这里图片太长我只截取部分</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/Untitled-5622778.png"                      alt="Untitled"                ></p><p>来源：<a class="link"   href="https://llvm.org/doxygen/classllvm_1_1Pass.html" >https://llvm.org/doxygen/classllvm_1_1Pass.html<i class="fas fa-external-link-alt"></i></a></p><p>LegacyPass中就是非常普通的继承链，从这个角度上来说没什么可讲的</p><p>而在新Pass中每个Pass都是一个满足了PassConcept的东西。而PassConcept的要求是和PassInfoMixin相关联起来的，也就是说继承了PassInfoMixin的类算是Pass。虽然说是mixin，但是C++语法层面没有这样的特性，因此通过特殊的技巧来实现这样的语义。</p><p>关于Pass的实现方式有这样一段注释，大意是说继承是非常不好的，因此采用了这种concept-based polymorphism方式。在这里不具体讲解相关细节了，有兴趣可以点进注释中提到的链接看下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Note that the implementations of the pass managers use concept-based</span></span><br><span class="line"><span class="comment">/// polymorphism as outlined in the &quot;Value Semantics and Concept-based</span></span><br><span class="line"><span class="comment">/// Polymorphism&quot; talk (or its abbreviated sibling &quot;Inheritance Is The Base</span></span><br><span class="line"><span class="comment">/// Class of Evil&quot;) by Sean Parent:</span></span><br><span class="line"><span class="comment">/// * http://github.com/sean-parent/sean-parent.github.com/wiki/Papers-and-Presentations</span></span><br><span class="line"><span class="comment">/// * http://www.youtube.com/watch?v=_BpMYeUFXv8</span></span><br><span class="line"><span class="comment">/// * http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil</span></span><br></pre></td></tr></table></figure><p>我对这个概念没什么了解，按照我目前从代码中看到的，用我的话来说更像是一种编译期间执行的动态类型，只要有满足PassConcept接口的东西就可以成为Pass。在后续的内容中会提到各种各样的满足PassConcept的类，目前先说基本的Pass。</p><p>include/llvm/IR/PassManagerInternal.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> IRUnitT, <span class="keyword">typename</span> AnalysisManagerT, <span class="keyword">typename</span>... ExtraArgTs&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PassConcept</span> &#123;</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PassConcept</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> PreservedAnalyses <span class="title">run</span><span class="params">(IRUnitT &amp;IR, AnalysisManagerT &amp;AM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                ExtraArgTs... ExtraArgs)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function">  <span class="title">printPipeline</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                function_ref&lt;StringRef(StringRef)&gt; MapClassName2PassName)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> StringRef <span class="title">name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Polymorphic method to to let a pass optionally exempted from skipping by</span></span><br><span class="line">  <span class="comment">/// PassInstrumentation.</span></span><br><span class="line">  <span class="comment">/// To opt-in, pass should implement `static bool isRequired()`. It&#x27;s no-op</span></span><br><span class="line">  <span class="comment">/// to have `isRequired` always return false since that is the default.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">isRequired</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意isRequired是可选的，不实现则会是默认false，处理这里则是在PassModel中</p><p>大概了解一下Concept有什么接口之后我们来看Mixin</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/llvm-pass-0/Untitled%201-5622778.png"                      alt="Untitled"                ></p><p>图为各种继承了PassInfoMixin的Pass</p><p>对于PassInfoMixin来说只有name以及printPipeline的部分，而我们编写的Pass是要补全run的部分。那么我们来看一下PassInfoMixin的声明部分，实际上利用CRTP的机制来获取PassInfoMixin的子类信息并且返回，同样做到了多态的效果</p><p>include/llvm/IR/PassManager.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A CRTP mix-in to automatically provide informational APIs needed for</span></span><br><span class="line"><span class="comment">/// passes.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This provides some boilerplate for types that are passes.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PassInfoMixin</span> &#123;</span></span><br><span class="line">  <span class="comment">/// Gets the name of the pass we are mixed into.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> StringRef <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_base_of&lt;PassInfoMixin, DerivedT&gt;::value,</span><br><span class="line">                  <span class="string">&quot;Must pass the derived type as the template argument!&quot;</span>);</span><br><span class="line">    StringRef Name = getTypeName&lt;DerivedT&gt;();</span><br><span class="line">    Name.<span class="built_in">consume_front</span>(<span class="string">&quot;llvm::&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">printPipeline</span><span class="params">(raw_ostream &amp;OS,</span></span></span><br><span class="line"><span class="params"><span class="function">                     function_ref&lt;StringRef(StringRef)&gt; MapClassName2PassName)</span> </span>&#123;</span><br><span class="line">    StringRef ClassName = DerivedT::<span class="built_in">name</span>();</span><br><span class="line">    <span class="keyword">auto</span> PassName = <span class="built_in">MapClassName2PassName</span>(ClassName);</span><br><span class="line">    OS &lt;&lt; PassName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="区分Analysis"><a href="#区分Analysis" class="headerlink" title="区分Analysis"></a>区分Analysis</h2><p>对于LegacyPass来说要注意的是对于LegacyPass来说不论是Analysis还是Transform都是一个Pass，只是Analysis是一种ImmutablePass，在注册的时候也会需要这个信息。</p><p>但是对于新Pass来说Analysis就是Analysis，并不是一种Pass。比如我们来看一个Analysis的签名</p><p>include/llvm/Analysis/AssumptionCache.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssumptionAnalysis</span> :</span> <span class="keyword">public</span> AnalysisInfoMixin&lt;AssumptionAnalysis&gt; &#123;</span><br><span class="line">  <span class="keyword">friend</span> AnalysisInfoMixin&lt;AssumptionAnalysis&gt;;</span><br><span class="line">  <span class="keyword">static</span> AnalysisKey Key;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> Result = AssumptionCache;</span><br><span class="line">  <span class="function">AssumptionCache <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>很明显这个run的返回结果是不满足PassConcept的，Analysis有自己的一套AnalysisConcept</p><h1 id="编写"><a href="#编写" class="headerlink" title="编写"></a>编写</h1><p>lib/Transforms/Scalar/FlattenCFGPass.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlattenCFGLegacyPass</span> :</span> <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID; <span class="comment">// Pass identification, replacement for typeid</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">FlattenCFGLegacyPass</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;</span><br><span class="line">    <span class="built_in">initializeFlattenCFGLegacyPassPass</span>(*PassRegistry::<span class="built_in">getPassRegistry</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp;AU)</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    AU.addRequired&lt;AAResultsWrapperPass&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  AliasAnalysis *AA;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FlattenCFGLegacyPass::runOnFunction</span><span class="params">(Function &amp;F)</span> </span>&#123;</span><br><span class="line">  AA = &amp;getAnalysis&lt;AAResultsWrapperPass&gt;().<span class="built_in">getAAResults</span>();</span><br><span class="line">  <span class="keyword">bool</span> EverChanged = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// iterativelyFlattenCFG can make some blocks dead.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">iterativelyFlattenCFG</span>(F, AA)) &#123;</span><br><span class="line">    <span class="built_in">removeUnreachableBlocks</span>(F);</span><br><span class="line">    EverChanged = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EverChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlattenCFGPass</span> :</span> PassInfoMixin&lt;FlattenCFGPass&gt; &#123;</span><br><span class="line">  <span class="function">PreservedAnalyses <span class="title">run</span><span class="params">(Function &amp;F, FunctionAnalysisManager &amp;AM)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">PreservedAnalyses <span class="title">FlattenCFGPass::run</span><span class="params">(Function &amp;F,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      FunctionAnalysisManager &amp;AM)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">bool</span> EverChanged = <span class="literal">false</span>;</span><br><span class="line">  AliasAnalysis *AA = &amp;AM.getResult&lt;AAManager&gt;(F);</span><br><span class="line">  <span class="comment">// iterativelyFlattenCFG can make some blocks dead.</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">iterativelyFlattenCFG</span>(F, AA)) &#123;</span><br><span class="line">    <span class="built_in">removeUnreachableBlocks</span>(F);</span><br><span class="line">    EverChanged = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> EverChanged ? PreservedAnalyses::<span class="built_in">none</span>() : PreservedAnalyses::<span class="built_in">all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂的LegacyPass"><a href="#复杂的LegacyPass" class="headerlink" title="复杂的LegacyPass"></a>复杂的LegacyPass</h2><p>对比代码可以看到LegacyPass非常麻烦</p><ol><li>添加initializeXXXPass</li><li>声明一个PassID</li><li>用到的analysis还需要手动addRequired</li></ol><p>而新的Pass则不需要关心那么多其他的事情，只需要专注于编写实现就可以了</p><h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>这里可以看到两者run的参数是有区别的，对于新的Pass来说还需要传递一个AnalysisManager</p><p>而run中传进来的类型（被称为IRUnitT）以及AnalysisManager的类型共同体现了这个Pass是作用范围是什么（是一个Function又或是一个Module等等）</p><p>对于返回的结果两者也不相同。LegacyPass返回的是 是否修改的bool值，对于新的Pass返回的是这个Pass不会影响到哪些Analysis</p><h1 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h1><p>LegacyPass的注册方式是在一个全局的Registry变量中add每一个Pass的info</p><p>lib/Transforms/Scalar/FlattenCFGPass.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> FlattenCFGLegacyPass::ID = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">INITIALIZE_PASS_BEGIN</span>(FlattenCFGLegacyPass, <span class="string">&quot;flattencfg&quot;</span>, <span class="string">&quot;Flatten the CFG&quot;</span>,</span><br><span class="line">                      <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">INITIALIZE_PASS_DEPENDENCY</span>(AAResultsWrapperPass)</span><br><span class="line"><span class="built_in">INITIALIZE_PASS_END</span>(FlattenCFGLegacyPass, <span class="string">&quot;flattencfg&quot;</span>, <span class="string">&quot;Flatten the CFG&quot;</span>,</span><br><span class="line">                    <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_PASS_BEGIN(passName, arg, name, cfg, analysis)              \</span></span><br><span class="line"><span class="meta">  static void *initialize##passName##PassOnce(PassRegistry &amp;Registry) &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_PASS_DEPENDENCY(depName) initialize##depName##Pass(Registry);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITIALIZE_AG_DEPENDENCY(depName)                                      \</span></span><br><span class="line"><span class="meta">  initialize##depName##AnalysisGroup(Registry);</span></span><br></pre></td></tr></table></figure><p>展开宏是这个样子的，看到这个initialize函数是不是有点眼熟？这就是刚才在构造函数中实际调用的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">initializeFlattenCFGLegacyPassPassOnce</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">initializeAAResultsWrapperPassPass</span>(Registry);</span><br><span class="line">  PassInfo *PI =</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">PassInfo</span>(<span class="string">&quot;Flatten the CFG&quot;</span>, <span class="string">&quot;flattencfg&quot;</span>, &amp;FlattenCFGLegacyPass::ID,</span><br><span class="line">                   PassInfo::<span class="built_in">NormalCtor_t</span>(callDefaultCtor&lt;FlattenCFGLegacyPass&gt;),</span><br><span class="line">                   <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">  Registry.<span class="built_in">registerPass</span>(*PI, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> PI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> llvm::once_flag InitializeFlattenCFGLegacyPassPassFlag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">llvm::initializeFlattenCFGLegacyPassPass</span><span class="params">(PassRegistry &amp;Registry)</span> </span>&#123;</span><br><span class="line">  llvm::<span class="built_in">call_once</span>(InitializeFlattenCFGLegacyPassPassFlag,</span><br><span class="line">                  initializeFlattenCFGLegacyPassPassOnce, std::<span class="built_in">ref</span>(Registry));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏的最后两个bool参数分别是 是否为CFGPass和AnalysisPass</p><p>新的则是在lib/Passes/PassRegistry.def中使用这样的方式注册</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">FUNCTION_PASS</span>(<span class="string">&quot;flattencfg&quot;</span>, <span class="built_in">FlattenCFGPass</span>())</span><br></pre></td></tr></table></figure><p>对于新的Pass来说不需要再添加选项区分是否为Analysis，而是通过采用了不同名称的宏来实现，比如说有这样一个用于注册Analysis的宏</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_ANALYSIS(NAME, CREATE_PASS)</span></span><br></pre></td></tr></table></figure><p>而宏的具体实现则是根据使用的上下文来实现。通过先define这个宏的具体实现再include这个def文件完成各种流程（我并不知道这个做法叫什么..）</p><p>在lib/Passes/PassBuilder.cpp中有这样一段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Error <span class="title">PassBuilder::parseFunctionPass</span><span class="params">(FunctionPassManager &amp;FPM,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     <span class="keyword">const</span> PipelineElement &amp;E)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="comment">// Now expand the basic registered passes from the .inc file.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS)                                       \</span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">if</span> (Name == NAME) &#123;                                                          \</span></span><br><span class="line"><span class="meta">    FPM.addPass(CREATE_PASS);                                                  \</span></span><br><span class="line"><span class="meta">    return Error::success();                                                   \</span></span><br><span class="line"><span class="meta">  &#125;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时这个宏还会被用于一些其他的地方，比如说打印Pass名字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PassBuilder::printPassNames</span><span class="params">(raw_ostream &amp;OS)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">OS &lt;&lt; <span class="string">&quot;Function passes:\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUNCTION_PASS(NAME, CREATE_PASS) printPassName(NAME, OS);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;PassRegistry.def&quot;</span></span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h1><h2 id="identifier"><a href="#identifier" class="headerlink" title="identifier"></a>identifier</h2><p>对于LegacyPass来说通过声明的静态成员变量来区分。上面的编写Pass的时候添加静态成员变量ID，之后在注册的宏内构建了PassInfo并且将整个ID传进去</p><p>对于新的Pass我觉得是根据name来区分的。因为name是通过获取Pass的TypeName得到的。这一点对于Analysis也一样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PassInfoMixin</span> &#123;</span></span><br><span class="line">  <span class="comment">/// Gets the name of the pass we are mixed into.</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> StringRef <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">static_assert</span></span>(std::is_base_of&lt;PassInfoMixin, DerivedT&gt;::value,</span><br><span class="line">                  <span class="string">&quot;Must pass the derived type as the template argument!&quot;</span>);</span><br><span class="line">    StringRef Name = getTypeName&lt;DerivedT&gt;();</span><br><span class="line">    Name.<span class="built_in">consume_front</span>(<span class="string">&quot;llvm::&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><p>对于LegacyPass来说PassInfo基本上都在PassInfo中了，而上面也提到注册的时候会将PassInfo塞到一个全局的Registry对象中，获取的话通过Registry对象的getPassInfo方法传入Id或者注册的时候填写的arg来获取到对应的PassInfo实例。</p><p>include/llvm/PassInfo.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PassInfo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> NormalCtor_t = Pass* (*)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  StringRef PassName;     <span class="comment">// Nice name for Pass</span></span><br><span class="line">  StringRef PassArgument; <span class="comment">// Command Line argument to run this pass</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *PassID;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsCFGOnlyPass = <span class="literal">false</span>;      <span class="comment">// Pass only looks at the CFG.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsAnalysis;                 <span class="comment">// True if an analysis pass.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> IsAnalysisGroup;            <span class="comment">// True if an analysis group.</span></span><br><span class="line">  std::vector&lt;<span class="keyword">const</span> PassInfo *&gt; ItfImpl; <span class="comment">// Interfaces implemented by this pass</span></span><br><span class="line">  NormalCtor_t NormalCtor = <span class="literal">nullptr</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Registry获取PassInfo的里有这样的代码</p><p>include/llvm/PassRegistry.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> PassInfo *<span class="title">PassRegistry::getPassInfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *TI)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="function">sys::SmartScopedReader&lt;<span class="literal">true</span>&gt; <span class="title">Guard</span><span class="params">(Lock)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> PassInfoMap.<span class="built_in">lookup</span>(TI);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// PassInfoMap - Keep track of the PassInfo object for each registered pass.</span></span><br><span class="line"><span class="keyword">using</span> MapType = DenseMap&lt;<span class="keyword">const</span> <span class="keyword">void</span> *, <span class="keyword">const</span> PassInfo *&gt;;</span><br><span class="line">MapType PassInfoMap;</span><br></pre></td></tr></table></figure><p>对于新的Pass来说原本的PassInfo中绝大部分信息都已经不再需要了，比如说是否为Analysis，是否为CFGOnly，ID等。PassInfo中有一个叫NormalCtor的成员，LegacyPass是通过PassInfo创建的因此需要保存构造Pass的方法，但新Pass这里采用了其他的做法，因此这个成员也是不需要的。</p><p>唯一需要的就是name信息。由于Transform Pass和Analysis都是由ID区分的，在PassBuilder中也有isAnalysisPassName这样根据ID来帮助我们判断是什么的函数</p><h1 id="简单区分"><a href="#简单区分" class="headerlink" title="简单区分"></a>简单区分</h1><p>由于同时存在两套机制，我在初次接触的时候也感到很困惑，之前想要获取新Pass元信息的时候还在尝试LegacyPass的方法</p><p>在对整个结构不了解的时候想要区分一个Pass相关的内容是旧的还是新的可以通过这么两个思路</p><ol><li>通过所使用的类的声明位置，LegacyPass的基础设施相关头文件目前都放到了include/llvm的路径下，而新Pass的基础设施则是分散在include/llvm/IR/ 和include/llvm/Passes/下</li><li>LegacyPass的名字都改为了XXXLegacyPass</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/llvm-pass-0/2c</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="LLVM" scheme="https://fusionbolt.github.io/tags/LLVM/"/>
    
    <category term="Pass" scheme="https://fusionbolt.github.io/tags/Pass/"/>
    
  </entry>
  
  <entry>
    <title>司机与列车</title>
    <link href="https://fusionbolt.github.io/2022/05/21/driver-and-train/"/>
    <id>https://fusionbolt.github.io/2022/05/21/driver-and-train/</id>
    <published>2022-05-21T09:18:52.000Z</published>
    <updated>2022-05-21T09:45:39.739Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/driver-and-train/Nanchefengmian.jpg"                      alt="Nanchefengmian"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">与我在列车道相交处相遇吧</center> <center style="font-size:14px;color:#C0C0C0;text-decoration:underline">图片出自萌娘百科：天朝铁道少女:南车篇条目</center> <h1 id="列车"><a href="#列车" class="headerlink" title="列车"></a>列车</h1><ol><li>提到列车，你第一时间想到的是什么？</li></ol><p>是去旅游的时候在列车上看到的沿途风景，还是在回家的时候的思乡之情。</p><ol start="2"><li>那么提到停不下来的列车呢？</li></ol><p>我的第一想法是人生，但仔细想下去这趟列车最终还是会停止的，尽管那是非常久以后的事情了。而对于这个年纪的我们还难以感知到终点，就像停不下来了一样</p><ul><li>坐在永远不会停下的列车会是怎么样的感受呢？</li></ul><p>是好奇后面的旅途？是对后面不确定的旅途感到恐惧？还是说一段时间之后将其视为理所当然，在列车上的这一意识逐渐淡薄？</p><ul><li>对于列车来说，最重要的应当是司机。上面几种情况的司机又是什么样的存在？</li></ul><p>对于1这样的普通情况来讲，自然是辛苦工作的司机了。而对于2这样的情况，那列车的司机可能是自己。</p><ul><li>除了司机，列车本身的形态又是怎样的呢？</li></ul><p>对于1来说自然就是平常看到的列车了，那对于2来说又是怎样的？我想自己能够看清列车内部构造，却看不清这趟列车的形态的，即便你能够“从窗口探出头”，那也只能看到一部分。但对于别人来说，他们能够看清你的外部形态，却看不到你的内部构造。</p><ul><li>看到的风景又是怎样的呢</li></ul><p>对于1来说自然是沿途的风景：有山川、有城市、有农田、有。对于2来说，可能取决于你是以怎样的视角看过去，而且对于每个人来说是完全不同的内容。</p><h1 id="hoka与列车"><a href="#hoka与列车" class="headerlink" title="hoka与列车"></a>hoka与列车</h1><p>hoka是UXCoffee这档播客的主持人。对于hoka而言，她不知道什么时候坐上了一趟看起来不会停下来的列车。而启动这辆车的司机是谁呢？列车的形态是怎样的？在列车上能看到怎样的风景？</p><h2 id="名为自己的列车"><a href="#名为自己的列车" class="headerlink" title="名为自己的列车"></a>名为自己的列车</h2><p>去年4月，她晋升为了设计经理。晋升本是一件好事，但是随着她的晋升也带来了问题：要做的事情指数级增长，事情太多来不及处理。晚上夜深人静的时候会想起白天做不完的事情，这些事情在脑中挥之不去导致她开始失眠，甚至入睡了还会梦到相关的事情并且惊醒。</p><p>每天超负荷工作，别人给到自身计划之外的任务会叹气，开始烦。工作日考虑要不要加班，不加班内心内疚，要不要加班和实际加班中内心争斗，无法做内心放松的事情，很焦虑，焦虑久了变得抑郁了。</p><p>她的身体也逐渐开始发出信号：溃疡和胃炎。她开始觉得应当休息一下，但又觉得国内的人都是996，是不是只有自己不够努力，因此并没有停下来。</p><p>她渐渐开始觉得自己像是不会停止的，永远在跑的列车。</p><h2 id="无法停下的列车"><a href="#无法停下的列车" class="headerlink" title="无法停下的列车"></a>无法停下的列车</h2><p>她意识到了这一点，既然自己是这辆列车本身，那应当自己能够停下来才对，但是她并没有做到。她开始害怕：害怕工作安排的没有那么满就会有报应，害怕别人看出来自己没有安排那么满；害怕如果做得少了、慢了、做的不好了以后可能会失去我现在的认可吧；觉得自己努力，成长比较快，如果工作不那么满了会不会成长没有这么快，会不会被别人追上了。</p><h2 id="开始逐渐获取列车掌控权"><a href="#开始逐渐获取列车掌控权" class="headerlink" title="开始逐渐获取列车掌控权"></a>开始逐渐获取列车掌控权</h2><p>她最首先想到的自然是去旅游放松以下，但是在旅游的时候依然持续工作状态导致最后并没有真正得到休息。</p><p>后来去咨询有经验的前辈，也得到了许多有意义的建议，她的想法开始些许改变，在这之前她认为这个样子是不得了的大事，遇到了人生的挫折，需要做出改变与换工作。但是在这之后她明白了人生会经历许多次这样的事情，并非每一次都要换工作来解决，如果她自身对工作的期待不变的话则很快就会迎来下一次。但这些还没有真正让她真的脱离当前的状态。</p><p>直到去年年底的时候，已经没有什么任务了，大家纷纷开始结束了办公状态。她每天会和朋友做软陶，而工作的过程没有deadline，没有deadline也不觉得负罪，因为实在没办法有deadline。</p><p>但是这个时候她意识到自己出乎意料的开心</p><blockquote><p>以前感觉自己没有在做正事就会有自己是一事无成的loser的感觉<br>从来没想到如果做的每一件事情都是当下觉得喜欢且度过的时光里大部分都很开心，这样的日子里却没有在意有没有取得成绩、做的好不好<br>很难得的是在那些日子里觉得就这样也挺好的，躺平做咸鱼也挺好的。过的比较轻松，即便依然有事情想要做好，但基本上生活的节奏还是比较轻松。</p></blockquote><blockquote><p>如何不去想那些恐惧与焦虑，面对这个问题我以前觉得对抗这些地方是做的更好，害怕自己做的不够好，所以就去做得更好。做的越来越好、跑的越来越快，但我没想到我感动、放松、舒服、满足和快乐的时候，那些最原本的焦虑和恐惧直接不见了。我意识到是不是一开始就问错问题了，我问自己的时候是怎么样做更多去应对自己做的不够多的焦虑，但我没想到答案竟然好像是我做的更少、我让自己开心的话焦虑就随风而散了</p></blockquote><p>意识到可以这个样子来解决问题的时候，她开始尽可能保持比较好的状态，减少工作量，或者说把工作量控制在能够的负荷的程度上，尽可能减少工作里面不必要的焦虑，让我自己保持在一个相对比较轻松比较愉悦的状态逐渐的她所看到的风景也发生了变化。</p><h2 id="列车与风景的变化"><a href="#列车与风景的变化" class="headerlink" title="列车与风景的变化"></a>列车与风景的变化</h2><p>她开始觉得更喜欢休息那段时间那个样子的自己，更接受自己，也更善待他人，而在另一位主持人眼中也看到了她更加接受自己和善待自己的样子。</p><p>她的视角开始发生了变化，她看到的风景也开始发生了变化。</p><p>在这之前疲于处理人际关系，为了别人五分钟能处理事情的请求感到暴躁。同时不想社交，觉得社交浪费时间。</p><p>在这之后，她和同事的工作和交流更有耐心，更加能够接受同事的一些问题。</p><p>在这之前如果别人会议没有邀请她则会心里想“为什么不邀请我，是不是上一次交流的时候做错了什么，是不是他不喜欢我，是不是他觉得我很没用，他是不是不需要我不喜欢我“，一直在反复思考这样的事情。</p><p>但是在这之后她开始问自己：这是自己想感受到的焦虑？这焦虑是不是有必要的？这对我是不是有帮助的？她开始能够产生情绪的时候多分析一下情绪本身，意识到这些以后负面想法自然而然的灰飞烟灭，并且能够正确的方式去解决问题。</p><h1 id="我与列车"><a href="#我与列车" class="headerlink" title="我与列车"></a>我与列车</h1><p>听到这一档播客的时候越听到最后越觉得非常沉重。并不是说节目的过程或者内容真的是多么沉重的内容，而是和我的想法几乎一模一样。</p><h2 id="控制列车前进"><a href="#控制列车前进" class="headerlink" title="控制列车前进"></a>控制列车前进</h2><p>注：这里以及后面的工作不是指去公司上班这样的工作，我觉得用自己认为自己要做的任务比较合适一些。</p><p>觉得自己不行，就要想方设法的去做些什么，觉得自己本来就很没用如果不做些什么只会越来越没用。不过实际上我很多能力客观来讲确实有不足，加上本身精力极其差，很快就失去了控制，也就无法踩下刹车。</p><p>现在依然觉得我各方面做的都很差，各方面都是非常有问题的一个人，但是我开始对于自评的准确性产生了更多的怀疑，自己看到的自己究竟多少是正确的，多少是错误的。</p><h2 id="与其他列车的轨道交错"><a href="#与其他列车的轨道交错" class="headerlink" title="与其他列车的轨道交错"></a>与其他列车的轨道交错</h2><p>与他人交流的时候会有相似的想法，自己是不是做的不够好，是不是哪里做错了什么。我的客观情况是以前确实存在过许多类似的情况，但是数年过去我依然将想法停留在过去什么都没有做的我身上，而没有正视现在的自己的努力，正视自己的变化，正视周边的环境。</p><p>我现在还是会因为各种和人之间交流中出现的各种错误而自责，但是我或许应该多一分对自己的宽容，多怀着这是应当被解决问题的角度去看待。</p><h2 id="尝试控制列车"><a href="#尝试控制列车" class="headerlink" title="尝试控制列车"></a>尝试控制列车</h2><p>我尝试了许多，尝试了解自己这个样子的形成原因；尝试通过运动从身体层面改善；尝试一些有意思的兴趣爱好；尝试像卧室摆花这样的方式来感受生活；尝试培养许多习惯增强自己对生活的掌控感；尝试去强迫自己主动与他人建立连接。</p><p>也尝试过和hoka一样的方法，遇到问题的时候反思这个焦虑是否合理、焦虑是怎么产生的，但是这个方法之前几次尝试对我来说效果不大。这个方法我在其他地方也见过多次，这也说明了同一个方法对于不同人的适用性是不同的。</p><p>尝试了这么多，不过很多时候我还是无法快速恢复到原来的状态，但是我觉得通过这些努力在部分方面有一些进步，对我来说需要的可能不是契机，而是需要再经过一些时间。</p><h2 id="hoka的列车带给我的想法"><a href="#hoka的列车带给我的想法" class="headerlink" title="hoka的列车带给我的想法"></a>hoka的列车带给我的想法</h2><p>听这期节目的时候感觉非常压抑，但是节目最后有这样一句话</p><blockquote><p>这是一个契机帮助我了解我自己，我相信我一定可以从这个状态走出来，所以我不再害怕了</p></blockquote><p>也许是负面想法过于相似的缘故，听到这里感受到了一股温暖，压抑感也消失了一大半。</p><p>很难说听了一期播客就能都想开了，但是这期节目又让我强迫自己去面对这样的想法，去审视反思自己该怎么做，如何将他人的经验能作为参考。</p><p>不过比起上面说的那些，对我来说更重要的可能是这么厉害的人也会有这样的想法，让我觉得安心一些了。</p><p>之前也见过“厉害的人也会有一些认为自己不行“的说法（并不是说越了解越发现自己无知的那种，而是觉得自己这个人不行），但是终究没有真实感，没有经历过终究只是一行文字罢了。</p><p>只是听或许只是留下深刻印象，但是写这篇文章的时候我需要再次强迫自己重新审视自己，类似的情况自己是怎么样的，这些是只停留在听远远达不到的。</p><h1 id="列车交错"><a href="#列车交错" class="headerlink" title="列车交错"></a>列车交错</h1><p>这里不论自身的工作（职业与自我）还是面对他人的想法，终究都要归到人上。能力的高低需要和人进行比较，工作做的怎么样会影响到他人的评判进而影响到别人的看法。不论好与坏，都是如此。但是实际上人生就像列车一样并不需要和其他人做比较，每个人有着各自属于自己的独一无二的路线。</p><p>但是大多数人并不能从心底接受这个想法（我也一样），因此我们在与他人建立联系的时候产生的不安全感，产生了焦虑、恐惧。</p><p>说到这些内容，我回想起《神经症与人性的成长》这本书提到的人的基本焦虑（这本书十分推荐给大家，不要因为书名有神经症就放弃了这本书，这本书能够帮助你理解你在成长过程中遇到的一些问题的根本成因）</p><blockquote><p>“其结果是使得小孩缺乏对“我们”的“归属感”与“连带感”，而代之以深刻的不安全感与莫名的恐惧，此种现象我称之为“基本焦虑”，是因处身于自己所认为敌对的世界中，而产生的一种被孤立或无助的感觉。这种基本焦虑会使小孩无法抒发真正的情感以与人相沟通，并可因而逼他去寻求对付别人的方法。他一定会（潜意识地）需要以某种方式来对付别人，而且这种方式必须不会激起或增加此种基本焦虑，而是会缓和它。由此种潜意识的策略需要所产生的特殊态度，须视小孩子的气质及环境的偶然性而定；简言之，他会试图去依附周遭最有权势的人；会反抗与格斗；会使他的内在生活与他人隔绝开来，且意气用事地远离他人；通常这意味着他会<strong>亲近</strong>、<strong>反抗</strong>或者<strong>逃避</strong>他人。</p></blockquote><p>注：关于这里提及的内容如果觉得说的太过于绝对还请看原书上下文，都有更详尽的解释。</p><p>对我来说一个人的时候就不会有这些内耗，想着不去建立联系就没有那么多问题了，这就是回避。但是这终究是错误的，同时也是不可能实现的。人们像列车一样总会以某种方式建立联系，对于列车来说可能会停在一起，可能会跑过相同的铁轨，可能相反会擦肩而过，可能会相同的方向发车。人们不也是如此吗，和别人相遇，和别人分离。好的联系，坏的联系；想要的联系，不想要的联系；会产生幸福感的联系，会产生焦虑感的联系，<strong>人们总会以某种方式产生关联，无法脱离开来</strong>。</p><p>对于我这样经常回避的人来说，一定要意识到回避掉是不可能的这件事情，然后去做出改变才可能打破现状。而对于非回避的情况我认为很大程度上也需要认识到人与人之间的关系，并且去寻求前人的经验，寻求身边的人帮助。</p><p>人的问题出在人与人之间的连接，但是解决问题的过程甚至最终方案依然要依赖于人与人之间的连接。</p><h1 id="各自的人生列车"><a href="#各自的人生列车" class="headerlink" title="各自的人生列车"></a>各自的人生列车</h1><p>每个人的问题都是不同的，即便会有相似的情况，可以参考一部分别人的做法，但是不太可能完全依靠和他人相同的解决方案解决自身的问题。每个人根据自己的性格特点以及现状解决方案都是各不相同的，但我觉得大多数情况是需要<strong>自己做出什么改变</strong>，因为操控这辆列车的人是你自己。即便有外部因素将你推动到另一个方向上，你依然可以让列车回到正规。</p><p>列车的行驶中一切不可能总是一帆风顺，如果这趟列车脱离了轨道，那请将这视为一个契机，发现问题，去解决问题。如果一时没能解决，很多时候并不是你的方法不对（就像hoka去旅游放松，本身并不是坏的选择），而是可能需要一些时间，可能需要一些其他契机。我认为最重要的是不管怎样不要害怕面对这个问题，即便你没有什么解决问题的想法。霍金说过“有生命就有希望”。</p><p>最后贴上这期节目的地址</p><p><a class="link"   href="https://uxcoffee.com/episodes/93" >https://uxcoffee.com/episodes/93<i class="fas fa-external-link-alt"></i></a></p><p>我挺喜欢这个节目的，尽管我对设计没什么了解，但是听了很多期都非常喜欢，在这里也推荐这档播客给读到结尾的你。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/driver-and-tra</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="Podcast" scheme="https://fusionbolt.github.io/tags/Podcast/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记 一些变动</title>
    <link href="https://fusionbolt.github.io/2022/05/15/rc-lang-change/"/>
    <id>https://fusionbolt.github.io/2022/05/15/rc-lang-change/</id>
    <published>2022-05-15T14:42:50.000Z</published>
    <updated>2022-05-15T14:44:21.653Z</updated>
    
    <content type="html"><![CDATA[<p>关于开发周记周更这件事情现在继续做的必要性我开始产生了疑问。</p><p>首先我写这个一方面是为了养成写博客的习惯，另一方面则是为了促进我形成写代码的习惯。然而随着我不断的做这样的事情，需要学习分析其他编译器实现的次数越来越多。这并非是因为我不继续做下去而要放弃，反而是我想要更好的做这件事情。这些分析的结果我更倾向于转换为其他系列的博客，因此我决定不再周更开发周记。</p><p>当然并不是说后面完全不更新了，如果我代码开始写新的内容一定会更新的，同时之后写的新内容一定会关联到对应一期分析的博客。至于分析的内容，当我了解完成一个阶段以后会对这些内容进行一个整理并且发布到我的博客。更新频率未必会周更，视我学习的进度而定，主要是想要尽可能保证内容的完整与连贯，有一些内容还是放在一起写会比较合适。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于开发周记周更这件事情现在继续做的必要性我开始产生了疑问。&lt;/p&gt;
&lt;p&gt;首先我写这个一方面是为了养成写博客的习惯，另一方面则是为了促进我形成写代码的习惯。然而随着我不断的做这样的事情，需要学习分析其他编译器实现的次数越来越多。这并非是因为我不继续做下去而要放弃，反而是我</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
  </entry>
  
  <entry>
    <title>我与博客</title>
    <link href="https://fusionbolt.github.io/2022/05/08/IandBlog/"/>
    <id>https://fusionbolt.github.io/2022/05/08/IandBlog/</id>
    <published>2022-05-08T03:42:36.000Z</published>
    <updated>2022-05-21T09:22:06.346Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/IandBlog/Untitled.png"                      alt="Untitled"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">你愿意和我一起读下去吗 pixiv: 44636666</center> <p>读《暗时间》这本书的时候看到关于你为什么应该写博客的章节，想先把自己有关博客的想法做一个记录，因此就有了本文。</p><h1 id="我和博客的开始"><a href="#我和博客的开始" class="headerlink" title="我和博客的开始"></a>我和博客的开始</h1><p>以前也尝试过建立博客，也搞过什么Wordpress之类的，但也都是搭建好新鲜感过去来，之后就没写什么东西，之后也就不了了之了。</p><p>去年三月多的时候又将这个事情回想了起来，决定好好对待这件事情。<del>结果去年一年也没写上几篇</del></p><p>今年的话渐渐有了更多的想法，内容也逐渐的有了一些。</p><h1 id="博客所带来的好处"><a href="#博客所带来的好处" class="headerlink" title="博客所带来的好处"></a>博客所带来的好处</h1><h2 id="反复思考"><a href="#反复思考" class="headerlink" title="反复思考"></a>反复思考</h2><p>写博客本身是一个反复思考复盘的过程。不论是单纯记录还是思考，写下的过程中会不断复习这些知识，在这个过程中自己对这些知识的记忆会更加牢靠，同时可能产生了新的问题，进而产生新的思考。同时梳理思考的过程中会无意中发现一些问题，我在写自己的开发周记的时候发现了一些自己的bug。</p><p>在讲解给读者的时候会强迫自己去思考，读者可能会提出哪些问题？这些地方自己是否真的明白了？有的技术博客我在写的时候也会发现自己知识的漏洞，现去弥补一下知识漏洞再来接着写。</p><p>这样长期反复梳理思考下去我觉得慢慢这种思考就会变成一种习惯，不仅是写博客，在做其他的事情也会受益。</p><h2 id="展示自我"><a href="#展示自我" class="headerlink" title="展示自我"></a>展示自我</h2><p>看博客能够知道你是什么样的人。你写什么样的博客，你关注哪些内容，你的思考方式是怎么样的等等。这也算是一种特殊的自我介绍了，在网络上看一个人的几条发言可能看不出一个人是怎样的，但是如果他一直持续输出内容，则可以从输出的内容中对这个人多几分了解。或许还会有志同道合的人因此和你成为朋友，也许其中还会有非常聊得来的人。（<del>首页中的图标和关于都有我的联系方式，欢迎私信</del>）</p><h2 id="积累与激励"><a href="#积累与激励" class="headerlink" title="积累与激励"></a>积累与激励</h2><p>看到自己写了那么多博客，既是一种积累，后面再回来看，看着自己的内容不断精进，不断变化，意识到自己的进步与成长，进而给自信添砖加瓦，激励自己后续持续学习和思考。这是一种良性循环，只要熬过了最初不知道该写什么与不知道怎么写的阶段，就会不断有所收获。</p><h1 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h1><h2 id="出师不利：不知道该写什么"><a href="#出师不利：不知道该写什么" class="headerlink" title="出师不利：不知道该写什么"></a>出师不利：不知道该写什么</h2><p>在刚开始写的时候，这个问题是最让我头疼的。去年年底开始写开发周记之前，基本上都没什么内容。后来开发周记写了几篇，读书的时候也开始能够留下一些笔记和想法，渐渐的有了一些想写的东西。读书感悟，简单的科普，开发问题复盘，自己的一些想法，我还有很多想法都没有写出来，很多来不及整理的只能在我的笔记中默默等待</p><p>仔细考虑的话，发生这种改变的本质原因是我去年开始做了各种各样的事情，同时渐渐开始养成记录内容的习惯（这个记录的习惯真的是非常重要，我的很多博客都是从碎片整理来的），因此我渐渐的有一些东西可说。如果你实在不知道怎么写，那就试着多留心观察自己的想法，自己经历的事情，说不定会找到什么答案。</p><p>但是因为不知道写什么就放弃不去写了这件事情是完全不一样的。如果不去做些什么的话，你不管放弃几次回头看可能都不知道写什么。只要写了一篇，就更可能有第二篇，以此类推</p><p>我在初学编程的时候也是不知道该写什么，因为我对这个东西没有形成一些印象，后来过了非常长的时间总算是多少入了门。在这个过程中我一直没有停止学习接触相关知识，即便现在看来都是错误的方式，但最终都是我过去的行为推动了我现在的行为</p><h2 id="想着一定要写好"><a href="#想着一定要写好" class="headerlink" title="想着一定要写好"></a>想着一定要写好</h2><p>当然保证质量是很重要的事情，但是也因此有的博客过于追求质量、又或者说把握不住详细到什么地步就难产了。</p><p>后来我在写第一篇读书笔记的时候写了一部分了，剩下的不知道怎么写，当我想到了我之前难产的博客以及如果再这么要求质量的话可能就完不成的时候我决定草草收尾。</p><p>对于一开始来说我觉得还是坚持写下去更加重要，尤其是在你觉得自己很不擅长这件事情的时候。之前看到一个人的推特写目标是坚持输出内容，前二十多期可以不追求质量，这也是同样的道理。一开始总是不熟练，那就放低要求，先以完成为目的。</p><h1 id="写博客的误区"><a href="#写博客的误区" class="headerlink" title="写博客的误区"></a>写博客的误区</h1><p>除了我上面提到的问题，《暗时间》这本书中还提到了一些写博客的误区，我也在这里提及一下，加入了一些我自己的想法，有兴趣的读者可以去看原书</p><h2 id="担心自己的内容"><a href="#担心自己的内容" class="headerlink" title="担心自己的内容"></a>担心自己的内容</h2><p>如果担心自己写的东西别人都已经写过了，我认为不需要去关心这些。这里要注意一个非常关键的点：<strong>写博客是为了更好的学习与思考，</strong>而不是说一定要去写什么别人没写过的东西。这不是毕业论文，不需要担心这些问题，你在成文的过程中的思考有所收获就够了。</p><p>如果担心内容质量不佳，那就像上面说的想着一定要写好一样，不再赘述。如果担心想法有漏洞，那更不必担心，这个漏洞不会因为你不写出来而消失，写出来被别人指正反而是更好的改进方式。</p><h2 id="关注反馈"><a href="#关注反馈" class="headerlink" title="关注反馈"></a>关注反馈</h2><p>上面也提到了写博客的目的，对于外部的反馈以及其他博客的好处来说这不过是附赠品，同时如果是为了外部反馈而写，那么很可能做出偏离学习与思考这一本意的行为。</p><p>暗时间中有这样一句话</p><blockquote><p>只做你最感兴趣的事情，钱会随之而来</p></blockquote><p>这个例子是类似的，牢记初心，专注于你当前真正要做的事情，其他的附属品都会随之而来。</p><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p>阅读博客的人更希望得到信息而非噪音。每个人都会有想法牢骚的冲动，但是这应该是在其他一些适合发牢骚的平台，比如说Twitter。</p><p>我在之前也非常容易碎碎念，看到这条以后我下定决心以后其他输出内容的地方都不会掺杂各种碎碎念，还请读者们监督。</p><h1 id="亲自动手写了博客才发现的事情"><a href="#亲自动手写了博客才发现的事情" class="headerlink" title="亲自动手写了博客才发现的事情"></a>亲自动手写了博客才发现的事情</h1><p>最大的感悟是输出内容真的是不容易。完成一篇内容充足的博客需要很久，同时又要保证质量的话是非常难的事情。</p><p>看别人写和自己写完全是两回事。经常看别人在知乎上写了那么长一大段的干货，真到自己写的时候发现是多么困难。（这里我不禁好奇他们是怎么有时间能写那么多那么长的回答？）</p><p>由于这些感受，我对持续输出内容的人逐渐开始有了更多的尊敬，因为输出内容确实是一件比较辛苦的事情。尽管有的时候输出内容也很开心，但是最终能够持续输出的还是少数。</p><h1 id="我与博客"><a href="#我与博客" class="headerlink" title="我与博客"></a>我与博客</h1><p>虽然我第一次接触博客的时候没有做下去，但庆幸的是现在我已经逐渐形成了这个习惯。即便去掉开发周记也还剩下许多其他博客，看到这些我感到十分欣慰。我会持续的输出内容，并且在保证不影响写完的前提下提升质量。</p><p>文章的最后我想引用一句《暗时间》中的话</p><blockquote><p>人太容易为各种各样的事情分心，要集中注意力做一件事情是非常难的，而正因为难，少有人做到，那些做到的，就都变成了牛。</p></blockquote><p>只有坚持做下去才能做到，而实际上博客所带来的基本上都是好处，为什么不坚持做下去呢？</p><p>不过能不能变成牛这不重要，只要坚持学习、思考与行动，最终总会变成大牛。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/IandBlog/Untit</summary>
      
    
    
    
    <category term="Thinking" scheme="https://fusionbolt.github.io/categories/Thinking/"/>
    
    
    <category term="Blog" scheme="https://fusionbolt.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记18 简单类型推导</title>
    <link href="https://fusionbolt.github.io/2022/05/08/rc-lang-dev-18/"/>
    <id>https://fusionbolt.github.io/2022/05/08/rc-lang-dev-18/</id>
    <published>2022-05-08T03:17:10.000Z</published>
    <updated>2022-05-08T03:29:24.275Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-18/timg.jpg"                      alt="timg.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">不要小看我，这种程度我也可以做得出！非pixiv</center> <p>本周主要都在了解MIR相关，但是还存有非常多的问题，因此先来讲一下之前写的TypeInfer的内容</p><p>我将Infer的过程分为了两部分。第一部分是最纯粹的类型推导，第二部分是实际将ast转换为带有类型信息的ast。</p><h1 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h1><p>目前先这样做了一个非常简易的样子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Type</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Boolean</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">String</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Int32</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Float</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Nil</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Fn</span>(ret: <span class="type">Type</span>, params: <span class="type">List</span>[<span class="type">Type</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Infer</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Err</span>(msg: <span class="type">String</span>)</span><br></pre></td></tr></table></figure><h1 id="Typed"><a href="#Typed" class="headerlink" title="Typed"></a>Typed</h1><p>对于类型相关的操作来讲，首先本身是有类型的才能进行infer，因此有了这样一个trait</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Typed</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ty:<span class="type">Type</span> = <span class="type">Type</span>.<span class="type">Infer</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withTy</span></span>(ty: <span class="type">Type</span>): <span class="keyword">this</span>.<span class="keyword">type</span> = &#123;</span><br><span class="line">    <span class="keyword">this</span>.ty = ty</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withInfer</span></span>: <span class="keyword">this</span>.<span class="keyword">type</span> = withTy(infer)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>: <span class="type">Type</span> = <span class="type">Infer</span>(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里默认的是Type.Infer，表示需要Infer才行</p><p>infer的过程则是调用了case object Infer（单例对象），后面会讲到</p><p>用的时候直接mixin这个trait即可</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">ASTNode</span> <span class="keyword">with</span> <span class="type">Typed</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(ident: <span class="type">Ident</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Item</span> <span class="keyword">extends</span> <span class="type">ASTNode</span> <span class="keyword">with</span> <span class="type">Typed</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Method</span>(decl: <span class="type">MethodDecl</span>, body: <span class="type">Block</span>) <span class="keyword">extends</span> <span class="type">Item</span> <span class="keyword">with</span> <span class="type">Typed</span></span><br></pre></td></tr></table></figure><h1 id="TyCtxt"><a href="#TyCtxt" class="headerlink" title="TyCtxt"></a>TyCtxt</h1><p>ctxt的部分主要存放一个全局符号表，以及一个局部符号表（这里的符号表只包含了类型信息）</p><p>而局部符号表又分为了当前scope以及outer的两部分。</p><p>接口也很简单，简单的添加与查找，以及进入一个新的scope</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TyCtxt</span>(<span class="params">val global:<span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>] = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>](</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> outer = <span class="type">List</span>[<span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]]()</span><br><span class="line">  <span class="keyword">var</span> local = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(ident: <span class="type">Ident</span>): <span class="type">Option</span>[<span class="type">Type</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> ty = local.get(ident) orElse outer.find(_.contains(ident)) orElse global.get(ident)</span><br><span class="line">    ty.asInstanceOf[<span class="type">Option</span>[<span class="type">Type</span>]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    outer ::= local</span><br><span class="line">    local = <span class="type">Map</span>[<span class="type">Ident</span>, <span class="type">Type</span>]()</span><br><span class="line">    <span class="keyword">val</span> result = f</span><br><span class="line">    local = outer.head</span><br><span class="line">    outer = outer.tail</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">addLocal</span></span>(k: <span class="type">Ident</span>, v: <span class="type">Type</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    local += (k -&gt; v)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于enter的参数需要讲一下，既不是一个f: T，也不是一个f: () ⇒ T。</p><p>使用f: ⇒ T的写法可以推迟实际传进来的求值过程。既可以接受一个简单的T，也可以接受一个函数计算结果的T，同样也可以接受一个() ⇒ T</p><p>看一个测试就明白了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&quot;nested&quot;</span>) &#123;</span><br><span class="line">  tyCtxt.enter(() =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> id = <span class="type">Ident</span>(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> ty = <span class="type">Nil</span></span><br><span class="line">    tyCtxt.addLocal(id, ty)</span><br><span class="line">    tyCtxt.enter(testEnter(id))</span><br><span class="line">    assert(tyCtxt.enter(id) == <span class="type">String</span>)</span><br><span class="line">    assert(tyCtxt.lookup(id).contains(ty))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testEnter</span></span>(id: <span class="type">Ident</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">assert(tyCtxt.local.isEmpty)</span><br><span class="line">  <span class="keyword">val</span> innerTy = <span class="type">String</span></span><br><span class="line">  tyCtxt.addLocal(id, innerTy)</span><br><span class="line">  assert(tyCtxt.lookup(id).contains(innerTy))</span><br><span class="line">  innerTy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的enter存在两种写法。</p><p>在进入testEnter之前添加了local，进入之后local变成了空的，也就是说进入了一个新的scope。</p><p>最初是觉得每次tyCtxt.enter(() ⇒ f())都要写() ⇒ 感到非常麻烦，后来发现了这样的写法</p><h1 id="Infer"><a href="#Infer" class="headerlink" title="Infer"></a>Infer</h1><p>成员变量只有一个tyCtxt</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">Infer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tyCtxt: <span class="type">TyCtxt</span> = <span class="type">TyCtxt</span>()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>infer的入口处</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(typed: <span class="type">Typed</span>, force: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  infer(typed, force)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(typed: <span class="type">Typed</span>, force: <span class="type">Boolean</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span>(!force &amp;&amp; typed.ty != <span class="type">Type</span>.<span class="type">Infer</span>) &#123;</span><br><span class="line">    typed.ty</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    infer(typed)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(typed: <span class="type">Typed</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  typed <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> expr: <span class="type">Expr</span> =&gt; infer(expr)</span><br><span class="line">    <span class="keyword">case</span> item: <span class="type">Item</span> =&gt; infer(item)</span><br><span class="line">    <span class="keyword">case</span> method: <span class="type">Item</span>.<span class="type">Method</span> =&gt; infer(method)</span><br><span class="line">    <span class="keyword">case</span> stmt: <span class="type">Stmt</span> =&gt; infer(stmt)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>force也很好理解，不是force的情况下原来有type则直接返回，而不是进行推导</p><h2 id="Expr-infer"><a href="#Expr-infer" class="headerlink" title="Expr infer"></a>Expr infer</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">infer</span></span>(expr: <span class="type">Expr</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  expr <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Number</span>(v) =&gt; <span class="type">Int32</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Identifier</span>(ident) =&gt; lookup(ident)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Bool</span>(b) =&gt; <span class="type">Boolean</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Binary</span>(op, lhs, rhs) =&gt; common(lhs, rhs)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Str</span>(str) =&gt; <span class="type">String</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">If</span>(cond, true_branch, false_branch) =&gt; false_branch <span class="keyword">match</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(fBr) =&gt; common(true_branch, fBr)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; infer(true_branch)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Return</span>(expr) =&gt; infer(expr)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Block</span>(stmts) =&gt; tyCtxt.enter(infer(stmts.last))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Call</span>(target, args) =&gt; lookup(target)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Infer的部分主要还是在于表达式的类型推导，实际上也很直观。有的种类表达式自身类型是确定了，需要考虑id的就去lookup，像if和binary这种通过common来获取。</p><h2 id="lookup"><a href="#lookup" class="headerlink" title="lookup"></a>lookup</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">lookup</span></span>(ident: <span class="type">Ident</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  tyCtxt.lookup(ident).getOrElse(<span class="type">Err</span>(<span class="string">s&quot;<span class="subst">$ident</span> not found&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的在ctxt中查找符号的信息</p><h2 id="common"><a href="#common" class="headerlink" title="common"></a>common</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">common</span></span>(lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>): <span class="type">Type</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> lt = infer(lhs)</span><br><span class="line">  <span class="keyword">val</span> rt = infer(rhs)</span><br><span class="line">  <span class="keyword">if</span> lt == rt then lt <span class="keyword">else</span> <span class="type">Err</span>(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我还抱有一些疑问，在这里产生一个TypeErr是否合适，但是如果lhs和rhs的类型是不兼容的情况那也无法得出一个正确的Type</p><p>虽然名字叫common，然而这里做的非常简单，只是简单判别类型是否相同而没有考虑到type compatible</p><h2 id="enter"><a href="#enter" class="headerlink" title="enter"></a>enter</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](tyCtxt: <span class="type">TyCtxt</span>, f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  <span class="keyword">this</span>.tyCtxt = tyCtxt</span><br><span class="line">  tyCtxt.enter(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f: =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">  tyCtxt.enter(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了普通的enter，还支持通过指定一个typeCtxt来推导</p><h1 id="Translator"><a href="#Translator" class="headerlink" title="Translator"></a>Translator</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">TypedTranslator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tyCtxt: <span class="type">TyCtxt</span> = <span class="type">TyCtxt</span>()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(tyCtxt: <span class="type">TyCtxt</span>)(module: <span class="type">RcModule</span>): <span class="type">RcModule</span> = &#123;</span><br><span class="line">    <span class="comment">// update local table in TypedTranslator will cause Infer ctxt update</span></span><br><span class="line">    <span class="comment">// because of pass a typCtxt by Ref</span></span><br><span class="line">    <span class="type">Infer</span>.enter(tyCtxt, <span class="type">RcModuleTrans</span>(module))</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传递一个ctxt的引用给Infer，之后在translator里面通过tyCtxt更新各种local信息，这样Infer只做infer就可以了，不需要关心其他的事情。翻译的最小单元则是一个Module</p><p>translator主要的想法就是通过infer获取类型，之后返回一个保存有意义的类型信息的ASTNode</p><h2 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exprTrans</span></span>(expr: <span class="type">Expr</span>): <span class="type">Expr</span> =</span><br><span class="line">(expr <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Binary</span>(op, lhs, rhs) =&gt; <span class="type">Binary</span>(op, lhs.withInfer, rhs.withInfer)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">If</span>(cond, true_branch, false_branch) =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> false_br = false_branch <span class="keyword">match</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(fBr) =&gt; <span class="type">Some</span>(fBr.withInfer)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">None</span></span><br><span class="line">      <span class="type">If</span>(cond.withInfer,</span><br><span class="line">        true_branch.withInfer.asInstanceOf[<span class="type">Block</span>],</span><br><span class="line">        false_br)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Call</span>(target, args) =&gt; <span class="type">Call</span>(target, args.map(_.withInfer))</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Return</span>(expr) =&gt; <span class="type">Return</span>(expr.withInfer)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Block</span>(stmts) =&gt; tyCtxt.enter(<span class="type">Block</span>(stmts.map(stmtTrans)))</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; expr).withInfer</span><br></pre></td></tr></table></figure><p>可以看到就是简单的将参数withInfer，之后重新构建起这个表达式，并且将这个表达式整体进行infer。</p><p>为了避免一个个调用withInfer，因此在最后将expr的结果统一调用withInfer</p><p>对于Stmt的部分本质做法是差不多的，就不再赘述了</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>下周开始会开始专注于适合优化层面IR的内容了。最早我给自己规定的每天写一部分功能，不过我后来已经将写与学习成为了习惯，因此不会再局限于每天写这种事情。现在更多的是了解各种不同的做法，分析不同做法之间的差异（了解这些的过程有些上瘾，一不小心就会陷进去）。也因此下周开始的内容可能写的篇幅会少一些，会多一些对比分析</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-18</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Type" scheme="https://fusionbolt.github.io/tags/Type/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记17 一点AST检查</title>
    <link href="https://fusionbolt.github.io/2022/05/01/rc-lang-dev-17/"/>
    <id>https://fusionbolt.github.io/2022/05/01/rc-lang-dev-17/</id>
    <published>2022-05-01T02:37:41.000Z</published>
    <updated>2022-05-01T02:39:16.944Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-17/69589494_p0.png"                      alt="69589494_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">聪明如我怎么会写出ast有错误的代码 pixiv:69589494</center> <p>先说一声五一快乐！久违的长假，之后会花一些时间把其他一些写到一半的博客整理出来</p><p>本来想要好好做一下检查相关以及类型推导的工作，但是目前来说我更需要先学习优化方面的知识，因此关于ast的检查以及类型推导和类型检查做的比较简易，过后有时间再回来做。本周虽然做了部分类型推导和类型检查，但是只做了一半，剩下的部分可能要下周再说了。下周大概就能做完简单的类型推导和检查</p><h1 id="AST检查"><a href="#AST检查" class="headerlink" title="AST检查"></a>AST检查</h1><p>目前所实现的检查无外乎这么几类</p><ol><li>名称冲突</li><li>未定义符号</li><li>变量的声明类型或者初始值必须有一个存在</li></ol><p>我挑出一些经典的部分讲解，不过多赘述重复的部分了</p><p>实际上能做的类型无关的检查还有非常多</p><h1 id="名称冲突"><a href="#名称冲突" class="headerlink" title="名称冲突"></a>名称冲突</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dupNameCheck</span></span>(names: <span class="type">List</span>[<span class="type">Ident</span>]): <span class="type">Result</span> = &#123;</span><br><span class="line">  dupCheck(names, <span class="string">&quot;Name&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dupCheck</span></span>[<span class="type">T</span> &lt;: <span class="type">ASTNode</span>](values: <span class="type">List</span>[<span class="type">T</span>], valueName: <span class="type">String</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> s = <span class="type">Set</span>[<span class="type">T</span>]()</span><br><span class="line">  values.filterNot(s.add).map(n =&gt; <span class="type">ValidateError</span>(n, <span class="string">s&quot;<span class="subst">$valueName</span> <span class="subst">$n</span> Dup&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkModule</span></span>(module: <span class="type">RcModule</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  dupNameCheck(module.items.map(item =&gt; item <span class="keyword">match</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Item</span>.<span class="type">Class</span>(name, _, _, _) =&gt; name</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Item</span>.<span class="type">Method</span>(decl, _) =&gt; decl.name</span><br><span class="line">  )):::module.items.flatMap(checkItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说Module的检查中对所有item的名字检查是否存在冲突，并且再check每个Item本身</p><p>关于返回值的Result只是一个type alias</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span> </span>= <span class="type">List</span>[<span class="type">ValidateError</span>]</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateError</span>(<span class="params">node: <span class="type">ASTNode</span>, reason: <span class="type">String</span></span>)</span></span><br></pre></td></tr></table></figure><p>这里还有很多待改进的空间，比如说将实际的错误分类，或者写一个diagnosis类来管理这些错误信息等等</p><p>这里使用一个type alias也是为了后面修改时候方便</p><p>这里可以看到所有的错误信息都是组合之后返回，原因是我想将代码中的副作用范围缩到最小，这样能够保证调用的结果尽可能的不受外部状态影响</p><h1 id="未定义的符号"><a href="#未定义的符号" class="headerlink" title="未定义的符号"></a>未定义的符号</h1><p>目前只做了一些简单的处理。这里还没有处理全局的符号（比如说函数和类）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Scope</span>(<span class="params">var localTable: <span class="type">Set</span>[<span class="type">Ident</span>] = <span class="type">Set</span>(</span>)) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    localTable.add(ident)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    localTable.contains(ident)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ScopeManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> scopes = <span class="type">List</span>[<span class="type">Scope</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](f:() =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    enter(<span class="type">Params</span>(<span class="type">List</span>()), f)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">enter</span></span>[<span class="type">T</span>](params: <span class="type">Params</span>, f:() =&gt; <span class="type">T</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> oldScope = scopes</span><br><span class="line">    scopes ::= <span class="type">Scope</span>(mutable.<span class="type">Set</span>.from(params.params.map(_.name)))</span><br><span class="line">    <span class="keyword">val</span> result = f()</span><br><span class="line">    scopes = oldScope</span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">curScope</span></span>: <span class="type">Scope</span> = scopes.last</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = curScope.add(ident)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    !scopes.exists(_.contains(ident))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">curContains</span></span>(ident: <span class="type">Ident</span>): <span class="type">Boolean</span> = curScope.contains(ident)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个Scope有自己的table，每次通过enter进入一个table则将当前的放到List中</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkBlock</span></span>(block: <span class="type">Block</span>, params: <span class="type">Params</span> = <span class="type">Params</span>(<span class="type">List</span>())): <span class="type">Result</span> = &#123;</span><br><span class="line">  scopes.enter(params, () =&gt; &#123;</span><br><span class="line">    block.stmts.flatMap(checkStmt)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkMethod</span></span>(method: <span class="type">Method</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  checkMethodDecl(method.decl)</span><br><span class="line">  checkBlock(method.body, method.decl.inputs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次进入一个Block的时候则进入了一个新的scope，比如说一个Method的body的expr</p><p>对于Id表达式则会去检查是否存在这个符号，</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">Expr</span>.<span class="type">Identifier</span>(id) =&gt; checkCond(scopes.contains(id), expr, <span class="string">&quot;$name not decl&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="初始值与类型二选一"><a href="#初始值与类型二选一" class="headerlink" title="初始值与类型二选一"></a>初始值与类型二选一</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fieldDefValid</span></span>(fieldDef: <span class="type">FieldDef</span>): <span class="type">Result</span> = &#123;</span><br><span class="line">  fieldDef.initValue <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">Some</span>(expr) =&gt; checkExpr(expr)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">None</span> =&gt; checkCond(fieldDef.ty != <span class="type">TyInfo</span>.<span class="type">Infer</span>, fieldDef, <span class="string">&quot;Field without initValue need spec Type&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于类的field做了这样的检查，存在initValue则去检查expr，否则检查ty是否为需要Infer的。如果没有initValue也没有ty信息，那我们无法在后面类型推导的时候得出类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-17</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="AST" scheme="https://fusionbolt.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记16 Rust源码学习之初识类型</title>
    <link href="https://fusionbolt.github.io/2022/04/26/rc-lang-dev-16/"/>
    <id>https://fusionbolt.github.io/2022/04/26/rc-lang-dev-16/</id>
    <published>2022-04-25T16:19:02.000Z</published>
    <updated>2022-04-26T16:10:52.233Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-16/74795024_p0.jpg"                      alt="74795024_p0.jpg"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">类型和猫咪先生有多少相似之处呢 pixiv:74795024</center> <p>本周先了解了一些Rust Type相关的代码，之后开始写一些类型无关的语法检查。</p><p>虽然上周看了Rust中desugar的代码，但我这里就先不做desugar了，现在东西比较少，没什么价值。由于语法检查还没写多少，xs因此留到下周讲解。本周还是讲一下我看Rust Type相关的信息的一些了解，其中大部分信息是文档中介绍的，在这里算是一个简单概括。</p><p><a class="link"   href="https://rustc-dev-guide.rust-lang.org/ty.html" >https://rustc-dev-guide.rust-lang.org/ty.html<i class="fas fa-external-link-alt"></i></a></p><h1 id="不同的类型表示"><a href="#不同的类型表示" class="headerlink" title="不同的类型表示"></a>不同的类型表示</h1><p>在Rust中，目前我看到的部分有这么“几种”类型</p><ol><li>ast::Ty</li><li>hir::Ty(rustc_hir::Ty)</li><li>ty::Ty</li></ol><p>关于ast::Ty到hir::Ty本质上是进行了desugar，所代表的Ty本质是没有变化的。至于为什么这么说，这就要谈及hir::Ty和ty::Ty的区别</p><h1 id="hir-Ty-vs-ty-Ty"><a href="#hir-Ty-vs-ty-Ty" class="headerlink" title="hir::Ty vs ty::Ty"></a>hir::Ty vs ty::Ty</h1><p>先来讲我认为最根本的区别。</p><p>hir::Ty所表示的是在源码中出现的一个应当出现在需要类型位置的类型，换句话说它是关联到源码的Ty</p><p>而ty::Ty则是编译器中对中间表示（这里是hir）分析过后产生的一种类型，包含了更切实的语义，换句话说是关联到编译器内部类型表示的Ty</p><p>我来引用一下官方文档中出现的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(x: <span class="built_in">u32</span>) → <span class="built_in">u32</span> &#123; x &#125;</span><br></pre></td></tr></table></figure><p>在这段代码中出现了两个u32，很显然这段代码的上下文中这两个u32都是同一个类型（注意不同lifetime的type是不同类型的）</p><p>每个u32本质上是关联到源码中某个位置的u32，比如说第一个关联的是源码第一行第10个字符开始的u32，而第二个则是关联到源码后面那个位置的u32。在没有type infer和type check之前我们并不知道是否关联相同的语义</p><p>而对于最终的type infer以及type check之后在这个语义环境下这两个u32会被视为同一个类型，最终这两个u32会被转换为相同的ty::Ty</p><p>文档中有这样一句</p><blockquote><p>they have two different <code>[Span</code>s](<a class="link"   href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html" >https://doc.rust-lang.org/nightly/nightly-rustc/rustc_span/struct.Span.html<i class="fas fa-external-link-alt"></i></a>) (locations).</p></blockquote><p>之后我们来看一下官方文档中的总结表格，一切描述都是围绕着同一个核心区别</p><table><thead><tr><th>rustc_hir::Ty</th><th>ty::Ty</th></tr></thead><tbody><tr><td>Describe the syntax of a type: what the user wrote (with some desugaring).</td><td>Describe the semantics of a type: the meaning of what the user wrote.</td></tr><tr><td>Each rustc_hir::Ty has its own spans corresponding to the appropriate place in the program.</td><td>Doesn’t correspond to a single place in the user’s program.</td></tr><tr><td>rustc_hir::Ty has generics and lifetimes; however, some of those lifetimes are special markers like LifetimeName::Implicit.</td><td>ty::Ty has the full type, including generics and lifetimes, even if the user left them out</td></tr><tr><td>fn foo(x: u32) → u32 { } - Two rustc_hir::Ty representing each usage of u32. Each has its own Spans, etc.- rustc_hir::Ty doesn’t tell us that both are the same type</td><td>fn foo(x: u32) → u32 { } - One ty::Ty for all instances of u32throughout the program.- ty::Ty tells us that both usages of u32 mean the same type.</td></tr><tr><td>fn foo(x: &amp;u32) -&gt; &amp;u32)- Two rustc_hir::Ty again.- Lifetimes for the references show up in the rustc_hir::Tys using a special marker, LifetimeName::Implicit.</td><td>fn foo(x: &amp;u32) -&gt; &amp;u32)- A single ty::Ty.- The ty::Ty has the hidden lifetime param</td></tr></tbody></table><p>要注意一个我刚才没有详细提及的点，那就是lifetime。由于经常会省略编写lifetime因此对于hir来说很可能不会包含其信息，这样的信息都是会转成hir之后再隐式插入的</p><h1 id="类型之间转换流程"><a href="#类型之间转换流程" class="headerlink" title="类型之间转换流程"></a>类型之间转换流程</h1><p>根据文档所说，在ast转换为HIR的时候会做一些基本的type infer以及type check。在type infer的过程中会产生ty::Ty并实际进行检查</p><p>发生转换的入口则是在ast_ty_to_ty这里，而这个函数则是在AstConv这个trait中</p><p>先来简单看一下十分直观的函数签名，传入一个hir::Ty返回一个ty::Ty</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Parses the programmer&#x27;s textual representation of a type into our</span></span><br><span class="line"><span class="comment">/// internal notion of a type.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">ast_ty_to_ty</span></span>(&amp;<span class="keyword">self</span>, ast_ty: &amp;hir::Ty&lt;<span class="symbol">&#x27;_</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.ast_ty_to_ty_inner(ast_ty, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ast-ty-to-ty-inner"><a href="#ast-ty-to-ty-inner" class="headerlink" title="ast_ty_to_ty_inner"></a>ast_ty_to_ty_inner</h1><h2 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h2><p>这个函数依然属于AstConv</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ast_ty_to_ty_inner</span></span>(&amp;<span class="keyword">self</span>, ast_ty: &amp;hir::Ty&lt;<span class="symbol">&#x27;_</span>&gt;, borrowed: <span class="built_in">bool</span>, in_path: <span class="built_in">bool</span>) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> tcx = <span class="keyword">self</span>.tcx();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result_ty = <span class="keyword">match</span> ast_ty.kind &#123; ... &#125;</span><br><span class="line">debug!(?result_ty);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.record_ty(ast_ty.hir_id, result_ty, ast_ty.span);</span><br><span class="line">  result_ty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先忽略转换的细节，看一下整体做了什么</p><ol><li>获取TyCtxt</li><li>实际转换</li><li>记录类型</li></ol><h2 id="tcx和record"><a href="#tcx和record" class="headerlink" title="tcx和record"></a>tcx和record</h2><p>self.tcx和self.record都是AstConv本身未实现的方法</p><p>再来看一下一个实现了AstConv的部分实现（以下涉及AstConv未实现的部分都会以FnCtxt的实现作为参考）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;tcx</span>&gt; AstConv&lt;<span class="symbol">&#x27;tcx</span>&gt; <span class="keyword">for</span> FnCtxt&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">tcx</span></span>&lt;<span class="symbol">&#x27;b</span>&gt;(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">self</span>) -&gt; TyCtxt&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.tcx</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">record_ty</span></span>(&amp;<span class="keyword">self</span>, hir_id: hir::HirId, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;, _span: Span) &#123;</span><br><span class="line">    <span class="keyword">self</span>.write_ty(hir_id, ty)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> FnCtxt &#123;</span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">write_ty</span></span>(&amp;<span class="keyword">self</span>, id: hir::HirId, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;) &#123;</span><br><span class="line">    debug!(<span class="string">&quot;write_ty(&#123;:?&#125;, &#123;:?&#125;) in fcx &#123;&#125;&quot;</span>, id, <span class="keyword">self</span>.resolve_vars_if_possible(ty), <span class="keyword">self</span>.tag());</span><br><span class="line">    <span class="keyword">self</span>.typeck_results.borrow_mut().node_types_mut().insert(id, ty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ty.references_error() &#123;</span><br><span class="line">        <span class="keyword">self</span>.has_errors.set(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">self</span>.set_tainted_by_errors();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcx没什么可说的，大多数都是这样简单的返回</p><p>record_ty中将一个hir的id与它的Ty进行关联，而这个hir的id则是hir::Ty的id。如果只看FnCtxt的record_ty的本身很容易以为一定是其他有类型的东西（比如expr或者Fn）的id关联到一个类型，但是往上看调用处没想到还会将一个hir::Ty指向ty::Ty</p><h2 id="ast-ty-to-ty"><a href="#ast-ty-to-ty" class="headerlink" title="ast_ty to ty"></a>ast_ty to ty</h2><p>内容比较多，这里选择几个讲一下</p><p>先来看一下里面是什么样子的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result_ty = <span class="keyword">match</span> ast_ty.kind &#123;</span><br><span class="line">    hir::TyKind::Slice(<span class="keyword">ref</span> ty) =&gt; tcx.mk_slice(<span class="keyword">self</span>.ast_ty_to_ty(ty)),</span><br><span class="line">    hir::TyKind::Ptr(<span class="keyword">ref</span> mt) =&gt; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据ast_ty的不同kind做不同处理（下面只选取某一个kind的处理方式讲解）</p><h3 id="infer"><a href="#infer" class="headerlink" title="infer"></a>infer</h3><p>先来看一下infer</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">hir::TyKind::Infer =&gt; &#123;</span><br><span class="line">    <span class="comment">// Infer also appears as the type of arguments or return</span></span><br><span class="line">    <span class="comment">// values in an ExprKind::Closure, or as</span></span><br><span class="line">    <span class="comment">// the type of local variables. Both of these cases are</span></span><br><span class="line">    <span class="comment">// handled specially and will not descend into this routine.</span></span><br><span class="line">    <span class="keyword">self</span>.ty_infer(<span class="literal">None</span>, ast_ty.span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl AstConv for FnCtxt</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ty_infer</span></span>(&amp;<span class="keyword">self</span>, param: <span class="built_in">Option</span>&lt;&amp;ty::GenericParamDef&gt;, span: Span) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(param) = param &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> GenericArgKind::Type(ty) = <span class="keyword">self</span>.var_for_def(span, param).unpack() &#123;</span><br><span class="line">            <span class="keyword">return</span> ty;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unreachable!</span>()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.next_ty_var(TypeVariableOrigin &#123;</span><br><span class="line">            kind: TypeVariableOriginKind::TypeInference,</span><br><span class="line">            span,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Impl inferCtxt</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">next_ty_var</span></span>(&amp;<span class="keyword">self</span>, origin: TypeVariableOrigin) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.tcx.mk_ty_var(<span class="keyword">self</span>.next_ty_var_id(origin))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty_var</span></span>(<span class="keyword">self</span>, v: TyVid) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty_infer(TyVar(v))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty_infer</span></span>(<span class="keyword">self</span>, it: InferTy) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(Infer(it))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ty</span></span>(<span class="keyword">self</span>, st: TyKind&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.interners.intern_ty(st, <span class="keyword">self</span>.sess, &amp;<span class="keyword">self</span>.gcx.untracked_resolutions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套娃比较多，不过内容也比较直观。关于intern_ty下一部分再仔细讲一下，先来看一下其他的例子</p><p>注意一点，这里infer产生的代码是unchecked的，上面也提到过</p><blockquote><p>在type infer的过程中会产生ty::Ty并实际进行检查</p></blockquote><h3 id="一些其他的"><a href="#一些其他的" class="headerlink" title="一些其他的"></a>一些其他的</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">hir::TyKind::Tup(fields) =&gt; tcx.mk_tup(fields.iter().map(|t| <span class="keyword">self</span>.ast_ty_to_ty(t))),</span><br><span class="line">hir::TyKind::Slice(<span class="keyword">ref</span> ty) =&gt; tcx.mk_slice(<span class="keyword">self</span>.ast_ty_to_ty(ty)),</span><br><span class="line">hir::TyKind::Ptr(<span class="keyword">ref</span> mt) =&gt; &#123;</span><br><span class="line">    tcx.mk_ptr(ty::TypeAndMut &#123; ty: <span class="keyword">self</span>.ast_ty_to_ty(mt.ty), mutbl: mt.mutbl &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_tup</span></span>&lt;I: InternAs&lt;[Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;], Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;&gt;&gt;(<span class="keyword">self</span>, iter: I) -&gt; I::Output &#123;</span><br><span class="line">    iter.intern_with(|ts| <span class="keyword">self</span>.mk_ty(Tuple(<span class="keyword">self</span>.intern_type_list(&amp;ts))))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_slice</span></span>(<span class="keyword">self</span>, ty: Ty&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(Slice(ty))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mk_ptr</span></span>(<span class="keyword">self</span>, tm: TypeAndMut&lt;<span class="symbol">&#x27;tcx</span>&gt;) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.mk_ty(RawPtr(tm))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来都比较直观，而每一个mk_xxx本质上都是直接或者间接调用了mk_ty，再进入intern_ty做处理</p><h1 id="InternTy"><a href="#InternTy" class="headerlink" title="InternTy"></a>InternTy</h1><p>实现代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Interns a type.</span></span><br><span class="line"><span class="meta">#[allow(rustc::usage_of_ty_tykind)]</span></span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">intern_ty</span></span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    kind: TyKind&lt;<span class="symbol">&#x27;tcx</span>&gt;,</span><br><span class="line">    sess: &amp;Session,</span><br><span class="line">    resolutions: &amp;ty::ResolverOutputs,</span><br><span class="line">) -&gt; Ty&lt;<span class="symbol">&#x27;tcx</span>&gt; &#123;</span><br><span class="line">  Ty(Interned::new_unchecked(</span><br><span class="line">    <span class="keyword">self</span>.type_</span><br><span class="line">      .intern(kind, |kind| &#123;</span><br><span class="line">        <span class="keyword">let</span> flags = super::flags::FlagComputation::for_kind(&amp;kind);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// It&#x27;s impossible to hash inference regions (and will ICE), so we don&#x27;t need to try to cache them.</span></span><br><span class="line">        <span class="comment">// Without incremental, we rarely stable-hash types, so let&#x27;s not do it proactively.</span></span><br><span class="line">        <span class="keyword">let</span> stable_hash = <span class="keyword">if</span> flags.flags.intersects(TypeFlags::HAS_RE_INFER)</span><br><span class="line">            || sess.opts.incremental.is_none()</span><br><span class="line">        &#123;</span><br><span class="line">            Fingerprint::ZERO</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> hasher = StableHasher::new();</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> hcx = StableHashingContext::ignore_spans(</span><br><span class="line">                sess,</span><br><span class="line">                &amp;resolutions.definitions,</span><br><span class="line">                &amp;*resolutions.cstore,</span><br><span class="line">            );</span><br><span class="line">            kind.hash_stable(&amp;<span class="keyword">mut</span> hcx, &amp;<span class="keyword">mut</span> hasher);</span><br><span class="line">            hasher.finish()</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ty_struct = TyS &#123;</span><br><span class="line">            kind,</span><br><span class="line">            flags: flags.flags,</span><br><span class="line">            outer_exclusive_binder: flags.outer_exclusive_binder,</span><br><span class="line">            stable_hash,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        InternedInSet(<span class="keyword">self</span>.arena.alloc(ty_struct))</span><br><span class="line">      &#125;)</span><br><span class="line">      .<span class="number">0</span>,</span><br><span class="line">  ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看起来大多是关于存储的细节，我也没有再过于深究了，但是要注意Ty的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Use this rather than `TyS`, whenever possible.</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]</span></span><br><span class="line"><span class="meta">#[rustc_diagnostic_item = <span class="meta-string">&quot;Ty&quot;</span>]</span></span><br><span class="line"><span class="meta">#[rustc_pass_by_value]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Ty</span></span>&lt;<span class="symbol">&#x27;tcx</span>&gt;(Interned&lt;<span class="symbol">&#x27;tcx</span>, TyS&lt;<span class="symbol">&#x27;tcx</span>&gt;&gt;);</span><br></pre></td></tr></table></figure><p>注意Ty这里保存了一个Interned，这个函数名本身也是intern_ty，那么这是代表了什么呢</p><p>我们看一下Interned的注释</p><blockquote><p>A reference to a value that is interned, and is known to be unique.<br>Note that it is possible to have a T and a Interned<T> that are (or refer to) equal but different values. But if you have two different Interned<T>s, they both refer to the same value, at a single location in memory. This means that equality and hashing can be done on the value’s address rather than the value’s contents, which can improve performance.<br>The PrivateZst field means you can pattern match with Interned(v, _) but you can only construct a Interned with new_unchecked, and not directly.</p></blockquote><p>Interned本质是指向实际unique的值的一个引用。</p><p>代码中可以看到将一个TyS传给了InternedInSet，而构建TyS的时候传入了一个stable_hash。关于这个stable_hash有着这样的注释</p><blockquote><p>The stable hash of the type. This way hashing of types will not have to work on the address of the type anymore, but can instead just read this field</p></blockquote><p>在上面提及hir::Ty和ty::Ty的时候说过相同的类型最后会转换为同一个ty::Ty，我想应该就是通过这些行为做到的。</p><p>要深入下去还有太多细节，而这些细节大多不是我目前关心的，所以就不深入了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-16</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="源码阅读" scheme="https://fusionbolt.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="Type" scheme="https://fusionbolt.github.io/tags/Type/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记15 Rust源码学习之desugar</title>
    <link href="https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/"/>
    <id>https://fusionbolt.github.io/2022/04/17/rc-lang-dev-15/</id>
    <published>2022-04-17T06:23:11.000Z</published>
    <updated>2022-06-19T07:13:12.358Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-15/68232005_p0.png"                      alt="68232005_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:68232005</center> <p>这周可以说几乎没写什么代码，都在学习别人的实现。在参考别人的做法之前自己写一版比较合适，这样会对整体有个了解（这样有利于阅读代码），知道哪些地方会有问题，看别人的代码后会发现哪里不一样并且去思考差异。不过我之前已经写过简易的实现了，因此直接来参考Rust的实现了</p><p>本周看的内容一半是desugar，另一半是关于MIR的。讲解的话目前先讲一下desugar的内容，内容相对较少能够一篇讲完。MIR的东西非常多，笔记也没有整理好，之后会单独开启一个源码阅读系列的坑</p><p>在讲之前首先要提的是<strong>为什么要学习他人的实现</strong>。尽管写出来能跑是没有问题的，但是参考这样的项目的过程中能学到他人写代码的方式，学到更多不一样的实现方式</p><h1 id="desugar"><a href="#desugar" class="headerlink" title="desugar"></a>desugar</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>我们现在在使用的编程语言中有一些语法糖，这些语法糖本质上是对一些功能的包装，让我们用的更方便，但是没有做到一些什么没有这个语法糖所做不到的东西。</p><p>这里举一个很直观的例子，ruby中有一个关键字是unless，它的功能是如果false则执行第一个分支，否则执行第二个分支，相当于if !cond</p><h2 id="为什么需要"><a href="#为什么需要" class="headerlink" title="为什么需要"></a>为什么需要</h2><p>上面也提到了只是包装，那么可能多种不同形式的语法糖都是针对同一种功能，像C语言中的while和for本质都是一个loop（Rust的for并不是，后面会提到这种for的desugar过程）</p><p>desugar的过程是将这些都转换为了更本质的东西，我觉得这属于一种“去重”的过程。还是上面的例子，假设需要对loop做优化，没有desugar的情况下我们需要对while和for两者都进行处理，两者又有轻微的差别，导致实现起来更不方便，每个优化都需要对这些细节做处理，那不如直接全部转换成一种形式来处理处理</p><p>关于Rust的文档中的介绍是这样</p><blockquote><p>This means many structures are removed if they are irrelevant for type analysis or similar syntax agnostic analyses.</p></blockquote><h1 id="Rust的实现"><a href="#Rust的实现" class="headerlink" title="Rust的实现"></a>Rust的实现</h1><p>官方的文档介绍</p><p><a class="link"   href="https://rustc-dev-guide.rust-lang.org/lowering.html" >https://rustc-dev-guide.rust-lang.org/lowering.html<i class="fas fa-external-link-alt"></i></a></p><p>在这里我要给Rust一个好评，开发文档比较详细，而且一些注释也相对容易懂一些。后面的很多东西都会以注释为参考讲了大概做了什么，注意这里<strong>我们的目的并不是搞清楚细节，而是搞清楚都做了什么操作，所以细节部分点到为止</strong>，细节深究下去是无底洞，有兴趣可以去源码处深入看一下</p><p>desugar相关代码不特别说明根目录都是rustc_ast_lowering</p><h2 id="读代码之前需要了解的"><a href="#读代码之前需要了解的" class="headerlink" title="读代码之前需要了解的"></a>读代码之前需要了解的</h2><p>了解了这些能够更容易看明白代码</p><ol><li>各种参数更多是使用ir来标识以及获取的</li><li>span用于记录源码相关信息</li><li>arean.alloc是用于分配构建ir的，看实现的时候不需要在意这里的细节，只需要看传进去的IR</li></ol><h2 id="DesugaringKind"><a href="#DesugaringKind" class="headerlink" title="DesugaringKind"></a>DesugaringKind</h2><p>这个类型在rustc_span/src/hygine.rs中</p><p>实际使用的时候主要用于创建span的时候填入相关信息，因此并没有放到ast_lowering的位置</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">DesugaringKind</span></span> &#123;</span><br><span class="line">    <span class="comment">/// We desugar `if c &#123; i &#125; else &#123; e &#125;` to `match $ExprKind::Use(c) &#123; true =&gt; i, _ =&gt; e &#125;`.</span></span><br><span class="line">    <span class="comment">/// However, we do not want to blame `c` for unreachability but rather say that `i`</span></span><br><span class="line">    <span class="comment">/// is unreachable. This desugaring kind allows us to avoid blaming `c`.</span></span><br><span class="line">    <span class="comment">/// This also applies to `while` loops.</span></span><br><span class="line">    CondTemporary,</span><br><span class="line">    QuestionMark,</span><br><span class="line">    TryBlock,</span><br><span class="line">    <span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line">    <span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line">    <span class="comment">/// `impl Trait` with `Foo`.</span></span><br><span class="line">    OpaqueTy,</span><br><span class="line">    Async,</span><br><span class="line">    Await,</span><br><span class="line">    ForLoop,</span><br><span class="line">    LetElse,</span><br><span class="line">    WhileLoop,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不考虑Async和Await，我们来一个个说其他的</p><h2 id="CondTemporary"><a href="#CondTemporary" class="headerlink" title="CondTemporary"></a>CondTemporary</h2><p>这部分都在src/expr.rs中</p><p>我们先来看一下它的调用位置，发现是在manage_let_cond这个函数中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If `cond` kind is `let`, returns `let`. Otherwise, wraps and returns `cond`</span></span><br><span class="line"><span class="comment">// in a temporary block.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">manage_let_cond</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, cond: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">has_let_expr</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt;(expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> expr.kind &#123;</span><br><span class="line">            hir::ExprKind::Binary(_, lhs, rhs) =&gt; has_let_expr(lhs) || has_let_expr(rhs),</span><br><span class="line">            hir::ExprKind::Let(..) =&gt; <span class="literal">true</span>,</span><br><span class="line">            _ =&gt; <span class="literal">false</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> has_let_expr(cond) &#123;</span><br><span class="line">        cond</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> reason = DesugaringKind::CondTemporary;</span><br><span class="line">        <span class="keyword">let</span> span_block = <span class="keyword">self</span>.mark_span_with_reason(reason, cond.span, <span class="literal">None</span>);</span><br><span class="line">        <span class="keyword">self</span>.expr_drop_temps(span_block, cond, AttrVec::new())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换条件"><a href="#转换条件" class="headerlink" title="转换条件"></a>转换条件</h3><p>根据函数名和参数我们可以得知这个是处理cond不为let的情况下，既然是cond那么应当会出现在while和if中</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实际查看manage_let_cond的usage也正是如此。这两处的处理都是类似的，因此我选取一段来介绍</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.lower_expr(cond);</span><br><span class="line"><span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br></pre></td></tr></table></figure><p>可以看到十分简单，就是先对cond本身lower，然后再对整个cond lower</p><p>然后我们再回到manage_let_cond的实现中</p><p>根据实现可以看到对expr递归判断，如果包含let则直接返回原始cond，否则进行转换</p><p>span_block是用于记录信息的，关键在expr_drop_temps中</p><h3 id="本质行为"><a href="#本质行为" class="headerlink" title="本质行为"></a>本质行为</h3><p>进入实现可以看到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Wrap the given `expr` in a terminating scope using `hir::ExprKind::DropTemps`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In terms of drop order, it has the same effect as wrapping `expr` in</span></span><br><span class="line"><span class="comment">/// `&#123; let _t = $expr; _t &#125;` but should provide better compile-time performance.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// The drop order can be important in e.g. `if expr &#123; .. &#125;`.</span></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_drop_temps_mut(span, expr, attrs))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span>(<span class="keyword">super</span>) <span class="function"><span class="keyword">fn</span> <span class="title">expr_drop_temps_mut</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    expr: &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    attrs: AttrVec,</span><br><span class="line">) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.expr(span, hir::ExprKind::DropTemps(expr), attrs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际做的事情就是转换为了DropTemps这种类型的Expr</p><h2 id="QuestionMark"><a href="#QuestionMark" class="headerlink" title="QuestionMark"></a>QuestionMark</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>QuestionMark是Result为Err或者Option为None的时候直接抛出错误的一种语法糖，摘选一段官方的例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused_variables)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line"><span class="keyword">use</span> std::num::ParseIntError;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">try_to_parse</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">i32</span> = <span class="string">&quot;123&quot;</span>.parse()?; <span class="comment">// x = 123</span></span><br><span class="line">    <span class="keyword">let</span> y: <span class="built_in">i32</span> = <span class="string">&quot;24a&quot;</span>.parse()?; <span class="comment">// returns an Err() immediately</span></span><br><span class="line">    <span class="literal">Ok</span>(x + y)                    <span class="comment">// Doesn&#x27;t run.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res = try_to_parse();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, res);</span><br><span class="line"><span class="built_in">assert!</span>(res.is_err())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看QuestionMark的usage，找到了lower_expr_try这个函数</p><h3 id="做了什么"><a href="#做了什么" class="headerlink" title="做了什么"></a>做了什么</h3><p>先来看注释，这里的注释可以说是非常清楚了，将一个QuestionMark转换为了一个模式匹配</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprKind::Try` from: `&lt;expr&gt;?` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// match Try::branch(&lt;expr&gt;) &#123;</span></span><br><span class="line"><span class="comment">///     ControlFlow::Continue(val) =&gt; #[allow(unreachable_code)] val,,</span></span><br><span class="line"><span class="comment">///     ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">///         #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">///         // If there is an enclosing `try &#123;...&#125;`:</span></span><br><span class="line"><span class="comment">///         break &#x27;catch_target Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">///         // Otherwise:</span></span><br><span class="line"><span class="comment">///         return Try::from_residual(residual),</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, span: Span, sub_expr: &amp;Expr) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt;</span><br></pre></td></tr></table></figure><p>既然是返回了一个match，那么我们先看一下Expr::Match的结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A `match` block, with a source that indicates whether or not it is</span></span><br><span class="line"><span class="comment">/// the result of a desugaring, and if so, which kind.</span></span><br><span class="line">Match(&amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;, &amp;<span class="symbol">&#x27;hir</span> [Arm&lt;<span class="symbol">&#x27;hir</span>&gt;], MatchSource)</span><br></pre></td></tr></table></figure><p>根据注释的内容看上去分为三个部分</p><ol><li>Try::branch(<expr>)</li></ol><p>非常直接的操作，直接lower传进来的sub_expr</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `Try::branch(&lt;expr&gt;)`</span></span><br><span class="line"><span class="keyword">let</span> scrutinee = &#123;</span><br><span class="line">    <span class="comment">// expand &lt;expr&gt;</span></span><br><span class="line">    <span class="keyword">let</span> sub_expr = <span class="keyword">self</span>.lower_expr_mut(sub_expr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.expr_call_lang_item_fn(</span><br><span class="line">        unstable_span,</span><br><span class="line">        hir::LangItem::TryTraitBranch,</span><br><span class="line">        arena_vec![<span class="keyword">self</span>; sub_expr],</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>ControlFlow::Continue(val)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的arm是构建了hir的Match的Arm参数</p><ol><li>ControlFlow::Break(residual)</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `ControlFlow::Break(residual) =&gt;</span></span><br><span class="line"><span class="comment">//     #[allow(unreachable_code)]</span></span><br><span class="line"><span class="comment">//     return Try::from_residual(residual),`</span></span><br><span class="line"><span class="keyword">let</span> break_arm = &#123;</span><br><span class="line">... <span class="comment">// 省略</span></span><br><span class="line">    <span class="keyword">let</span> break_pat = <span class="keyword">self</span>.pat_cf_break(try_span, residual_local);</span><br><span class="line">    <span class="keyword">self</span>.arm(break_pat, ret_expr)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和上面差不多，细节都在省略的部分</p><p>在实际的处理中在最前面的有一部分像上面的CondTemporary一样，先创建一个span用于记录源码相关的信息，源码不再赘述</p><p>还会创建一个*<code>#[allow(unreachable_code)]</code>* 供后面的match使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> attr = &#123;</span><br><span class="line">    <span class="comment">// `allow(unreachable_code)`</span></span><br><span class="line">    <span class="keyword">let</span> allow = &#123;</span><br><span class="line">        <span class="keyword">let</span> allow_ident = Ident::new(sym::allow, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_ident = Ident::new(sym::unreachable_code, <span class="keyword">self</span>.lower_span(span));</span><br><span class="line">        <span class="keyword">let</span> uc_nested = attr::mk_nested_word_item(uc_ident);</span><br><span class="line">        attr::mk_list_item(allow_ident, <span class="built_in">vec!</span>[uc_nested])</span><br><span class="line">    &#125;;</span><br><span class="line">    attr::mk_attr_outer(allow)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> attrs = <span class="built_in">vec!</span>[attr];</span><br></pre></td></tr></table></figure><h2 id="TryBlock"><a href="#TryBlock" class="headerlink" title="TryBlock"></a>TryBlock</h2><p>在lower_expr_try_block中被用到</p><h3 id="做了什么-1"><a href="#做了什么-1" class="headerlink" title="做了什么"></a>做了什么</h3><p>这里的注释解释的比较清楚了，我就不再赘述</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `try &#123; &lt;stmts&gt;; &lt;expr&gt; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(&lt;expr&gt;) &#125;`,</span></span><br><span class="line"><span class="comment">/// `try &#123; &lt;stmts&gt;; &#125;` into `&#123; &lt;stmts&gt;; ::std::ops::Try::from_output(()) &#125;`</span></span><br><span class="line"><span class="comment">/// and save the block id to use it as a break target for desugaring of the `?` operator.</span></span><br></pre></td></tr></table></figure><p>最终都是转换为一个包含stmts和::std::ops::Try::from_output的block</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>我们从返回值往上看，可以看到返回了一个Block，Block的第二个参数是Label，这里并不需要因此设置为了None</p><p>那么我们顺着第一个参数block往上看来源，又回到了函数的开始</p><p>和注释所讲的一样，根据是否有一个expr来做两种不同的处理方式，也是比较直观的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_try_block</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, body: &amp;Block) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">self</span>.with_catch_scope(body.id, |this| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> block = this.lower_block_noalloc(body, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Final expression of the block (if present) or `()` with span at the end of block</span></span><br><span class="line">        <span class="keyword">let</span> (try_span, tail_expr) = <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(expr) = block.expr.take() &#123;</span><br><span class="line">            (</span><br><span class="line">                this.mark_span_with_reason(</span><br><span class="line">                    DesugaringKind::TryBlock,</span><br><span class="line">                    expr.span,</span><br><span class="line">                    this.allow_try_trait.clone(),</span><br><span class="line">                ),</span><br><span class="line">                expr,</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> try_span = this.mark_span_with_reason(</span><br><span class="line">                DesugaringKind::TryBlock,</span><br><span class="line">                this.sess.source_map().end_point(body.span),</span><br><span class="line">                this.allow_try_trait.clone(),</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            (try_span, this.expr_unit(try_span))</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> ok_wrapped_span =</span><br><span class="line">            this.mark_span_with_reason(DesugaringKind::TryBlock, tail_expr.span, <span class="literal">None</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `::std::ops::Try::from_output($tail_expr)`</span></span><br><span class="line">        block.expr = <span class="literal">Some</span>(this.wrap_in_try_constructor(</span><br><span class="line">            hir::LangItem::TryTraitFromOutput,</span><br><span class="line">            try_span,</span><br><span class="line">            tail_expr,</span><br><span class="line">            ok_wrapped_span,</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        hir::ExprKind::Block(this.arena.alloc(block), <span class="literal">None</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OpaqueTy"><a href="#OpaqueTy" class="headerlink" title="OpaqueTy"></a>OpaqueTy</h2><h3 id="OpaqueTy是什么"><a href="#OpaqueTy是什么" class="headerlink" title="OpaqueTy是什么"></a>OpaqueTy是什么</h3><p>OpaqueTy是impl Trait的一种别名，看一下这个例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Foo</span></span> = <span class="keyword">impl</span> Bar;</span><br></pre></td></tr></table></figure><p>实际参数使用Foo的时候只能使用Bar中的接口，不论实现了Bar的类型是否实现了其他类型</p><h3 id="lower做了什么"><a href="#lower做了什么" class="headerlink" title="lower做了什么"></a>lower做了什么</h3><p>关于这个lower的操作，在DesugaringKind::OpaqueTy的位置写的非常清楚了，只是做了简单的类型替换</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugaring of an `impl Trait` in return type position</span></span><br><span class="line"><span class="comment">/// to an `type Foo = impl Trait;` and replacing the</span></span><br><span class="line"><span class="comment">/// `impl Trait` with `Foo`.</span></span><br></pre></td></tr></table></figure><h3 id="lower操作"><a href="#lower操作" class="headerlink" title="lower操作"></a>lower操作</h3><p>lower操作在lower_opaque_impl_trait这个函数中(src/lib.rs)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_opaque_impl_trait</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        span: Span,</span><br><span class="line">        fn_def_id: <span class="built_in">Option</span>&lt;LocalDefId&gt;,</span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">        opaque_ty_node_id: NodeId,</span><br><span class="line">        capturable_lifetimes: <span class="built_in">Option</span>&lt;&amp;FxHashSet&lt;hir::LifetimeName&gt;&gt;,</span><br><span class="line">        lower_bounds: <span class="keyword">impl</span> <span class="built_in">FnOnce</span>(&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>) -&gt; hir::GenericBounds&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    ) -&gt; hir::TyKind&lt;<span class="symbol">&#x27;hir</span>&gt; </span><br></pre></td></tr></table></figure><p>来看一下返回值的部分，可以看到主要处理分为两部分，一部分是处理ID相关的，另一部分是处理lifetime</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `impl Trait` now just becomes `Foo&lt;&#x27;a, &#x27;b, ..&gt;`.</span></span><br><span class="line">    hir::TyKind::OpaqueDef(hir::ItemId &#123; def_id: opaque_ty_def_id &#125;, lifetimes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里也就不展开了，上面的细节很多是关于type相关的，这部分我不了解，内容也比较长。</p><p>lower_opaque_impl_trait这个函数则是被在上面的lower_ty_direct()调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">TyKind::ImplTrait(def_node_id, <span class="keyword">ref</span> bounds) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> span = t.span;</span><br><span class="line">  <span class="keyword">match</span> itctx &#123;</span><br><span class="line">      ImplTraitContext::ReturnPositionOpaqueTy &#123; fn_def_id, origin &#125; =&gt; <span class="keyword">self</span></span><br><span class="line">          .lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">Some</span>(fn_def_id),</span><br><span class="line">              origin,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              |this| this.lower_param_bounds(bounds, itctx),</span><br><span class="line">          ),</span><br><span class="line">      ImplTraitContext::TypeAliasesOpaqueTy &#123; <span class="keyword">ref</span> capturable_lifetimes &#125; =&gt; &#123;</span><br><span class="line">          <span class="comment">// Reset capturable lifetimes, any nested impl trait</span></span><br><span class="line">          <span class="comment">// types will inherit lifetimes from this opaque type,</span></span><br><span class="line">          <span class="comment">// so don&#x27;t need to capture them again.</span></span><br><span class="line">          <span class="keyword">let</span> nested_itctx = ImplTraitContext::TypeAliasesOpaqueTy &#123;</span><br><span class="line">              capturable_lifetimes: &amp;<span class="keyword">mut</span> FxHashSet::default(),</span><br><span class="line">          &#125;;</span><br><span class="line">          <span class="keyword">self</span>.lower_opaque_impl_trait(</span><br><span class="line">              span,</span><br><span class="line">              <span class="literal">None</span>,</span><br><span class="line">              hir::OpaqueTyOrigin::TyAlias,</span><br><span class="line">              def_node_id,</span><br><span class="line">              <span class="literal">Some</span>(capturable_lifetimes),</span><br><span class="line">              |this| this.lower_param_bounds(bounds, nested_itctx),</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这里的TypeKind为ImplTrait且ImplTraitContext为TypeAliasesOpaqueTy或者ReturnPositionOpaqueTy的时候才会做这个desugar操作</p><ul><li><input disabled="" type="checkbox"> 这里我其实不是很明白。。</li></ul><h3 id="ImpltraitContext"><a href="#ImpltraitContext" class="headerlink" title="ImpltraitContext"></a>ImpltraitContext</h3><p>来看一下ImpltraitContext，根据Disallowed注释大意和成员可以得知这个类主要关联了一个位置是否可以使用impl trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,</span></span><br><span class="line"><span class="comment">/// and if so, what meaning it has.</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ImplTraitContext</span></span>&lt;<span class="symbol">&#x27;b</span>, <span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new universal generic parameter.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo(x: impl Debug)`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a fresh universal parameter like `fn foo&lt;T: Debug&gt;(x: T)`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// Newly generated parameters should be inserted into the given `Vec`.</span></span><br><span class="line">    Universal(&amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> <span class="built_in">Vec</span>&lt;hir::GenericParam&lt;<span class="symbol">&#x27;a</span>&gt;&gt;, LocalDefId),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Treat `impl Trait` as shorthand for a new opaque type.</span></span><br><span class="line">    <span class="comment">/// Example: `fn foo() -&gt; impl Debug`, where `impl Debug` is conceptually</span></span><br><span class="line">    <span class="comment">/// equivalent to a new opaque type like `type T = impl Debug; fn foo() -&gt; T`.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    ReturnPositionOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// `DefId` for the parent function, used to look up necessary</span></span><br><span class="line">        <span class="comment">/// information later.</span></span><br><span class="line">        fn_def_id: LocalDefId,</span><br><span class="line">        <span class="comment">/// Origin: Either OpaqueTyOrigin::FnReturn or OpaqueTyOrigin::AsyncFn,</span></span><br><span class="line">        origin: hir::OpaqueTyOrigin,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// Impl trait in type aliases.</span></span><br><span class="line">    TypeAliasesOpaqueTy &#123;</span><br><span class="line">        <span class="comment">/// Set of lifetimes that this opaque type can capture, if it uses</span></span><br><span class="line">        <span class="comment">/// them. This includes lifetimes bound since we entered this context.</span></span><br><span class="line">        <span class="comment">/// For example:</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">/// type A&lt;&#x27;b&gt; = impl for&lt;&#x27;a&gt; Trait&lt;&#x27;a, Out = impl Sized + &#x27;a&gt;;</span></span><br><span class="line">        <span class="comment">/// ```</span></span><br><span class="line">        <span class="comment">///</span></span><br><span class="line">        <span class="comment">/// Here the inner opaque type captures `&#x27;a` because it uses it. It doesn&#x27;t</span></span><br><span class="line">        <span class="comment">/// need to capture `&#x27;b` because it already inherits the lifetime</span></span><br><span class="line">        <span class="comment">/// parameter from `A`.</span></span><br><span class="line">        <span class="comment">// FIXME(impl_trait): but `required_region_bounds` will ICE later</span></span><br><span class="line">        <span class="comment">// anyway.</span></span><br><span class="line">        capturable_lifetimes: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> FxHashSet&lt;hir::LifetimeName&gt;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">/// `impl Trait` is not accepted in this position.</span></span><br><span class="line">    Disallowed(ImplTraitPosition),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在上面只有ReturnPositionOpaqueTy和TypeAliasesOpaqueTy的情况下可以使用，当然从名字就可以看出来这两种情况就是为了OpaqueTy而设计的</p><h2 id="ForLoop"><a href="#ForLoop" class="headerlink" title="ForLoop"></a>ForLoop</h2><p>调用处的函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_for</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        e: &amp;Expr,</span><br><span class="line">        pat: &amp;Pat,</span><br><span class="line">        head: &amp;Expr,</span><br><span class="line">        body: &amp;Block,</span><br><span class="line">        opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">    ) -&gt; hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>注释写的非常详细了，将一个ForLoop转换为一个iterator操作</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Desugar `ExprForLoop` from: `[opt_ident]: for &lt;pat&gt; in &lt;head&gt; &lt;body&gt;` into:</span></span><br><span class="line"><span class="comment">/// ```rust</span></span><br><span class="line"><span class="comment">/// &#123;</span></span><br><span class="line"><span class="comment">///     let result = match IntoIterator::into_iter(&lt;head&gt;) &#123;</span></span><br><span class="line"><span class="comment">///         mut iter =&gt; &#123;</span></span><br><span class="line"><span class="comment">///             [opt_ident]: loop &#123;</span></span><br><span class="line"><span class="comment">///                 match Iterator::next(&amp;mut iter) &#123;</span></span><br><span class="line"><span class="comment">///                     None =&gt; break,</span></span><br><span class="line"><span class="comment">///                     Some(&lt;pat&gt;) =&gt; &lt;body&gt;,</span></span><br><span class="line"><span class="comment">///                 &#125;;</span></span><br><span class="line"><span class="comment">///             &#125;</span></span><br><span class="line"><span class="comment">///         &#125;</span></span><br><span class="line"><span class="comment">///     &#125;;</span></span><br><span class="line"><span class="comment">///     result</span></span><br><span class="line"><span class="comment">/// &#125;</span></span><br><span class="line"><span class="comment">/// ```</span></span><br></pre></td></tr></table></figure><p>实现比较长就不贴了，想要了解更详细的可以去源码处查看</p><h2 id="LetElse"><a href="#LetElse" class="headerlink" title="LetElse"></a>LetElse</h2><h3 id="什么情况会转换"><a href="#什么情况会转换" class="headerlink" title="什么情况会转换"></a>什么情况会转换</h3><p>在lower_let_else中被调用，而这个lower_let_else则是在lower_stmts中</p><p>这是lower_stmts中的处理代码，可以看到是InitElse的情况下会进行处理</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> expr = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> [s, tail @ ..] = ast_stmts &#123;</span><br><span class="line">            <span class="keyword">match</span> s.kind &#123;</span><br><span class="line">                StmtKind::Local(<span class="keyword">ref</span> local) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">let</span> hir_id = <span class="keyword">self</span>.lower_node_id(s.id);</span><br><span class="line">                    <span class="keyword">match</span> &amp;local.kind &#123;</span><br><span class="line">                        LocalKind::InitElse(init, els) =&gt; &#123;</span><br><span class="line">                            <span class="keyword">let</span> e = <span class="keyword">self</span>.lower_let_else(hir_id, local, init, els, tail);</span><br><span class="line">                            expr = <span class="literal">Some</span>(e);</span><br><span class="line"><span class="comment">// remaining statements are in let-else expression</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>注意这里的break</p><p>来看一下InitElse</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">LocalKind</span></span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// Local declaration with an initializer and an `else` clause.</span></span><br><span class="line"><span class="comment">/// Example: `let Some(x) = y else &#123; return &#125;;`</span></span><br><span class="line">InitElse(P&lt;Expr&gt;, P&lt;Block&gt;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br></pre></td></tr></table></figure><p>一开始看到函数签名中的tail产生了一些疑惑，不知道用途是什么。一开始想到的是会往里添加东西，但是一看类型是immutable的（传进来的是一个array的slice），后面看到调用处的break才明白过来，具体用途后面会讲到</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_let_else</span></span>(</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">        stmt_hir_id: hir::HirId,</span><br><span class="line">        local: &amp;Local,</span><br><span class="line">        init: &amp;Expr,</span><br><span class="line">        els: &amp;Block,</span><br><span class="line">        tail: &amp;[Stmt],</span><br><span class="line">    ) -&gt; &amp;<span class="symbol">&#x27;hir</span> hir::Expr&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> ty = local</span><br><span class="line">      .ty</span><br><span class="line">      .as_ref()</span><br><span class="line">      .map(|t| <span class="keyword">self</span>.lower_ty(t, ImplTraitContext::Disallowed(ImplTraitPosition::Variable)));</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(local.span);</span><br><span class="line">  <span class="keyword">let</span> span = <span class="keyword">self</span>.mark_span_with_reason(DesugaringKind::LetElse, span, <span class="literal">None</span>);</span><br><span class="line">  <span class="keyword">let</span> init = <span class="keyword">self</span>.lower_expr(init);</span><br><span class="line">  <span class="keyword">let</span> local_hir_id = <span class="keyword">self</span>.lower_node_id(local.id);</span><br><span class="line">  <span class="keyword">self</span>.lower_attrs(local_hir_id, &amp;local.attrs);</span><br><span class="line">  <span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">          hir_id: local_hir_id,</span><br><span class="line">          pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">          ty,</span><br><span class="line">          init,</span><br><span class="line">          span,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">      <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(let_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">self</span>.alias_attrs(else_expr.hir_id, local_hir_id);</span><br><span class="line">  <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.arena.alloc(hir::Expr &#123;</span><br><span class="line">      hir_id: stmt_hir_id,</span><br><span class="line">      span,</span><br><span class="line">      kind: hir::ExprKind::If(let_expr, then_expr, <span class="literal">Some</span>(else_expr)),</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> !<span class="keyword">self</span>.sess.features_untracked().let_else &#123;</span><br><span class="line">      feature_err(</span><br><span class="line">          &amp;<span class="keyword">self</span>.sess.parse_sess,</span><br><span class="line">          sym::let_else,</span><br><span class="line">          local.span,</span><br><span class="line">          <span class="string">&quot;`let...else` statements are unstable&quot;</span>,</span><br><span class="line">      )</span><br><span class="line">      .emit();</span><br><span class="line">  &#125;</span><br><span class="line">  if_expr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从返回值向上看，可以看到if_expr的参数是let_expr, then_expr, else_expr</p><ol><li>let_expr的部分转成了HIR的let</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> let_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> lex = <span class="keyword">self</span>.arena.alloc(hir::Let &#123;</span><br><span class="line">        hir_id: local_hir_id,</span><br><span class="line">        pat: <span class="keyword">self</span>.lower_pat(&amp;local.pat),</span><br><span class="line">        ty,</span><br><span class="line">        init,</span><br><span class="line">        span,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr(span, hir::ExprKind::Let(lex), AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们来看一下定义和注释</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Represents a `let &lt;pat&gt;[: &lt;ty&gt;] = &lt;expr&gt;` expression (not a Local), occurring in an `if-let` or</span></span><br><span class="line"><span class="comment">/// `let-else`, evaluating to a boolean. Typically the pattern is refutable.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// In an if-let, imagine it as `if (let &lt;pat&gt; = &lt;expr&gt;) &#123; ... &#125;`; in a let-else, it is part of the</span></span><br><span class="line"><span class="comment">/// desugaring to if-let. Only let-else supports the type annotation at present.</span></span><br><span class="line"><span class="meta">#[derive(Debug, HashStable_Generic)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Let</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> hir_id: HirId,</span><br><span class="line">    <span class="keyword">pub</span> span: Span,</span><br><span class="line">    <span class="keyword">pub</span> pat: &amp;<span class="symbol">&#x27;hir</span> Pat&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">    <span class="keyword">pub</span> ty: <span class="built_in">Option</span>&lt;&amp;<span class="symbol">&#x27;hir</span> Ty&lt;<span class="symbol">&#x27;hir</span>&gt;&gt;,</span><br><span class="line">    <span class="keyword">pub</span> init: &amp;<span class="symbol">&#x27;hir</span> Expr&lt;<span class="symbol">&#x27;hir</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">ExprKind</span></span>&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/// A `let $pat = $expr` expression.</span></span><br><span class="line">  <span class="comment">///</span></span><br><span class="line">  <span class="comment">/// These are not `Local` and only occur as expressions.</span></span><br><span class="line">  <span class="comment">/// The `let Some(x) = foo()` in `if let Some(x) = foo()` is an example of `Let(..)`.</span></span><br><span class="line">  Let(&amp;<span class="symbol">&#x27;hir</span> Let&lt;<span class="symbol">&#x27;hir</span>&gt;),</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>then_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> then_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> (stmts, expr) = <span class="keyword">self</span>.lower_stmts(tail);</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_all(span, stmts, expr);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里解答了我对传进来的tail的疑惑。这里的意思是then的话那么会继续lower tail的部分，将这部分插入到then的block中</p><ol><li>else_expr</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> else_expr = &#123;</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.lower_block(els, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(block, AttrVec::new()))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里将传进来的els（InitElse的else block）lower到了一个block</p><h3 id="实际做了什么转换"><a href="#实际做了什么转换" class="headerlink" title="实际做了什么转换"></a>实际做了什么转换</h3><p>单个看起来可能不够直观，将三个部分组合起来的话这个逻辑就是</p><p>cond中创建了一个expr bind</p><p>true：将后面的stmts lower到一个新的block中（因此外面需要break）</p><p>false：将els的部分lower到block</p><h3 id="false为什么不lower-tail"><a href="#false为什么不lower-tail" class="headerlink" title="false为什么不lower tail"></a>false为什么不lower tail</h3><p>像我一样不了解这里语法的情况会觉得false的行为很奇怪，false就不走tail了吗</p><p>于是我就写了这样的一个用例</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(let_else)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y:<span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接报了编译错误，else中的内容是要强制从当前函数返回才行</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">error[E0308]: `<span class="keyword">else</span>` clause of `<span class="keyword">let</span>...<span class="keyword">else</span>` does not diverge</span><br><span class="line"> --&gt; src/main.rs:<span class="number">4</span>:<span class="number">26</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">4</span> |       <span class="keyword">let</span> <span class="literal">Some</span>(x) = y <span class="keyword">else</span> &#123; </span><br><span class="line">  |  __________________________^</span><br><span class="line"><span class="number">5</span> | |         <span class="built_in">println!</span>(<span class="string">&quot;fail&quot;</span>) &#125;;</span><br><span class="line">  | |__________________________^ expected `!`, found `()`</span><br><span class="line">  |</span><br><span class="line">  = note: expected <span class="class"><span class="keyword">type</span> `!`</span></span><br><span class="line"><span class="class">             <span class="title">found</span></span> <span class="class"><span class="keyword">type</span> `()`</span></span><br><span class="line"><span class="class">  = <span class="title">help</span></span>: <span class="keyword">try</span> adding a diverging expression, such <span class="keyword">as</span> `<span class="keyword">return</span>` or `<span class="built_in">panic!</span>(..)`</span><br><span class="line">  = help: ...or <span class="keyword">use</span> `<span class="keyword">match</span>` instead of `<span class="keyword">let</span>...<span class="keyword">else</span>`</span><br><span class="line"></span><br><span class="line">For more information about this error, <span class="keyword">try</span> `rustc --explain E0308`.</span><br><span class="line">error: could not compile `playground` due to previous error</span><br></pre></td></tr></table></figure><h2 id="WhileLoop"><a href="#WhileLoop" class="headerlink" title="WhileLoop"></a>WhileLoop</h2><p>在lower_expr_mut中被调用，在外部创建span信息然后在lower_expr_while_in_loop_scope中实际进行lower</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ExprKind::While(<span class="keyword">ref</span> cond, <span class="keyword">ref</span> body, opt_label) =&gt; &#123;</span><br><span class="line">      <span class="keyword">self</span>.with_loop_scope(e.id, |this| &#123;</span><br><span class="line">          <span class="keyword">let</span> span =</span><br><span class="line">              this.mark_span_with_reason(DesugaringKind::WhileLoop, e.span, <span class="literal">None</span>);</span><br><span class="line">          this.lower_expr_while_in_loop_scope(span, cond, body, opt_label)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="做了什么-2"><a href="#做了什么-2" class="headerlink" title="做了什么"></a>做了什么</h3><p>注释也非常易懂，将一个while转换为一个loop加一个，cond作为一个if，cond为false则break</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We desugar: `&#x27;label: while $cond $body` into:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">// &#x27;label: loop &#123;</span></span><br><span class="line"><span class="comment">//   if &#123; let _t = $cond; _t &#125; &#123;</span></span><br><span class="line"><span class="comment">//     $body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">//   else &#123;</span></span><br><span class="line"><span class="comment">//     break;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ```</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Wrap in a construct equivalent to `&#123; let _t = $cond; _t &#125;`</span></span><br><span class="line"><span class="comment">// to preserve drop semantics since `while $cond &#123; ... &#125;` does not</span></span><br><span class="line"><span class="comment">// let temporaries live outside of `cond`.</span></span><br></pre></td></tr></table></figure><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>实际的实现代码也是非常直接，没什么可讲的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">lower_expr_while_in_loop_scope</span></span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    span: Span,</span><br><span class="line">    cond: &amp;Expr,</span><br><span class="line">    body: &amp;Block,</span><br><span class="line">    opt_label: <span class="built_in">Option</span>&lt;Label&gt;,</span><br><span class="line">) -&gt; hir::ExprKind&lt;<span class="symbol">&#x27;hir</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> lowered_cond = <span class="keyword">self</span>.with_loop_condition_scope(|t| t.lower_expr(cond));</span><br><span class="line">    <span class="keyword">let</span> new_cond = <span class="keyword">self</span>.manage_let_cond(lowered_cond);</span><br><span class="line">    <span class="keyword">let</span> then = <span class="keyword">self</span>.lower_block_expr(body);</span><br><span class="line">    <span class="keyword">let</span> expr_break = <span class="keyword">self</span>.expr_break(span, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> stmt_break = <span class="keyword">self</span>.stmt_expr(span, expr_break);</span><br><span class="line">    <span class="keyword">let</span> else_blk = <span class="keyword">self</span>.block_all(span, arena_vec![<span class="keyword">self</span>; stmt_break], <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">let</span> else_expr = <span class="keyword">self</span>.arena.alloc(<span class="keyword">self</span>.expr_block(else_blk, ThinVec::new()));</span><br><span class="line">    <span class="keyword">let</span> if_kind = hir::ExprKind::If(new_cond, <span class="keyword">self</span>.arena.alloc(then), <span class="literal">Some</span>(else_expr));</span><br><span class="line">    <span class="keyword">let</span> if_expr = <span class="keyword">self</span>.expr(span, if_kind, ThinVec::new());</span><br><span class="line">    <span class="keyword">let</span> block = <span class="keyword">self</span>.block_expr(<span class="keyword">self</span>.arena.alloc(if_expr));</span><br><span class="line">    <span class="keyword">let</span> span = <span class="keyword">self</span>.lower_span(span.with_hi(cond.span.hi()));</span><br><span class="line">    <span class="keyword">let</span> opt_label = <span class="keyword">self</span>.lower_label(opt_label);</span><br><span class="line">    hir::ExprKind::Loop(block, opt_label, hir::LoopSource::While, span)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本来以为desugar的东西比较少就想都写完，但是越写发现越多，这还忽略了很多细节上的东西，导致了文章比较长</p><p>在读代码的时候一开始我是没看到DesugaringKind这个类型的，想着既然要lower，那么首先将ast和hir的定义进行比较。由于内容比较多，只选了熟悉的Expr和Stmt进行对比。查看实际有哪些成员发生了变化，之后再去找到实现的位置。查看实现的过程中偶然看到DesugaringKind，之后看的过程就顺畅了许多</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-15</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    <category term="源码阅读" scheme="https://fusionbolt.github.io/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="Desugar" scheme="https://fusionbolt.github.io/tags/Desugar/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记14 重构与AST Visitor</title>
    <link href="https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/"/>
    <id>https://fusionbolt.github.io/2022/04/10/rc-lang-dev-14/</id>
    <published>2022-04-10T03:22:23.000Z</published>
    <updated>2022-04-10T03:49:21.753Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-14/noire.jpg"                      alt="noire"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">非pixiv作品</center> <p>本周先是解决了上周遗留下来的一个非常头疼的问题，之后重构了Token和AST的定义以及考虑了一下Visitor。之后也编写了建立符号表的代码以及一半转换到vm指令的代码，但是总觉得哪里不太对劲就先停了下来，后续确认无误了再一起拿出来讲。还学习了一些rust的实现方式，关于IR方面有更多了解以后有意向再单独出一篇文章讲解自己的一些了解</p><h1 id="PackratReader"><a href="#PackratReader" class="headerlink" title="PackratReader"></a>PackratReader</h1><p>上周为了解决左递归的语法使用了PackratParser，但是这会引入一个问题，PackratParser会使用PackratReader管理输入，而PackratReader并没有重载toString，因此在<strong>log的时候</strong>都是类似于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trying class member at scala.util.parsing.combinator.PackratParsers$$anon$1@4d3167f4</span><br></pre></td></tr></table></figure><p>我的解决思路如下</p><p>首先尝试继承并且实现一个自己的PackratReader，因为之前TokenReader就是继承并实现了Reader。但是发现经过了PackratParser的处理后又会变成系统自带的reader</p><p>查看源码发现有这么一段内容</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rest</span></span>: <span class="type">Reader</span>[<span class="type">T</span>] = <span class="keyword">new</span> <span class="type">PackratReader</span>(underlying.rest) &#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> cache = outer.cache</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">private</span>[<span class="type">PackratParsers</span>] <span class="keyword">val</span> recursionHeads = outer.recursionHeads</span><br><span class="line">  lrStack = outer.lrStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到每次获取rest的时候都会重新构造一个PackratReader，因此继承这条路行不通。之后我的思路一直在想着如何hack这个类的toString（用ruby的话我一定会这么做的，对于ruby来说这种做法是理所应当的），但是对于Scala来说并没有那么过分的元编程能力（至少我没有搜寻到相关解决方案）。</p><p>反复尝试无果后，只好继续硬调代码了。调试的过程中偶然想到我可以重载log这个函数，前面的思路都是我需要它的字符串，但是我实际的需求是能够log输出正确的信息</p><p>这是我重载以后的行为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">take</span></span>[<span class="type">T</span>](p: <span class="type">Reader</span>[<span class="type">T</span>], n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; !p.atEnd) then p.first::take(p.rest, n - <span class="number">1</span>) <span class="keyword">else</span> <span class="type">Nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  in <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> reader: <span class="type">PackratReader</span>[<span class="type">Token</span>] =&gt;</span><br><span class="line">      println(<span class="string">s&quot;trying <span class="subst">$&#123;name&#125;</span> at (<span class="subst">$&#123;take(reader, 3).mkString(&quot;, &quot;)&#125;</span>)&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      println(<span class="string">&quot;trying &quot;</span> + name + <span class="string">&quot; at &quot;</span> + in)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是原本的实现</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span></span>[<span class="type">T</span>](p: =&gt; <span class="type">Parser</span>[<span class="type">T</span>])(name: <span class="type">String</span>): <span class="type">Parser</span>[<span class="type">T</span>] = <span class="type">Parser</span>&#123; in =&gt;</span><br><span class="line">  println(<span class="string">&quot;trying &quot;</span>+ name +<span class="string">&quot; at &quot;</span>+ in)</span><br><span class="line">  <span class="keyword">val</span> r = p(in)</span><br><span class="line">  println(name +<span class="string">&quot; --&gt; &quot;</span>+ r)</span><br><span class="line">  r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>之前的博客也提到过Token的定义不太好，之前思路过于死板，只想着用enum来解决，但是这里可以更灵活的将trait和enum组合起来，可以通过类型更好的区分不同的Token，AST也是如此。以下这是新的定义的部分代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Token</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Literal</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">NUMBER</span>(int: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">STRING</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">TRUE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">FALSE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Delimiter</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_PARENT_THESES</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LEFT_SQUARE</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RIGHT_SQUARE</span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Ident</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">UPPER_IDENTIFIER</span>(str: <span class="type">String</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Keyword</span> <span class="keyword">extends</span> <span class="type">Token</span>:</span><br><span class="line">  <span class="comment">// local</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAR</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">VAL</span></span><br><span class="line">  <span class="comment">// method</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">DEF</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">RETURN</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">END</span></span><br></pre></td></tr></table></figure><p>据我所了解rust的trait是不能携带变量的，在这方面上Scala好用的多，不需要再在每个Token里面保存一个position信息</p><p>举一个这样写法实际比较有帮助的例子，比如说我现在Lexer结束获得了一个List[Token]，想要将其中Keyword的部分全部提取出来并且将这些信息传给编辑器插件高亮处理，那么我不需要再费力的去写一个麻烦的逻辑判断是否是Keyword的方法，而是直接匹配类型。再写其他逻辑不仅是麻烦的问题，实际也容易出错，比如说漏掉什么或者多写了什么，而这些东西直接写到类型定义中大大减少了问题的产生</p><p>我没有写过插件，不知道实际是否是需要这样，但是这种想法和思路都是一样的</p><p>实际处理代码</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tokens.filter &#123;</span><br><span class="line">  <span class="keyword">case</span> k: <span class="type">Keyword</span> =&gt; <span class="literal">true</span></span><br><span class="line">  <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h2><p>大体思路都在Token部分讲的差不多了，这里贴一下部分关键的AST定义就好了</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTNode</span> <span class="keyword">extends</span> <span class="title">Positional</span></span></span><br><span class="line"></span><br><span class="line">enum <span class="type">Expr</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Number</span>(v: <span class="type">Int</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Identifier</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Bool</span>(b: <span class="type">Boolean</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Binary</span>(op: <span class="type">BinaryOp</span>, lhs: <span class="type">Expr</span>, rhs: <span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Str</span>(str: <span class="type">String</span>)</span><br><span class="line">  <span class="comment">// false -&gt; elsif | else</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">If</span>(cond: <span class="type">Expr</span>, true_branch: <span class="type">Block</span>, false_branch: <span class="type">Option</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Lambda</span>(args: <span class="type">List</span>[<span class="type">Expr</span>], stmts: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Call</span>(target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Ident</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Block</span>(stmts: <span class="type">List</span>[<span class="type">Stmt</span>])</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Return</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Constant</span>(ident: <span class="type">Ident</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br><span class="line"></span><br><span class="line">enum <span class="type">Stmt</span> <span class="keyword">extends</span> <span class="type">ASTNode</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Local</span>(name: <span class="type">Ident</span>, ty: <span class="type">Type</span>, value: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Expr</span>(expr: ast.<span class="type">Expr</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">While</span>(cond: ast.<span class="type">Expr</span>, stmts: <span class="type">Block</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Assign</span>(name: <span class="type">Ident</span>, value: ast.<span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><p>之前写的str与Id的隐式转换函数放到了一个object中，需要的时候直接import这个object中的一个函数或者全部函数，将隐式转换函数都放在一个位置进行管理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitConversions</span> </span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToId</span></span>(str: <span class="type">String</span>): <span class="type">Ident</span> = <span class="type">Ident</span>(str)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">IdToStr</span></span>(id: <span class="type">Ident</span>): <span class="type">String</span> = id.str</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">boolToAST</span></span>(b: <span class="type">Boolean</span>): <span class="type">Expr</span>.<span class="type">Bool</span> = <span class="type">Expr</span>.<span class="type">Bool</span>(b)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToAST</span></span>(i: <span class="type">Int</span>): <span class="type">Expr</span>.<span class="type">Number</span> = <span class="type">Expr</span>.<span class="type">Number</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要用到的时候</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ast.<span class="type">ImplicitConversions</span>.*</span><br></pre></td></tr></table></figure><h1 id="AST-Visitor"><a href="#AST-Visitor" class="headerlink" title="AST Visitor"></a>AST Visitor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>虽然在公司做的ai compiler的项目里也有visitor，但那终究只是对特殊形式对expr处理的，也可以说是针对一种DSL的，并不能直接套用。之前用ruby写的版本存在很多问题，同时也使用了动态语言才能写出来的方式。</p><p>编写遍历的时候关键在于遍历函数的签名。除了结点本身之外应当传递什么参数？返回值又是怎样的？</p><p>我的思路是先想一下之后的使用场景是怎么样的。能想到的场景大致有这么几种</p><ol><li>ast check</li><li>type infer</li><li>lower</li><li>其他pass</li></ol><p>ast check这个显然是要遍历所有结点</p><p>type infer没有做过，对于实际要怎么做我还没有一个思路</p><p>lower在很多编译器也是作为一种pass存在，而我目前暂时想先作为一个单独的流程存在。</p><p>其他pass只是参与过公司项目，但是传统compiler还没有做过。关于这个我还存有许多问题，比如说都会用到什么样的访问方式？我目前想到的方面是针对表达式或者说某个特定类型的结点进行处理，那么应用的时候是需要做</p><p>最后结论还是去学习一下前人的做法，尝试查看Scala和rust的实现，Scala实现方式过于复杂，因此最终参考的是rust的实现（但Scala但是实现我还是挺感兴趣但，可能会再花一些时间研究一下）</p><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><p>rust中写了一个visitor的trait，其中包含了各种ast中出现的内容：crate，stmt，ident等都有。其中每一个visit_xxx的默认实现都是调用了walk_xxx，而walk是访问当前这个节点的所有成员，因此默认实现的整个逻辑是：先进入visit，visit调用到了walk，walk对每一个节点进行visit，而每个节点的visit又是调用了walk</p><p>从上面提及的函数签名的角度来看，传递了一个所需的ast结点，无返回值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pub <span class="class"><span class="keyword">trait</span> <span class="title">Visitor&lt;</span>&#x27;<span class="title">ast&gt;</span></span>: <span class="type">Sized</span> &#123;</span><br><span class="line">...</span><br><span class="line">fn visit_crate(&amp;mut self, krate: &amp;<span class="symbol">&#x27;ast</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_crate(self, krate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn walk_crate&lt;<span class="symbol">&#x27;a</span>, <span class="type">V</span>: <span class="type">Visitor</span>&lt;<span class="symbol">&#x27;a</span>&gt;&gt;(visitor: &amp;mut <span class="type">V</span>, krate: &amp;<span class="symbol">&#x27;a</span> <span class="type">Crate</span>) &#123;</span><br><span class="line">    walk_list!(visitor, visit_item, &amp;krate.items);</span><br><span class="line">    walk_list!(visitor, visit_attribute, &amp;krate.attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个小问题我即便在写到这里的时候我还是没能理解，为什么要传一个visitor进来，直接作为trait的成员不就好了吗？rust的高层IR有好几层，起初我以为是为了给其他的ir使用（思考完这个问题我才意识到这是一个不良设计，每一层的东西应当隔离开来），但经过查看每一层但IR都是完全单独的visitor和walk，偶尔使用walk也是在impl ast visitor的时候</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>选取片段</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">ASTVisitor</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">R</span> </span>= <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(modules: <span class="type">Modules</span>): <span class="type">R</span> = visitRecursive(modules)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(module: <span class="type">RcModule</span>): <span class="type">R</span> = visitRecursive(module)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = visitRecursive(item)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(expr: <span class="type">Expr</span>): <span class="type">R</span> = visitRecursive(expr)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">visitRecursive</span></span>(item: <span class="type">Item</span>): <span class="type">R</span> = &#123;</span><br><span class="line">    item <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> method: <span class="type">Item</span>.<span class="type">Method</span> =&gt; visit(method)</span><br><span class="line">      <span class="keyword">case</span> klass: <span class="type">Item</span>.<span class="type">Class</span> =&gt; visit(klass)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;NoneItem&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于返回值的地方我也纠结了一下，虽然留有了一个R的类型，但是没想好之后怎么用。因此就先这样实现吧，之后根据需求再改。在不了解的情况下不应当想着一口气写出合适的实现，而是先从能用开始，再不断修改</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-14</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="Rust" scheme="https://fusionbolt.github.io/tags/Rust/"/>
    
    <category term="AST" scheme="https://fusionbolt.github.io/tags/AST/"/>
    
  </entry>
  
  <entry>
    <title>Rc-lang开发周记13 另一些Parser</title>
    <link href="https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/"/>
    <id>https://fusionbolt.github.io/2022/04/04/rc-lang-dev-13/</id>
    <published>2022-04-04T02:21:54.000Z</published>
    <updated>2022-04-10T03:41:48.893Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/rc-lang-dev-13/52EA4D4A98FF564EE062964187F4D6B0.jpg"                      alt="52EA4D4A98FF564EE062964187F4D6B0"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">pixiv:40165995</center> <p>本周的内容主要就是添加剩下的一些parser，主要是和类相关的，同时还添加了数组的下标索引。内容稍微少一些，我觉得也没有太多值得讲的，基本上就是确定语法 + 直接写实现。代码写的也不多，花了不少时间在另一篇博客上，同时还要添加测试。到此为止原先的parser支持的差不多了。还增加了类型以及下标索引的内容，同时还有了更合理的测试。今天收下尾差不多可以开始写其他的内容了</p><h1 id="本周出现的所有语法"><a href="#本周出现的所有语法" class="headerlink" title="本周出现的所有语法"></a>本周出现的所有语法</h1><p>首先我们要确定要写出什么样的语法。语法大致先这样，不知道怎么样的语法才是优雅的，先都做出来再说</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &lt;</span> Parent <span class="comment">// 继承，类型名必须首字母大写</span></span><br><span class="line">  v1: Fun <span class="comment">// 成员变量</span></span><br><span class="line">  v2: Int = <span class="number">1</span> <span class="comment">// 成员变量默认值</span></span><br><span class="line"></span><br><span class="line">  def update() <span class="comment">// 成员函数</span></span><br><span class="line">@v2 = @v2 + <span class="number">1</span> <span class="comment">// @获取成员变量</span></span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def f()</span><br><span class="line">var v = F.<span class="keyword">new</span>() <span class="comment">// Class.new()的形式构建变量。new本质是object基类的方法</span></span><br><span class="line">v.update() <span class="comment">// 调用成员函数</span></span><br><span class="line">  var arr = Array.<span class="keyword">new</span>(<span class="number">2</span>)</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 常规的取数组下标</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>其实我有点中意下面这种写法，将vars和methods都限制在一起，但是后面如果类中可以添加新的东西那会麻烦一些，所以这个想法暂时保留</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span></span></span><br><span class="line">vars:</span><br><span class="line">  v1: <span class="type">Fun</span></span><br><span class="line">  v2: <span class="type">Int</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">methods:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">f1</span></span>()</span><br><span class="line"></span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classDefine</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>.<span class="type">Class</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">CLASS</span> ~&gt; sym ~ (<span class="type">OPERATOR</span>(<span class="string">&quot;&lt;&quot;</span>) ~&gt; sym).?) ~ log(item | field | noneItem)(<span class="string">&quot;class member&quot;</span>).* &lt;~ log(<span class="type">END</span>)(<span class="string">&quot;class end&quot;</span>) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> klass ~ parent ~ defines =&gt;</span><br><span class="line">      <span class="type">Item</span>.<span class="type">Class</span>(klass, parent,</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Field</span>]).map(_.asInstanceOf[<span class="type">Field</span>]),</span><br><span class="line">        defines.filter(_.isInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]).map(_.asInstanceOf[<span class="type">Item</span>.<span class="type">Method</span>]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noneItem</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  <span class="type">EOL</span> ^^^ <span class="type">Item</span>.<span class="type">None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">field</span></span>: <span class="type">Parser</span>[<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  oneline(<span class="type">VAR</span> ~&gt; (id &lt;~ <span class="type">COLON</span>) ~ sym ~ (<span class="type">EQL</span> ~&gt; expr).?) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> id ~ ty ~ value =&gt; <span class="type">Field</span>(id, <span class="type">Type</span>.<span class="type">Spec</span>(ty), value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">item</span></span>: <span class="type">Parser</span>[<span class="type">Item</span>] = positioned &#123;</span><br><span class="line">  oneline(method | classDefine)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Expr"><a href="#Expr" class="headerlink" title="Expr"></a>Expr</h1><p>新增加的ast成员。其中Constant是大写字母开头的名字</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="type">MethodCall</span>(obj: <span class="type">Expr</span>, target: <span class="type">Id</span>, args: <span class="type">List</span>[<span class="type">Expr</span>])</span><br><span class="line"><span class="keyword">case</span> <span class="type">Field</span>(expr: <span class="type">Expr</span>, id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Self</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">Constant</span>(id: <span class="type">Id</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="type">Index</span>(expr: <span class="type">Expr</span>, i: <span class="type">Expr</span>)</span><br></pre></td></tr></table></figure><h2 id="MethodCall"><a href="#MethodCall" class="headerlink" title="MethodCall"></a>MethodCall</h2><p>调用成员函数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memCall</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">MethodCall</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ~ parSround(repsep(termExpr, <span class="type">COMMA</span>)) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ id ~ args =&gt; <span class="type">Expr</span>.<span class="type">MethodCall</span>(obj, id, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (termExpr &lt;~ <span class="type">DOT</span>) ~ id ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> obj ~ name =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(obj, name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selfField</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Field</span>] = positioned &#123;</span><br><span class="line">  (<span class="type">AT</span> ~&gt; id) ^^ (id =&gt; <span class="type">Expr</span>.<span class="type">Field</span>(<span class="type">Expr</span>.<span class="type">Self</span>, id))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">arrayIndex</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>.<span class="type">Index</span>] = positioned &#123;</span><br><span class="line">  termExpr ~ squareSround(termExpr) ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> expr ~ index =&gt; <span class="type">Expr</span>.<span class="type">Index</span>(expr, index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">squareSround</span></span>[<span class="type">T</span>](p: <span class="type">Parser</span>[<span class="type">T</span>]) = <span class="type">LEFT_SQUARE</span> ~&gt; p &lt;~ <span class="type">RIGHT_SQUARE</span></span><br></pre></td></tr></table></figure><h2 id="左递归"><a href="#左递归" class="headerlink" title="左递归"></a>左递归</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> beginWithTerm: <span class="type">PackratParser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  memCall | memField | arrayIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">term</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  bool | num | string | selfField | call | beginWithTerm | sym ^^ <span class="type">Expr</span>.<span class="type">Constant</span> | idExpr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">termExpr</span></span>: <span class="type">Parser</span>[<span class="type">Expr</span>] = positioned &#123;</span><br><span class="line">  term ~ (operator ~ term).* ^^ &#123;</span><br><span class="line">    <span class="keyword">case</span> term ~ terms =&gt; termsToBinary(term, terms.map(a =&gt; <span class="type">List</span>(a._1, a._2)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加了如上几个语法后，语法已经变成了左递归的形式。遇到这种问题一般来说是转成非左递归的语法，因为左递归的情况很容易堆栈溢出，而Scala的parser combaintor提供了记忆化的能力，简单来说就是能够缓存遍历过的情况，第二次递归到某个情况，如果这个情况已经被遍历过那么直接从缓存中取出即可，而不需要再次递归搜索</p><p>想要使用这个功能需要两个步骤</p><ol><li>parser继承自PackratParsers。之前我的parser都是继承自Parsers，而更换成PackratParsers是兼容的，直接修改继承类名即可</li><li>显式指定需要这个功能的parser返回PackratParser</li><li>函数必须改成lazy val</li></ol><p>可以看到上面的beginWithTerm已经修改为了这种形式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/rc-lang-dev-13</summary>
      
    
    
    
    <category term="Compiler" scheme="https://fusionbolt.github.io/categories/Compiler/"/>
    
    
    <category term="Rc-lang" scheme="https://fusionbolt.github.io/tags/Rc-lang/"/>
    
    <category term="ParserCombaintor" scheme="https://fusionbolt.github.io/tags/ParserCombaintor/"/>
    
    <category term="Parser" scheme="https://fusionbolt.github.io/tags/Parser/"/>
    
  </entry>
  
  <entry>
    <title>与CI和链接大战三百回合</title>
    <link href="https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/"/>
    <id>https://fusionbolt.github.io/2022/03/29/solve-ci-and-link/</id>
    <published>2022-03-29T15:34:17.000Z</published>
    <updated>2022-04-04T08:48:10.192Z</updated>
    
    <content type="html"><![CDATA[<p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/solve-ci-and-link/54707001_p0.png"                      alt="54707001_p0.png"                ></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">攻撃隊、出撃！Vorwärts！ pixiv:54707001</center> <h1 id="噩梦开始的地方"><a href="#噩梦开始的地方" class="headerlink" title="噩梦开始的地方"></a>噩梦开始的地方</h1><p>在C#的CI测试中（目前仅开启了ubuntu）DllImport报错DllNotFoundException。而报错的位置是我对自己搞的一个capi做的C#包装</p><h1 id="本地尝试"><a href="#本地尝试" class="headerlink" title="本地尝试"></a>本地尝试</h1><p>遇到这种问题，我的第一反应还是先在本地的环境确认一下，这样的做法相对来说成本低很多，能够初步确认一些问题（但是由于自己配的环境的影响会导致很多问题无法排查）</p><p>自然本地是失败了，切到了Windows的机器上依然失败，又切到了公司内部的ubuntu服务器（我没有做过什么环境配置，可以认为相对干净一些）依然是失败了</p><h1 id="查看类似的情况"><a href="#查看类似的情况" class="headerlink" title="查看类似的情况"></a>查看类似的情况</h1><p>项目中也有其他使用我们自己做的C#包装的测试，因此我想到了确认一下它的正确性。我使用了自己的分支，而主分支是没有问题的。自己这里确认的过程中还是不够严谨，应该直接查看对应测试成功与失败的用例的执行情况，只是用这样想当然的想法来考虑。</p><h1 id="CI调试神器"><a href="#CI调试神器" class="headerlink" title="CI调试神器"></a>CI调试神器</h1><p>各种尝试无果（忘了做了哪些，总之都没有效果），之后尝试在Windows和mac下进行测试，这两者居然是能通过的。</p><p>一时之间也没能想到有什么决定性的因素，后来想到以前看过本地模拟ci环境的东西，因此去搜索关于ci调试的信息，并且发现了这个神器</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">tmate</span> <span class="string">session</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">mxschmitt/action-tmate@v3</span></span><br></pre></td></tr></table></figure><p>只要将这一段加到GitHub action的yaml文件中，即可在执行到这里的时候停住。此时会不断刷新ssh连接的命令。</p><h1 id="进入CI后"><a href="#进入CI后" class="headerlink" title="进入CI后"></a>进入CI后</h1><p>我做的第一时间是检查so本身是否存在问题</p><p>像以往一样写了一个最简单的main.c，之后 <code>gcc main.c -L . llibname</code> 查看报错。</p><p>我一直使用这样的方式来检查实际链接的时候因为哪些符号是undefined导致链接挂掉，简单易实施，久而久之也开始潜意识的认为这样能过链接就没有问题了，还是对链接了解不够。</p><p>这里出现了一个我忽略了的问题，也正是这个问题导致我浪费了大半天时间。因为这个库是我自己写的自己编的，不会依赖于系统库之外的so，<strong>我潜意识认为这里不会出问题，所以我没有使用ldd进行确认链接状态</strong>。</p><h1 id="启动一个裸docker测试"><a href="#启动一个裸docker测试" class="headerlink" title="启动一个裸docker测试"></a>启动一个裸docker测试</h1><p>前面那一步做好也就不会有后面的那么多操作了..总之后面的操作也回顾一下</p><p>为了和跑测试的ci版本一致，启动了一个ubuntu18.04的docker（后面可以看到，幸好我这里选择了一致的版本，不然可能解决问题的时间需要更久…）</p><p>由于是非常干净的镜像，什么都没有，折腾了半天安装所需要的基本组建，开始编译并且执行测试，依然是存在问题。之后也没什么好思路，后来跑了一下上面提及的类似性质的相关测试的正确性，发现docker中也是错的。（这里如果我之前更严谨的确认了可能也会减少一些重复过程）</p><p>之后我就喊实现这块的同事和我一起看问题，切到了主分支测试也不能通过。后来不记得为什么了我随手敲了个ldd看了一下他的so，他看到了错误信息，一提醒我才看到。自己思考问题经常会钻牛角尖，以及经常会忽略掉一些信息，有的时候换个人从旁观者角度来看会好很多，自己想切换到旁观者角度还是有些难。</p><h1 id="GLIBC-x-xx-not-found"><a href="#GLIBC-x-xx-not-found" class="headerlink" title="GLIBC_x.xx not found"></a>GLIBC_x.xx not found</h1><p>看到的错误信息是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBCXX_3.xx&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>由于这是一个非常干净的ubuntu，所以甚至没有这个东西。这个时候我意识到了自己的库在CI中会不会也是类似的原因，我之前是否ldd检查过，检查过的话是否是忽略了这么重要的调试信息？（这个时候由于没有清晰的思路和严谨的做法，开始怀疑之前是否做过这个测试）</p><p>随后意识到在ci中会不会也是类似的问题。于是进入了ci调试器，看到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./libxxx.so: /lib/x86_64-linux-gnu/libm.so.6: version `GLIBC_2.29&#x27; not found (required by ./libxxx.so)</span><br></pre></td></tr></table></figure><p>测试能通过的so中是没有类似的错误信息。使用<code>strings /usr/lib/x86_64-linux-gnu/libc.so.6</code> 查看其中的glibc版本信息，发现其中并没有我们所需的版本（注意不要去看libc.so，它虽然叫so但不是动态链接库，用file可以看到实际上是一个文本文件）</p><p>这时可以确认问题就在这里了。</p><h1 id="“失误”"><a href="#“失误”" class="headerlink" title="“失误”"></a>“失误”</h1><p>这个时候我觉得离谱的是这个库我是通过github ci编译的，最后ci不能通过，也许还有什么因素应该控制但是我没有做好的。</p><p>本来还想吐槽这个，最后想办法处理GLIBC版本不一致的时候发现自己编的时候用的是ubuntu-latest的ci…而测试的地方是18.04。这一部分是我不知道从哪里直接就拷贝过来的，没有确认是否有问题就进行拷贝（之前也没有遇到过这样的情况，确认可能也不会想到这一点。但是我也确实没有进行过核对）</p><p>同时这次的经历意识到了自己编的库还是应该尽量依赖低版本的glibc</p><h1 id="关于glibc和GLIBC-XX"><a href="#关于glibc和GLIBC-XX" class="headerlink" title="关于glibc和GLIBC_XX"></a>关于glibc和GLIBC_XX</h1><p>这个我整理起来发现东西不少，以及要控制一下文章长度，因此整理到了另一篇博客上</p><p><a class="link"   href="https://homura.live/2022/03/29/glibc-version/" >https://homura.live/2022/03/29/glibc-version/<i class="fas fa-external-link-alt"></i></a></p><h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><ol><li>GLIBC的version版本对应不上（错误的根本原因）</li><li>在写编译的ci的时候没有认真写，而是随便找了一个抄上就完事（错误的产生原因）</li><li>没有一套严谨的确认问题的思路（花费了我大半天的原因）</li></ol><p>太多意想不到的地方出了问题，不论是ldd还是最后发现是系统版本错，也许是自己在这些地方都没有太注意，最后各种小问题堆积太多导致出现了这种坑。</p><h1 id="事后诸葛亮"><a href="#事后诸葛亮" class="headerlink" title="事后诸葛亮"></a><del>事后诸葛亮</del></h1><p>在此写一下理想的解决思路应该是怎么样的</p><ol><li>发现CI出现问题，查看错误是DllNotFoundException</li><li>本地相同系统测试能通过，那么要确认查找的过程没有问题。多半是要排除掉环境变量的影响因素</li><li>确认路径查找是没有问题的以后进入CI环境查看dll的状态<ol><li>ldd查看依赖是否满足（本次错误看到a即可）</li><li>如果依赖满足的则再手动链接查看是否有undefined的符号之类</li></ol></li><li>发现是glibc的问题，确认是否真的找不到版本（这里我真的遇到过（虽然是GLIBCXX）…安了conda以后因为会先找到conda的glibc，而这个版本可能又是不合要求的，然后就会报错了..解决方案是直接修改链接，如果你遇到类似的问题一搜就能搜到解决方案）</li><li>glibc通常和环境有关，真的是没有匹配版本那么要查看环境的不同</li><li>由于是ci环境，那么肯定首先要看ci的yaml文件，对比配置的差异（问题解决）</li></ol><p>先确认第三步其实也可以，最好的情况下我们先去做了第三步是会省了第二步的问题。但我觉得这种dll链接相关的路径查找的问题可能更多一些，总之这些都是需要确认的步骤。</p><p>这个思路是在本地能够通过测试的前提条件下。需要调的这种情况一般是要合并了之类，这种情况肯定是要先在本地做好测试的。没有做好的情况肯定是要先测试的</p><h1 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h1><p>自己经常会遇到这种离谱的问题，然而每个问题看起来再离谱最终都是会找到原因的，而且这个原因往往出现在意想不到的地方。想要减少这种现象的出现，只有明确自己行为的后果，以及不断踩坑的过程中形成一套自己的应对策略。（如果是别人的库那首先要注意的肯定是查看相关位置的源码）</p><p>这些问题的解决方式大多貌似都是口口相传，因此我打算再遇到这样类似的问题就进行一个记录。记录下我的思路，最终是如何解决问题的以及在这个途中有什么错误的想法，尽量避免第二次犯同样的错误，不断反思形成一套自己的解决问题方案，同时又会重新回顾在这之中有什么细节或者知识点是遗漏的。以后会增加更多这样的博客</p><p>遇到这种问题很重要的一点是如果不能调试，那解决问题可能要付出成倍的时间代价。像这个例子如果我不进去ci环境查看，也比较难确定是否真的是版本问题，不断更新ci打log也可以，但是非常非常麻烦且低效。</p><p>后面应该再写一个链接问题定位的博客（写的话大概会说一些自己踩过的坑）。我的思路未必全面，但是一定有着参考价值<del>（下次一定，在新建文件了，难不成我还能咕咕咕吗）</del></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
                     data-src=&quot;/images/solve-ci-and-l</summary>
      
    
    
    
    <category term="Debug" scheme="https://fusionbolt.github.io/categories/Debug/"/>
    
    
    <category term="Link" scheme="https://fusionbolt.github.io/tags/Link/"/>
    
    <category term="CI" scheme="https://fusionbolt.github.io/tags/CI/"/>
    
  </entry>
  
</feed>
